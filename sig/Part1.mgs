(* Parameter Eps_i "174b78e53fc239e8c2aab4ab5a996a27e3e5741e88070dad186e05fb13f275e5" *)
Parameter Eps_i : (set -> prop) -> set.
Axiom Eps_i_ax : forall P : set -> prop , forall x : set , P x -> P (Eps_i P).
Definition True : prop := forall p : prop , p -> p.
Definition False : prop := forall p : prop , p.
Definition not : prop -> prop := fun A : prop => A -> False.
(* Unicode ~ "00ac" *)
Prefix ~ 700 := not.
Definition and : prop -> prop -> prop := fun A B : prop => forall p : prop , (A -> B -> p) -> p.
(* Unicode /\ "2227" *)
Infix /\ 780 left  := and.
Definition or : prop -> prop -> prop := fun A B : prop => forall p : prop , (A -> p) -> (B -> p) -> p.
(* Unicode \/ "2228" *)
Infix \/ 785 left  := or.
Definition iff : prop -> prop -> prop := fun A B : prop => and (A -> B) (B -> A).
(* Unicode <-> "2194" *)
Infix <-> 805 := iff.
Section Eq.
Variable A : SType.
Definition eq : A -> A -> prop := fun x y : A => forall Q : A -> A -> prop , Q x y -> Q y x.
Definition neq : A -> A -> prop := fun x y : A => ~ eq x y.
End Eq.
Infix = 502 := eq.
(* Unicode <> "2260" *)
Infix <> 502 := neq.
Section FE.
Variable A B : SType.
Axiom func_ext : forall f g : A -> B , (forall x : A , f x = g x) -> f = g.
End FE.
Section Ex.
Variable A : SType.
Definition ex : (A -> prop) -> prop := fun Q : A -> prop => forall P : prop , (forall x : A , Q x -> P) -> P.
End Ex.
(* Unicode exists "2203" *)
Binder+ exists , := ex.
Axiom prop_ext : forall p q : prop , iff p q -> p = q.
Parameter In : set -> set -> prop.
Definition Subq : set -> set -> prop := fun A B => forall x :e A , x :e B.
Axiom set_ext : forall X Y : set , X c= Y -> Y c= X -> X = Y.
Axiom In_ind : forall P : set -> prop , (forall X : set , (forall x :e X , P x) -> P X) -> forall X : set , P X.
Binder+ exists , := ex ; and.
Parameter Empty : set.
Axiom EmptyAx : ~ exists x : set , x :e Empty.
(* Unicode Union "22C3" *)
Parameter Union : set -> set.
Axiom UnionEq : forall X x , x :e Union X <-> exists Y , x :e Y /\ Y :e X.
(* Unicode Power "1D4AB" *)
Parameter Power : set -> set.
Axiom PowerEq : forall X Y : set , Y :e Power X <-> Y c= X.
Parameter Repl : set -> (set -> set) -> set.
Notation Repl Repl.
Axiom ReplEq : forall A : set , forall F : set -> set , forall y : set , y :e {F x|x :e A} <-> exists x :e A , y = F x.
Definition TransSet : set -> prop := fun U : set => forall x :e U , x c= U.
Definition Union_closed : set -> prop := fun U : set => forall X : set , X :e U -> Union X :e U.
Definition Power_closed : set -> prop := fun U : set => forall X : set , X :e U -> Power X :e U.
Definition Repl_closed : set -> prop := fun U : set => forall X : set , X :e U -> forall F : set -> set , (forall x : set , x :e X -> F x :e U) -> {F x|x :e X} :e U.
Definition ZF_closed : set -> prop := fun U : set => Union_closed U /\ Power_closed U /\ Repl_closed U.
Parameter UnivOf : set -> set.
Axiom UnivOf_In : forall N : set , N :e UnivOf N.
Axiom UnivOf_TransSet : forall N : set , TransSet (UnivOf N).
Axiom UnivOf_ZF_closed : forall N : set , ZF_closed (UnivOf N).
Axiom UnivOf_Min : forall N U : set , N :e U -> TransSet U -> ZF_closed U -> UnivOf N c= U.
Axiom FalseE : False -> forall p : prop , p.
Axiom TrueI : True.
Axiom andI : forall A B : prop , A -> B -> A /\ B.
Axiom andEL : forall A B : prop , A /\ B -> A.
Axiom andER : forall A B : prop , A /\ B -> B.
Axiom orIL : forall A B : prop , A -> A \/ B.
Axiom orIR : forall A B : prop , B -> A \/ B.
Section PropN.
Variable P1 P2 P3 : prop.
Axiom and3I : P1 -> P2 -> P3 -> P1 /\ P2 /\ P3.
Axiom and3E : P1 /\ P2 /\ P3 -> (forall p : prop , (P1 -> P2 -> P3 -> p) -> p).
Axiom or3I1 : P1 -> P1 \/ P2 \/ P3.
Axiom or3I2 : P2 -> P1 \/ P2 \/ P3.
Axiom or3I3 : P3 -> P1 \/ P2 \/ P3.
Axiom or3E : P1 \/ P2 \/ P3 -> (forall p : prop , (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> p).
Variable P4 : prop.
Axiom and4I : P1 -> P2 -> P3 -> P4 -> P1 /\ P2 /\ P3 /\ P4.
Variable P5 : prop.
Axiom and5I : P1 -> P2 -> P3 -> P4 -> P5 -> P1 /\ P2 /\ P3 /\ P4 /\ P5.
End PropN.
Axiom not_or_and_demorgan : forall A B : prop , ~ (A \/ B) -> ~ A /\ ~ B.
Axiom not_ex_all_demorgan_i : forall P : set -> prop , (~ exists x , P x) -> forall x , ~ P x.
Axiom iffI : forall A B : prop , (A -> B) -> (B -> A) -> (A <-> B).
Axiom iffEL : forall A B : prop , (A <-> B) -> A -> B.
Axiom iffER : forall A B : prop , (A <-> B) -> B -> A.
Axiom iff_refl : forall A : prop , A <-> A.
Axiom iff_sym : forall A B : prop , (A <-> B) -> (B <-> A).
Axiom iff_trans : forall A B C : prop , (A <-> B) -> (B <-> C) -> (A <-> C).
Axiom eq_i_tra : forall x y z , x = y -> y = z -> x = z.
Axiom f_eq_i : forall f : set -> set , forall x y , x = y -> f x = f y.
Axiom neq_i_sym : forall x y , x <> y -> y <> x.
Definition nIn : set -> set -> prop := fun x X => ~ In x X.
(* Unicode /:e "2209" *)
Infix /:e 502 := nIn.
Axiom Eps_i_ex : forall P : set -> prop , (exists x , P x) -> P (Eps_i P).
Axiom pred_ext : forall P Q : set -> prop , (forall x , P x <-> Q x) -> P = Q.
Axiom prop_ext_2 : forall p q : prop , (p -> q) -> (q -> p) -> p = q.
Axiom Subq_ref : forall X : set , X c= X.
Axiom Subq_tra : forall X Y Z : set , X c= Y -> Y c= Z -> X c= Z.
Axiom Subq_contra : forall X Y z : set , X c= Y -> z /:e Y -> z /:e X.
Axiom EmptyE : forall x : set , x /:e Empty.
Axiom Subq_Empty : forall X : set , Empty c= X.
Axiom Empty_Subq_eq : forall X : set , X c= Empty -> X = Empty.
Axiom Empty_eq : forall X : set , (forall x , x /:e X) -> X = Empty.
Axiom UnionI : forall X x Y : set , x :e Y -> Y :e X -> x :e Union X.
Axiom UnionE : forall X x : set , x :e Union X -> exists Y : set , x :e Y /\ Y :e X.
Axiom UnionE_impred : forall X x : set , x :e Union X -> forall p : prop , (forall Y : set , x :e Y -> Y :e X -> p) -> p.
Axiom PowerI : forall X Y : set , Y c= X -> Y :e Power X.
Axiom PowerE : forall X Y : set , Y :e Power X -> Y c= X.
Axiom Empty_In_Power : forall X : set , Empty :e Power X.
Axiom Self_In_Power : forall X : set , X :e Power X.
Axiom xm : forall P : prop , P \/ ~ P.
Axiom dneg : forall P : prop , ~ ~ P -> P.
Axiom not_all_ex_demorgan_i : forall P : set -> prop , ~ (forall x , P x) -> exists x , ~ P x.
Axiom eq_or_nand : or = (fun x y : prop => ~ (~ x /\ ~ y)).
(* Parameter exactly1of2 "3578b0d6a7b318714bc5ea889c6a38cf27f08eaccfab7edbde3cb7a350cf2d9b" "163602f90de012a7426ee39176523ca58bc964ccde619b652cb448bd678f7e21" *)
Parameter exactly1of2 : prop -> prop -> prop.
Axiom exactly1of2_I1 : forall A B : prop , A -> ~ B -> exactly1of2 A B.
Axiom exactly1of2_I2 : forall A B : prop , ~ A -> B -> exactly1of2 A B.
Axiom exactly1of2_E : forall A B : prop , exactly1of2 A B -> forall p : prop , (A -> ~ B -> p) -> (~ A -> B -> p) -> p.
Axiom exactly1of2_or : forall A B : prop , exactly1of2 A B -> A \/ B.
Axiom ReplI : forall A : set , forall F : set -> set , forall x : set , x :e A -> F x :e {F x|x :e A}.
Axiom ReplE : forall A : set , forall F : set -> set , forall y : set , y :e {F x|x :e A} -> exists x :e A , y = F x.
Axiom ReplE_impred : forall A : set , forall F : set -> set , forall y : set , y :e {F x|x :e A} -> forall p : prop , (forall x : set , x :e A -> y = F x -> p) -> p.
Axiom ReplE' : forall X , forall f : set -> set , forall p : set -> prop , (forall x :e X , p (f x)) -> forall y :e {f x|x :e X} , p y.
Axiom Repl_Empty : forall F : set -> set , {F x|x :e Empty} = Empty.
Axiom ReplEq_ext_sub : forall X , forall F G : set -> set , (forall x :e X , F x = G x) -> {F x|x :e X} c= {G x|x :e X}.
Axiom ReplEq_ext : forall X , forall F G : set -> set , (forall x :e X , F x = G x) -> {F x|x :e X} = {G x|x :e X}.
Axiom Repl_inv_eq : forall P : set -> prop , forall f g : set -> set , (forall x , P x -> g (f x) = x) -> forall X , (forall x :e X , P x) -> {g y|y :e {f x|x :e X}} = X.
Axiom Repl_invol_eq : forall P : set -> prop , forall f : set -> set , (forall x , P x -> f (f x) = x) -> forall X , (forall x :e X , P x) -> {f y|y :e {f x|x :e X}} = X.
(* Parameter If_i "8c8f550868df4fdc93407b979afa60092db4b1bb96087bc3c2f17fadf3f35cbf" "b8ff52f838d0ff97beb955ee0b26fad79602e1529f8a2854bda0ecd4193a8a3c" *)
Parameter If_i : prop -> set -> set -> set.
Notation IfThenElse If_i.
Axiom If_i_correct : forall p : prop , forall x y : set , p /\ (if p then x else y) = x \/ ~ p /\ (if p then x else y) = y.
Axiom If_i_0 : forall p : prop , forall x y : set , ~ p -> (if p then x else y) = y.
Axiom If_i_1 : forall p : prop , forall x y : set , p -> (if p then x else y) = x.
Axiom If_i_or : forall p : prop , forall x y : set , (if p then x else y) = x \/ (if p then x else y) = y.
(* Parameter UPair "80aea0a41bb8a47c7340fe8af33487887119c29240a470e920d3f6642b91990d" "74243828e4e6c9c0b467551f19c2ddaebf843f72e2437cc2dea41d079a31107f" *)
Parameter UPair : set -> set -> set.
Notation SetEnum2 UPair.
Axiom UPairE : forall x y z : set , x :e {y,z} -> x = y \/ x = z.
Axiom UPairI1 : forall y z : set , y :e {y,z}.
Axiom UPairI2 : forall y z : set , z :e {y,z}.
(* Parameter Sing "158bae29452f8cbf276df6f8db2be0a5d20290e15eca88ffe1e7b41d211d41d7" "bd01a809e97149be7e091bf7cbb44e0c2084c018911c24e159f585455d8e6bd0" *)
Parameter Sing : set -> set.
Notation SetEnum1 Sing.
Axiom SingI : forall x : set , x :e {x}.
Axiom SingE : forall x y : set , y :e {x} -> y = x.
Axiom Sing_inj : forall x y , {x} = {y} -> x = y.
(* Parameter binunion "0a445311c45f0eb3ba2217c35ecb47f122b2301b2b80124922fbf03a5c4d223e" "5e1ac4ac93257583d0e9e17d6d048ff7c0d6ccc1a69875b2a505a2d4da305784" *)
Parameter binunion : set -> set -> set.
(* Unicode :\/: "222a" *)
Infix :\/: 345 left  := binunion.
Axiom binunionI1 : forall X Y z : set , z :e X -> z :e X :\/: Y.
Axiom binunionI2 : forall X Y z : set , z :e Y -> z :e X :\/: Y.
Axiom binunionE : forall X Y z : set , z :e X :\/: Y -> z :e X \/ z :e Y.
Axiom binunionE' : forall X Y z , forall p : prop , (z :e X -> p) -> (z :e Y -> p) -> (z :e X :\/: Y -> p).
Axiom binunion_asso : forall X Y Z : set , X :\/: (Y :\/: Z) = (X :\/: Y) :\/: Z.
Axiom binunion_com_Subq : forall X Y : set , X :\/: Y c= Y :\/: X.
Axiom binunion_com : forall X Y : set , X :\/: Y = Y :\/: X.
Axiom binunion_idl : forall X : set , Empty :\/: X = X.
Axiom binunion_idr : forall X : set , X :\/: Empty = X.
Axiom binunion_Subq_1 : forall X Y : set , X c= X :\/: Y.
Axiom binunion_Subq_2 : forall X Y : set , Y c= X :\/: Y.
Axiom binunion_Subq_min : forall X Y Z : set , X c= Z -> Y c= Z -> X :\/: Y c= Z.
Axiom Subq_binunion_eq : forall X Y , (X c= Y) = (X :\/: Y = Y).
Definition SetAdjoin : set -> set -> set := fun X y => X :\/: {y}.
Notation SetEnum Empty Sing UPair SetAdjoin.
(* Parameter famunion "d772b0f5d472e1ef525c5f8bd11cf6a4faed2e76d4eacfa455f4d65cc24ec792" "b3e3bf86a58af5d468d398d3acad61ccc50261f43c856a68f8594967a06ec07a" *)
Parameter famunion : set -> (set -> set) -> set.
(* Unicode \/_ "22C3" *)
(* Subscript \/_ *)
Binder \/_ , := famunion.
Axiom famunionI : forall X : set , forall F : (set -> set) , forall x y : set , x :e X -> y :e F x -> y :e \/_ x :e X , F x.
Axiom famunionE : forall X : set , forall F : (set -> set) , forall y : set , y :e (\/_ x :e X , F x) -> exists x :e X , y :e F x.
Axiom famunionE_impred : forall X : set , forall F : (set -> set) , forall y : set , y :e (\/_ x :e X , F x) -> forall p : prop , (forall x , x :e X -> y :e F x -> p) -> p.
Axiom famunion_Empty : forall F : set -> set , (\/_ x :e Empty , F x) = Empty.
Axiom famunion_Subq : forall X , forall f g : set -> set , (forall x :e X , f x c= g x) -> famunion X f c= famunion X g.
Axiom famunion_ext : forall X , forall f g : set -> set , (forall x :e X , f x = g x) -> famunion X f = famunion X g.
Section SepSec.
Variable X : set.
Variable P : set -> prop.
Let z : set := Eps_i (fun z => z :e X /\ P z).
Let F : set -> set := fun x => if P x then x else z.
(* Parameter Sep "f7e63d81e8f98ac9bc7864e0b01f93952ef3b0cbf9777abab27bcbd743b6b079" "f336a4ec8d55185095e45a638507748bac5384e04e0c48d008e4f6a9653e9c44" *)
Parameter Sep : set.
End SepSec.
Notation Sep Sep.
Axiom SepI : forall X : set , forall P : (set -> prop) , forall x : set , x :e X -> P x -> x :e {x :e X|P x}.
Axiom SepE : forall X : set , forall P : (set -> prop) , forall x : set , x :e {x :e X|P x} -> x :e X /\ P x.
Axiom SepE1 : forall X : set , forall P : (set -> prop) , forall x : set , x :e {x :e X|P x} -> x :e X.
Axiom SepE2 : forall X : set , forall P : (set -> prop) , forall x : set , x :e {x :e X|P x} -> P x.
Axiom Sep_Empty : forall P : set -> prop , {x :e Empty|P x} = Empty.
Axiom Sep_Subq : forall X : set , forall P : set -> prop , {x :e X|P x} c= X.
Axiom Sep_In_Power : forall X : set , forall P : set -> prop , {x :e X|P x} :e Power X.
(* Parameter ReplSep "f627d20f1b21063483a5b96e4e2704bac09415a75fed6806a2587ce257f1f2fd" "ec807b205da3293041239ff9552e2912636525180ddecb3a2b285b91b53f70d8" *)
Parameter ReplSep : set -> (set -> prop) -> (set -> set) -> set.
Notation ReplSep ReplSep.
Axiom ReplSepI : forall X : set , forall P : set -> prop , forall F : set -> set , forall x : set , x :e X -> P x -> F x :e {F x|x :e X,P x}.
Axiom ReplSepE : forall X : set , forall P : set -> prop , forall F : set -> set , forall y : set , y :e {F x|x :e X,P x} -> exists x : set , x :e X /\ P x /\ y = F x.
Axiom ReplSepE_impred : forall X : set , forall P : set -> prop , forall F : set -> set , forall y : set , y :e {F x|x :e X,P x} -> forall p : prop , (forall x :e X , P x -> y = F x -> p) -> p.
(* Parameter binintersect "8cf6b1f490ef8eb37db39c526ab9d7c756e98b0eb12143156198f1956deb5036" "b2abd2e5215c0170efe42d2fa0fb8a62cdafe2c8fbd0d37ca14e3497e54ba729" *)
Parameter binintersect : set -> set -> set.
(* Unicode :/\: "2229" *)
Infix :/\: 340 left  := binintersect.
Axiom binintersectI : forall X Y z , z :e X -> z :e Y -> z :e X :/\: Y.
Axiom binintersectE : forall X Y z , z :e X :/\: Y -> z :e X /\ z :e Y.
Axiom binintersectE1 : forall X Y z , z :e X :/\: Y -> z :e X.
Axiom binintersectE2 : forall X Y z , z :e X :/\: Y -> z :e Y.
Axiom binintersect_Subq_1 : forall X Y : set , X :/\: Y c= X.
Axiom binintersect_Subq_2 : forall X Y : set , X :/\: Y c= Y.
Axiom binintersect_Subq_eq_1 : forall X Y , X c= Y -> X :/\: Y = X.
Axiom binintersect_Subq_max : forall X Y Z : set , Z c= X -> Z c= Y -> Z c= X :/\: Y.
Axiom binintersect_com_Subq : forall X Y : set , X :/\: Y c= Y :/\: X.
Axiom binintersect_com : forall X Y : set , X :/\: Y = Y :/\: X.
(* Parameter setminus "cc569397a7e47880ecd75c888fb7c5512aee4bcb1e7f6bd2c5f80cccd368c060" "c68e5a1f5f57bc5b6e12b423f8c24b51b48bcc32149a86fc2c30a969a15d8881" *)
Parameter setminus : set -> set -> set.
(* Unicode :\: "2216" *)
Infix :\: 350 := setminus.
Axiom setminusI : forall X Y z , (z :e X) -> (z /:e Y) -> z :e X :\: Y.
Axiom setminusE : forall X Y z , (z :e X :\: Y) -> z :e X /\ z /:e Y.
Axiom setminusE1 : forall X Y z , (z :e X :\: Y) -> z :e X.
Axiom setminusE2 : forall X Y z , (z :e X :\: Y) -> z /:e Y.
Axiom setminus_Subq : forall X Y : set , X :\: Y c= X.
Axiom setminus_Subq_contra : forall X Y Z : set , Z c= Y -> X :\: Y c= X :\: Z.
Axiom setminus_In_Power : forall A U , A :\: U :e Power A.
Axiom setminus_idr : forall X , X :\: Empty = X.
Axiom In_irref : forall x , x /:e x.
Axiom In_no2cycle : forall x y , x :e y -> y :e x -> False.
(* Parameter ordsucc "9db634daee7fc36315ddda5f5f694934869921e9c5f55e8b25c91c0a07c5cbec" "65d8837d7b0172ae830bed36c8407fcd41b7d875033d2284eb2df245b42295a6" *)
Parameter ordsucc : set -> set.
Axiom ordsuccI1 : forall x : set , x c= ordsucc x.
Axiom ordsuccI2 : forall x : set , x :e ordsucc x.
Axiom ordsuccE : forall x y : set , y :e ordsucc x -> y :e x \/ y = x.
Notation Nat Empty ordsucc.
Axiom neq_0_ordsucc : forall a : set , 0 <> ordsucc a.
Axiom neq_ordsucc_0 : forall a : set , ordsucc a <> 0.
Axiom ordsucc_inj : forall a b : set , ordsucc a = ordsucc b -> a = b.
Axiom ordsucc_inj_contra : forall a b : set , a <> b -> ordsucc a <> ordsucc b.
Axiom In_0_1 : 0 :e 1.
Axiom In_0_2 : 0 :e 2.
Axiom In_1_2 : 1 :e 2.
Axiom In_1_3 : 1 :e 3.
Axiom In_2_3 : 2 :e 3.
Axiom In_1_4 : 1 :e 4.
Axiom In_2_4 : 2 :e 4.
Axiom In_3_4 : 3 :e 4.
Axiom In_1_5 : 1 :e 5.
Axiom In_2_5 : 2 :e 5.
Axiom In_3_5 : 3 :e 5.
Axiom In_4_5 : 4 :e 5.
Axiom In_1_6 : 1 :e 6.
Axiom In_1_7 : 1 :e 7.
Axiom In_1_8 : 1 :e 8.
Definition nat_p : set->prop := fun n:set => forall p:set->prop, p 0 -> (forall x:set, p x -> p (ordsucc x)) -> p n.
Axiom nat_0 : nat_p 0.
Axiom nat_ordsucc : forall n : set , nat_p n -> nat_p (ordsucc n).
Axiom nat_1 : nat_p 1.
Axiom nat_2 : nat_p 2.
Axiom nat_3 : nat_p 3.
Axiom nat_4 : nat_p 4.
Axiom nat_5 : nat_p 5.
Axiom nat_6 : nat_p 6.
Axiom nat_7 : nat_p 7.
Axiom nat_8 : nat_p 8.
Axiom nat_0_in_ordsucc : forall n , nat_p n -> 0 :e ordsucc n.
Axiom nat_ordsucc_in_ordsucc : forall n , nat_p n -> forall m :e n , ordsucc m :e ordsucc n.
Axiom nat_ind : forall p : set -> prop , p 0 -> (forall n , nat_p n -> p n -> p (ordsucc n)) -> forall n , nat_p n -> p n.
Axiom nat_inv_impred : forall p : set -> prop , p 0 -> (forall n , nat_p n -> p (ordsucc n)) -> forall n , nat_p n -> p n.
Axiom nat_inv : forall n , nat_p n -> n = 0 \/ exists x , nat_p x /\ n = ordsucc x.
Axiom nat_complete_ind : forall p : set -> prop , (forall n , nat_p n -> (forall m :e n , p m) -> p n) -> forall n , nat_p n -> p n.
Axiom nat_p_trans : forall n , nat_p n -> forall m :e n , nat_p m.
Axiom nat_trans : forall n , nat_p n -> forall m :e n , m c= n.
Axiom nat_ordsucc_trans : forall n , nat_p n -> forall m :e ordsucc n , m c= n.
Axiom Union_ordsucc_eq : forall n , nat_p n -> Union (ordsucc n) = n.
Axiom cases_1 : forall i :e 1 , forall p : set -> prop , p 0 -> p i.
Axiom cases_2 : forall i :e 2 , forall p : set -> prop , p 0 -> p 1 -> p i.
Axiom cases_3 : forall i :e 3 , forall p : set -> prop , p 0 -> p 1 -> p 2 -> p i.
Axiom neq_0_1 : 0 <> 1.
Axiom neq_1_0 : 1 <> 0.
Axiom neq_0_2 : 0 <> 2.
Axiom neq_2_0 : 2 <> 0.
Axiom neq_1_2 : 1 <> 2.
Axiom neq_1_3 : 1 <> 3.
Axiom neq_2_3 : 2 <> 3.
Axiom neq_2_4 : 2 <> 4.
Axiom neq_3_4 : 3 <> 4.
Axiom ZF_closed_E : forall U , ZF_closed U -> forall p : prop , (Union_closed U -> Power_closed U -> Repl_closed U -> p) -> p.
Axiom ZF_Union_closed : forall U , ZF_closed U -> forall X :e U , Union X :e U.
Axiom ZF_Power_closed : forall U , ZF_closed U -> forall X :e U , Power X :e U.
Axiom ZF_Repl_closed : forall U , ZF_closed U -> forall X :e U , forall F : set -> set , (forall x :e X , F x :e U) -> {F x|x :e X} :e U.
Axiom ZF_UPair_closed : forall U , ZF_closed U -> forall x y :e U , {x,y} :e U.
Axiom ZF_Sing_closed : forall U , ZF_closed U -> forall x :e U , {x} :e U.
Axiom ZF_binunion_closed : forall U , ZF_closed U -> forall X Y :e U , (X :\/: Y) :e U.
Axiom ZF_ordsucc_closed : forall U , ZF_closed U -> forall x :e U , ordsucc x :e U.
Axiom nat_p_UnivOf_Empty : forall n : set , nat_p n -> n :e UnivOf Empty.
(* Unicode omega "3c9" *)
(* Parameter omega "39cdf86d83c7136517f803d29d0c748ea45a274ccbf9b8488f9cda3e21f4b47c" "6fc30ac8f2153537e397b9ff2d9c981f80c151a73f96cf9d56ae2ee27dfd1eb2" *)
Parameter omega : set.
Axiom omega_nat_p : forall n :e omega , nat_p n.
Axiom nat_p_omega : forall n : set , nat_p n -> n :e omega.
Axiom omega_ordsucc : forall n :e omega , ordsucc n :e omega.
Definition ordinal : set -> prop := fun alpha : set => TransSet alpha /\ forall beta :e alpha , TransSet beta.
Axiom ordinal_TransSet : forall alpha : set , ordinal alpha -> TransSet alpha.
Axiom ordinal_Empty : ordinal Empty.
Axiom ordinal_Hered : forall alpha : set , ordinal alpha -> forall beta :e alpha , ordinal beta.
Axiom TransSet_ordsucc : forall X : set , TransSet X -> TransSet (ordsucc X).
Axiom ordinal_ordsucc : forall alpha : set , ordinal alpha -> ordinal (ordsucc alpha).
Axiom nat_p_ordinal : forall n : set , nat_p n -> ordinal n.
Axiom ordinal_1 : ordinal 1.
Axiom ordinal_2 : ordinal 2.
Axiom omega_TransSet : TransSet omega.
Axiom omega_ordinal : ordinal omega.
Axiom ordsucc_omega_ordinal : ordinal (ordsucc omega).
Axiom TransSet_ordsucc_In_Subq : forall X : set , TransSet X -> forall x :e X , ordsucc x c= X.
Axiom ordinal_ordsucc_In_Subq : forall alpha , ordinal alpha -> forall beta :e alpha , ordsucc beta c= alpha.
Axiom ordinal_trichotomy_or : forall alpha beta : set , ordinal alpha -> ordinal beta -> alpha :e beta \/ alpha = beta \/ beta :e alpha.
Axiom ordinal_trichotomy_or_impred : forall alpha beta : set , ordinal alpha -> ordinal beta -> forall p : prop , (alpha :e beta -> p) -> (alpha = beta -> p) -> (beta :e alpha -> p) -> p.
Axiom ordinal_In_Or_Subq : forall alpha beta , ordinal alpha -> ordinal beta -> alpha :e beta \/ beta c= alpha.
Axiom ordinal_linear : forall alpha beta , ordinal alpha -> ordinal beta -> alpha c= beta \/ beta c= alpha.
Axiom ordinal_ordsucc_In_eq : forall alpha beta , ordinal alpha -> beta :e alpha -> ordsucc beta :e alpha \/ alpha = ordsucc beta.
Axiom ordinal_lim_or_succ : forall alpha , ordinal alpha -> (forall beta :e alpha , ordsucc beta :e alpha) \/ (exists beta :e alpha , alpha = ordsucc beta).
Axiom ordinal_ordsucc_In : forall alpha , ordinal alpha -> forall beta :e alpha , ordsucc beta :e ordsucc alpha.
Axiom ordinal_famunion : forall X , forall F : set -> set , (forall x :e X , ordinal (F x)) -> ordinal (\/_ x :e X , F x).
Axiom ordinal_binintersect : forall alpha beta , ordinal alpha -> ordinal beta -> ordinal (alpha :/\: beta).
Axiom ordinal_binunion : forall alpha beta , ordinal alpha -> ordinal beta -> ordinal (alpha :\/: beta).
Axiom ordinal_ind : forall p : set -> prop , (forall alpha , ordinal alpha -> (forall beta :e alpha , p beta) -> p alpha) -> forall alpha , ordinal alpha -> p alpha.
Axiom least_ordinal_ex : forall p : set -> prop , (exists alpha , ordinal alpha /\ p alpha) -> exists alpha , ordinal alpha /\ p alpha /\ forall beta :e alpha , ~ p beta.
Definition inj : set -> set -> (set -> set) -> prop := fun X Y f => (forall u :e X , f u :e Y) /\ (forall u v :e X , f u = f v -> u = v).
Definition bij : set -> set -> (set -> set) -> prop := fun X Y f => (forall u :e X , f u :e Y) /\ (forall u v :e X , f u = f v -> u = v) /\ (forall w :e Y , exists u :e X , f u = w).
Axiom bijI : forall X Y , forall f : set -> set , (forall u :e X , f u :e Y) -> (forall u v :e X , f u = f v -> u = v) -> (forall w :e Y , exists u :e X , f u = w) -> bij X Y f.
Axiom bijE : forall X Y , forall f : set -> set , bij X Y f -> forall p : prop , ((forall u :e X , f u :e Y) -> (forall u v :e X , f u = f v -> u = v) -> (forall w :e Y , exists u :e X , f u = w) -> p) -> p.
(* Parameter inv "e1e47685e70397861382a17f4ecc47d07cdab63beca11b1d0c6d2985d3e2d38b" "896fa967e973688effc566a01c68f328848acd8b37e857ad23e133fdd4a50463" *)
Parameter inv : set -> (set -> set) -> set -> set.
Axiom surj_rinv : forall X Y , forall f : set -> set , (forall w :e Y , exists u :e X , f u = w) -> forall y :e Y , inv X f y :e X /\ f (inv X f y) = y.
Axiom inj_linv : forall X , forall f : set -> set , (forall u v :e X , f u = f v -> u = v) -> forall x :e X , inv X f (f x) = x.
Axiom bij_inv : forall X Y , forall f : set -> set , bij X Y f -> bij Y X (inv X f).
Axiom bij_id : forall X , bij X X (fun x => x).
Axiom bij_comp : forall X Y Z : set , forall f g : set -> set , bij X Y f -> bij Y Z g -> bij X Z (fun x => g (f x)).
Definition equip : set -> set -> prop := fun X Y : set => exists f : set -> set , bij X Y f.
Axiom equip_ref : forall X , equip X X.
Axiom equip_sym : forall X Y , equip X Y -> equip Y X.
Axiom equip_tra : forall X Y Z , equip X Y -> equip Y Z -> equip X Z.
Axiom equip_0_Empty : forall X , equip X 0 -> X = 0.
Section SchroederBernstein.
Axiom KnasterTarski_set : forall A , forall F : set -> set , (forall U :e Power A , F U :e Power A) -> (forall U V :e Power A , U c= V -> F U c= F V) -> exists Y :e Power A , F Y = Y.
Axiom image_In_Power : forall A B , forall f : set -> set , (forall x :e A , f x :e B) -> forall U :e Power A , {f x|x :e U} :e Power B.
Axiom image_monotone : forall f : set -> set , forall U V , U c= V -> {f x|x :e U} c= {f x|x :e V}.
Axiom setminus_antimonotone : forall A U V , U c= V -> A :\: V c= A :\: U.
Axiom SchroederBernstein : forall A B , forall f g : set -> set , inj A B f -> inj B A g -> equip A B.
End SchroederBernstein.
Section PigeonHole.
Axiom PigeonHole_nat : forall n , nat_p n -> forall f : set -> set , (forall i :e ordsucc n , f i :e n) -> ~ (forall i j :e ordsucc n , f i = f j -> i = j).
Axiom PigeonHole_nat_bij : forall n , nat_p n -> forall f : set -> set , (forall i :e n , f i :e n) -> (forall i j :e n , f i = f j -> i = j) -> bij n n f.
End PigeonHole.
Definition finite : set -> prop := fun X => exists n :e omega , equip X n.
Axiom finite_ind : forall p : set -> prop , p Empty -> (forall X y , finite X -> y /:e X -> p X -> p (X :\/: {y})) -> forall X , finite X -> p X.
Axiom finite_Empty : finite 0.
Axiom adjoin_finite : forall X y , finite X -> finite (X :\/: {y}).
Axiom binunion_finite : forall X , finite X -> forall Y , finite Y -> finite (X :\/: Y).
Axiom famunion_nat_finite : forall X : set -> set , forall n , nat_p n -> (forall i :e n , finite (X i)) -> finite (\/_ i :e n , X i).
Axiom Subq_finite : forall X , finite X -> forall Y , Y c= X -> finite Y.
Axiom TransSet_In_ordsucc_Subq : forall x y , TransSet y -> x :e ordsucc y -> x c= y.
Axiom exandE_i : forall P Q : set -> prop , (exists x , P x /\ Q x) -> forall r : prop , (forall x , P x -> Q x -> r) -> r.
Axiom exandE_ii : forall P Q : (set -> set) -> prop , (exists x : set -> set , P x /\ Q x) -> forall p : prop , (forall x : set -> set , P x -> Q x -> p) -> p.
Axiom exandE_iii : forall P Q : (set -> set -> set) -> prop , (exists x : set -> set -> set , P x /\ Q x) -> forall p : prop , (forall x : set -> set -> set , P x -> Q x -> p) -> p.
Axiom exandE_iiii : forall P Q : (set -> set -> set -> set) -> prop , (exists x : set -> set -> set -> set , P x /\ Q x) -> forall p : prop , (forall x : set -> set -> set -> set , P x -> Q x -> p) -> p.
Section Descr_ii.
Variable P : (set -> set) -> prop.
(* Parameter Descr_ii "a6e81668bfd1db6e6eb6a13bf66094509af176d9d0daccda274aa6582f6dcd7c" "3bae39e9880bbf5d70538d82bbb05caf44c2c11484d80d06dee0589d6f75178c" *)
Parameter Descr_ii : set -> set.
Hypothesis Pex : exists f : set -> set , P f.
Hypothesis Puniq : forall f g : set -> set , P f -> P g -> f = g.
Axiom Descr_ii_prop : P Descr_ii.
End Descr_ii.
Section Descr_iii.
Variable P : (set -> set -> set) -> prop.
(* Parameter Descr_iii "dc42f3fe5d0c55512ef81fe5d2ad0ff27c1052a6814b1b27f5a5dcb6d86240bf" "ca5fc17a582fdd4350456951ccbb37275637ba6c06694213083ed9434fe3d545" *)
Parameter Descr_iii : set -> set -> set.
Hypothesis Pex : exists f : set -> set -> set , P f.
Hypothesis Puniq : forall f g : set -> set -> set , P f -> P g -> f = g.
Axiom Descr_iii_prop : P Descr_iii.
End Descr_iii.
Section Descr_Vo1.
Variable P : Vo 1 -> prop.
(* Parameter Descr_Vo1 "322bf09a1711d51a4512e112e1767cb2616a7708dc89d7312c8064cfee6e3315" "615c0ac7fca2b62596ed34285f29a77b39225d1deed75d43b7ae87c33ba37083" *)
Parameter Descr_Vo1 : Vo 1.
Hypothesis Pex : exists f : Vo 1 , P f.
Hypothesis Puniq : forall f g : Vo 1 , P f -> P g -> f = g.
Axiom Descr_Vo1_prop : P Descr_Vo1.
End Descr_Vo1.
Section If_ii.
Variable p : prop.
Variable f g : set -> set.
(* Parameter If_ii "e76df3235104afd8b513a92c00d3cc56d71dd961510bf955a508d9c2713c3f29" "17057f3db7be61b4e6bd237e7b37125096af29c45cb784bb9cc29b1d52333779" *)
Parameter If_ii : set -> set.
Axiom If_ii_1 : p -> If_ii = f.
Axiom If_ii_0 : ~ p -> If_ii = g.
End If_ii.
Section If_iii.
Variable p : prop.
Variable f g : set -> set -> set.
(* Parameter If_iii "53034f33cbed012c3c6db42812d3964f65a258627a765f5bede719198af1d1ca" "3314762dce5a2e94b7e9e468173b047dd4a9fac6ee2c5f553c6ea15e9c8b7542" *)
Parameter If_iii : set -> set -> set.
Axiom If_iii_1 : p -> If_iii = f.
Axiom If_iii_0 : ~ p -> If_iii = g.
End If_iii.
Section EpsilonRec_i.
Variable F : set -> (set -> set) -> set.
Definition In_rec_i_G : set -> set -> prop := fun X Y => forall R : set -> set -> prop , (forall X : set , forall f : set -> set , (forall x :e X , R x (f x)) -> R X (F X f)) -> R X Y.
(* Parameter In_rec_i "f97da687c51f5a332ff57562bd465232bc70c9165b0afe0a54e6440fc4962a9f" "fac413e747a57408ad38b3855d3cde8673f86206e95ccdadff2b5babaf0c219e" *)
Parameter In_rec_i : set -> set.
Axiom In_rec_i_G_c : forall X : set , forall f : set -> set , (forall x :e X , In_rec_i_G x (f x)) -> In_rec_i_G X (F X f).
Axiom In_rec_i_G_inv : forall X : set , forall Y : set , In_rec_i_G X Y -> exists f : set -> set , (forall x :e X , In_rec_i_G x (f x)) /\ Y = F X f.
Hypothesis Fr : forall X : set , forall g h : set -> set , (forall x :e X , g x = h x) -> F X g = F X h.
Axiom In_rec_i_G_f : forall X : set , forall Y Z : set , In_rec_i_G X Y -> In_rec_i_G X Z -> Y = Z.
Axiom In_rec_i_G_In_rec_i : forall X : set , In_rec_i_G X (In_rec_i X).
Axiom In_rec_i_G_In_rec_i_d : forall X : set , In_rec_i_G X (F X In_rec_i).
Axiom In_rec_i_eq : forall X : set , In_rec_i X = F X In_rec_i.
End EpsilonRec_i.
Section EpsilonRec_ii.
Variable F : set -> (set -> (set -> set)) -> (set -> set).
Definition In_rec_G_ii : set -> (set -> set) -> prop := fun X Y => forall R : set -> (set -> set) -> prop , (forall X : set , forall f : set -> (set -> set) , (forall x :e X , R x (f x)) -> R X (F X f)) -> R X Y.
(* Parameter In_rec_ii "4d137cad40b107eb0fc2c707372525f1279575e6cadb4ebc129108161af3cedb" "f3c9abbc5074c0d68e744893a170de526469426a5e95400ae7fc81f74f412f7e" *)
Parameter In_rec_ii : set -> (set -> set).
Axiom In_rec_G_ii_c : forall X : set , forall f : set -> (set -> set) , (forall x :e X , In_rec_G_ii x (f x)) -> In_rec_G_ii X (F X f).
Axiom In_rec_G_ii_inv : forall X : set , forall Y : (set -> set) , In_rec_G_ii X Y -> exists f : set -> (set -> set) , (forall x :e X , In_rec_G_ii x (f x)) /\ Y = F X f.
Hypothesis Fr : forall X : set , forall g h : set -> (set -> set) , (forall x :e X , g x = h x) -> F X g = F X h.
Axiom In_rec_G_ii_f : forall X : set , forall Y Z : (set -> set) , In_rec_G_ii X Y -> In_rec_G_ii X Z -> Y = Z.
Axiom In_rec_G_ii_In_rec_ii : forall X : set , In_rec_G_ii X (In_rec_ii X).
Axiom In_rec_G_ii_In_rec_ii_d : forall X : set , In_rec_G_ii X (F X In_rec_ii).
Axiom In_rec_ii_eq : forall X : set , In_rec_ii X = F X In_rec_ii.
End EpsilonRec_ii.
Section EpsilonRec_iii.
Variable F : set -> (set -> (set -> set -> set)) -> (set -> set -> set).
Definition In_rec_G_iii : set -> (set -> set -> set) -> prop := fun X Y => forall R : set -> (set -> set -> set) -> prop , (forall X : set , forall f : set -> (set -> set -> set) , (forall x :e X , R x (f x)) -> R X (F X f)) -> R X Y.
(* Parameter In_rec_iii "222f1b8dcfb0d2e33cc4b232e87cbcdfe5c4a2bdc5326011eb70c6c9aeefa556" "9b3a85b85e8269209d0ca8bf18ef658e56f967161bf5b7da5e193d24d345dd06" *)
Parameter In_rec_iii : set -> (set -> set -> set).
Axiom In_rec_G_iii_c : forall X : set , forall f : set -> (set -> set -> set) , (forall x :e X , In_rec_G_iii x (f x)) -> In_rec_G_iii X (F X f).
Axiom In_rec_G_iii_inv : forall X : set , forall Y : (set -> set -> set) , In_rec_G_iii X Y -> exists f : set -> (set -> set -> set) , (forall x :e X , In_rec_G_iii x (f x)) /\ Y = F X f.
Hypothesis Fr : forall X : set , forall g h : set -> (set -> set -> set) , (forall x :e X , g x = h x) -> F X g = F X h.
Axiom In_rec_G_iii_f : forall X : set , forall Y Z : (set -> set -> set) , In_rec_G_iii X Y -> In_rec_G_iii X Z -> Y = Z.
Axiom In_rec_G_iii_In_rec_iii : forall X : set , In_rec_G_iii X (In_rec_iii X).
Axiom In_rec_G_iii_In_rec_iii_d : forall X : set , In_rec_G_iii X (F X In_rec_iii).
Axiom In_rec_iii_eq : forall X : set , In_rec_iii X = F X In_rec_iii.
End EpsilonRec_iii.
Section NatRec.
Variable z : set.
Variable f : set -> set -> set.
Let F : set -> (set -> set) -> set := fun n g => if Union n :e n then f (Union n) (g (Union n)) else z.
Definition nat_primrec : set -> set := In_rec_i F.
Axiom nat_primrec_r : forall X : set , forall g h : set -> set , (forall x :e X , g x = h x) -> F X g = F X h.
Axiom nat_primrec_0 : nat_primrec 0 = z.
Axiom nat_primrec_S : forall n : set , nat_p n -> nat_primrec (ordsucc n) = f n (nat_primrec n).
End NatRec.
Section NatArith.
Definition add_nat : set -> set -> set := fun n m : set => nat_primrec n (fun _ r => ordsucc r) m.
Infix + 360 right  := add_nat.
Axiom add_nat_0R : forall n : set , n + 0 = n.
Axiom add_nat_SR : forall n m : set , nat_p m -> n + ordsucc m = ordsucc (n + m).
Axiom add_nat_p : forall n : set , nat_p n -> forall m : set , nat_p m -> nat_p (n + m).
Axiom add_nat_1_1_2 : 1 + 1 = 2.
Axiom add_nat_0L : forall m : set , nat_p m -> 0 + m = m.
Axiom add_nat_SL : forall n : set , nat_p n -> forall m : set , nat_p m -> ordsucc n + m = ordsucc (n + m).
Axiom add_nat_com : forall n : set , nat_p n -> forall m : set , nat_p m -> n + m = m + n.
Axiom nat_Subq_add_ex : forall n , nat_p n -> forall m , nat_p m -> n c= m -> exists k , nat_p k /\ m = k + n.
Definition mul_nat : set -> set -> set := fun n m : set => nat_primrec 0 (fun _ r => n + r) m.
Infix * 355 right  := mul_nat.
Axiom mul_nat_0R : forall n : set , n * 0 = 0.
Axiom mul_nat_SR : forall n m : set , nat_p m -> n * ordsucc m = n + n * m.
Axiom mul_nat_p : forall n : set , nat_p n -> forall m : set , nat_p m -> nat_p (n * m).
End NatArith.
Definition Inj1 : set -> set := In_rec_i (fun X f => {0} :\/: {f x|x :e X}).
Axiom Inj1_eq : forall X : set , Inj1 X = {0} :\/: {Inj1 x|x :e X}.
Axiom Inj1I1 : forall X : set , 0 :e Inj1 X.
Axiom Inj1I2 : forall X x : set , x :e X -> Inj1 x :e Inj1 X.
Axiom Inj1E : forall X y : set , y :e Inj1 X -> y = 0 \/ exists x :e X , y = Inj1 x.
Axiom Inj1NE1 : forall x : set , Inj1 x <> 0.
Axiom Inj1NE2 : forall x : set , Inj1 x /:e {0}.
Definition Inj0 : set -> set := fun X => {Inj1 x|x :e X}.
Axiom Inj0I : forall X x : set , x :e X -> Inj1 x :e Inj0 X.
Axiom Inj0E : forall X y : set , y :e Inj0 X -> exists x : set , x :e X /\ y = Inj1 x.
Definition Unj : set -> set := In_rec_i (fun X f => {f x|x :e X :\: {0}}).
Axiom Unj_eq : forall X : set , Unj X = {Unj x|x :e X :\: {0}}.
Axiom Unj_Inj1_eq : forall X : set , Unj (Inj1 X) = X.
Axiom Inj1_inj : forall X Y : set , Inj1 X = Inj1 Y -> X = Y.
Axiom Unj_Inj0_eq : forall X : set , Unj (Inj0 X) = X.
Axiom Inj0_inj : forall X Y : set , Inj0 X = Inj0 Y -> X = Y.
Axiom Inj0_0 : Inj0 0 = 0.
Axiom Inj0_Inj1_neq : forall X Y : set , Inj0 X <> Inj1 Y.
Definition setsum : set -> set -> set := fun X Y => {Inj0 x|x :e X} :\/: {Inj1 y|y :e Y}.
(* Unicode :+: "002b" *)
Infix :+: 450 left  := setsum.
Axiom Inj0_setsum : forall X Y x : set , x :e X -> Inj0 x :e X :+: Y.
Axiom Inj1_setsum : forall X Y y : set , y :e Y -> Inj1 y :e X :+: Y.
Axiom setsum_Inj_inv : forall X Y z : set , z :e X :+: Y -> (exists x :e X , z = Inj0 x) \/ (exists y :e Y , z = Inj1 y).
Axiom Inj0_setsum_0L : forall X : set , 0 :+: X = Inj0 X.
Axiom Subq_1_Sing0 : 1 c= {0}.
Axiom Subq_Sing0_1 : {0} c= 1.
Axiom eq_1_Sing0 : 1 = {0}.
Axiom Inj1_setsum_1L : forall X : set , 1 :+: X = Inj1 X.
Axiom nat_setsum1_ordsucc : forall n : set , nat_p n -> 1 :+: n = ordsucc n.
Axiom setsum_0_0 : 0 :+: 0 = 0.
Axiom setsum_1_0_1 : 1 :+: 0 = 1.
Axiom setsum_1_1_2 : 1 :+: 1 = 2.
Section pair_setsum.
Let pair := setsum.
Definition proj0 : set -> set := fun Z => {Unj z|z :e Z,exists x : set , Inj0 x = z}.
Definition proj1 : set -> set := fun Z => {Unj z|z :e Z,exists y : set , Inj1 y = z}.
Axiom Inj0_pair_0_eq : Inj0 = pair 0.
Axiom Inj1_pair_1_eq : Inj1 = pair 1.
Axiom pairI0 : forall X Y x , x :e X -> pair 0 x :e pair X Y.
Axiom pairI1 : forall X Y y , y :e Y -> pair 1 y :e pair X Y.
Axiom pairE : forall X Y z , z :e pair X Y -> (exists x :e X , z = pair 0 x) \/ (exists y :e Y , z = pair 1 y).
Axiom pairE0 : forall X Y x , pair 0 x :e pair X Y -> x :e X.
Axiom pairE1 : forall X Y y , pair 1 y :e pair X Y -> y :e Y.
Axiom proj0I : forall w u : set , pair 0 u :e w -> u :e proj0 w.
Axiom proj0E : forall w u : set , u :e proj0 w -> pair 0 u :e w.
Axiom proj1I : forall w u : set , pair 1 u :e w -> u :e proj1 w.
Axiom proj1E : forall w u : set , u :e proj1 w -> pair 1 u :e w.
Axiom proj0_pair_eq : forall X Y : set , proj0 (pair X Y) = X.
Axiom proj1_pair_eq : forall X Y : set , proj1 (pair X Y) = Y.
Definition Sigma : set -> (set -> set) -> set := fun X Y => \/_ x :e X , {pair x y|y :e Y x}.
(* Unicode Sigma_ "2211" *)
Binder+ Sigma_ , := Sigma.
Axiom pair_Sigma : forall X : set , forall Y : set -> set , forall x :e X , forall y :e Y x , pair x y :e Sigma_ x :e X , Y x.
Axiom Sigma_eta_proj0_proj1 : forall X : set , forall Y : set -> set , forall z :e (Sigma_ x :e X , Y x) , pair (proj0 z) (proj1 z) = z /\ proj0 z :e X /\ proj1 z :e Y (proj0 z).
Axiom proj_Sigma_eta : forall X : set , forall Y : set -> set , forall z :e (Sigma_ x :e X , Y x) , pair (proj0 z) (proj1 z) = z.
Axiom proj0_Sigma : forall X : set , forall Y : set -> set , forall z : set , z :e (Sigma_ x :e X , Y x) -> proj0 z :e X.
Axiom proj1_Sigma : forall X : set , forall Y : set -> set , forall z : set , z :e (Sigma_ x :e X , Y x) -> proj1 z :e Y (proj0 z).
Axiom pair_Sigma_E1 : forall X : set , forall Y : set -> set , forall x y : set , pair x y :e (Sigma_ x :e X , Y x) -> y :e Y x.
Axiom Sigma_E : forall X : set , forall Y : set -> set , forall z : set , z :e (Sigma_ x :e X , Y x) -> exists x :e X , exists y :e Y x , z = pair x y.
Definition setprod : set -> set -> set := fun X Y : set => Sigma_ x :e X , Y.
(* Unicode :*: "2a2f" *)
Infix :*: 440 left  := setprod.
Let lam : set -> (set -> set) -> set := Sigma.
Definition ap : set -> set -> set := fun f x => {proj1 z|z :e f,exists y : set , z = pair x y}.
Notation SetImplicitOp ap.
Notation SetLam Sigma.
Axiom lamI : forall X : set , forall F : set -> set , forall x :e X , forall y :e F x , pair x y :e fun x :e X => F x.
Axiom lamE : forall X : set , forall F : set -> set , forall z : set , z :e (fun x :e X => F x) -> exists x :e X , exists y :e F x , z = pair x y.
Axiom apI : forall f x y , pair x y :e f -> y :e f x.
Axiom apE : forall f x y , y :e f x -> pair x y :e f.
Axiom beta : forall X : set , forall F : set -> set , forall x : set , x :e X -> (fun x :e X => F x) x = F x.
Axiom proj0_ap_0 : forall u , proj0 u = u 0.
Axiom proj1_ap_1 : forall u , proj1 u = u 1.
Axiom pair_ap_0 : forall x y : set , (pair x y) 0 = x.
Axiom pair_ap_1 : forall x y : set , (pair x y) 1 = y.
Axiom ap0_Sigma : forall X : set , forall Y : set -> set , forall z : set , z :e (Sigma_ x :e X , Y x) -> (z 0) :e X.
Axiom ap1_Sigma : forall X : set , forall Y : set -> set , forall z : set , z :e (Sigma_ x :e X , Y x) -> (z 1) :e (Y (z 0)).
Definition pair_p : set -> prop := fun u : set => pair (u 0) (u 1) = u.
Axiom pair_p_I : forall x y , pair_p (pair x y).
Axiom Subq_2_UPair01 : 2 c= {0,1}.
Axiom tuple_pair : forall x y : set , pair x y = (x,y).
Definition Pi : set -> (set -> set) -> set := fun X Y => {f :e Power (Sigma_ x :e X , Union (Y x))|forall x :e X , f x :e Y x}.
(* Unicode Pi_ "220f" *)
Binder+ Pi_ , := Pi.
Axiom PiI : forall X : set , forall Y : set -> set , forall f : set , (forall u :e f , pair_p u /\ u 0 :e X) -> (forall x :e X , f x :e Y x) -> f :e Pi_ x :e X , Y x.
Axiom lam_Pi : forall X : set , forall Y : set -> set , forall F : set -> set , (forall x :e X , F x :e Y x) -> (fun x :e X => F x) :e (Pi_ x :e X , Y x).
Axiom ap_Pi : forall X : set , forall Y : set -> set , forall f : set , forall x : set , f :e (Pi_ x :e X , Y x) -> x :e X -> f x :e Y x.
Definition setexp : set -> set -> set := fun X Y : set => Pi_ y :e Y , X.
(* Superscript :^: *)
Infix :^: 430 left  := setexp.
Axiom pair_tuple_fun : pair = (fun x y => (x,y)).
Axiom lamI2 : forall X , forall F : set -> set , forall x :e X , forall y :e F x , (x,y) :e fun x :e X => F x.
Section Tuples.
Variable x0 x1 : set.
Axiom tuple_2_0_eq : (x0,x1) 0 = x0.
Axiom tuple_2_1_eq : (x0,x1) 1 = x1.
End Tuples.
Axiom ReplEq_setprod_ext : forall X Y , forall F G : set -> set -> set , (forall x :e X , forall y :e Y , F x y = G x y) -> {F (w 0) (w 1)|w :e X :*: Y} = {G (w 0) (w 1)|w :e X :*: Y}.
Axiom tuple_2_Sigma : forall X : set , forall Y : set -> set , forall x :e X , forall y :e Y x , (x,y) :e Sigma_ x :e X , Y x.
Axiom tuple_2_setprod : forall X : set , forall Y : set , forall x :e X , forall y :e Y , (x,y) :e X :*: Y.
End pair_setsum.
