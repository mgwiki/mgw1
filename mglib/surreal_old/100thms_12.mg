(* Parameter Eps_i "174b78e53fc239e8c2aab4ab5a996a27e3e5741e88070dad186e05fb13f275e5" *)
Parameter Eps_i : (set->prop)->set.
Axiom Eps_i_ax : forall P:set->prop, forall x:set, P x -> P (Eps_i P).
Definition True : prop := forall p:prop, p -> p.
Definition False : prop := forall p:prop, p.
Definition not : prop -> prop := fun A:prop => A -> False.
(* Unicode ~ "00ac" *)
Prefix ~ 700 := not.
Definition and : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> B -> p) -> p.
(* Unicode /\ "2227" *)
Infix /\ 780 left := and.
Definition or : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> p) -> (B -> p) -> p.
(* Unicode \/ "2228" *)
Infix \/ 785 left := or.
Definition iff : prop -> prop -> prop := fun A B:prop => and (A -> B) (B -> A).
(* Unicode <-> "2194" *)
Infix <-> 805 := iff.
Section Eq.
Variable A:SType.
Definition eq : A->A->prop := fun x y:A => forall Q:A->A->prop, Q x y -> Q y x.
Definition neq : A->A->prop := fun x y:A => ~ eq x y.
End Eq.
Infix = 502 := eq.
(* Unicode <> "2260" *)
Infix <> 502 := neq.
Section FE.
Variable A B : SType.
Axiom func_ext : forall f g : A -> B , (forall x : A , f x = g x) -> f = g.
End FE.
Section Ex.
Variable A:SType.
Definition ex : (A->prop)->prop := fun Q:A->prop => forall P:prop, (forall x:A, Q x -> P) -> P.
End Ex.
(* Unicode exists "2203" *)
Binder+ exists , := ex.
Axiom prop_ext : forall p q:prop, iff p q -> p = q.
Parameter In:set->set->prop.
Definition Subq : set -> set -> prop := fun A B => forall x :e A, x :e B.
Axiom set_ext : forall X Y:set, X c= Y -> Y c= X -> X = Y.
Axiom In_ind : forall P:set->prop, (forall X:set, (forall x :e X, P x) -> P X) -> forall X:set, P X.
Binder+ exists , := ex; and.
Parameter Empty : set.
Axiom EmptyAx : ~exists x:set, x :e Empty.
(* Unicode Union "22C3" *)
Parameter Union : set->set.
Axiom UnionEq : forall X x, x :e Union X <-> exists Y, x :e Y /\ Y :e X.
(* Unicode Power "1D4AB" *)
Parameter Power : set->set.
Axiom PowerEq : forall X Y:set, Y :e Power X <-> Y c= X.
Parameter Repl : set -> (set -> set) -> set.
Notation Repl Repl.
Axiom ReplEq : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} <-> exists x :e A, y = F x.
Definition TransSet : set->prop := fun U:set => forall x :e U, x c= U.
Definition Union_closed : set->prop := fun U:set => forall X:set, X :e U -> Union X :e U.
Definition Power_closed : set->prop := fun U:set => forall X:set, X :e U -> Power X :e U.
Definition Repl_closed : set->prop := fun U:set => forall X:set, X :e U -> forall F:set->set,
   (forall x:set, x :e X -> F x :e U) -> {F x|x :e X} :e U.
Definition ZF_closed : set->prop := fun U:set =>
   Union_closed U
/\ Power_closed U
/\ Repl_closed U.
Parameter UnivOf : set->set.
Axiom UnivOf_In : forall N:set, N :e UnivOf N.
Axiom UnivOf_TransSet : forall N:set, TransSet (UnivOf N).
Axiom UnivOf_ZF_closed : forall N:set, ZF_closed (UnivOf N).
Axiom UnivOf_Min : forall N U:set, N :e U
  -> TransSet U
  -> ZF_closed U
  -> UnivOf N c= U.

Theorem andI : forall (A B : prop), A -> B -> A /\ B.
exact (fun A B a b P H => H a b).
Qed.

Theorem orIL : forall (A B : prop), A -> A \/ B.
exact (fun A B a P H1 H2 => H1 a).
Qed.

Theorem orIR : forall (A B : prop), B -> A \/ B.
exact (fun A B b P H1 H2 => H2 b).
Qed.

Theorem iffI : forall A B:prop, (A -> B) -> (B -> A) -> (A <-> B).
exact (fun A B => andI (A -> B) (B -> A)).
Qed.

Theorem pred_ext : forall P Q:set -> prop, (forall x, P x <-> Q x) -> P = Q.
let P Q. assume H1. apply func_ext set prop.
let x. apply prop_ext.
prove P x <-> Q x. exact H1 x.
Qed.

Definition nIn : set->set->prop :=
fun x X => ~In x X.
(* Unicode /:e "2209" *)
Infix /:e 502 := nIn.

Theorem EmptyE : forall x:set, x /:e Empty.
let x. assume H.
apply EmptyAx.
witness x. exact H.
Qed.

Theorem PowerI : forall X Y:set, Y c= X -> Y :e Power X.
let X Y. apply PowerEq X Y. exact (fun _ H => H).
Qed.

Theorem Subq_Empty : forall X:set, Empty c= X.
exact (fun (X x : set) (H : x :e Empty) => EmptyE x H (x :e X)).
Qed.

Theorem Empty_In_Power : forall X:set, Empty :e Power X.
exact (fun X : set => PowerI X Empty (Subq_Empty X)).
Qed.

Theorem xm : forall P:prop, P \/ ~P.
let P:prop.
set p1 := fun x : set => x = Empty \/ P.
set p2 := fun x : set => x <> Empty \/ P.
claim L1:p1 Empty.
{ prove (Empty = Empty \/ P). apply orIL. exact (fun q H => H). }
claim L2: (Eps_i p1) = Empty \/ P.
{ exact (Eps_i_ax p1 Empty L1). }
claim L3:p2 (Power Empty).
{ prove ~(Power Empty = Empty) \/ P. apply orIL.
  assume H1: Power Empty = Empty.
  apply EmptyE Empty.
  prove Empty :e Empty.
  rewrite <- H1 at 2. apply Empty_In_Power.
}
claim L4: Eps_i p2 <> Empty \/ P.
{ exact (Eps_i_ax p2 (Power Empty) L3). }
apply L2.
- assume H1: Eps_i p1 = Empty.
  apply L4.
  + assume H2: Eps_i p2 <> Empty.
    prove P \/ ~ P.
    apply orIR.
    prove ~ P.
    assume H3 : P.
    claim L5:p1 = p2.
    { apply pred_ext. let x. apply iffI.
      - assume H4.
        prove (~(x = Empty) \/ P).
        apply orIR.
        prove P.
        exact H3.
      - assume H4.
        prove (x = Empty \/ P).
        apply orIR.
        prove P.
        exact H3.
    }
    apply H2. rewrite <- L5. exact H1.
  + assume H2:P.
    prove P \/ ~ P.
    apply orIL.
    prove P.
    exact H2.
- assume H1:P.
    prove P \/ ~ P.
    apply orIL.
    prove P.
    exact H1.
Qed.

Theorem FalseE : False -> forall p:prop, p.
exact (fun H => H).
Qed.

Theorem andEL : forall (A B : prop), A /\ B -> A.
exact (fun A B H => H A (fun a b => a)).
Qed.

Theorem andER : forall (A B : prop), A /\ B -> B.
exact (fun A B H => H B (fun a b => b)).
Qed.

Section PropN.
Variable P1 P2 P3:prop.

Theorem and3I : P1 -> P2 -> P3 -> P1 /\ P2 /\ P3.
exact (fun H1 H2 H3 => andI (P1 /\ P2) P3 (andI P1 P2 H1 H2) H3).
Qed.

Theorem and3E : P1 /\ P2 /\ P3 -> (forall p:prop, (P1 -> P2 -> P3 -> p) -> p).
exact (fun u p H => u p (fun u u3 => u p (fun u1 u2 => H u1 u2 u3))).
Qed.

Theorem or3I1 : P1 -> P1 \/ P2 \/ P3.
exact (fun u => orIL (P1 \/ P2) P3 (orIL P1 P2 u)).
Qed.

Theorem or3I2 : P2 -> P1 \/ P2 \/ P3.
exact (fun u => orIL (P1 \/ P2) P3 (orIR P1 P2 u)).
Qed.

Theorem or3I3 : P3 -> P1 \/ P2 \/ P3.
exact (orIR (P1 \/ P2) P3).
Qed.

Theorem or3E : P1 \/ P2 \/ P3 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> p).
exact (fun u p H1 H2 H3 => u p (fun u => u p H1 H2) H3).
Qed.

Variable P4:prop.

Theorem and4I : P1 -> P2 -> P3 -> P4 -> P1 /\ P2 /\ P3 /\ P4.
exact (fun H1 H2 H3 H4 => andI (P1 /\ P2 /\ P3) P4 (and3I H1 H2 H3) H4).
Qed.

Variable P5:prop.

Theorem and5I : P1 -> P2 -> P3 -> P4 -> P5 -> P1 /\ P2 /\ P3 /\ P4 /\ P5.
exact (fun H1 H2 H3 H4 H5 => andI (P1 /\ P2 /\ P3 /\ P4) P5 (and4I H1 H2 H3 H4) H5).
Qed.

Variable P6:prop.

Theorem and6I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6.
exact (fun H1 H2 H3 H4 H5 H6 => andI (P1 /\ P2 /\ P3 /\ P4 /\ P5) P6 (and5I H1 H2 H3 H4 H5) H6).
Qed.

Variable P7:prop.

Theorem and7I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7.
exact (fun H1 H2 H3 H4 H5 H6 H7 => andI (P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6) P7 (and6I H1 H2 H3 H4 H5 H6) H7).
Qed.

End PropN.

Theorem not_or_and_demorgan : forall A B:prop, ~(A \/ B) -> ~A /\ ~B.
let A B.
assume u : ~(A \/ B).
apply andI.
- prove ~A. assume a:A. exact (u (orIL A B a)).
- prove ~B. assume b:B. exact (u (orIR A B b)).
Qed.

Theorem not_ex_all_demorgan_i : forall P:set->prop, (~exists x, P x) -> forall x, ~P x.
let P. assume H1. let x. assume H2. apply H1.
witness x.
exact H2.
Qed.

Theorem iffEL : forall A B:prop, (A <-> B) -> A -> B.
exact (fun A B => andEL (A -> B) (B -> A)).
Qed.

Theorem iffER : forall A B:prop, (A <-> B) -> B -> A.
exact (fun A B => andER (A -> B) (B -> A)).
Qed.

Theorem iff_refl : forall A:prop, A <-> A.
exact (fun A:prop => andI (A -> A) (A -> A) (fun H : A => H) (fun H : A => H)).
Qed.

Theorem iff_sym : forall A B:prop, (A <-> B) -> (B <-> A).
let A B.
assume H1: (A -> B) /\ (B -> A).
apply H1.
assume H2: A -> B.
assume H3: B -> A.
exact iffI B A H3 H2.
Qed.

Theorem iff_trans : forall A B C: prop, (A <-> B) -> (B <-> C) -> (A <-> C).
let A B C.
assume H1: A <-> B.
assume H2: B <-> C.
apply H1.
assume H3: A -> B.
assume H4: B -> A.
apply H2.
assume H5: B -> C.
assume H6: C -> B.
exact (iffI A C (fun H => H5 (H3 H)) (fun H => H4 (H6 H))).
Qed.

Theorem eq_i_tra : forall x y z, x = y -> y = z -> x = z.
let x y z. assume H1 H2. rewrite <- H2. exact H1.
Qed.

Theorem neq_i_sym: forall x y, x <> y -> y <> x.
let x y. assume H1 H2. apply H1. symmetry. exact H2.
Qed.

Theorem Eps_i_ex : forall P:set -> prop, (exists x, P x) -> P (Eps_i P).
let P. assume H1. apply H1.
let x. assume H2.
exact Eps_i_ax P x H2.
Qed.

Theorem prop_ext_2 : forall p q:prop, (p -> q) -> (q -> p) -> p = q.
let p q. assume H1 H2. apply prop_ext. apply iffI.
- exact H1.
- exact H2.
Qed.

Theorem Subq_ref : forall X:set, X c= X.
exact (fun (X x : set) (H : x :e X) => H).
Qed.

Theorem Subq_tra : forall X Y Z:set, X c= Y -> Y c= Z -> X c= Z.
exact (fun (X Y Z : set) (H1 : X c= Y) (H2 : Y c= Z) (x : set) (H : x :e X) => (H2 x (H1 x H))).
Qed.

Theorem Empty_Subq_eq : forall X:set, X c= Empty -> X = Empty.
let X.
assume H1: X c= Empty.
apply set_ext.
- exact H1.
- exact (Subq_Empty X).
Qed.

Theorem Empty_eq : forall X:set, (forall x, x /:e X) -> X = Empty.
let X.
assume H1: forall x, x /:e X.
apply Empty_Subq_eq.
let x.
assume H2: x :e X.
prove False.
exact (H1 x H2).
Qed.

Theorem UnionI : forall X x Y:set, x :e Y -> Y :e X -> x :e Union X.
let X x Y.
assume H1: x :e Y.
assume H2: Y :e X.
apply UnionEq X x.
assume _ H3. apply H3.
prove exists Y:set, x :e Y /\ Y :e X.
witness Y.
apply andI.
- exact H1.
- exact H2.
Qed.

Theorem UnionE : forall X x:set, x :e Union X -> exists Y:set, x :e Y /\ Y :e X.
exact (fun X x : set => iffEL (x :e Union X) (exists Y:set, x :e Y /\ Y :e X) (UnionEq X x)).
Qed.

Theorem UnionE_impred : forall X x:set, x :e Union X -> forall p:prop, (forall Y:set, x :e Y -> Y :e X -> p) -> p.
let X x. assume H1.
let p. assume Hp.
apply UnionE X x H1.
let x. assume H2. apply H2.
exact Hp x.
Qed.

Theorem PowerE : forall X Y:set, Y :e Power X -> Y c= X.
let X Y. apply PowerEq X Y. exact (fun H _ => H).
Qed.

Theorem Self_In_Power : forall X:set, X :e Power X.
exact (fun X : set => PowerI X X (Subq_ref X)).
Qed.

Theorem dneg : forall P:prop, ~~P -> P.
let P. assume H1.
apply xm P.
- exact (fun H => H).
- assume H2: ~P.
  prove False.
  exact H1 H2.
Qed.

Theorem not_all_ex_demorgan_i : forall P:set->prop, ~(forall x, P x) -> exists x, ~P x.
let P.
assume u:~forall x, P x.
apply dneg.
assume v:~exists x, ~P x.
apply u. let x. apply dneg.
assume w:~P x. 
exact (not_ex_all_demorgan_i (fun x => ~P x) v x w).
Qed.

Theorem eq_or_nand : or = (fun (x y:prop) => ~(~x /\ ~y)).
apply func_ext prop (prop -> prop).
let x. apply func_ext prop prop.
let y. apply prop_ext_2.
- assume H1: x \/ y.
  assume H2: ~x /\ ~y.
  apply H2. assume H3 H4. exact (H1 False H3 H4).
- assume H1:~(~x /\ ~y).
  apply (xm x).
  + assume H2: x. apply orIL. exact H2.
  + assume H2: ~x. apply (xm y).
    * assume H3: y. apply orIR. exact H3.
    * assume H3: ~y. apply H1. exact (andI (~x) (~y) H2 H3).
Qed.

(* Parameter exactly1of2 "3578b0d6a7b318714bc5ea889c6a38cf27f08eaccfab7edbde3cb7a350cf2d9b" "163602f90de012a7426ee39176523ca58bc964ccde619b652cb448bd678f7e21" *)
Definition exactly1of2 : prop->prop->prop := fun A B:prop =>
A /\ ~B \/ ~A /\ B.

Theorem exactly1of2_I1 : forall A B:prop, A -> ~B -> exactly1of2 A B.
let A B.
assume HA: A.
assume HB: ~B.
prove A /\ ~B \/ ~A /\ B.
apply orIL.
prove A /\ ~B.
exact (andI A (~B) HA HB).
Qed.

Theorem exactly1of2_I2 : forall A B:prop, ~A -> B -> exactly1of2 A B.
let A B.
assume HA: ~A.
assume HB: B.
prove A /\ ~B \/ ~A /\ B.
apply orIR.
prove ~A /\ B.
exact (andI (~A) B HA HB).
Qed.

Theorem exactly1of2_E : forall A B:prop, exactly1of2 A B ->
forall p:prop,
(A -> ~B -> p) ->
(~A -> B -> p) ->
p.
let A B.
assume H1: exactly1of2 A B.
let p.
assume H2 : A -> ~B -> p.
assume H3 : ~A -> B -> p.
apply (H1 p).
- exact (fun H4 : A /\ ~B => H4 p H2).
- exact (fun H4 : ~A /\ B => H4 p H3).
Qed.

Theorem exactly1of2_or : forall A B:prop, exactly1of2 A B -> A \/ B.
let A B.
assume H1: exactly1of2 A B.
apply (exactly1of2_E A B H1 (A \/ B)).
- exact (fun (HA : A) (_ : ~B) => orIL A B HA).
- exact (fun (_ : ~A) (HB : B) => orIR A B HB).
Qed.

Theorem ReplI : forall A:set, forall F:set->set, forall x:set, x :e A -> F x :e {F x|x :e A}.
let A F x. assume H1.
apply ReplEq A F (F x).
assume _ H2. apply H2.
prove exists x' :e A, F x = F x'.
witness x. apply andI.
- exact H1.
- exact (fun q H => H).
Qed.

Theorem ReplE : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} -> exists x :e A, y = F x.
let A F y. apply ReplEq A F y. exact (fun H _ => H).
Qed.

Theorem ReplE_impred : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} -> forall p:prop, (forall x:set, x :e A -> y = F x -> p) -> p.
let A F y. assume H1.
apply ReplE A F y H1.
let x. assume H2. apply H2.
assume H3 H4.
let p. assume Hp.
exact Hp x H3 H4.
Qed.

Theorem ReplE' : forall X, forall f:set -> set, forall p:set -> prop, (forall x :e X, p (f x)) -> forall y :e {f x|x :e X}, p y.
let X f p. assume H1. let y. assume Hy.
apply ReplE_impred X f y Hy.
let x. assume Hx: x :e X. assume Hx2: y = f x.
prove p y. rewrite Hx2. exact H1 x Hx.
Qed.

Theorem Repl_Empty : forall F:set -> set, {F x|x :e Empty} = Empty.
let F. apply (Empty_eq {F x|x :e Empty}).
let y.
assume H1: y :e {F x|x :e Empty}.
apply (ReplE_impred Empty F y H1).
let x.
assume H2: x :e Empty.
assume _.
exact (EmptyE x H2).
Qed.

Theorem ReplEq_ext_sub : forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> {F x|x :e X} c= {G x|x :e X}.
let X F G.
assume H1: forall x :e X, F x = G x.
let y. assume Hy: y :e {F x|x :e X}.
apply ReplE_impred X F y Hy.
let x. assume Hx: x :e X.
assume H2: y = F x.
prove y :e {G x|x :e X}.
rewrite H2.
prove F x :e {G x|x :e X}.
rewrite H1 x Hx.
prove G x :e {G x|x :e X}.
apply ReplI. exact Hx.
Qed.

Theorem ReplEq_ext : forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> {F x|x :e X} = {G x|x :e X}.
let X F G.
assume H1: forall x :e X, F x = G x.
apply set_ext.
- exact ReplEq_ext_sub X F G H1.
- apply ReplEq_ext_sub X G F.
  let x. assume Hx. symmetry. exact H1 x Hx.
Qed.

Theorem Repl_inv_eq : forall P:set -> prop, forall f g:set -> set,
    (forall x, P x -> g (f x) = x)
 -> forall X, (forall x :e X, P x) -> {g y|y :e {f x|x :e X}} = X.
let P f g. assume H1. let X. assume HX.
apply set_ext.
- let w. assume Hw: w :e {g y|y :e {f x|x :e X}}.
  apply ReplE_impred {f x|x :e X} g w Hw.
  let y. assume Hy: y :e {f x|x :e X}.
  assume Hwy: w = g y.
  apply ReplE_impred X f y Hy.
  let x. assume Hx: x :e X.
  assume Hyx: y = f x.
  prove w :e X. rewrite Hwy. rewrite Hyx.
  prove g (f x) :e X.
  rewrite H1 x (HX x Hx).
  exact Hx.
- let x. assume Hx: x :e X.
  rewrite <- H1 x (HX x Hx).
  prove g (f x) :e {g y|y :e {f x|x :e X}}.
  apply ReplI.
  prove f x :e {f x|x :e X}.
  apply ReplI. exact Hx.
Qed.

Theorem Repl_invol_eq : forall P:set -> prop, forall f:set -> set,
    (forall x, P x -> f (f x) = x)
 -> forall X, (forall x :e X, P x) -> {f y|y :e {f x|x :e X}} = X.
let P f. assume H1.
exact Repl_inv_eq P f f H1.
Qed.

(* Parameter If_i "8c8f550868df4fdc93407b979afa60092db4b1bb96087bc3c2f17fadf3f35cbf" "b8ff52f838d0ff97beb955ee0b26fad79602e1529f8a2854bda0ecd4193a8a3c" *)
Definition If_i : prop->set->set->set := (fun p x y => Eps_i (fun z:set => p /\ z = x \/ ~p /\ z = y)).
Notation IfThenElse If_i.

Theorem If_i_correct : forall p:prop, forall x y:set,
p /\ (if p then x else y) = x \/ ~p /\ (if p then x else y) = y.
let p x y.
apply (xm p).
- assume H1: p.
  claim L1: p /\ x = x \/ ~p /\ x = y.
  {
    apply orIL. apply andI.
    - exact H1.
    - reflexivity.
  }
  exact (Eps_i_ax (fun z : set => p /\ z = x \/ ~ p /\ z = y) x L1).
- assume H1: ~p.
  claim L1: p /\ y = x \/ ~p /\ y = y.
  {
    apply orIR. apply andI.
    - exact H1.
    - reflexivity.
  }
  exact (Eps_i_ax (fun z : set => p /\ z = x \/ ~ p /\ z = y) y L1).
Qed.

Theorem If_i_0 : forall p:prop, forall x y:set,
~ p -> (if p then x else y) = y.
let p x y.
assume H1: ~p.
apply (If_i_correct p x y).
- assume H2: p /\ (if p then x else y) = x.
  exact (H1 (andEL p ((if p then x else y) = x) H2) ((if p then x else y) = y)).
- assume H2: ~p /\ (if p then x else y) = y.
  exact (andER (~p) ((if p then x else y) = y) H2).
Qed.

Theorem If_i_1 : forall p:prop, forall x y:set,
p -> (if p then x else y) = x.
let p x y.
assume H1: p.
apply (If_i_correct p x y).
- assume H2: p /\ (if p then x else y) = x.
  exact (andER p ((if p then x else y) = x) H2).
- assume H2: ~p /\ (if p then x else y) = y.
  exact (andEL (~p) ((if p then x else y) = y) H2 H1 ((if p then x else y) = x)).
Qed.

Theorem If_i_or : forall p:prop, forall x y:set, (if p then x else y) = x \/ (if p then x else y) = y.
let p x y.
apply (xm p).
- assume H1: p. apply orIL. exact (If_i_1 p x y H1).
- assume H1: ~p. apply orIR. exact (If_i_0 p x y H1).
Qed.

(* Parameter UPair "80aea0a41bb8a47c7340fe8af33487887119c29240a470e920d3f6642b91990d" "74243828e4e6c9c0b467551f19c2ddaebf843f72e2437cc2dea41d079a31107f" *)
Definition UPair : set->set->set :=
fun y z => {if Empty :e X then y else z | X :e Power (Power Empty)}.
Notation SetEnum2 UPair.

Theorem UPairE :
forall x y z:set, x :e {y,z} -> x = y \/ x = z.
let x y z.
assume H1: x :e {y,z}.
apply (ReplE (Power (Power Empty)) (fun X => if Empty :e X then y else z) x H1).
let X.
assume H2: X :e Power (Power Empty) /\ x = if Empty :e X then y else z.
claim L1: x = if Empty :e X then y else z.
{ exact (andER (X :e Power (Power Empty)) (x = if Empty :e X then y else z) H2). }
apply (If_i_or (Empty :e X) y z).
- assume H3: (if Empty :e X then y else z) = y.
  apply orIL.
  prove x = y.
  rewrite <- H3. exact L1.
- assume H3: (if Empty :e X then y else z) = z.
  apply orIR.
  prove x = z.
  rewrite <- H3. exact L1.
Qed.

Theorem UPairI1 : forall y z:set, y :e {y,z}.
let y z.
prove y :e {y,z}.
rewrite <- (If_i_1 (Empty :e Power Empty) y z (Empty_In_Power Empty)) at 1.
prove (if Empty :e Power Empty then y else z) :e {y,z}.
prove (if Empty :e Power Empty then y else z) :e {if Empty :e X then y else z | X :e Power (Power Empty)}.
apply (ReplI (Power (Power Empty)) (fun X : set => if (Empty :e X) then y else z) (Power Empty)).
prove Power Empty :e Power (Power Empty).
exact (Self_In_Power (Power Empty)).
Qed.

Theorem UPairI2 : forall y z:set, z :e {y,z}.
let y z.
prove z :e {y,z}.
rewrite <- (If_i_0 (Empty :e Empty) y z (EmptyE Empty)) at 1.
prove (if Empty :e Empty then y else z) :e {y,z}.
prove (if Empty :e Empty then y else z) :e {if Empty :e X then y else z | X :e Power (Power Empty)}.
apply (ReplI (Power (Power Empty)) (fun X : set => if (Empty :e X) then y else z) Empty).
prove Empty :e Power (Power Empty).
exact (Empty_In_Power (Power Empty)).
Qed.

(* Parameter Sing "158bae29452f8cbf276df6f8db2be0a5d20290e15eca88ffe1e7b41d211d41d7" "bd01a809e97149be7e091bf7cbb44e0c2084c018911c24e159f585455d8e6bd0" *)
Definition Sing : set -> set := fun x => {x,x}.
Notation SetEnum1 Sing.

Theorem SingI : forall x:set, x :e {x}. 
exact (fun x : set => UPairI1 x x).
Qed.

Theorem SingE : forall x y:set, y :e {x} -> y = x. 
exact (fun x y H => UPairE y x x H (y = x) (fun H => H) (fun H => H)).
Qed.

(* Parameter binunion "0a445311c45f0eb3ba2217c35ecb47f122b2301b2b80124922fbf03a5c4d223e" "5e1ac4ac93257583d0e9e17d6d048ff7c0d6ccc1a69875b2a505a2d4da305784" *)
Definition binunion : set -> set -> set := fun X Y => Union {X,Y}.
(* Unicode :\/: "222a" *)
Infix :\/: 345 left := binunion.

Theorem binunionI1 : forall X Y z:set, z :e X -> z :e X :\/: Y.
let X Y z.
assume H1: z :e X.
prove z :e X :\/: Y.
prove z :e Union {X,Y}.
apply (UnionI {X,Y} z X).
- prove z :e X. exact H1.
- prove X :e {X,Y}. exact (UPairI1 X Y).
Qed.

Theorem binunionI2 : forall X Y z:set, z :e Y -> z :e X :\/: Y.
let X Y z.
assume H1: z :e Y.
prove z :e X :\/: Y.
prove z :e Union {X,Y}.
apply (UnionI {X,Y} z Y).
- prove z :e Y. exact H1.
- prove Y :e {X,Y}. exact (UPairI2 X Y).
Qed.

Theorem binunionE : forall X Y z:set, z :e X :\/: Y -> z :e X \/ z :e Y.
let X Y z.
assume H1: z :e X :\/: Y.
prove z :e X \/ z :e Y.
apply (UnionE_impred {X,Y} z H1).
let Z.
assume H2: z :e Z.
assume H3: Z :e {X,Y}.
apply (UPairE Z X Y H3).
- assume H4: Z = X.
  apply orIL.
  prove z :e X.
  rewrite <- H4.
  prove z :e Z.
  exact H2.
- assume H4: Z = Y.
  apply orIR.
  prove z :e Y.
  rewrite <- H4.
  prove z :e Z.
  exact H2.
Qed.

Theorem binunionE' : forall X Y z, forall p:prop, (z :e X -> p) -> (z :e Y -> p) -> (z :e X :\/: Y -> p).
let X Y z p. assume H1 H2 Hz.
apply binunionE X Y z Hz.
- assume H3: z :e X. exact H1 H3.
- assume H3: z :e Y. exact H2 H3.
Qed.

Theorem binunion_asso:forall X Y Z:set, X :\/: (Y :\/: Z) = (X :\/: Y) :\/: Z.
let X Y Z. apply set_ext.
- let w. assume H1: w :e X :\/: (Y :\/: Z).
  prove w :e (X :\/: Y) :\/: Z.
  apply (binunionE X (Y :\/: Z) w H1).
  + assume H2: w :e X.
    apply binunionI1. apply binunionI1. exact H2.
  + assume H2: w :e Y :\/: Z.
    apply (binunionE Y Z w H2).
    * assume H3: w :e Y.
      apply binunionI1. apply binunionI2. exact H3.
    * assume H3: w :e Z.
      apply binunionI2. exact H3.
- let w. assume H1: w :e (X :\/: Y) :\/: Z.
  prove w :e X :\/: (Y :\/: Z).
  apply (binunionE (X :\/: Y) Z w H1).
  + assume H2: w :e X :\/: Y.
    apply (binunionE X Y w H2).
    * assume H3: w :e X.
      apply binunionI1. exact H3.
    * assume H3: w :e Y.
      apply binunionI2. apply binunionI1. exact H3.
  + assume H2: w :e Z.
    apply binunionI2. apply binunionI2. exact H2.
Qed.

Theorem binunion_com_Subq:forall X Y:set, X :\/: Y c= Y :\/: X.
let X Y w. assume H1: w :e X :\/: Y.
prove w :e Y :\/: X.
apply (binunionE X Y w H1).
- assume H2: w :e X. apply binunionI2. exact H2.
- assume H2: w :e Y. apply binunionI1. exact H2.
Qed.

Theorem binunion_com:forall X Y:set, X :\/: Y = Y :\/: X.
let X Y. apply set_ext.
- exact (binunion_com_Subq X Y).
- exact (binunion_com_Subq Y X).
Qed.

Theorem binunion_idl:forall X:set, Empty :\/: X = X.
let X. apply set_ext.
- let x. assume H1: x :e Empty :\/: X.
  apply (binunionE Empty X x H1).
  + assume H2: x :e Empty. prove False. exact (EmptyE x H2).
  + assume H2: x :e X. exact H2.
- let x. assume H2: x :e X. prove x :e Empty :\/: X. apply binunionI2. exact H2.
Qed.

Theorem binunion_idr:forall X:set, X :\/: Empty = X.
let X.
rewrite (binunion_com X Empty).
exact (binunion_idl X).
Qed.

Theorem binunion_Subq_1: forall X Y:set, X c= X :\/: Y.
exact binunionI1.
Qed.

Theorem binunion_Subq_2: forall X Y:set, Y c= X :\/: Y.
exact binunionI2.
Qed.

Theorem binunion_Subq_min: forall X Y Z:set, X c= Z -> Y c= Z -> X :\/: Y c= Z.
let X Y Z.
assume H1: X c= Z.
assume H2: Y c= Z.
let w.
assume H3: w :e X :\/: Y.
apply (binunionE X Y w H3).
- assume H4: w :e X. exact (H1 w H4).
- assume H4: w :e Y. exact (H2 w H4).
Qed.

Theorem Subq_binunion_eq:forall X Y, (X c= Y) = (X :\/: Y = Y).
let X Y. apply prop_ext_2.
- assume H1: X c= Y.
  prove X :\/: Y = Y.
  apply set_ext.
  + prove X :\/: Y c= Y. apply (binunion_Subq_min X Y Y).
    * prove X c= Y. exact H1.
    * prove Y c= Y. exact (Subq_ref Y).
  + prove Y c= X :\/: Y. exact (binunion_Subq_2 X Y).
- assume H1: X :\/: Y = Y.
  prove X c= Y.
  rewrite <- H1.
  prove X c= X :\/: Y.
  exact (binunion_Subq_1 X Y).
Qed.

Definition SetAdjoin : set->set->set := fun X y => X :\/: {y}.
Notation SetEnum Empty Sing UPair SetAdjoin.
(* Parameter famunion "d772b0f5d472e1ef525c5f8bd11cf6a4faed2e76d4eacfa455f4d65cc24ec792" "b3e3bf86a58af5d468d398d3acad61ccc50261f43c856a68f8594967a06ec07a" *)
Definition famunion:set->(set->set)->set
:= fun X F => Union {F x|x :e X}.
(* Unicode \/_ "22C3" *)
(* Subscript \/_ *)
Binder \/_ , := famunion.

Theorem famunionI:forall X:set, forall F:(set->set), forall x y:set, x :e X -> y :e F x -> y :e \/_ x :e X, F x.
exact (fun X F x y H1 H2 => UnionI (Repl X F) y (F x) H2 (ReplI X F x H1)).
Qed.

Theorem famunionE:forall X:set, forall F:(set->set), forall y:set, y :e (\/_ x :e X, F x) -> exists x :e X, y :e F x.
let X F y.
assume H1: y :e (\/_ x :e X, F x).
prove exists x :e X, y :e F x.
apply (UnionE_impred {F x|x :e X} y H1).
let Y.
assume H2: y :e Y.
assume H3: Y :e {F x|x :e X}.
apply (ReplE_impred X F Y H3).
let x.
assume H4: x :e X.
assume H5: Y = F x.
witness x.
prove x :e X /\ y :e F x.
apply andI.
- exact H4.
- prove y :e F x.
  rewrite <- H5.
  exact H2.
Qed.

Theorem famunionE_impred : forall X : set , forall F : (set -> set) , forall y : set , y :e (\/_ x :e X , F x) -> forall p:prop, (forall x, x :e X -> y :e F x -> p) -> p.
let X F y. assume Hy.
let p. assume Hp.
apply famunionE X F y Hy.
let x. assume H1. apply H1.
exact Hp x.
Qed.

Theorem famunion_Empty: forall F:set -> set, (\/_ x :e Empty, F x) = Empty.
let F. apply Empty_Subq_eq.
let y. assume Hy: y :e \/_ x :e Empty, F x.
apply famunionE_impred Empty F y Hy.
let x. assume Hx: x :e Empty. prove False. exact EmptyE x Hx.
Qed.

Theorem famunion_Subq: forall X, forall f g:set -> set, (forall x :e X, f x c= g x) -> famunion X f c= famunion X g.
let X f g. assume Hfg.
let y. assume Hy. apply famunionE_impred X f y Hy.
let x. assume Hx.
assume H1: y :e f x.
apply famunionI X g x y Hx.
prove y :e g x.
exact Hfg x Hx y H1.
Qed.

Theorem famunion_ext: forall X, forall f g:set -> set, (forall x :e X, f x = g x) -> famunion X f = famunion X g.
let X f g. assume Hfg.
apply set_ext.
- apply famunion_Subq.
  let x. assume Hx. rewrite Hfg x Hx. apply Subq_ref.
- apply famunion_Subq.
  let x. assume Hx. rewrite Hfg x Hx. apply Subq_ref.
Qed.

Section SepSec.
Variable X:set.
Variable P:set->prop.
Let z : set := Eps_i (fun z => z :e X /\ P z).
Let F:set->set := fun x => if P x then x else z.
(* Parameter Sep "f7e63d81e8f98ac9bc7864e0b01f93952ef3b0cbf9777abab27bcbd743b6b079" "f336a4ec8d55185095e45a638507748bac5384e04e0c48d008e4f6a9653e9c44" *)
Definition Sep:set
:= if (exists z :e X, P z) then {F x|x :e X} else Empty.
End SepSec.
Notation Sep Sep.

Theorem SepI:forall X:set, forall P:(set->prop), forall x:set, x :e X -> P x -> x :e {x :e X|P x}.
let X P x.
set z : set := Eps_i (fun z => z :e X /\ P z).
set F : set->set := fun x => if P x then x else z.
assume H1: x :e X.
assume H2: P x.
claim L1: exists z :e X, P z.
{
  witness x. apply andI.
  - exact H1.
  - exact H2.
}
prove x :e {x :e X|P x}.
prove x :e if (exists z :e X, P z) then {F x|x :e X} else Empty.
(*** Note:
 Making L2 a claim and then rewriting with it succeeds, but rewrite (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1) fails.
 The reason is that when the proposition proved by (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1) is
 extracted by the code, the F x will be beta reduced to be if P x then x else z. After this beta reduction, the left hand side of the
 equation does not match the right hand side of the claim x :e if (exists z :e X, P z) then {F x|x :e X} else Empty.
 This is an example of how one must be careful using the apply and rewrite tactics and must sometimes give these
 kinds of explicit annotations, i.e., proving a beta-eta-delta equivalent claim.
 ***)
claim L2: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = {F x|x :e X}.
{
  exact (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1).
}
rewrite L2.
prove x :e {F x|x :e X}.
claim L3: F x = x.
{
  prove (if P x then x else z) = x.
  exact (If_i_1 (P x) x z H2).
}
rewrite <- L3.
prove F x :e {F x|x :e X}.
exact (ReplI X F x H1).
Qed.

Theorem SepE:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X /\ P x.
let X P x.
set z : set := Eps_i (fun z => z :e X /\ P z).
set F : set->set := fun x => if P x then x else z.
apply (xm (exists z :e X, P z)).
- assume H1: exists z :e X, P z.
  prove (x :e (if (exists z :e X, P z) then {F x|x :e X} else Empty) -> x :e X /\ P x).
  claim L1: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = {F x|x :e X}.
  {
    exact (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty H1).
  }
  rewrite L1.
  prove x :e {F x|x :e X} -> x :e X /\ P x.
  assume H2: x :e {F x|x :e X}.
  apply (ReplE_impred X F x H2).
  let y.
  assume H3: y :e X.
  assume H4: x = F y.
  prove x :e X /\ P x.
  apply (xm (P y)).
  + assume H5: P y.
    claim L2: x = y.
    {
      rewrite <- (If_i_1 (P y) y z H5).
      exact H4.
    }
    rewrite L2.
    prove y :e X /\ P y.
    apply andI.
    * exact H3.
    * exact H5.
  + assume H5: ~P y.
    claim L2: x = z.
    {
      rewrite <- (If_i_0 (P y) y z H5).
      exact H4.
    }
    rewrite L2.
    prove z :e X /\ P z.
    exact (Eps_i_ex (fun z => z :e X /\ P z) H1).
- assume H1: ~exists z :e X, P z.
  prove (x :e (if (exists z :e X, P z) then {F x|x :e X} else Empty) -> x :e X /\ P x).
  claim L1: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = Empty.
  { exact (If_i_0 (exists z :e X, P z) {F x|x :e X} Empty H1). }
  rewrite L1.
  prove x :e Empty -> x :e X /\ P x.
  assume H2: x :e Empty.
  prove False.
  exact (EmptyE x H2).
Qed.

Theorem SepE1:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X.
exact (fun X P x H => SepE X P x H (x :e X) (fun H _ => H)).
Qed.

Theorem SepE2:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> P x.
exact (fun X P x H => SepE X P x H (P x) (fun _ H => H)).
Qed.

Theorem Sep_Empty: forall P:set -> prop, {x :e Empty|P x} = Empty.
let P. apply Empty_eq.
let x. assume Hx.
exact EmptyE x (SepE1 Empty P x Hx).
Qed.

Theorem Sep_Subq : forall X:set, forall P:set->prop, {x :e X|P x} c= X.
exact SepE1.
Qed.

Theorem Sep_In_Power : forall X:set, forall P:set->prop, {x :e X|P x} :e Power X.
exact (fun X P => PowerI X (Sep X P) (Sep_Subq X P)).
Qed.

(* Parameter ReplSep "f627d20f1b21063483a5b96e4e2704bac09415a75fed6806a2587ce257f1f2fd" "ec807b205da3293041239ff9552e2912636525180ddecb3a2b285b91b53f70d8" *)
Definition ReplSep : set->(set->prop)->(set->set)->set := fun X P F => {F x|x :e {z :e X|P z}}.
Notation ReplSep ReplSep.

Theorem ReplSepI: forall X:set, forall P:set->prop, forall F:set->set, forall x:set, x :e X -> P x -> F x :e {F x|x :e X, P x}.
exact (fun X P F x u v => ReplI (Sep X P) F x (SepI X P x u v)).
Qed.

Theorem ReplSepE:forall X:set, forall P:set->prop, forall F:set->set, forall y:set, y :e {F x|x :e X, P x} -> exists x:set, x :e X /\ P x /\ y = F x.
let X P F y.
assume H1: y :e {F x|x :e {z :e X|P z}}.
apply (ReplE {z :e X|P z} F y H1).
let x.
assume H2: x :e {z :e X|P z} /\ y = F x.
apply H2.
assume H3: x :e {z :e X|P z}.
assume H4: y = F x.
apply (SepE X P x H3).
assume H5: x :e X.
assume H6: P x.
witness x.
apply and3I.
- exact H5.
- exact H6.
- exact H4.
Qed.

Theorem ReplSepE_impred: forall X:set, forall P:set->prop, forall F:set->set, forall y:set, y :e {F x|x :e X, P x} -> forall p:prop, (forall x :e X, P x -> y = F x -> p) -> p.
let X P F y.
assume H1: y :e {F x|x :e X, P x}.
let p.
assume H2: forall x :e X, P x -> y = F x -> p.
prove p.
apply ReplSepE X P F y H1.
let x. assume H3. apply H3. assume H3. apply H3.
exact H2 x.
Qed.

(* Parameter binintersect "8cf6b1f490ef8eb37db39c526ab9d7c756e98b0eb12143156198f1956deb5036" "b2abd2e5215c0170efe42d2fa0fb8a62cdafe2c8fbd0d37ca14e3497e54ba729" *)
Definition binintersect:set->set->set
:= fun X Y => {x :e X |x :e Y}.
(* Unicode :/\: "2229" *)
Infix :/\: 340 left := binintersect.

Theorem binintersectI:forall X Y z, z :e X -> z :e Y -> z :e X :/\: Y.
exact (fun X Y z H1 H2 => SepI X (fun x:set => x :e Y) z H1 H2).
Qed.

Theorem binintersectE:forall X Y z, z :e X :/\: Y -> z :e X /\ z :e Y.
exact (fun X Y z H1 => SepE X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersectE1:forall X Y z, z :e X :/\: Y -> z :e X.
exact (fun X Y z H1 => SepE1 X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersectE2:forall X Y z, z :e X :/\: Y -> z :e Y.
exact (fun X Y z H1 => SepE2 X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersect_Subq_1:forall X Y:set, X :/\: Y c= X.
exact binintersectE1.
Qed.

Theorem binintersect_Subq_2:forall X Y:set, X :/\: Y c= Y.
exact binintersectE2.
Qed.

Theorem binintersect_Subq_eq_1 : forall X Y, X c= Y -> X :/\: Y = X.
let X Y.
assume H1: X c= Y.
apply set_ext.
- apply binintersect_Subq_1.
- let x. assume H2: x :e X.
  apply binintersectI.
  + exact H2.
  + apply H1. exact H2.
Qed.

Theorem binintersect_Subq_max:forall X Y Z:set, Z c= X -> Z c= Y -> Z c= X :/\: Y.
let X Y Z.
assume H1: Z c= X.
assume H2: Z c= Y.
let w.
assume H3: w :e Z.
apply (binintersectI X Y w).
- prove w :e X. exact (H1 w H3).
- prove w :e Y. exact (H2 w H3).
Qed.

Theorem binintersect_com_Subq: forall X Y:set, X :/\: Y c= Y :/\: X.
let X Y. apply (binintersect_Subq_max Y X (X :/\: Y)).
- prove X :/\: Y c= Y. apply binintersect_Subq_2.
- prove X :/\: Y c= X. apply binintersect_Subq_1.
Qed.

Theorem binintersect_com: forall X Y:set, X :/\: Y = Y :/\: X.
let X Y. apply set_ext.
- exact (binintersect_com_Subq X Y).
- exact (binintersect_com_Subq Y X).
Qed.

(* Parameter setminus "cc569397a7e47880ecd75c888fb7c5512aee4bcb1e7f6bd2c5f80cccd368c060" "c68e5a1f5f57bc5b6e12b423f8c24b51b48bcc32149a86fc2c30a969a15d8881" *)
Definition setminus:set->set->set
:= fun X Y => Sep X (fun x => x /:e Y).
(* Unicode :\: "2216" *)
Infix :\: 350 := setminus.

Theorem setminusI:forall X Y z, (z :e X) -> (z /:e Y) -> z :e X :\: Y.
exact (fun X Y z H1 H2 => SepI X (fun x:set => x /:e Y) z H1 H2).
Qed.

Theorem setminusE:forall X Y z, (z :e X :\: Y) -> z :e X /\ z /:e Y.
exact (fun X Y z H => SepE X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminusE1:forall X Y z, (z :e X :\: Y) -> z :e X.
exact (fun X Y z H => SepE1 X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminusE2:forall X Y z, (z :e X :\: Y) -> z /:e Y.
exact (fun X Y z H => SepE2 X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminus_Subq:forall X Y:set, X :\: Y c= X.
exact setminusE1.
Qed.

Theorem setminus_In_Power : forall A U, A :\: U :e Power A.
let A U. apply PowerI. apply setminus_Subq.
Qed.

Theorem binunion_remove1_eq: forall X, forall x :e X, X = (X :\: {x}) :\/: {x}.
let X x.
assume Hx: x :e X.
apply set_ext.
- let y. assume Hy: y :e X.
  prove y :e (X :\: {x}) :\/: {x}.
  apply xm (y :e {x}).
  + assume H1: y :e {x}.
    apply binunionI2. exact H1.
  + assume H1: y /:e {x}.
    apply binunionI1. apply setminusI.
    * exact Hy.
    * exact H1.
- let y. assume Hy: y :e (X :\: {x}) :\/: {x}.
  apply binunionE (X :\: {x}) {x} y Hy.
  + assume H1: y :e X :\: {x}.
    prove y :e X.
    exact setminusE1 X {x} y H1.
  + assume H1: y :e {x}.
    prove y :e X.
    rewrite SingE x y H1.
    prove x :e X.
    exact Hx.
Qed.

Theorem In_irref : forall x, x /:e x.
apply In_ind.
prove (forall X:set, (forall x:set, x :e X -> x /:e x) -> X /:e X).
let X.
assume IH: forall x : set, x :e X -> x /:e x.
assume H: X :e X.
exact IH X H H.
Qed.

Theorem In_no2cycle : forall x y, x :e y -> y :e x -> False.
apply In_ind.
let x.
assume IH: forall z, z :e x -> forall y, z :e y -> y :e z -> False.
let y.
assume H1: x :e y.
assume H2: y :e x.
exact IH y H2 x H2 H1.
Qed.

(* Parameter ordsucc "9db634daee7fc36315ddda5f5f694934869921e9c5f55e8b25c91c0a07c5cbec" "65d8837d7b0172ae830bed36c8407fcd41b7d875033d2284eb2df245b42295a6" *)
Definition ordsucc : set->set := fun x:set => x :\/: {x}.

Theorem ordsuccI1 : forall x:set, x c= ordsucc x.
let x.
exact (fun (y : set) (H1 : y :e x) => binunionI1 x {x} y H1).
Qed.

Theorem ordsuccI2 : forall x:set, x :e ordsucc x.
exact (fun x : set => binunionI2 x {x} x (SingI x)).
Qed.

Theorem ordsuccE : forall x y:set, y :e ordsucc x -> y :e x \/ y = x.
let x y.
assume H1: y :e x :\/: {x}.
apply (binunionE x {x} y H1).
- assume H2: y :e x. apply orIL. exact H2.
- assume H2: y :e {x}. apply orIR. exact (SingE x y H2).
Qed.

Notation Nat Empty ordsucc.

Theorem neq_0_ordsucc : forall a:set, 0 <> ordsucc a.
let a. prove ~(0 = ordsucc a).
assume H1: 0 = ordsucc a.
claim L1: a :e ordsucc a -> False.
{ rewrite <- H1. exact (EmptyE a). }
exact (L1 (ordsuccI2 a)).
Qed.

Theorem neq_ordsucc_0 : forall a:set, ordsucc a <> 0.
let a. exact neq_i_sym 0 (ordsucc a) (neq_0_ordsucc a).
Qed.

Theorem ordsucc_inj : forall a b:set, ordsucc a = ordsucc b -> a = b.
let a b.
assume H1: ordsucc a = ordsucc b.
claim L1: a :e ordsucc b.
{
  rewrite <- H1.
  exact (ordsuccI2 a).
}
apply (ordsuccE b a L1).
- assume H2: a :e b.
  claim L2: b :e ordsucc a.
  {
    rewrite H1.
    exact (ordsuccI2 b).
  }
  apply (ordsuccE a b L2).
  + assume H3: b :e a. prove False. exact (In_no2cycle a b H2 H3).
  + assume H3: b = a. symmetry. exact H3.
- assume H2: a = b. exact H2.
Qed.

Theorem In_0_1 : 0 :e 1.
exact (ordsuccI2 0).
Qed.

Theorem In_0_2 : 0 :e 2.
exact (ordsuccI1 1 0 In_0_1).
Qed.

Theorem In_1_2 : 1 :e 2.
exact (ordsuccI2 1).
Qed.

Definition nat_p : set->prop := fun n:set => forall p:set->prop, p 0 -> (forall x:set, p x -> p (ordsucc x)) -> p n.

Theorem nat_0 : nat_p 0.
exact (fun p H _ => H).
Qed.

Theorem nat_ordsucc : forall n:set, nat_p n -> nat_p (ordsucc n).
exact (fun n H1 p H2 H3 => H3 n (H1 p H2 H3)).
Qed.

Theorem nat_1 : nat_p 1.
exact (nat_ordsucc 0 nat_0).
Qed.

Theorem nat_2 : nat_p 2.
exact (nat_ordsucc 1 nat_1).
Qed.

Theorem nat_0_in_ordsucc : forall n, nat_p n -> 0 :e ordsucc n.
let n.
assume H1.
apply H1 (fun n => 0 :e ordsucc n).
- prove 0 :e ordsucc 0.
  exact In_0_1.
- let n.
  assume IH: 0 :e ordsucc n.
  prove 0 :e ordsucc (ordsucc n).
  exact (ordsuccI1 (ordsucc n) 0 IH).
Qed.

Theorem nat_ordsucc_in_ordsucc : forall n, nat_p n -> forall m :e n, ordsucc m :e ordsucc n.
let n.
assume H1.
apply (H1 (fun n => forall m :e n, ordsucc m :e ordsucc n)).
- prove forall m :e 0, ordsucc m :e ordsucc 0.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume IH: forall m :e n, ordsucc m :e ordsucc n.
  prove forall m :e ordsucc n, ordsucc m :e ordsucc (ordsucc n).
  let m.
  assume H2: m :e ordsucc n.
  prove ordsucc m :e ordsucc (ordsucc n).
  apply (ordsuccE n m H2).
  + assume H3: m :e n.
    claim L1: ordsucc m :e ordsucc n.
    { exact (IH m H3). }
    exact (ordsuccI1 (ordsucc n) (ordsucc m) L1).
  + assume H3: m = n.
    rewrite H3.
    prove ordsucc n :e ordsucc (ordsucc n).
    exact (ordsuccI2 (ordsucc n)).
Qed.

Theorem nat_ind : forall p:set->prop, p 0 -> (forall n, nat_p n -> p n -> p (ordsucc n)) -> forall n, nat_p n -> p n.
let p.
assume H1: p 0.
assume H2: forall n, nat_p n -> p n -> p (ordsucc n).
claim L1: nat_p 0 /\ p 0.
{ exact (andI (nat_p 0) (p 0) nat_0 H1). }
claim L2: forall n, nat_p n /\ p n -> nat_p (ordsucc n) /\ p (ordsucc n).
{ let n.
  assume H3: nat_p n /\ p n.
  apply H3.
  assume H4: nat_p n.
  assume H5: p n.
  apply andI.
  - prove nat_p (ordsucc n).
    exact (nat_ordsucc n H4).
  - prove p (ordsucc n).
    exact (H2 n H4 H5).
}
let n.
assume H3.
claim L3: nat_p n /\ p n.
{ exact (H3 (fun n => nat_p n /\ p n) L1 L2). }
exact (andER (nat_p n) (p n) L3).
Qed.

Theorem nat_complete_ind : forall p:set->prop, (forall n, nat_p n -> (forall m :e n, p m) -> p n) -> forall n, nat_p n -> p n.
let p.
assume H1: forall n, nat_p n -> (forall m :e n, p m) -> p n.
claim L1: forall n:set, nat_p n -> forall m :e n, p m.
{ apply nat_ind.
  - prove forall m :e 0, p m.
    let m.
    assume Hm: m :e 0.
    prove False.
    exact (EmptyE m Hm).
  - let n.
    assume Hn: nat_p n.
    assume IHn: forall m :e n, p m.
    prove forall m :e ordsucc n, p m.
    let m.
    assume Hm: m :e ordsucc n.
    prove p m.
    apply (ordsuccE n m Hm).
    + assume H2: m :e n.
      exact (IHn m H2).
    + assume H2: m = n.
      prove p m.
      rewrite H2.
      prove p n.
      exact (H1 n Hn IHn).
}
prove forall n, nat_p n -> p n.
exact (fun n Hn => H1 n Hn (L1 n Hn)).
Qed.

Theorem nat_inv_impred : forall p:set->prop, p 0 -> (forall n, nat_p n -> p (ordsucc n)) -> forall n, nat_p n -> p n.
let p. assume H1 H2. exact nat_ind p H1 (fun n H _ => H2 n H).
Qed.

Theorem nat_inv : forall n, nat_p n -> n = 0 \/ exists x, nat_p x /\ n = ordsucc x.
apply nat_inv_impred.
- apply orIL. reflexivity.
- let n. assume Hn. apply orIR. witness n. apply andI.
  + exact Hn.
  + reflexivity.
Qed.

Theorem nat_p_trans : forall n, nat_p n -> forall m :e n, nat_p m.
apply nat_ind.
- prove forall m :e 0, nat_p m.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume Hn: nat_p n.
  assume IHn: forall m :e n, nat_p m.
  prove forall m :e ordsucc n, nat_p m.
  let m.
  assume Hm: m :e ordsucc n.
  apply (ordsuccE n m Hm).
  + assume H1: m :e n.
    exact (IHn m H1).
  + assume H1: m = n.
    rewrite H1.
    exact Hn.
Qed.

Theorem nat_trans : forall n, nat_p n -> forall m :e n, m c= n.
apply nat_ind.
- prove forall m :e 0, m c= 0.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume Hn: nat_p n.
  assume IHn: forall m :e n, m c= n.
  prove forall m :e ordsucc n, m c= ordsucc n.
  let m.
  assume Hm: m :e ordsucc n.
  apply (ordsuccE n m Hm).
  + assume H1: m :e n.
    prove m c= ordsucc n.
    apply (Subq_tra m n (ordsucc n)).
    * exact (IHn m H1).
    * exact (ordsuccI1 n).
  + assume H1: m = n.
    prove m c= ordsucc n.
    rewrite H1.
    prove n c= ordsucc n.
    exact (ordsuccI1 n).
Qed.

Theorem nat_ordsucc_trans : forall n, nat_p n -> forall m :e ordsucc n, m c= n.
let n.
assume Hn: nat_p n.
let m.
assume Hm: m :e ordsucc n.
let k.
assume Hk: k :e m.
prove k :e n.
apply (ordsuccE n m Hm).
- assume H1: m :e n.
  exact nat_trans n Hn m H1 k Hk.
- assume H1: m = n.
  rewrite <- H1.
  exact Hk.
Qed.

Definition surj : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall w :e Y, exists u :e X, f u = w).

Theorem form100_63_surjCantor: forall A:set, forall f:set -> set, ~surj A (Power A) f.
let A f. assume H. apply H.
assume H1: forall u :e A, f u :e Power A.
assume H2: forall w :e Power A, exists u :e A, f u = w.
set D := {x :e A|x /:e f x}.
claim L1: D :e Power A.
{ exact Sep_In_Power A (fun x => x /:e f x). }
apply H2 D L1.
let d. assume H. apply H.
assume Hd: d :e A.
assume HfdD: f d = D.
claim L2: d /:e D.
{ assume H3: d :e D.
  apply SepE2 A (fun x => x /:e f x) d H3.
  prove d :e f d.
  rewrite HfdD.
  prove d :e D.
  exact H3.
}
apply L2.
prove d :e D.
apply SepI.
- prove d :e A. exact Hd.
- prove d /:e f d. rewrite HfdD. exact L2.
Qed.

Definition inj : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall u v :e X, f u = f v -> u = v).

Theorem form100_63_injCantor: forall A:set, forall f:set -> set, ~inj (Power A) A f.
let A f. assume H. apply H.
assume H1: forall X :e Power A, f X :e A.
assume H2: forall X Y :e Power A, f X = f Y -> X = Y.
set D := {f X | X :e Power A, f X /:e X}.
claim L1: D :e Power A.
{ apply PowerI.
  let n. assume H3: n :e D.
  apply ReplSepE_impred (Power A) (fun X => f X /:e X) f n H3.
  let X. assume HX: X :e Power A.
  assume H4: f X /:e X.
  assume H5: n = f X.
  prove n :e A. rewrite H5. apply H1. exact HX.
}
claim L2: f D /:e D.
{ assume H3: f D :e D.
  apply ReplSepE_impred (Power A) (fun X => f X /:e X) f (f D) H3.
  let X. assume HX: X :e Power A.
  assume H4: f X /:e X.
  assume H5: f D = f X.
  claim L2a: D = X.
  { exact H2 D L1 X HX H5. }
  apply H4. rewrite <- L2a. exact H3.
}
apply L2.
prove f D :e D.
apply ReplSepI.
- prove D :e Power A. exact L1.
- prove f D /:e D. exact L2.
Qed.

Theorem injI : forall X Y, forall f:set -> set, (forall x :e X, f x :e Y) -> (forall x z :e X, f x = f z -> x = z) -> inj X Y f.
let X Y f. assume H1 H2.
prove (forall x :e X, f x :e Y) /\ (forall x z :e X, f x = f z -> x = z).
apply andI.
- exact H1.
- exact H2.
Qed.

Theorem inj_comp : forall X Y Z:set, forall f g:set->set, inj X Y f -> inj Y Z g -> inj X Z (fun x => g (f x)).
let X Y Z f g.
assume Hf.
assume Hg.
apply Hf.
assume Hf1 Hf2.
apply Hg.
assume Hg1 Hg2.
apply injI.
- let u. assume Hu: u :e X. exact (Hg1 (f u) (Hf1 u Hu)).
- let u. assume Hu: u :e X. let v. assume Hv: v :e X.
  assume H1: g (f u) = g (f v).
  prove u = v.
  apply Hf2 u Hu v Hv.
  prove f u = f v.
  apply Hg2 (f u) (Hf1 u Hu) (f v) (Hf1 v Hv).
  prove g (f u) = g (f v).
  exact H1.
Qed.

Definition bij : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall u v :e X, f u = f v -> u = v)
  /\
  (forall w :e Y, exists u :e X, f u = w).

Theorem bijI : forall X Y, forall f:set -> set,
    (forall u :e X, f u :e Y)
 -> (forall u v :e X, f u = f v -> u = v)
 -> (forall w :e Y, exists u :e X, f u = w)
 -> bij X Y f.
let X Y f. assume Hf1 Hf2 Hf3.
prove (forall u :e X, f u :e Y)
   /\ (forall u v :e X, f u = f v -> u = v)
   /\ (forall w :e Y, exists u :e X, f u = w).
apply and3I.
- exact Hf1.
- exact Hf2.
- exact Hf3.
Qed.

Theorem bijE : forall X Y, forall f:set -> set,
    bij X Y f
 -> forall p:prop,
      ((forall u :e X, f u :e Y)
    -> (forall u v :e X, f u = f v -> u = v)
    -> (forall w :e Y, exists u :e X, f u = w)
    -> p)
   -> p.
let X Y f. assume Hf. let p. assume Hp.
apply Hf. assume Hf. apply Hf.
assume Hf1 Hf2 Hf3.
exact Hp Hf1 Hf2 Hf3.
Qed.

Theorem bij_inj : forall X Y, forall f:set -> set, bij X Y f -> inj X Y f.
let X Y f. assume H1. apply H1. assume H1 _. exact H1.
Qed.

Theorem bij_id : forall X, bij X X (fun x => x).
let X.
prove (forall u :e X, u :e X) /\ (forall u v :e X, u = v -> u = v) /\ (forall w :e X, exists u :e X, u = w).
apply and3I.
- exact (fun u Hu => Hu).
- exact (fun u Hu v Hv H1 => H1).
- let w. assume Hw. witness w. apply andI.
  + exact Hw.
  + reflexivity.
Qed.

Theorem bij_comp : forall X Y Z:set, forall f g:set->set, bij X Y f -> bij Y Z g -> bij X Z (fun x => g (f x)).
let X Y Z f g.
assume Hf. apply Hf. assume Hf12 Hf3. apply Hf12. assume Hf1 Hf2.
assume Hg. apply Hg. assume Hg12 Hg3. apply Hg12. assume Hg1 Hg2.
prove (forall u :e X, g (f u) :e Z)
  /\
  (forall u v :e X, g (f u) = g (f v) -> u = v)
  /\
  (forall w :e Z, exists u :e X, g (f u) = w).
apply and3I.
- let u. assume Hu: u :e X. exact (Hg1 (f u) (Hf1 u Hu)).
- let u. assume Hu: u :e X. let v. assume Hv: v :e X.
  assume H1: g (f u) = g (f v).
  prove u = v.
  apply Hf2 u Hu v Hv.
  prove f u = f v.
  apply Hg2 (f u) (Hf1 u Hu) (f v) (Hf1 v Hv).
  prove g (f u) = g (f v).
  exact H1.
- let w. assume Hw: w :e Z. apply Hg3 w Hw.
  let y. assume Hy12. apply Hy12.
  assume Hy1: y :e Y. assume Hy2: g y = w.
  apply Hf3 y Hy1.
  let u. assume Hu12. apply Hu12.
  assume Hu1: u :e X. assume Hu2: f u = y.
  prove exists u :e X, g (f u) = w.
  witness u.
  apply andI.
  + exact Hu1.
  + rewrite Hu2. exact Hy2.
Qed.

Theorem bij_surj : forall X Y, forall f:set -> set, bij X Y f -> surj X Y f.
let X Y f. assume H1. apply H1. assume H1. apply H1.
assume H1 _ H2.
prove (forall u :e X, f u :e Y)
   /\ (forall w :e Y, exists u :e X, f u = w).
apply andI.
- exact H1.
- exact H2.
Qed.

Definition inv : set -> (set -> set) -> set -> set := fun X f => fun y:set => Eps_i (fun x => x :e X /\ f x = y).

Theorem surj_rinv : forall X Y, forall f:set->set, (forall w :e Y, exists u :e X, f u = w) -> forall y :e Y, inv X f y :e X /\ f (inv X f y) = y.
let X Y f. assume H1.
let y. assume Hy: y :e Y.
apply H1 y Hy.
let x.
assume H2.
exact Eps_i_ax (fun x => x :e X /\ f x = y) x H2.
Qed.

Theorem inj_linv : forall X, forall f:set->set, (forall u v :e X, f u = f v -> u = v) -> forall x :e X, inv X f (f x) = x.
let X f.
assume H1.
let x. assume Hx.
claim L1: inv X f (f x) :e X /\ f (inv X f (f x)) = f x.
{ apply Eps_i_ax (fun x' => x' :e X /\ f x' = f x) x.
  apply andI.
  - exact Hx.
  - reflexivity.
}
apply L1.
assume H2 H3.
exact H1 (inv X f (f x)) H2 x Hx H3.
Qed.

Theorem bij_inv : forall X Y, forall f:set->set, bij X Y f -> bij Y X (inv X f).
let X Y f.
assume H1. apply H1.
assume H2. apply H2.
assume H3: forall u :e X, f u :e Y.
assume H4: forall u v :e X, f u = f v -> u = v.
assume H5: forall w :e Y, exists u :e X, f u = w.
set g : set->set := fun y => Eps_i (fun x => x :e X /\ f x = y).
claim L1: forall y :e Y, g y :e X /\ f (g y) = y.
{ exact surj_rinv X Y f H5. }
prove (forall u :e Y, g u :e X)
      /\
      (forall u v :e Y, g u = g v -> u = v)
      /\
      (forall w :e X, exists u :e Y, g u = w).
apply and3I.
- prove forall u :e Y, g u :e X.
  let u. assume Hu. apply L1 u Hu. assume H _. exact H.
- prove forall u v :e Y, g u = g v -> u = v.
  let u. assume Hu. let v. assume Hv H6.
  prove u = v.
  apply L1 u Hu.
  assume H7: g u :e X.
  assume H8: f (g u) = u.
  apply L1 v Hv.
  assume H9: g v :e X.
  assume H10: f (g v) = v.
  rewrite <- H8.
  rewrite <- H10.
  rewrite <- H6.
  reflexivity.
- prove forall w :e X, exists u :e Y, g u = w.
  let w. assume Hw.
  claim Lfw: f w :e Y.
  { exact H3 w Hw. }
  witness f w.
  apply andI.
  + exact Lfw.
  + exact inj_linv X f H4 w Hw.
Qed.

Definition atleastp : set -> set -> prop
 := fun X Y : set => exists f : set -> set, inj X Y f.

Theorem atleastp_tra: forall X Y Z, atleastp X Y -> atleastp Y Z -> atleastp X Z.
let X Y Z. assume H1 H2.
apply H1.
let f.
assume Hf: inj X Y f.
apply H2.
let g.
assume Hg: inj Y Z g.
prove exists h:set -> set, inj X Z h.
set h : set -> set := fun x => g (f x).
witness h.
exact inj_comp X Y Z f g Hf Hg.
Qed.

Theorem Subq_atleastp : forall X Y, X c= Y -> atleastp X Y.
let X Y.
assume H1: X c= Y.
set f : set -> set := fun x => x.
prove exists f:set->set, inj X Y f.
witness f. apply injI.
- exact H1.
- let x. assume Hx: x :e X.
  let x'. assume Hx': x' :e X.
  assume H2: x = x'.
  exact H2.
Qed.

Definition equip : set -> set -> prop
 := fun X Y : set => exists f : set -> set, bij X Y f.

Theorem equip_atleastp: forall X Y, equip X Y -> atleastp X Y.
let X Y.
assume H1. apply H1.
let f.
assume Hf: bij X Y f.
prove exists f:set->set, inj X Y f.
witness f.
exact bij_inj X Y f Hf.
Qed.

Theorem equip_ref : forall X, equip X X.
let X.
prove exists f:set -> set, bij X X f.
witness (fun x:set => x).
exact bij_id X.
Qed.

Theorem equip_sym : forall X Y, equip X Y -> equip Y X.
let X Y. assume H1. apply H1.
let f. assume H2: bij X Y f.
prove exists g:set -> set, bij Y X g.
witness (inv X f).
prove bij Y X (inv X f).
exact bij_inv X Y f H2.
Qed.

Theorem equip_tra : forall X Y Z, equip X Y -> equip Y Z -> equip X Z.
let X Y Z. assume H1 H2.
apply H1.
let f. assume H3: bij X Y f.
apply H2.
let g. assume H4: bij Y Z g.
prove exists h:set -> set, bij X Z h.
witness (fun x:set => g (f x)).
exact bij_comp X Y Z f g H3 H4.
Qed.

Theorem equip_0_Empty : forall X, equip X 0 -> X = 0.
let X. assume H1.
apply Empty_eq.
let x. assume Hx.
prove False.
apply H1.
let f. assume Hf: bij X 0 f.
apply bijE X 0 f Hf.
assume Hf1: forall x :e X, f x :e 0.
prove False.
exact EmptyE (f x) (Hf1 x Hx).
Qed.

Theorem equip_adjoin_ordsucc : forall N X y, y /:e X -> equip N X -> equip (ordsucc N) (X :\/: {y}).
let N X y.
assume H1: y /:e X.
assume H2: equip N X.
apply H2.
let f.
assume Hf: bij N X f.
apply bijE N X f Hf.
assume Hf1: forall u :e N, f u :e X.
assume Hf2: forall u v :e N, f u = f v -> u = v.
assume Hf3: forall w :e X, exists u :e N, f u = w.
claim L1: exists g:set -> set, (forall u :e N, g u = f u) /\ g N = y.
{ set g : set -> set := fun u => if u :e N then f u else y.
  witness g. apply andI.
  - let u. assume Hu: u :e N.
    prove g u = f u.
    exact If_i_1 (u :e N) (f u) y Hu.
  - prove g N = y.
    exact If_i_0 (N :e N) (f N) y (In_irref N).
}
apply L1.
let g. assume H. apply H.
assume Hg1: forall u :e N, g u = f u.
assume Hg2: g N = y.
prove exists g:set->set, bij (ordsucc N) (X :\/: {y}) g.
witness g. apply bijI.
- let u. assume Hu: u :e ordsucc N.
  apply ordsuccE N u Hu.
  + assume H3: u :e N.
    prove g u :e X :\/: {y}.
    apply binunionI1.
    rewrite Hg1 u H3.
    prove f u :e X.
    exact Hf1 u H3.
  + assume H3: u = N.
    prove g u :e X :\/: {y}.
    apply binunionI2.
    prove g u :e {y}.
    rewrite H3. rewrite Hg2.
    prove y :e {y}.
    apply SingI.
- let u. assume Hu: u :e ordsucc N.
  let v. assume Hv: v :e ordsucc N.
  prove g u = g v -> u = v.
  apply ordsuccE N u Hu.
  + assume H3: u :e N.
    rewrite Hg1 u H3.
    apply ordsuccE N v Hv.
    * assume H4: v :e N.
      rewrite Hg1 v H4.
      prove f u = f v -> u = v.
      exact Hf2 u H3 v H4.
    * assume H4: v = N.
      rewrite H4. rewrite Hg2.
      assume H5: f u = y.
      prove False.
      apply H1.
      prove y :e X.
      rewrite <- H5. exact Hf1 u H3.
  + assume H3: u = N.
    apply ordsuccE N v Hv.
    * assume H4: v :e N.
      rewrite H3. rewrite Hg2.
      rewrite Hg1 v H4.
      assume H5: y = f v.
      prove False.
      apply H1.
      prove y :e X.
      rewrite H5. exact Hf1 v H4.
    * assume H4: v = N.
      assume _.
      prove u = v.
      rewrite H4. exact H3.
- let w. assume Hw: w :e X :\/: {y}.
  prove exists u :e ordsucc N, g u = w.
  apply binunionE X {y} w Hw.
  + assume H3: w :e X.
    apply Hf3 w H3.
    let u. assume H. apply H.
    assume H4: u :e N.
    assume H5: f u = w.
    witness u. apply andI.
    * prove u :e ordsucc N. apply ordsuccI1. exact H4.
    * prove g u = w. rewrite Hg1 u H4. exact H5.
  + assume H3: w :e {y}.
    witness N. apply andI.
    * prove N :e ordsucc N. apply ordsuccI2.
    * prove g N = w. rewrite SingE y w H3. exact Hg2.
Qed.

Theorem equip_ordsucc_remove1: forall X N, forall x :e X, equip X (ordsucc N) -> equip (X :\: {x}) N.
let X N x.
assume Hx: x :e X.
assume H1: equip X (ordsucc N).
apply equip_sym X (ordsucc N) H1.
let f.
assume Hf: bij (ordsucc N) X f.
apply bijE (ordsucc N) X f Hf.
assume Hf1: forall u :e ordsucc N, f u :e X.
assume Hf2: forall u v :e ordsucc N, f u = f v -> u = v.
assume Hf3: forall y :e X, exists u :e ordsucc N, f u = y.
apply equip_sym.
prove equip N (X :\: {x}).
apply Hf3 x Hx.
let w. assume H. apply H.
assume Hw: w :e ordsucc N.
assume Hfw: f w = x.
apply ordsuccE N w Hw.
- assume H2: w :e N.
  claim L1: f N <> x.
  { assume H3: f N = x.
    claim L1a: f w = f N.
    { rewrite H3. exact Hfw. }
    apply In_irref N.
    prove N :e N.
    rewrite <- Hf2 w (ordsuccI1 N w H2) N (ordsuccI2 N) L1a at 1.
    prove w :e N.
    exact H2.
  }
  claim L2: forall u :e N, f u <> f N.
  { let u. assume Hu: u :e N.
    assume H3: f u = f N.
    apply In_irref N.
    prove N :e N.
    rewrite <- Hf2 u (ordsuccI1 N u Hu) N (ordsuccI2 N) H3 at 1.
    prove u :e N.
    exact Hu.
  }
  claim L3: exists g:set->set, (forall u :e ordsucc N, u <> w -> g u = f u) /\ g w = f N.
  { set g:set->set := fun u => if u = w then f N else f u.
    witness g. apply andI.
    - let u. assume Hu: u :e ordsucc N.
      assume H3: u <> w.
      exact If_i_0 (u = w) (f N) (f u) H3.
    - prove (if w = w then f N else f w) = f N.
      exact If_i_1 (w = w) (f N) (f w) (fun q H => H).
  }
  apply L3.
  let g. assume H. apply H.
  assume Hg1: forall u :e ordsucc N, u <> w -> g u = f u.
  assume Hg2: g w = f N.
  prove exists g:set->set, bij N (X :\: {x}) g.
  witness g.
  apply bijI.
  + let u. assume Hu: u :e N.
    prove g u :e X :\: {x}.
    apply xm (u = w).
    * { assume H3: u = w. rewrite H3. rewrite Hg2.
        prove f N :e X :\: {x}.
        apply setminusI.
        - prove f N :e X. exact Hf1 N (ordsuccI2 N).
        - assume H4: f N :e {x}.
          apply L1.
          prove f N = x.
          apply SingE. exact H4.
      }
    * { assume H3: u <> w.
        rewrite Hg1 u (ordsuccI1 N u Hu) H3.
        prove f u :e X :\: {x}.
        apply setminusI.
        - prove f u :e X. exact Hf1 u (ordsuccI1 N u Hu).
        - assume H4: f u :e {x}.
          apply H3.
          prove u = w.
          apply Hf2 u (ordsuccI1 N u Hu) w Hw.
          prove f u = f w.
          rewrite Hfw.
          prove f u = x. apply SingE. exact H4.
      }
  + let u. assume Hu: u :e N.
    let v. assume Hv: v :e N.
    prove g u = g v -> u = v.
    apply xm (u = w).
    * { assume H3: u = w.
        apply xm (v = w).
        - assume H4: v = w.
          assume _.
          prove u = v.
          rewrite H4. exact H3.
        - assume H4: v <> w.
          rewrite H3. rewrite Hg2.
          rewrite Hg1 v (ordsuccI1 N v Hv) H4.
          assume H5: f N = f v.
          prove False.
          apply L2 v Hv.
          prove f v = f N.
          symmetry.
          exact H5.
      }
    * { assume H3: u <> w.
        rewrite Hg1 u (ordsuccI1 N u Hu) H3.
        apply xm (v = w).
        - assume H4: v = w.
          rewrite H4. rewrite Hg2.
          assume H5: f u = f N.
          prove False.
          apply L2 u Hu.
          prove f u = f N.
          exact H5.
        - assume H4: v <> w.
          rewrite Hg1 v (ordsuccI1 N v Hv) H4.
          prove f u = f v -> u = v.
          exact Hf2 u (ordsuccI1 N u Hu) v (ordsuccI1 N v Hv).
      }
  + let y. assume Hy: y :e X :\: {x}.
    apply setminusE X {x} y Hy.
    assume Hy1: y :e X.
    assume Hy2: y /:e {x}.
    apply Hf3 y Hy1.
    let u. assume H. apply H.
    assume Hu1: u :e ordsucc N.
    assume Hu2: f u = y.
    claim L4: u <> w.
    { assume H3: u = w.
      apply Hy2.
      prove y :e {x}.
      rewrite <- Hu2. rewrite <- Hfw.
      rewrite H3.
      apply SingI.
    }
    apply ordsuccE N u Hu1.
    * { assume H3: u :e N.
        witness u. apply andI.
        - exact H3.
        - prove g u = y.
          rewrite Hg1 u Hu1 L4.
          prove f u = y.
          exact Hu2.
      }
    * { assume H3: u = N.
        witness w. apply andI.
        - exact H2.
        - prove g w = y.
          rewrite Hg2.
          prove f N = y.
          rewrite <- H3. exact Hu2.
      }
- assume H2: w = N.
  prove exists g:set->set, bij N (X :\: {x}) g.
  witness f.
  apply bijI.
  + let u. assume Hu: u :e N.
    prove f u :e X :\: {x}.
    apply setminusI.
    * exact Hf1 u (ordsuccI1 N u Hu).
    * assume H3: f u :e {x}.
      claim L5: u = N.
      {  apply Hf2 u (ordsuccI1 N u Hu) N (ordsuccI2 N).
         prove f u = f N.
         rewrite <- H2. rewrite Hfw.
         prove f u = x.
         apply SingE. exact H3.
      }
      apply In_irref N.
      prove N :e N.
      rewrite <- L5 at 1.
      prove u :e N.
      exact Hu.
  + let u. assume Hu: u :e N.
    let v. assume Hv: v :e N.
    prove f u = f v -> u = v.
    exact Hf2 u (ordsuccI1 N u Hu) v (ordsuccI1 N v Hv).
  + let y. assume Hy: y :e X :\: {x}.
    apply setminusE X {x} y Hy.
    assume Hy1: y :e X.
    assume Hy2: y /:e {x}.
    apply Hf3 y Hy1.
    let u. assume H. apply H.
    assume Hu1: u :e ordsucc N.
    assume Hu2: f u = y.
    witness u. apply andI.
    * { prove u :e N.
        apply ordsuccE N u Hu1.
        - assume H3: u :e N. exact H3.
        - assume H3: u = N. prove False.
          apply Hy2.
          prove y :e {x}.
          rewrite <- Hu2. rewrite H3. rewrite <- H2.
          prove f w :e {x}.
          rewrite Hfw. apply SingI.
      }
    * prove f u = y. exact Hu2.
Qed.

Section SchroederBernstein.

Theorem KnasterTarski_set: forall A, forall F:set->set,
    (forall U :e Power A, F U :e Power A)
 -> (forall U V :e Power A, U c= V -> F U c= F V)
 -> exists Y :e Power A, F Y = Y.
let A F. assume H1 H2.
set Y : set := {u :e A|forall X :e Power A, F X c= X -> u :e X}.
claim L1: Y :e Power A.
{ apply Sep_In_Power. }
claim L2: F Y :e Power A.
{ exact H1 Y L1. }
claim L3: forall X :e Power A, F X c= X -> Y c= X.
{ let X. assume HX: X :e Power A.
  assume H3: F X c= X.
  let y. assume Hy: y :e Y.
  exact SepE2 A (fun u => forall X :e Power A, F X c= X -> u :e X) y Hy X HX H3.
}
claim L4: F Y c= Y.
{ let u. assume H3: u :e F Y. prove u :e Y.
  apply SepI.
  - prove u :e A. exact PowerE A (F Y) L2 u H3.
  - let X. assume HX: X :e Power A.
    assume H4: F X c= X.
    prove u :e X.
    claim L4a: Y c= X.
    { exact L3 X HX H4. }
    claim L4b: F Y c= F X.
    { exact H2 Y L1 X HX L4a. }
    prove u :e X. apply H4. prove u :e F X. apply L4b. exact H3.
}
claim L5: F (F Y) c= F Y.
{ exact H2 (F Y) L2 Y L1 L4. }
witness Y.
apply andI.
- exact L1.
- apply set_ext.
  + exact L4.
  + prove Y c= F Y. apply L3.
    * exact L2.
    * exact L5.
Qed.

Theorem image_In_Power : forall A B, forall f:set -> set, (forall x :e A, f x :e B) -> forall U :e Power A, {f x|x :e U} :e Power B.
let A B f. assume Hf.
let U. assume HU. apply PowerI.
let y. assume Hy: y :e {f x|x :e U}.
apply ReplE_impred U f y Hy.
let x.
assume Hx: x :e U.
assume H1: y = f x. rewrite H1. apply Hf.
prove x :e A.
apply PowerE A U HU.
exact Hx.
Qed.

Theorem image_monotone : forall f:set -> set, forall U V, U c= V -> {f x|x :e U} c= {f x|x :e V}.
let f U V. assume HUV.
let y. assume Hy: y :e {f x|x :e U}.
apply ReplE_impred U f y Hy.
let x.
assume Hx: x :e U.
assume H1: y = f x. rewrite H1.
prove f x :e {f x|x :e V}.
apply ReplI. apply HUV. exact Hx.
Qed.

Theorem setminus_antimonotone : forall A U V, U c= V -> A :\: V c= A :\: U.
let A U V. assume HUV.
let x. assume Hx. apply setminusE A V x Hx.
assume H1 H2. apply setminusI.
- exact H1.
- assume H3: x :e U. apply H2. prove x :e V. exact HUV x H3.
Qed.

Theorem SchroederBernstein: forall A B, forall f g:set -> set, inj A B f -> inj B A g -> equip A B.
let A B f g. assume Hf Hg.
apply Hf. assume Hf1 Hf2.
apply Hg. assume Hg1 Hg2.
set F : set -> set := fun X => {g y|y :e B :\: {f x|x :e A :\: X}}.
claim L1: forall U :e Power A, F U :e Power A.
{ let U. assume HU.
  prove {g y|y :e B :\: {f x|x :e A :\: U}} :e Power A.
  apply image_In_Power B A g Hg1.
  prove B :\: {f x|x :e A :\: U} :e Power B.
  apply setminus_In_Power.
}
claim L2: forall U V :e Power A, U c= V -> F U c= F V.
{ let U. assume HU. let V. assume HV HUV.
  prove {g y|y :e B :\: {f x|x :e A :\: U}} c= {g y|y :e B :\: {f x|x :e A :\: V}}.
  apply image_monotone g.
  prove B :\: {f x|x :e A :\: U} c= B :\: {f x|x :e A :\: V}.
  apply setminus_antimonotone.
  prove {f x|x :e A :\: V} c= {f x|x :e A :\: U}.
  apply image_monotone f.
  prove A :\: V c= A :\: U. apply setminus_antimonotone. exact HUV.
}
apply KnasterTarski_set A F L1 L2.
let Y. assume H1. apply H1.
assume H1: Y :e Power A.
assume H2: F Y = Y.
set h : set -> set := fun x => if x :e Y then inv B g x else f x.
prove exists f:set -> set, bij A B f.
witness h.
apply bijI.
- let x. assume Hx.
  prove (if x :e Y then inv B g x else f x) :e B.
  apply xm (x :e Y).
  + assume H3: x :e Y. rewrite If_i_1 (x :e Y) (inv B g x) (f x) H3.
    prove inv B g x :e B.
    claim L1: x :e F Y.
    { rewrite H2. exact H3. }
    apply ReplE_impred (B :\: {f x|x :e A :\: Y}) g x L1.
    let y. assume H4: y :e B :\: {f x|x :e A :\: Y}.
    assume H5: x = g y.
    claim L2: y :e B.
    { exact setminusE1 B {f x|x :e A :\: Y} y H4. }
    rewrite H5. prove inv B g (g y) :e B.
    rewrite inj_linv B g Hg2 y L2.
    prove y :e B. exact L2.
  + assume H3: x /:e Y. rewrite If_i_0 (x :e Y) (inv B g x) (f x) H3.
    prove f x :e B. apply Hf1. exact Hx.
- let x. assume Hx. let y. assume Hy.
  prove (if x :e Y then inv B g x else f x)
      = (if y :e Y then inv B g y else f y)
     -> x = y.
  apply xm (x :e Y).
  + assume H3: x :e Y. rewrite If_i_1 (x :e Y) (inv B g x) (f x) H3.
    prove inv B g x = (if y :e Y then inv B g y else f y)
       -> x = y.
    claim Lx: x :e F Y.
    { rewrite H2. exact H3. }
    apply ReplE_impred (B :\: {f x|x :e A :\: Y}) g x Lx.
    let z.
    assume Hz1: z :e B :\: {f x|x :e A :\: Y}.
    assume Hz2: x = g z.
    apply setminusE B {f x|x :e A :\: Y} z Hz1.
    assume Hz1a Hz1b.
    apply xm (y :e Y).
    * { assume H4: y :e Y. rewrite If_i_1 (y :e Y) (inv B g y) (f y) H4.
        prove inv B g x = inv B g y -> x = y.
        claim Ly: y :e F Y.
        { rewrite H2. exact H4. }
        apply ReplE_impred (B :\: {f x|x :e A :\: Y}) g y Ly.
        let w.
        assume Hw1: w :e B :\: {f x|x :e A :\: Y}.
        assume Hw2: y = g w.
        rewrite Hz2. rewrite Hw2.
        rewrite inj_linv B g Hg2 z Hz1a.
        rewrite inj_linv B g Hg2 w (setminusE1 B {f x|x :e A :\: Y} w Hw1).
        assume H5: z = w.
        prove g z = g w.
        f_equal. exact H5.
      }
    * { assume H4: y /:e Y. rewrite If_i_0 (y :e Y) (inv B g y) (f y) H4.
        prove inv B g x = f y -> x = y.
        rewrite Hz2.
        rewrite inj_linv B g Hg2 z Hz1a.
        prove z = f y -> g z = y.
        assume H5: z = f y.
        prove False.
        apply Hz1b.
        prove z :e {f x|x :e A :\: Y}.
        rewrite H5.
        apply ReplI.
        prove y :e A :\: Y.
        apply setminusI.
        + exact Hy.
        + exact H4.
      }
  + assume H3: x /:e Y. rewrite If_i_0 (x :e Y) (inv B g x) (f x) H3.
    prove f x = (if y :e Y then inv B g y else f y)
       -> x = y.
    apply xm (y :e Y).
    * { assume H4: y :e Y. rewrite If_i_1 (y :e Y) (inv B g y) (f y) H4.
        prove f x = inv B g y -> x = y.
        claim Ly: y :e F Y.
        { rewrite H2. exact H4. }
        apply ReplE_impred (B :\: {f x|x :e A :\: Y}) g y Ly.
        let w.
        assume Hw1: w :e B :\: {f x|x :e A :\: Y}.
        assume Hw2: y = g w.
        apply setminusE B {f x|x :e A :\: Y} w Hw1.
        assume Hw1a Hw1b.
        rewrite Hw2.
        rewrite inj_linv B g Hg2 w Hw1a.
        assume H5: f x = w.
        prove False.
        apply Hw1b.
        prove w :e {f x|x :e A :\: Y}.
        rewrite <- H5.
        apply ReplI. apply setminusI.
        - exact Hx.
        - exact H3.
      }
    * { assume H4: y /:e Y. rewrite If_i_0 (y :e Y) (inv B g y) (f y) H4.
        prove f x = f y -> x = y.
        exact Hf2 x Hx y Hy.
      }
- let w. assume Hw: w :e B.
  apply xm (w :e {f x|x :e A :\: Y}).
  + assume H3: w :e {f x|x :e A :\: Y}.
    apply ReplE_impred (A :\: Y) f w H3.
    let x. assume H4: x :e A :\: Y.
    assume H5: w = f x.
    apply setminusE A Y x H4.
    assume H6: x :e A.
    assume H7: x /:e Y.
    witness x. apply andI.
    * exact H6.
    * prove (if x :e Y then inv B g x else f x) = w.
      rewrite If_i_0 (x :e Y) (inv B g x) (f x) H7.
      symmetry. exact H5.
  + assume H3: w /:e {f x|x :e A :\: Y}.
    claim Lgw: g w :e Y.
    { rewrite <- H2. prove g w :e F Y.
      prove g w :e {g y|y :e B :\: {f x|x :e A :\: Y}}.
      apply ReplI.
      apply setminusI.
      - prove w :e B. exact Hw.
      - prove w /:e {f x|x :e A :\: Y}. exact H3.
    }
    witness (g w). apply andI.
    * prove g w :e A. apply Hg1. exact Hw.
    * prove (if g w :e Y then inv B g (g w) else f (g w)) = w.
      rewrite If_i_1 (g w :e Y) (inv B g (g w)) (f (g w)) Lgw.
      exact inj_linv B g Hg2 w Hw.
Qed.

Theorem atleastp_antisym_equip: forall A B, atleastp A B -> atleastp B A -> equip A B.
let A B.
assume H1: atleastp A B.
assume H2: atleastp B A.
apply H1.
let f. assume Hf: inj A B f.
apply H2.
let g. assume Hg: inj B A g.
exact SchroederBernstein A B f g Hf Hg.
Qed.

End SchroederBernstein.

Section PigeonHole.

Theorem PigeonHole_nat : forall n, nat_p n -> forall f:set -> set, (forall i :e ordsucc n, f i :e n) -> ~(forall i j :e ordsucc n, f i = f j -> i = j).
apply nat_ind (fun n => forall f:set -> set, (forall i :e ordsucc n, f i :e n) -> ~(forall i j :e ordsucc n, f i = f j -> i = j)).
- prove forall f:set -> set, (forall i :e 1, f i :e 0) -> ~(forall i j :e 1, f i = f j -> i = j).
  let f. assume H1. apply EmptyE (f 0) (H1 0 In_0_1).
- let n. assume Hn: nat_p n.
  assume IH: forall f:set -> set, (forall i :e ordsucc n, f i :e n) -> ~(forall i j :e ordsucc n, f i = f j -> i = j).
  let f.
  assume H1: forall i :e ordsucc (ordsucc n), f i :e ordsucc n.
  assume H2: forall i j :e ordsucc (ordsucc n), f i = f j -> i = j.
  apply xm (exists i :e ordsucc (ordsucc n), f i = n).
  + assume H3. apply H3. let k. assume Hk. apply Hk.
    assume Hk1: k :e ordsucc (ordsucc n).
    assume Hk2: f k = n.
    set f' := fun i:set => if k c= i then f (ordsucc i) else f i.
    apply IH f'.
    * { prove forall i :e ordsucc n, f' i :e n.
        let i. assume Hi: i :e ordsucc n.
        apply xm (k c= i).
        - assume H4: k c= i.
          prove (if k c= i then f (ordsucc i) else f i) :e n.
          rewrite If_i_1 (k c= i) (f (ordsucc i)) (f i) H4.
          prove f (ordsucc i) :e n.
          claim L1: ordsucc i :e ordsucc (ordsucc n).
          { apply nat_ordsucc_in_ordsucc.
            - apply nat_ordsucc. exact Hn.
            - exact Hi.
          }
          apply ordsuccE n (f (ordsucc i)) (H1 (ordsucc i) L1).
          + assume H5: f (ordsucc i) :e n. exact H5.
          + assume H5: f (ordsucc i) = n.
            prove False.
            apply In_irref i.
            prove i :e i.
            claim L2: k = ordsucc i.
            { apply H2.
              - exact Hk1.
              - exact L1.
              - rewrite H5. exact Hk2.
            }
            claim L3: i :e k.
            { rewrite L2. apply ordsuccI2. }
            exact H4 i L3.
        - assume H4: ~(k c= i).
          prove (if k c= i then f (ordsucc i) else f i) :e n.
          rewrite If_i_0 (k c= i) (f (ordsucc i)) (f i) H4.
          prove f i :e n.
          apply ordsuccE n (f i) (H1 i (ordsuccI1 (ordsucc n) i Hi)).
          + assume H5: f i :e n. exact H5.
          + assume H5: f i = n.
            prove False.
            apply H4.
            prove k c= i.
            claim L2: k = i.
            { apply H2.
              - exact Hk1.
              - exact ordsuccI1 (ordsucc n) i Hi.
              - rewrite H5. exact Hk2.
            }
            rewrite <- L2.
            exact (fun x Hx => Hx).
      }
    * { prove forall i j :e ordsucc n, f' i = f' j -> i = j.
        let i. assume Hi. let j. assume Hj.
        prove (if k c= i then f (ordsucc i) else f i) = (if k c= j then f (ordsucc j) else f j) -> i = j.
        claim Li1: i :e ordsucc (ordsucc n).
        { apply ordsuccI1. exact Hi. }
        claim Li2: ordsucc i :e ordsucc (ordsucc n).
        { apply nat_ordsucc_in_ordsucc.
          - apply nat_ordsucc. exact Hn.
          - exact Hi.
        }
        claim Lj1: j :e ordsucc (ordsucc n).
        { apply ordsuccI1. exact Hj. }
        claim Lj2: ordsucc j :e ordsucc (ordsucc n).
        { apply nat_ordsucc_in_ordsucc.
          - apply nat_ordsucc. exact Hn.
          - exact Hj.
        }
        apply xm (k c= i).
        - assume H4: k c= i.
          rewrite If_i_1 (k c= i) (f (ordsucc i)) (f i) H4.
          apply xm (k c= j).
          + assume H5: k c= j.
            rewrite If_i_1 (k c= j) (f (ordsucc j)) (f j) H5.
            prove f (ordsucc i) = f (ordsucc j) -> i = j.
            assume H6.
            apply ordsucc_inj.
            prove ordsucc i = ordsucc j.
            exact H2 (ordsucc i) Li2 (ordsucc j) Lj2 H6.
          + assume H5: ~(k c= j).
            rewrite If_i_0 (k c= j) (f (ordsucc j)) (f j) H5.
            prove f (ordsucc i) = f j -> i = j.
            assume H6.
            prove False.
            claim L3: ordsucc i = j.
            { apply H2.
              - exact Li2.
              - exact Lj1.
              - exact H6.
            }
            apply H5.
            rewrite <- L3.
            let x. assume Hx: x :e k.
            apply ordsuccI1. apply H4. exact Hx.
        - assume H4: ~(k c= i).
          rewrite If_i_0 (k c= i) (f (ordsucc i)) (f i) H4.
          apply xm (k c= j).
          + assume H5: k c= j.
            rewrite If_i_1 (k c= j) (f (ordsucc j)) (f j) H5.
            prove f i = f (ordsucc j) -> i = j.
            assume H6.
            prove False.
            claim L3: i = ordsucc j.
            { apply H2.
              - exact Li1.
              - exact Lj2.
              - exact H6.
            }
            apply H4.
            rewrite L3.
            let x. assume Hx: x :e k.
            apply ordsuccI1. apply H5. exact Hx.
          + assume H5: ~(k c= j).
            rewrite If_i_0 (k c= j) (f (ordsucc j)) (f j) H5.
            prove f i = f j -> i = j.
            apply H2.
            * exact Li1.
            * exact Lj1.
      }
  + assume H3: ~(exists i :e ordsucc (ordsucc n), f i = n).
    apply IH f.
    * { prove forall i :e ordsucc n, f i :e n.
        let i. assume Hi: i :e ordsucc n.
        apply ordsuccE n (f i) (H1 i (ordsuccI1 (ordsucc n) i Hi)).
        - assume Hfi: f i :e n. exact Hfi.
        - assume Hfi: f i = n. apply H3. witness i. apply andI.
          + apply ordsuccI1. exact Hi.
          + exact Hfi.
      }
    * { prove forall i j :e ordsucc n, f i = f j -> i = j.
        let i. assume Hi. let j. assume Hj.
        apply H2.
        - apply ordsuccI1. exact Hi.
        - apply ordsuccI1. exact Hj.
      }
Qed.

Theorem Pigeonhole_not_atleastp_ordsucc : forall n, nat_p n -> ~atleastp (ordsucc n) n.
let n. assume Hn.
assume H1. apply H1.
let f.
assume Hf: inj (ordsucc n) n f.
apply Hf.
assume Hf1 Hf2.
exact PigeonHole_nat n Hn f Hf1 Hf2.
Qed.

End PigeonHole.

Theorem Union_ordsucc_eq : forall n, nat_p n -> Union (ordsucc n) = n.
apply nat_complete_ind.
let n.
assume Hn: nat_p n.
assume IHn: forall m :e n, Union (ordsucc m) = m.
prove Union (ordsucc n) = n.
apply set_ext.
- let m.
  assume Hm: m :e Union (ordsucc n).
  apply (UnionE_impred (ordsucc n) m Hm).
  let k.
  assume H1: m :e k.
  assume H2: k :e ordsucc n.
  prove m :e n.
  exact nat_ordsucc_trans n Hn k H2 m H1.
- let m.
  assume Hm: m :e n.
  prove m :e Union (ordsucc n).
  apply (UnionI (ordsucc n) m n).
  + exact Hm.
  + exact (ordsuccI2 n).
Qed.

Theorem cases_1: forall i :e 1, forall p:set->prop, p 0 -> p i.
let i. assume Hi. let p. assume Hp0.
apply ordsuccE 0 i Hi.
- assume Hil: i :e 0.
  apply EmptyE i Hil.
- assume Hie: i = 0.
  rewrite Hie. exact Hp0.
Qed.

Theorem cases_2: forall i :e 2, forall p:set->prop, p 0 -> p 1 -> p i.
let i. assume Hi. let p. assume Hp0 Hp1.
apply ordsuccE 1 i Hi.
- assume Hil: i :e 1.
  exact cases_1 i Hil p Hp0.
- assume Hie: i = 1.
  rewrite Hie. exact Hp1.
Qed.

Theorem neq_0_1 : 0 <> 1.
exact (neq_0_ordsucc 0).
Qed.

Theorem neq_1_0 : 1 <> 0.
exact (neq_ordsucc_0 0).
Qed.

Theorem neq_0_2 : 0 <> 2.
exact (neq_0_ordsucc 1).
Qed.

Theorem neq_2_0 : 2 <> 0.
exact (neq_ordsucc_0 1).
Qed.

Definition ordinal : set->prop := fun (alpha:set) => TransSet alpha /\ forall beta :e alpha, TransSet beta.

Theorem ordinal_TransSet : forall alpha:set, ordinal alpha -> TransSet alpha.
exact (fun alpha H => andEL (TransSet alpha) (forall beta :e alpha, TransSet beta) H).
Qed.

Theorem ordinal_Empty : ordinal Empty.
prove TransSet Empty /\ forall x :e Empty, TransSet x.
apply andI.
- let x.
  assume Hx: x :e Empty.
  prove False.
  exact (EmptyE x Hx).
- let x.
  assume Hx: x :e Empty.
  prove False.
  exact (EmptyE x Hx).
Qed.

Theorem ordinal_Hered : forall alpha:set, ordinal alpha -> forall beta :e alpha, ordinal beta.
let alpha.
assume H1: TransSet alpha /\ forall x :e alpha, TransSet x.
let beta.
assume H2: beta :e alpha.
prove TransSet beta /\ forall x :e beta, TransSet x.
apply H1.
assume H3: TransSet alpha.
assume H4: forall x :e alpha, TransSet x.
apply andI.
- exact (H4 beta H2).
- prove forall x :e beta, TransSet x.
  let x.
  assume Hx: x :e beta.
  claim L1: x :e alpha.
  { exact (H3 beta H2 x Hx). }
  prove TransSet x.
  exact (H4 x L1).
Qed.

Theorem TransSet_ordsucc : forall X:set, TransSet X -> TransSet (ordsucc X).
let X.
assume H1: TransSet X.
let x.
assume H2: x :e ordsucc X.
let y.
assume H3: y :e x.
prove y :e ordsucc X.
apply (ordsuccE X x H2).
- assume H4: x :e X.
  apply ordsuccI1.
  prove y :e X.
  exact (H1 x H4 y H3).
- assume H4: x = X.
  apply ordsuccI1.
  prove y :e X.
  rewrite <- H4.
  prove y :e x.
  exact H3.
Qed.

Theorem ordinal_ordsucc : forall alpha:set, ordinal alpha -> ordinal (ordsucc alpha).
let alpha.
assume H1: TransSet alpha /\ forall beta :e alpha, TransSet beta.
apply H1.
assume H2: TransSet alpha.
assume H3: forall beta :e alpha, TransSet beta.
prove TransSet (ordsucc alpha) /\ forall beta :e ordsucc alpha, TransSet beta.
apply andI.
- exact (TransSet_ordsucc alpha H2).
- let beta.
  assume H4: beta :e ordsucc alpha.
  prove TransSet beta.
  apply (ordsuccE alpha beta H4).
  + assume H5: beta :e alpha.
    exact (H3 beta H5).
  + assume H5: beta = alpha.
    rewrite H5.
    exact H2.
Qed.

Theorem nat_p_ordinal : forall n:set, nat_p n -> ordinal n.
apply nat_ind.
- prove ordinal 0.
  exact ordinal_Empty.
- let n.
  assume Hn: nat_p n.
  assume IHn: ordinal n.
  prove ordinal (ordsucc n).
  exact (ordinal_ordsucc n IHn).
Qed.

Theorem ordinal_1 : ordinal 1.
exact nat_p_ordinal 1 nat_1.
Qed.

Theorem ordinal_2 : ordinal 2.
exact nat_p_ordinal 2 nat_2.
Qed.

Theorem TransSet_ordsucc_In_Subq : forall X:set, TransSet X -> forall x :e X, ordsucc x c= X.
let X.
assume H1: TransSet X.
let x.
assume H2: x :e X.
let y.
assume H3: y :e ordsucc x.
prove y :e X.
apply (ordsuccE x y H3).
- assume H4: y :e x.
  exact (H1 x H2 y H4).
- assume H4: y = x.
  rewrite H4.
  prove x :e X.
  exact H2.
Qed.

Theorem ordinal_ordsucc_In_Subq : forall alpha, ordinal alpha -> forall beta :e alpha, ordsucc beta c= alpha.
let alpha.
assume H: ordinal alpha.
exact (TransSet_ordsucc_In_Subq alpha (ordinal_TransSet alpha H)).
Qed.

Theorem ordinal_trichotomy_or : forall alpha beta:set, ordinal alpha -> ordinal beta -> alpha :e beta \/ alpha = beta \/ beta :e alpha.
apply In_ind.
let alpha.
assume IHalpha: forall gamma :e alpha, forall beta:set, ordinal gamma -> ordinal beta -> gamma :e beta \/ gamma = beta \/ beta :e gamma.
prove forall beta:set, ordinal alpha -> ordinal beta -> alpha :e beta \/ alpha = beta \/ beta :e alpha.
apply In_ind.
let beta.
assume IHbeta: forall delta :e beta, ordinal alpha -> ordinal delta -> alpha :e delta \/ alpha = delta \/ delta :e alpha.
assume Halpha : ordinal alpha.
assume Hbeta : ordinal beta.
prove alpha :e beta \/ alpha = beta \/ beta :e alpha.
apply (xm (alpha :e beta)).
- assume H1: alpha :e beta.
  apply or3I1.
  exact H1.
- assume H1: alpha /:e beta.
  apply (xm (beta :e alpha)).
  + assume H2: beta :e alpha.
    apply or3I3.
    exact H2.
  + assume H2: beta /:e alpha.
    apply or3I2.
    prove alpha = beta.
    apply set_ext.
    * { prove alpha c= beta.
        let gamma.
        assume H3: gamma :e alpha.
        prove gamma :e beta.
        claim Lgamma: ordinal gamma.
        { exact (ordinal_Hered alpha Halpha gamma H3). }
        apply (or3E (gamma :e beta) (gamma = beta) (beta :e gamma) (IHalpha gamma H3 beta Lgamma Hbeta)).
        - assume H4: gamma :e beta.
          exact H4.
        - assume H4: gamma = beta.
          prove False.
          apply H2.
          prove beta :e alpha.
          rewrite <- H4.
          exact H3.
        - assume H4: beta :e gamma.
          prove False.
          apply H2.
          prove beta :e alpha.
          exact (ordinal_TransSet alpha Halpha gamma H3 beta H4).
      }
    * { prove beta c= alpha.
        let delta.
        assume H3: delta :e beta.
        prove delta :e alpha.
        claim Ldelta: ordinal delta.
        { exact (ordinal_Hered beta Hbeta delta H3). }
        apply (or3E (alpha :e delta) (alpha = delta) (delta :e alpha) (IHbeta delta H3 Halpha Ldelta)).
        - assume H4: alpha :e delta.
          prove False.
          apply H1.
          prove alpha :e beta.
          exact (ordinal_TransSet beta Hbeta delta H3 alpha H4).
        - assume H4: alpha = delta.
          prove False.
          apply H1.
          prove alpha :e beta.
          rewrite H4.
          exact H3.
        - assume H4: delta :e alpha.
          exact H4.
      }
Qed.    

Theorem ordinal_trichotomy_or_impred : forall alpha beta:set, ordinal alpha -> ordinal beta -> forall p:prop, (alpha :e beta -> p) -> (alpha = beta -> p) -> (beta :e alpha -> p) -> p.
let alpha beta. assume H1 H2.
exact (or3E (alpha :e beta) (alpha = beta) (beta :e alpha) (ordinal_trichotomy_or alpha beta H1 H2)).
Qed.

Theorem ordinal_In_Or_Subq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha :e beta \/ beta c= alpha.
let alpha beta.
assume H1: ordinal alpha.
assume H2: ordinal beta.
apply (or3E (alpha :e beta) (alpha = beta) (beta :e alpha) (ordinal_trichotomy_or alpha beta H1 H2)).
- assume H3: alpha :e beta.
  apply orIL.
  exact H3.
- assume H3: alpha = beta.
  apply orIR.
  rewrite H3.
  apply Subq_ref.
- assume H3: beta :e alpha.
  apply orIR.
  exact (ordinal_TransSet alpha H1 beta H3).
Qed.

Theorem ordinal_linear : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta \/ beta c= alpha.
let alpha beta.
assume H1: ordinal alpha.
assume H2: ordinal beta.
apply (ordinal_In_Or_Subq alpha beta H1 H2).
- assume H3: alpha :e beta.
  apply orIL.
  exact (ordinal_TransSet beta H2 alpha H3).
- assume H3: beta c= alpha.
  apply orIR.
  exact H3.
Qed.

Theorem ordinal_ordsucc_In_eq : forall alpha beta, ordinal alpha -> beta :e alpha -> ordsucc beta :e alpha \/ alpha = ordsucc beta.
let alpha beta.
assume Ha Hb.
claim L1: ordinal (ordsucc beta).
{ exact ordinal_ordsucc beta (ordinal_Hered alpha Ha beta Hb). }
apply ordinal_trichotomy_or alpha (ordsucc beta) Ha L1. assume H1. apply H1.
- assume H2: alpha :e ordsucc beta.
  prove False.
  apply ordsuccE beta alpha H2.
  + assume H3: alpha :e beta.
    exact In_no2cycle alpha beta H3 Hb.
  + assume H3: alpha = beta.
    apply In_irref alpha. rewrite H3 at 1. exact Hb.
- assume H2: alpha = ordsucc beta. apply orIR. exact H2.
- assume H2: ordsucc beta :e alpha. apply orIL. exact H2.
Qed.

Theorem ordinal_lim_or_succ : forall alpha, ordinal alpha -> (forall beta :e alpha, ordsucc beta :e alpha) \/ (exists beta :e alpha, alpha = ordsucc beta).
let alpha. assume Ha.
apply xm (exists beta :e alpha, alpha = ordsucc beta).
- assume H1. apply orIR. exact H1.
- assume H1: ~exists beta :e alpha, alpha = ordsucc beta.
  apply orIL.
  let beta. assume H2: beta :e alpha.
  apply ordinal_ordsucc_In_eq alpha beta Ha H2.
  + assume H3: ordsucc beta :e alpha. exact H3.
  + assume H3: alpha = ordsucc beta. prove False. apply H1.
    witness beta. apply andI.
    * exact H2.
    * exact H3.
Qed.

Theorem ordinal_ordsucc_In : forall alpha, ordinal alpha -> forall beta :e alpha, ordsucc beta :e ordsucc alpha.
let alpha. assume Ha. let beta. assume Hb.
claim L1: ordsucc beta c= alpha.
{ exact ordinal_ordsucc_In_Subq alpha Ha beta Hb. }
apply ordinal_In_Or_Subq (ordsucc beta) alpha (ordinal_ordsucc beta (ordinal_Hered alpha Ha beta Hb)) Ha.
- assume H1: ordsucc beta :e alpha. apply ordsuccI1. exact H1.
- assume H1: alpha c= ordsucc beta.
  claim L2: ordsucc beta = alpha.
  { apply set_ext.
    - exact L1.
    - exact H1.
  }
  rewrite L2. apply ordsuccI2.
Qed.

Theorem ordinal_famunion : forall X, forall F:set -> set, (forall x :e X, ordinal (F x)) -> ordinal (\/_ x :e X, F x).
let X F. assume HXF.
prove TransSet (\/_ x :e X, F x) /\ forall y :e (\/_ x :e X, F x), TransSet y.
apply andI.
- let y. assume Hy: y :e \/_ x :e X, F x.
  apply famunionE X F y Hy.
  let x. assume H1. apply H1.
  assume Hx: x :e X.
  assume Hy: y :e F x.
  prove y c= \/_ x :e X, F x.
  claim LFx: ordinal (F x).
  { exact HXF x Hx. }
  apply LFx. assume HFx1 _.
  let z. assume Hz: z :e y.
  prove z :e \/_ x :e X, F x.
  claim LzFx: z :e F x.
  { exact HFx1 y Hy z Hz. }
  exact famunionI X F x z Hx LzFx.
- let y. assume Hy: y :e \/_ x :e X, F x.
  prove TransSet y.
  apply famunionE X F y Hy.
  let x. assume H1. apply H1.
  assume Hx: x :e X.
  assume Hy: y :e F x.
  claim LFx: ordinal (F x).
  { exact HXF x Hx. }
  claim Ly: ordinal y.
  { exact ordinal_Hered (F x) LFx y Hy. }
  apply Ly. assume Hy1 _. exact Hy1.
Qed.

Theorem ordinal_binintersect : forall alpha beta, ordinal alpha -> ordinal beta -> ordinal (alpha :/\: beta).
let alpha beta. assume Ha Hb.
apply Ha. assume Ha1 _.
apply Hb. assume Hb1 _.
apply ordinal_In_Or_Subq alpha beta Ha Hb.
- assume H1: alpha :e beta.
  rewrite binintersect_Subq_eq_1 alpha beta (Hb1 alpha H1).
  exact Ha.
- assume H1: beta c= alpha.
  rewrite binintersect_com.
  rewrite binintersect_Subq_eq_1 beta alpha H1.
  exact Hb.
Qed.

Theorem ordinal_binunion : forall alpha beta, ordinal alpha -> ordinal beta -> ordinal (alpha :\/: beta).
let alpha beta. assume Ha Hb.
apply Ha. assume Ha1 _.
apply Hb. assume Hb1 _.
apply ordinal_linear alpha beta Ha Hb.
- rewrite Subq_binunion_eq.
  assume H1: alpha :\/: beta = beta.
  rewrite H1.
  exact Hb.
- rewrite Subq_binunion_eq. rewrite binunion_com.
  assume H1: alpha :\/: beta = alpha.
  rewrite H1.
  exact Ha.
Qed.

Theorem ordinal_ind : forall p:set->prop, 
(forall alpha, ordinal alpha -> (forall beta :e alpha, p beta) -> p alpha)
->
forall alpha, ordinal alpha -> p alpha.
let p.
assume H1: forall alpha, ordinal alpha -> (forall beta :e alpha, p beta) -> p alpha.
apply In_ind.
let alpha.
assume IH: forall beta :e alpha, ordinal beta -> p beta.
assume H2: ordinal alpha.
prove p alpha.
apply (H1 alpha H2).
let beta.
assume H3: beta :e alpha.
prove p beta.
apply (IH beta H3).
prove ordinal beta.
exact (ordinal_Hered alpha H2 beta H3).
Qed.

Theorem least_ordinal_ex : forall p:set -> prop, (exists alpha, ordinal alpha /\ p alpha) -> exists alpha, ordinal alpha /\ p alpha /\ forall beta :e alpha, ~p beta.
let p. assume H1.
apply dneg.
assume H2: ~exists alpha, ordinal alpha /\ p alpha /\ forall beta :e alpha, ~p beta.
claim L1: forall alpha, ordinal alpha -> ~p alpha.
{ apply ordinal_ind.
  let alpha. assume Ha.
  assume IH: forall beta :e alpha, ~p beta.
  assume H3: p alpha.
  apply H2.
  witness alpha. apply and3I.
  - exact Ha.
  - exact H3.
  - exact IH.
}
apply H1.
let alpha. assume H1a. apply H1a.
assume Ha: ordinal alpha.
assume Hp: p alpha.
exact L1 alpha Ha Hp.
Qed.

Theorem equip_Sing_1 : forall x, equip {x} 1.
let x. 
prove exists f:set->set, bij {x} 1 f.
witness (fun _:set => 0).
apply bijI {x} 1 (fun _ => 0).
- let y. assume _. prove 0 :e 1. exact In_0_1.
- let y. assume Hy. let z. assume Hz _.
  prove y = z.
  rewrite SingE x z Hz.
  prove y = x.
  exact SingE x y Hy.
- let w. assume Hw: w :e 1.
  prove exists y :e {x}, 0 = w.
  witness x. apply andI.
  + apply SingI.
  + prove 0 = w. apply cases_1 w Hw (fun w => 0 = w).
    prove 0 = 0. reflexivity.
Qed.

Theorem TransSet_In_ordsucc_Subq : forall x y, TransSet y -> x :e ordsucc y -> x c= y.
let x y. assume H1 H2. apply ordsuccE y x H2.
- assume H3: x :e y. exact H1 x H3.
- assume H3: x = y. rewrite H3. apply Subq_ref.
Qed.

Theorem exandE_i : forall P Q:set -> prop, (exists x, P x /\ Q x) -> forall r:prop, (forall x, P x -> Q x -> r) -> r.
let P Q. assume H1. let r. assume Hr.
apply H1. let x. assume H2. apply H2. exact Hr x.
Qed.

Theorem exandE_ii : forall P Q:(set -> set) -> prop, (exists x:set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set, P x -> Q x -> p) -> p.
let P Q. assume H. let p. assume Hp.
apply H. let x. assume H0.
apply H0.
assume H1 H2. exact Hp x H1 H2.
Qed.

Theorem exandE_iii : forall P Q:(set -> set -> set) -> prop, (exists x:set -> set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> set, P x -> Q x -> p) -> p.
let P Q. assume H. let p. assume Hp.
apply H. let x. assume H0.
apply H0.
assume H1 H2. exact Hp x H1 H2.
Qed.

Theorem exandE_iiii : forall P Q:(set -> set -> set -> set) -> prop, (exists x:set -> set -> set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> set -> set, P x -> Q x -> p) -> p.
let P Q. assume H. let p. assume Hp.
apply H. let x. assume H0.
apply H0.
assume H1 H2. exact Hp x H1 H2.
Qed.

Section Descr_ii.
Variable P : (set -> set) -> prop.
(* Parameter Descr_ii "a6e81668bfd1db6e6eb6a13bf66094509af176d9d0daccda274aa6582f6dcd7c" "3bae39e9880bbf5d70538d82bbb05caf44c2c11484d80d06dee0589d6f75178c" *)
Definition Descr_ii : set -> set := fun x:set => Eps_i (fun y => forall h:set -> set, P h -> h x = y).
Hypothesis Pex: exists f:set -> set, P f.
Hypothesis Puniq: forall f g:set -> set, P f -> P g -> f = g.

Theorem Descr_ii_prop : P Descr_ii.
apply Pex.
let f. assume Hf: P f.
claim L1: f = Descr_ii.
{ apply func_ext set set.
  let x.
  prove f x = Descr_ii x.
  prove f x = Eps_i (fun y => forall h:set -> set, P h -> h x = y).
  claim L2: forall h:set -> set, P h -> h x = f x.
  { let h. assume Hh. rewrite Puniq f h Hf Hh. exact (fun q H => H). }
  claim L3: forall h:set -> set, P h -> h x = Descr_ii x.
  { exact Eps_i_ax (fun y => forall h:set -> set, P h -> h x = y) (f x) L2. }
  exact L3 f Hf.
}
rewrite <- L1. exact Hf.
Qed.

End Descr_ii.
Section Descr_iii.
Variable P : (set -> set -> set) -> prop.
(* Parameter Descr_iii "dc42f3fe5d0c55512ef81fe5d2ad0ff27c1052a6814b1b27f5a5dcb6d86240bf" "ca5fc17a582fdd4350456951ccbb37275637ba6c06694213083ed9434fe3d545" *)
Definition Descr_iii : set -> set -> set := fun x y:set => Eps_i (fun z => forall h:set -> set -> set, P h -> h x y = z).
Hypothesis Pex: exists f:set -> set -> set, P f.
Hypothesis Puniq: forall f g:set -> set -> set, P f -> P g -> f = g.

Theorem Descr_iii_prop : P Descr_iii.
apply Pex.
let f. assume Hf: P f.
claim L1: f = Descr_iii.
{ apply func_ext set (set -> set).
  let x.
  apply func_ext set set.
  let y.
  prove f x y = Descr_iii x y.
  prove f x y = Eps_i (fun z => forall h:set -> set -> set, P h -> h x y = z).
  claim L2: forall h:set -> set -> set, P h -> h x y = f x y.
  { let h. assume Hh. rewrite Puniq f h Hf Hh. exact (fun q H => H). }
  claim L3: forall h:set -> set -> set, P h -> h x y = Descr_iii x y.
  { exact Eps_i_ax (fun z => forall h:set -> set -> set, P h -> h x y = z) (f x y) L2. }
  exact L3 f Hf.
}
rewrite <- L1. exact Hf.
Qed.

End Descr_iii.
Section Descr_Vo1.
Variable P : Vo 1 -> prop.
(* Parameter Descr_Vo1 "322bf09a1711d51a4512e112e1767cb2616a7708dc89d7312c8064cfee6e3315" "615c0ac7fca2b62596ed34285f29a77b39225d1deed75d43b7ae87c33ba37083" *)
Definition Descr_Vo1 : Vo 1 := fun x:set => forall h:set -> prop, P h -> h x.
Hypothesis Pex: exists f:Vo 1, P f.
Hypothesis Puniq: forall f g:Vo 1, P f -> P g -> f = g.

Theorem Descr_Vo1_prop : P Descr_Vo1.
apply Pex.
let f. assume Hf: P f.
claim L1: f = Descr_Vo1.
{ apply func_ext set prop.
  let x.
  prove f x = Descr_Vo1 x.
  apply prop_ext_2.
  - assume H1: f x. let h. assume Hh: P h. prove h x.
    rewrite <- Puniq f h Hf Hh. exact H1.
  - assume H1: Descr_Vo1 x.
    exact H1 f Hf.
}
rewrite <- L1. exact Hf.
Qed.

End Descr_Vo1.
Section If_ii.
Variable p:prop.
Variable f g:set -> set.
(* Parameter If_ii "e76df3235104afd8b513a92c00d3cc56d71dd961510bf955a508d9c2713c3f29" "17057f3db7be61b4e6bd237e7b37125096af29c45cb784bb9cc29b1d52333779" *)
Definition If_ii : set -> set := fun x => if p then f x else g x.

Theorem If_ii_1 : p -> If_ii = f.
assume H1. apply func_ext set set.
let x.
prove If_ii x = f x.
exact If_i_1 p (f x) (g x) H1.
Qed.

Theorem If_ii_0 : ~p -> If_ii = g.
assume H1. apply func_ext set set.
let x.
prove If_ii x = g x.
exact If_i_0 p (f x) (g x) H1.
Qed.

End If_ii.
Section If_iii.
Variable p:prop.
Variable f g:set -> set -> set.
(* Parameter If_iii "53034f33cbed012c3c6db42812d3964f65a258627a765f5bede719198af1d1ca" "3314762dce5a2e94b7e9e468173b047dd4a9fac6ee2c5f553c6ea15e9c8b7542" *)
Definition If_iii : set -> set -> set := fun x y => if p then f x y else g x y.

Theorem If_iii_1 : p -> If_iii = f.
assume H1.
apply func_ext set (set -> set).
let x.
apply func_ext set set.
let y.
prove If_iii x y = f x y.
exact If_i_1 p (f x y) (g x y) H1.
Qed.

Theorem If_iii_0 : ~p -> If_iii = g.
assume H1.
apply func_ext set (set -> set).
let x.
apply func_ext set set.
let y.
prove If_iii x y = g x y.
exact If_i_0 p (f x y) (g x y) H1.
Qed.

End If_iii.
Section EpsilonRec_i.
Variable F:set -> (set -> set) -> set.
Definition In_rec_i_G : set -> set -> prop :=
fun X Y =>
forall R:set->set->prop,
(forall X:set, forall f:set->set, (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_i "f97da687c51f5a332ff57562bd465232bc70c9165b0afe0a54e6440fc4962a9f" "fac413e747a57408ad38b3855d3cde8673f86206e95ccdadff2b5babaf0c219e" *)
Definition In_rec_i : set -> set := fun X => Eps_i (In_rec_i_G X).

Theorem In_rec_i_G_c : forall X:set, forall f:set->set, (forall x :e X, In_rec_i_G x (f x)) -> In_rec_i_G X (F X f).
let X:set.
let f:set->set.
assume H1: forall x :e X, In_rec_i_G x (f x).
prove In_rec_i_G X (F X f).
let R:set->set->prop.
assume H2: forall X:set, forall f:set->set, (forall x :e X, R x (f x)) -> R X (F X f).
prove R X (F X f).
apply (H2 X f).
prove forall x :e X, R x (f x).
let x:set.
assume H3: x :e X.
prove R x (f x).
exact (H1 x H3 R H2).
Qed.

Theorem In_rec_i_G_inv : forall X:set, forall Y:set, In_rec_i_G X Y -> exists f:set->set, (forall x :e X, In_rec_i_G x (f x)) /\ Y = F X f.
let X Y.
assume H1: In_rec_i_G X Y.
set R := (fun X:set => fun Y:set => exists f:set->set, (forall x :e X, In_rec_i_G x (f x)) /\ Y = F X f).
apply (H1 R).
prove forall Z:set, forall g:set->set, (forall z :e Z, R z (g z)) -> R Z (F Z g).
let Z g.
assume IH: forall z :e Z, exists f:set->set, (forall x :e z, In_rec_i_G x (f x)) /\ g z = F z f.
prove exists f:set->set, (forall x :e Z, In_rec_i_G x (f x)) /\ F Z g = F Z f.
witness g. apply andI.
- let z.
  assume H2: z :e Z.
  apply (exandE_ii (fun f => forall x :e z, In_rec_i_G x (f x)) (fun f => g z = F z f) (IH z H2)).
  let f:set->set.
  assume H3: forall x :e z, In_rec_i_G x (f x).
  assume H4: g z = F z f.
  prove In_rec_i_G z (g z).
  rewrite H4.
  prove In_rec_i_G z (F z f).
  exact (In_rec_i_G_c z f H3).
- reflexivity.
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> set, (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_i_G_f : forall X:set, forall Y Z:set, In_rec_i_G X Y -> In_rec_i_G X Z -> Y = Z.
apply In_ind.
let X.
assume IH: forall x :e X, forall y z:set, In_rec_i_G x y -> In_rec_i_G x z -> y = z.
let Y Z.
assume H1: In_rec_i_G X Y.
assume H2: In_rec_i_G X Z.
prove Y = Z.
claim L1: exists f:set->set, (forall x :e X, In_rec_i_G x (f x)) /\ Y = F X f.
{ exact (In_rec_i_G_inv X Y H1). }
claim L2: exists f:set->set, (forall x :e X, In_rec_i_G x (f x)) /\ Z = F X f.
{ exact (In_rec_i_G_inv X Z H2). }
apply (exandE_ii (fun f => forall x :e X, In_rec_i_G x (f x)) (fun f => Y = F X f) L1).
let g.
assume H3: forall x :e X, In_rec_i_G x (g x).
assume H4: Y = F X g.
apply (exandE_ii (fun f => forall x :e X, In_rec_i_G x (f x)) (fun f => Z = F X f) L2).
let h.
assume H5: forall x :e X, In_rec_i_G x (h x).
assume H6: Z = F X h.
prove Y = Z.
rewrite H4.
rewrite H6.
prove F X g = F X h.
apply Fr.
prove forall x :e X, g x = h x.
let x.
assume H7: x :e X.
exact (IH x H7 (g x) (h x) (H3 x H7) (H5 x H7)).
Qed.

Theorem In_rec_i_G_In_rec_i : forall X:set, In_rec_i_G X (In_rec_i X).
apply In_ind.
let X.
assume IH: forall x :e X, In_rec_i_G x (In_rec_i x).
prove In_rec_i_G X (In_rec_i X).
prove In_rec_i_G X (Eps_i (In_rec_i_G X)).
apply (Eps_i_ax (In_rec_i_G X) (F X In_rec_i)).
prove In_rec_i_G X (F X In_rec_i).
exact (In_rec_i_G_c X In_rec_i IH).
Qed.

Theorem In_rec_i_G_In_rec_i_d : forall X:set, In_rec_i_G X (F X In_rec_i).
let X R.
assume H1: forall X:set, forall f:set->set, (forall x :e X, R x (f x)) -> R X (F X f).
apply (H1 X In_rec_i).
let x. assume _.
exact (In_rec_i_G_In_rec_i x R H1).
Qed.

Theorem In_rec_i_eq : forall X:set, In_rec_i X = F X In_rec_i.
exact (fun X : set => In_rec_i_G_f X (In_rec_i X) (F X In_rec_i) (In_rec_i_G_In_rec_i X) (In_rec_i_G_In_rec_i_d X)).
Qed.

End EpsilonRec_i.
Section EpsilonRec_ii.
Variable F:set -> (set -> (set -> set)) -> (set -> set).
Definition In_rec_G_ii : set -> (set -> set) -> prop :=
fun X Y =>
forall R:set->(set -> set)->prop,
(forall X:set, forall f:set->(set -> set), (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_ii "4d137cad40b107eb0fc2c707372525f1279575e6cadb4ebc129108161af3cedb" "f3c9abbc5074c0d68e744893a170de526469426a5e95400ae7fc81f74f412f7e" *)
Definition In_rec_ii : set -> (set -> set) := fun X => Descr_ii (In_rec_G_ii X).

Theorem In_rec_G_ii_c : forall X:set, forall f:set->(set -> set), (forall x :e X, In_rec_G_ii x (f x)) -> In_rec_G_ii X (F X f).
let X:set.
let f:set->(set -> set).
assume H1: forall x :e X, In_rec_G_ii x (f x).
prove In_rec_G_ii X (F X f).
let R:set->(set -> set)->prop.
assume H2: forall X:set, forall f:set->(set -> set), (forall x :e X, R x (f x)) -> R X (F X f).
prove R X (F X f).
apply (H2 X f).
prove forall x :e X, R x (f x).
let x:set.
assume H3: x :e X.
prove R x (f x).
exact (H1 x H3 R H2).
Qed.

Theorem In_rec_G_ii_inv : forall X:set, forall Y:(set -> set), In_rec_G_ii X Y -> exists f:set->(set -> set), (forall x :e X, In_rec_G_ii x (f x)) /\ Y = F X f.
let X Y.
assume H1: In_rec_G_ii X Y.
set R := (fun X:set => fun Y:(set -> set) => exists f:set->(set -> set), (forall x :e X, In_rec_G_ii x (f x)) /\ Y = F X f).
apply (H1 R).
prove forall Z:set, forall g:set->(set -> set), (forall z :e Z, R z (g z)) -> R Z (F Z g).
let Z g.
assume IH: forall z :e Z, exists f:set->(set -> set), (forall x :e z, In_rec_G_ii x (f x)) /\ g z = F z f.
prove exists f:set->(set -> set), (forall x :e Z, In_rec_G_ii x (f x)) /\ F Z g = F Z f.
witness g. apply andI.
- let z.
  assume H2: z :e Z.
  apply (exandE_iii (fun f => forall x :e z, In_rec_G_ii x (f x)) (fun f => g z = F z f) (IH z H2)).
  let f:set->(set -> set).
  assume H3: forall x :e z, In_rec_G_ii x (f x).
  assume H4: g z = F z f.
  prove In_rec_G_ii z (g z).
  rewrite H4.
  prove In_rec_G_ii z (F z f).
  exact (In_rec_G_ii_c z f H3).
- exact (fun q H => H).
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> (set -> set), (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_G_ii_f : forall X:set, forall Y Z:(set -> set), In_rec_G_ii X Y -> In_rec_G_ii X Z -> Y = Z.
apply In_ind.
let X.
assume IH: forall x :e X, forall y z:(set -> set), In_rec_G_ii x y -> In_rec_G_ii x z -> y = z.
let Y Z.
assume H1: In_rec_G_ii X Y.
assume H2: In_rec_G_ii X Z.
prove Y = Z.
claim L1: exists f:set->(set -> set), (forall x :e X, In_rec_G_ii x (f x)) /\ Y = F X f.
{ exact (In_rec_G_ii_inv X Y H1). }
claim L2: exists f:set->(set -> set), (forall x :e X, In_rec_G_ii x (f x)) /\ Z = F X f.
{ exact (In_rec_G_ii_inv X Z H2). }
apply (exandE_iii (fun f => forall x :e X, In_rec_G_ii x (f x)) (fun f => Y = F X f) L1).
let g.
assume H3: forall x :e X, In_rec_G_ii x (g x).
assume H4: Y = F X g.
apply (exandE_iii (fun f => forall x :e X, In_rec_G_ii x (f x)) (fun f => Z = F X f) L2).
let h.
assume H5: forall x :e X, In_rec_G_ii x (h x).
assume H6: Z = F X h.
prove Y = Z.
rewrite H4.
rewrite H6.
prove F X g = F X h.
apply Fr.
prove forall x :e X, g x = h x.
let x.
assume H7: x :e X.
exact (IH x H7 (g x) (h x) (H3 x H7) (H5 x H7)).
Qed.

Theorem In_rec_G_ii_In_rec_ii : forall X:set, In_rec_G_ii X (In_rec_ii X).
apply In_ind.
let X.
assume IH: forall x :e X, In_rec_G_ii x (In_rec_ii x).
prove In_rec_G_ii X (In_rec_ii X).
prove In_rec_G_ii X (Descr_ii (In_rec_G_ii X)).
apply (Descr_ii_prop (In_rec_G_ii X)).
- witness (F X In_rec_ii).
  prove In_rec_G_ii X (F X In_rec_ii).
  exact (In_rec_G_ii_c X In_rec_ii IH).
- exact In_rec_G_ii_f X.
Qed.

Theorem In_rec_G_ii_In_rec_ii_d : forall X:set, In_rec_G_ii X (F X In_rec_ii).
let X R.
assume H1: forall X:set, forall f:set->(set -> set), (forall x :e X, R x (f x)) -> R X (F X f).
apply (H1 X In_rec_ii).
let x. assume _.
exact (In_rec_G_ii_In_rec_ii x R H1).
Qed.

Theorem In_rec_ii_eq : forall X:set, In_rec_ii X = F X In_rec_ii.
exact (fun X : set => In_rec_G_ii_f X (In_rec_ii X) (F X In_rec_ii) (In_rec_G_ii_In_rec_ii X) (In_rec_G_ii_In_rec_ii_d X)).
Qed.

End EpsilonRec_ii.
Section EpsilonRec_iii.
Variable F:set -> (set -> (set -> set -> set)) -> (set -> set -> set).
Definition In_rec_G_iii : set -> (set -> set -> set) -> prop :=
fun X Y =>
forall R:set->(set -> set -> set)->prop,
(forall X:set, forall f:set->(set -> set -> set), (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_iii "222f1b8dcfb0d2e33cc4b232e87cbcdfe5c4a2bdc5326011eb70c6c9aeefa556" "9b3a85b85e8269209d0ca8bf18ef658e56f967161bf5b7da5e193d24d345dd06" *)
Definition In_rec_iii : set -> (set -> set -> set) := fun X => Descr_iii (In_rec_G_iii X).

Theorem In_rec_G_iii_c : forall X:set, forall f:set->(set -> set -> set), (forall x :e X, In_rec_G_iii x (f x)) -> In_rec_G_iii X (F X f).
let X:set.
let f:set->(set -> set -> set).
assume H1: forall x :e X, In_rec_G_iii x (f x).
prove In_rec_G_iii X (F X f).
let R:set->(set -> set -> set)->prop.
assume H2: forall X:set, forall f:set->(set -> set -> set), (forall x :e X, R x (f x)) -> R X (F X f).
prove R X (F X f).
apply (H2 X f).
prove forall x :e X, R x (f x).
let x:set.
assume H3: x :e X.
prove R x (f x).
exact (H1 x H3 R H2).
Qed.

Theorem In_rec_G_iii_inv : forall X:set, forall Y:(set -> set -> set), In_rec_G_iii X Y -> exists f:set->(set -> set -> set), (forall x :e X, In_rec_G_iii x (f x)) /\ Y = F X f.
let X Y.
assume H1: In_rec_G_iii X Y.
set R := (fun X:set => fun Y:(set -> set -> set) => exists f:set->(set -> set -> set), (forall x :e X, In_rec_G_iii x (f x)) /\ Y = F X f).
apply (H1 R).
prove forall Z:set, forall g:set->(set -> set -> set), (forall z :e Z, R z (g z)) -> R Z (F Z g).
let Z g.
assume IH: forall z :e Z, exists f:set->(set -> set -> set), (forall x :e z, In_rec_G_iii x (f x)) /\ g z = F z f.
prove exists f:set->(set -> set -> set), (forall x :e Z, In_rec_G_iii x (f x)) /\ F Z g = F Z f.
witness g. apply andI.
- let z.
  assume H2: z :e Z.
  apply (exandE_iiii (fun f => forall x :e z, In_rec_G_iii x (f x)) (fun f => g z = F z f) (IH z H2)).
  let f:set->(set -> set -> set).
  assume H3: forall x :e z, In_rec_G_iii x (f x).
  assume H4: g z = F z f.
  prove In_rec_G_iii z (g z).
  rewrite H4.
  prove In_rec_G_iii z (F z f).
  exact (In_rec_G_iii_c z f H3).
- exact (fun q H => H).
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> (set -> set -> set), (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_G_iii_f : forall X:set, forall Y Z:(set -> set -> set), In_rec_G_iii X Y -> In_rec_G_iii X Z -> Y = Z.
apply In_ind.
let X.
assume IH: forall x :e X, forall y z:(set -> set -> set), In_rec_G_iii x y -> In_rec_G_iii x z -> y = z.
let Y Z.
assume H1: In_rec_G_iii X Y.
assume H2: In_rec_G_iii X Z.
prove Y = Z.
claim L1: exists f:set->(set -> set -> set), (forall x :e X, In_rec_G_iii x (f x)) /\ Y = F X f.
{ exact (In_rec_G_iii_inv X Y H1). }
claim L2: exists f:set->(set -> set -> set), (forall x :e X, In_rec_G_iii x (f x)) /\ Z = F X f.
{ exact (In_rec_G_iii_inv X Z H2). }
apply (exandE_iiii (fun f => forall x :e X, In_rec_G_iii x (f x)) (fun f => Y = F X f) L1).
let g.
assume H3: forall x :e X, In_rec_G_iii x (g x).
assume H4: Y = F X g.
apply (exandE_iiii (fun f => forall x :e X, In_rec_G_iii x (f x)) (fun f => Z = F X f) L2).
let h.
assume H5: forall x :e X, In_rec_G_iii x (h x).
assume H6: Z = F X h.
prove Y = Z.
rewrite H4.
rewrite H6.
prove F X g = F X h.
apply Fr.
prove forall x :e X, g x = h x.
let x.
assume H7: x :e X.
exact (IH x H7 (g x) (h x) (H3 x H7) (H5 x H7)).
Qed.

Theorem In_rec_G_iii_In_rec_iii : forall X:set, In_rec_G_iii X (In_rec_iii X).
apply In_ind.
let X.
assume IH: forall x :e X, In_rec_G_iii x (In_rec_iii x).
prove In_rec_G_iii X (In_rec_iii X).
prove In_rec_G_iii X (Descr_iii (In_rec_G_iii X)).
apply (Descr_iii_prop (In_rec_G_iii X)).
- witness (F X In_rec_iii).
  prove In_rec_G_iii X (F X In_rec_iii).
  exact (In_rec_G_iii_c X In_rec_iii IH).
- exact In_rec_G_iii_f X.
Qed.

Theorem In_rec_G_iii_In_rec_iii_d : forall X:set, In_rec_G_iii X (F X In_rec_iii).
let X R.
assume H1: forall X:set, forall f:set->(set -> set -> set), (forall x :e X, R x (f x)) -> R X (F X f).
apply (H1 X In_rec_iii).
let x. assume _.
exact (In_rec_G_iii_In_rec_iii x R H1).
Qed.

Theorem In_rec_iii_eq : forall X:set, In_rec_iii X = F X In_rec_iii.
exact (fun X : set => In_rec_G_iii_f X (In_rec_iii X) (F X In_rec_iii) (In_rec_G_iii_In_rec_iii X) (In_rec_G_iii_In_rec_iii_d X)).
Qed.

End EpsilonRec_iii.
Section NatRec.
Variable z:set.
Variable f:set->set->set.
Let F : set->(set->set)->set := fun n g => if Union n :e n then f (Union n) (g (Union n)) else z.
Definition nat_primrec : set->set := In_rec_i F.

Theorem nat_primrec_r : forall X:set, forall g h:set -> set, (forall x :e X, g x = h x) -> F X g = F X h.
let X g h.
assume H1: forall x :e X, g x = h x.
prove F X g = F X h.
apply xm (Union X :e X).
- assume H2: (Union X :e X).
  prove (if Union X :e X then f (Union X) (g (Union X)) else z) = (if Union X :e X then f (Union X) (h (Union X)) else z).
  rewrite (H1 (Union X) H2).
  prove (if Union X :e X then f (Union X) (h (Union X)) else z) = (if Union X :e X then f (Union X) (h (Union X)) else z).
  exact (fun q H => H).
- assume H2: ~(Union X :e X).
  prove (if Union X :e X then f (Union X) (g (Union X)) else z) = (if Union X :e X then f (Union X) (h (Union X)) else z).
  claim L1: (if Union X :e X then f (Union X) (g (Union X)) else z) = z.
  { exact (If_i_0 (Union X :e X) (f (Union X) (g (Union X))) z H2). }
  claim L2: (if Union X :e X then f (Union X) (h (Union X)) else z) = z.
  { exact (If_i_0 (Union X :e X) (f (Union X) (h (Union X))) z H2). }
  rewrite L2.
  exact L1.
Qed.

Theorem nat_primrec_0 : nat_primrec 0 = z.
prove (In_rec_i F 0 = z).
rewrite (In_rec_i_eq F nat_primrec_r).
prove F 0 (In_rec_i F) = z.
prove (if Union 0 :e 0 then f (Union 0) (In_rec_i F (Union 0)) else z) = z.
exact (If_i_0 (Union 0 :e 0) (f (Union 0) (In_rec_i F (Union 0))) z (EmptyE (Union 0))).
Qed.

Theorem nat_primrec_S : forall n:set, nat_p n -> nat_primrec (ordsucc n) = f n (nat_primrec n).
let n.
assume Hn: nat_p n.
prove (In_rec_i F (ordsucc n) = f n (In_rec_i F n)).
rewrite (In_rec_i_eq F nat_primrec_r) at 1.
prove F (ordsucc n) (In_rec_i F) = f n (In_rec_i F n).
prove (if Union (ordsucc n) :e ordsucc n then f (Union (ordsucc n)) (In_rec_i F (Union (ordsucc n))) else z) = f n (In_rec_i F n).
rewrite (Union_ordsucc_eq n Hn).
prove (if n :e ordsucc n then f n (In_rec_i F n) else z) = f n (In_rec_i F n).
exact (If_i_1 (n :e ordsucc n) (f n (In_rec_i F n)) z (ordsuccI2 n)).
Qed.

End NatRec.

Section NatAdd.

Definition add_nat : set->set->set := fun n m:set => nat_primrec n (fun _ r => ordsucc r) m.
Infix + 360 right := add_nat.

Theorem add_nat_0R : forall n:set, n + 0 = n.
let n.
exact (nat_primrec_0 n (fun _ r => ordsucc r)).
Qed.

Theorem add_nat_SR : forall n m:set, nat_p m -> n + ordsucc m = ordsucc (n + m).
let n m. assume Hm.
exact (nat_primrec_S n (fun _ r => ordsucc r) m Hm).
Qed.

Theorem add_nat_p : forall n:set, nat_p n -> forall m:set, nat_p m -> nat_p (n + m).
let n.
assume Hn: nat_p n.
apply nat_ind.
- prove nat_p (n+0).
  rewrite (add_nat_0R n).
  prove nat_p n.
  exact Hn.
- let m.
  assume Hm: nat_p m.
  assume IHm: nat_p (n+m).
  prove nat_p (n + ordsucc m).
  rewrite (add_nat_SR n m Hm).
  prove nat_p (ordsucc (n+m)).
  apply nat_ordsucc.
  prove nat_p (n+m).
  exact IHm.
Qed.

Theorem add_nat_1_1_2 : 1 + 1 = 2.
symmetry.
prove ordsucc 1 = 1 + ordsucc 0.
rewrite add_nat_SR 1 0 nat_0.
prove ordsucc 1 = ordsucc (1 + 0).
rewrite add_nat_0R 1.
exact (fun q H => H).
Qed.

Theorem add_nat_asso : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> (n+m)+k = n+(m+k).
let n. assume Hn: nat_p n.
let m. assume Hm: nat_p m.
apply nat_ind.
- prove (n+m)+0 = n+(m+0).
  rewrite add_nat_0R. rewrite add_nat_0R.
  reflexivity.
- let k.
  assume Hk: nat_p k.
  assume IHk: (n+m)+k = n+(m+k).
  prove (n + m) + ordsucc k = n + (m + ordsucc k).
  rewrite (add_nat_SR (n+m) k Hk).
  rewrite (add_nat_SR m k Hk).
  prove ordsucc ((n+m)+k) = n + ordsucc (m+k).
  rewrite add_nat_SR.
  + prove ordsucc ((n+m)+k) = ordsucc (n+(m+k)).
    rewrite IHk.
    reflexivity.
  + prove nat_p (m+k).
    exact add_nat_p m Hm k Hk.
Qed.

Theorem add_nat_0L : forall m:set, nat_p m -> 0+m = m.
apply nat_ind.
- prove 0+0 = 0.
  apply add_nat_0R.
- let m.
  assume Hm: nat_p m.
  assume IHm: 0 + m = m.
  prove 0 + ordsucc m = ordsucc m.
  rewrite (add_nat_SR 0 m Hm).
  prove ordsucc (0 + m) = ordsucc m.
  rewrite IHm.
  reflexivity.
Qed.

Theorem add_nat_SL : forall n:set, nat_p n -> forall m:set, nat_p m -> ordsucc n + m = ordsucc (n+m).
let n.
assume Hn: nat_p n.
apply nat_ind.
- prove ordsucc n + 0 = ordsucc (n+0).
  rewrite add_nat_0R. rewrite add_nat_0R.
  reflexivity.
- let m.
  assume Hm: nat_p m.
  assume IHm: ordsucc n + m = ordsucc (n+m).
  prove ordsucc n + ordsucc m = ordsucc (n + ordsucc m).
  rewrite (add_nat_SR (ordsucc n) m Hm).
  prove ordsucc (ordsucc n + m) = ordsucc (n + ordsucc m).
  rewrite (add_nat_SR n m Hm).
  prove ordsucc (ordsucc n + m) = ordsucc (ordsucc (n + m)).
  rewrite IHm.
  reflexivity.
Qed.

Theorem add_nat_com : forall n:set, nat_p n -> forall m:set, nat_p m -> n + m = m + n.
let n.
assume Hn: nat_p n.
apply nat_ind.
- prove n + 0 = 0 + n.
  rewrite (add_nat_0L n Hn).
  exact (add_nat_0R n).
- let m.
  assume Hm: nat_p m.
  assume IHm: n+m = m+n.
  prove n + ordsucc m = ordsucc m + n.
  rewrite (add_nat_SL m Hm n Hn).
  prove n + ordsucc m = ordsucc (m + n).
  rewrite <- IHm.
  prove n + ordsucc m = ordsucc (n + m).
  exact (add_nat_SR n m Hm).
Qed.

Theorem add_nat_In_R: forall m, nat_p m -> forall k :e m, forall n, nat_p n -> k + n :e m + n.
let m. assume Hm: nat_p m.
let k. assume Hk: k :e m.
apply nat_ind.
- prove k + 0 :e m + 0.
  rewrite add_nat_0R. rewrite add_nat_0R.
  exact Hk.
- let n. assume Hn: nat_p n.
  assume IHn: k + n :e m + n.
  prove k + ordsucc n :e m + ordsucc n.
  rewrite add_nat_SR k n Hn.
  rewrite add_nat_SR m n Hn.
  prove ordsucc (k + n) :e ordsucc (m + n).
  apply ordinal_ordsucc_In (m + n) (nat_p_ordinal (m + n) (add_nat_p m Hm n Hn)) (k + n).
  prove k + n :e m + n.
  exact IHn.
Qed.

Theorem add_nat_In_L: forall n, nat_p n -> forall m, nat_p m -> forall k :e m, n + k :e n + m.
let n. assume Hn. let m. assume Hm. let k. assume Hk: k :e m.
prove n + k :e n + m.
rewrite add_nat_com n Hn k (nat_p_trans m Hm k Hk).
rewrite add_nat_com n Hn m Hm.
exact add_nat_In_R m Hm k Hk n Hn.
Qed.

Theorem add_nat_Subq_R: forall k, nat_p k -> forall m, nat_p m -> k c= m -> forall n, nat_p n -> k + n c= m + n.
let k. assume Hk: nat_p k.
let m. assume Hm: nat_p m.
assume Hkm: k c= m.
let n. assume Hn: nat_p n.
apply ordinal_In_Or_Subq k m (nat_p_ordinal k Hk) (nat_p_ordinal m Hm).
- assume H1: k :e m.
  prove k + n c= m + n.
  apply nat_trans (m + n) (add_nat_p m Hm n Hn).
  prove k + n :e m + n.
  exact add_nat_In_R m Hm k H1 n Hn.
- assume H1: m c= k.
  claim L1: k = m.
  { apply set_ext.
    - exact Hkm.
    - exact H1.
  }
  prove k + n c= m + n.
  rewrite L1.
  apply Subq_ref.
Qed.

Theorem add_nat_Subq_L: forall n, nat_p n -> forall k, nat_p k -> forall m, nat_p m -> k c= m -> n + k c= n + m.
let n. assume Hn: nat_p n.
let k. assume Hk: nat_p k.
let m. assume Hm: nat_p m.
assume Hkm: k c= m.
rewrite add_nat_com n Hn k Hk.
rewrite add_nat_com n Hn m Hm.
exact add_nat_Subq_R k Hk m Hm Hkm n Hn.
Qed.

Theorem add_nat_Subq_R' : forall m, nat_p m -> forall n, nat_p n -> m c= m + n.
let m. assume Hm: nat_p m.
apply nat_ind.
- prove m c= m + 0. rewrite add_nat_0R. apply Subq_ref.
- let n. assume Hn: nat_p n.
  assume IHn: m c= m + n.
  prove m c= m + ordsucc n.
  rewrite add_nat_SR m n Hn.
  prove m c= ordsucc (m + n).
  apply Subq_tra m (m + n) (ordsucc (m + n)) IHn.
  prove m + n c= ordsucc (m + n).
  apply ordsuccI1.
Qed.

Theorem nat_Subq_add_ex: forall n, nat_p n -> forall m, nat_p m -> n c= m -> exists k, nat_p k /\ m = k + n.
apply nat_ind.
- let m. assume Hm Hnm. witness m. apply andI.
  + exact Hm.
  + prove m = m + 0.
    symmetry.
    exact add_nat_0R m.
- let n. assume Hn.
  assume IH: forall m, nat_p m -> n c= m -> exists k, nat_p k /\ m = k + n.
  apply nat_inv_impred.
  + assume Hnm: ordsucc n c= 0. prove False.
    apply EmptyE n. prove n :e 0. apply Hnm. apply ordsuccI2.
  + let m.
    assume Hm: nat_p m.
    assume Hnm: ordsucc n c= ordsucc m.
    claim Lnm: n c= m.
    { apply ordinal_In_Or_Subq m n (nat_p_ordinal m Hm) (nat_p_ordinal n Hn).
      - assume H1: m :e n. prove False.
        apply In_irref (ordsucc m).
        apply Hnm.
        prove ordsucc m :e ordsucc n.
        exact nat_ordsucc_in_ordsucc n Hn m H1.
      - assume H1: n c= m. exact H1.
    }
    apply IH m Hm Lnm.
    let k. assume H. apply H.
    assume Hk: nat_p k.
    assume H1: m = k + n.
    prove exists k, nat_p k /\ ordsucc m = k + ordsucc n.
    witness k. apply andI.
    * exact Hk.
    * prove ordsucc m = k + ordsucc n.
      rewrite add_nat_SR k n Hn.
      prove ordsucc m = ordsucc (k + n).
      f_equal.
      exact H1.
Qed.

Theorem add_nat_cancel_R : forall k, nat_p k -> forall m, nat_p m -> forall n, nat_p n -> k + n = m + n -> k = m.
let k. assume Hk. let m. assume Hm.
apply nat_ind.
- prove k + 0 = m + 0 -> k = m.
  rewrite add_nat_0R. rewrite add_nat_0R.
  assume H1: k = m.
  exact H1.
- let n. assume Hn: nat_p n.
  assume IHn: k + n = m + n -> k = m.
  prove k + ordsucc n = m + ordsucc n -> k = m.
  rewrite add_nat_SR k n Hn.
  rewrite add_nat_SR m n Hn.
  prove ordsucc (k + n) = ordsucc (m + n) -> k = m.
  assume H1: ordsucc (k + n) = ordsucc (m + n).
  prove k = m.
  apply IHn.
  prove k + n = m + n.
  apply ordsucc_inj.
  exact H1.
Qed.

End NatAdd.

Section NatMul.

Infix + 360 right := add_nat.

Definition mul_nat : set->set->set := fun n m:set => nat_primrec 0 (fun _ r => n + r) m.
Infix * 355 right := mul_nat.

Theorem mul_nat_0R : forall n:set, n * 0 = 0.
let n.
exact (nat_primrec_0 0 (fun _ r => n + r)).
Qed.

Theorem mul_nat_SR : forall n m, nat_p m -> n * ordsucc m = n + n * m.
let n m. assume Hm.
exact (nat_primrec_S 0 (fun _ r => n + r) m Hm).
Qed.

Theorem mul_nat_1R: forall n, n * 1 = n.
let n.
rewrite mul_nat_SR n 0 nat_0.
prove n + n * 0 = n.
rewrite mul_nat_0R.
prove n + 0 = n.
apply add_nat_0R.
Qed.

Theorem mul_nat_p : forall n:set, nat_p n -> forall m:set, nat_p m -> nat_p (n * m).
let n.
assume Hn: nat_p n.
apply nat_ind.
- prove nat_p (n*0).
  rewrite (mul_nat_0R n).
  prove nat_p 0.
  exact nat_0.
- let m.
  assume Hm: nat_p m.
  assume IHm: nat_p (n*m).
  prove nat_p (n * ordsucc m).
  rewrite (mul_nat_SR n m Hm).
  prove nat_p (n + n*m).
  exact (add_nat_p n Hn (n*m) IHm).
Qed.

Theorem mul_nat_0L : forall m:set, nat_p m -> 0 * m = 0.
apply nat_ind.
- prove 0 * 0 = 0.
  exact (mul_nat_0R 0).
- let m.
  assume Hm: nat_p m.
  assume IHm: 0 * m = 0.
  prove 0 * ordsucc m = 0.
  rewrite (mul_nat_SR 0 m Hm).
  prove 0 + 0 * m = 0.
  rewrite IHm.
  prove 0 + 0 = 0.
  exact (add_nat_0R 0).
Qed.

Theorem mul_nat_SL : forall n:set, nat_p n -> forall m:set, nat_p m -> ordsucc n * m = n * m + m.
let n.
assume Hn: nat_p n.
apply nat_ind.
- prove ordsucc n * 0 = n * 0 + 0.
  rewrite mul_nat_0R. rewrite mul_nat_0R.
  prove 0 = 0 + 0.
  symmetry.
  exact (add_nat_0R 0).
- let m.
  assume Hm: nat_p m.
  assume IHm: ordsucc n * m = n * m + m.
  prove ordsucc n * ordsucc m = n * ordsucc m + ordsucc m.
  rewrite (mul_nat_SR (ordsucc n) m Hm).
  prove ordsucc n + ordsucc n * m = n * ordsucc m + ordsucc m.
  rewrite IHm.
  prove ordsucc n + (n * m + m) = n * ordsucc m + ordsucc m.
  rewrite add_nat_SL.
  + prove ordsucc (n + (n * m + m)) = n * ordsucc m + ordsucc m.
    rewrite (mul_nat_SR n m Hm).
    prove ordsucc (n + (n * m + m)) = (n + n * m) + ordsucc m.
    rewrite (add_nat_SR (n + n * m) m Hm).
    prove ordsucc (n + (n * m + m)) = ordsucc ((n + n * m) + m).
    rewrite add_nat_asso.
    * reflexivity.
    * exact Hn.
    * exact (mul_nat_p n Hn m Hm).
    * exact Hm.
  + exact Hn.
  + exact (add_nat_p (n*m) (mul_nat_p n Hn m Hm) m Hm).
Qed.

Theorem mul_nat_com : forall n:set, nat_p n -> forall m:set, nat_p m -> n * m = m * n.
let n.
assume Hn: nat_p n.
apply nat_ind.
- prove n * 0 = 0 * n.
  rewrite (mul_nat_0L n Hn).
  exact (mul_nat_0R n).
- let m.
  assume Hm: nat_p m.
  assume IHm: n * m = m * n.
  prove n * ordsucc m = ordsucc m * n.
  rewrite (mul_nat_SR n m Hm).
  prove n + n * m = ordsucc m * n.
  rewrite (mul_nat_SL m Hm n Hn).
  prove n + n * m = m * n + n.
  rewrite IHm.
  prove n + m * n = m * n + n.
  exact (add_nat_com n Hn (m*n) (mul_nat_p m Hm n Hn)).
Qed.

Theorem mul_add_nat_distrL : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> n * (m + k) = n * m + n * k.
let n.
assume Hn: nat_p n.
let m.
assume Hm: nat_p m.
apply nat_ind.
- prove n * (m + 0) = n * m + n * 0.
  rewrite add_nat_0R.
  rewrite mul_nat_0R.
  prove n * m = n * m + 0.
  symmetry.
  exact (add_nat_0R (n*m)).
- let k.
  assume Hk: nat_p k.
  assume IHk: n * (m + k) = n * m + n * k.
  prove n * (m + ordsucc k) = n * m + n * ordsucc k.
  rewrite (add_nat_SR m k Hk).
  prove n * ordsucc (m + k) = n * m + n * ordsucc k.
  rewrite (mul_nat_SR n (m+k) (add_nat_p m Hm k Hk)).
  prove n + n * (m + k) = n * m + n * ordsucc k.
  rewrite IHk.
  prove n + (n * m + n * k) = n * m + n * ordsucc k.
  rewrite (mul_nat_SR n k Hk).
  prove n + (n * m + n * k) = n * m + (n + n * k).
  rewrite <- (add_nat_asso n Hn (n*m) (mul_nat_p n Hn m Hm) (n*k) (mul_nat_p n Hn k Hk)).
  prove (n + n * m) + n * k = n * m + (n + n * k).
  rewrite (add_nat_com n Hn (n*m) (mul_nat_p n Hn m Hm)).
  prove (n * m + n) + n * k = n * m + (n + n * k).
  exact (add_nat_asso (n*m) (mul_nat_p n Hn m Hm) n Hn (n*k) (mul_nat_p n Hn k Hk)).
Qed.

Theorem mul_nat_asso : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> (n*m)*k = n*(m*k).
let n.
assume Hn: nat_p n.
let m.
assume Hm: nat_p m.
apply nat_ind.
- prove (n*m)*0=n*(m*0).
  rewrite mul_nat_0R at 2. rewrite mul_nat_0R at 2.
  exact (mul_nat_0R (n*m)).
- let k.
  assume Hk: nat_p k.
  assume IHk: (n*m)*k = n*(m*k).
  prove (n * m) * ordsucc k = n * (m * ordsucc k).
  rewrite mul_nat_SR.
  + prove n * m + (n * m) * k = n * (m * ordsucc k).
    rewrite mul_nat_SR.
    * { prove n * m + (n * m) * k = n * (m + m * k).
        rewrite mul_add_nat_distrL.
        - prove n * m + (n * m) * k = n * m + n * (m * k).
          rewrite IHk.
          reflexivity.
        - exact Hn.
        - exact Hm.
        - exact (mul_nat_p m Hm k Hk).
      }
    * exact Hk.
  + exact Hk.
Qed.

Theorem mul_nat_Subq_R : forall m n, nat_p m -> nat_p n -> m c= n -> forall k, nat_p k -> m * k c= n * k.
let m n. assume Hm Hn Hmn.
apply nat_ind.
- prove m * 0 c= n * 0.
  rewrite mul_nat_0R.
  rewrite mul_nat_0R.
  apply Subq_ref.
- let k. assume Hk: nat_p k.
  assume IHk: m * k c= n * k.
  prove m * ordsucc k c= n * ordsucc k.
  rewrite mul_nat_SR m k Hk.
  rewrite mul_nat_SR n k Hk.
  prove m + m * k c= n + n * k.
  apply Subq_tra (m + m * k) (m + n * k) (n + n * k).
  + prove m + m * k c= m + n * k.
    apply add_nat_Subq_L m Hm (m * k) (mul_nat_p m Hm k Hk) (n * k) (mul_nat_p n Hn k Hk).
    prove m * k c= n * k.
    exact IHk.
  + prove m + n * k c= n + n * k.
    exact add_nat_Subq_R m Hm n Hn Hmn (n * k) (mul_nat_p n Hn k Hk).
Qed.

Theorem mul_nat_Subq_L : forall m n, nat_p m -> nat_p n -> m c= n -> forall k, nat_p k -> k * m c= k * n.
let m n. assume Hm Hn Hmn.
let k. assume Hk.
rewrite mul_nat_com k Hk m Hm.
rewrite mul_nat_com k Hk n Hn.
exact mul_nat_Subq_R m n Hm Hn Hmn k Hk.
Qed.

Theorem mul_nat_0_or_Subq: forall m, nat_p m -> forall n, nat_p n -> n = 0 \/ m c= m * n.
let m. assume Hm. let n. assume Hn.
apply ordinal_In_Or_Subq n 1 (nat_p_ordinal n Hn) (nat_p_ordinal 1 nat_1).
- assume H1: n :e 1. apply orIL.
  prove n = 0.
  apply cases_1 n H1.
  prove 0 = 0.
  reflexivity.
- assume H1: 1 c= n. apply orIR.
  prove m c= m * n.
  rewrite <- mul_nat_1R m at 1.
  prove m * 1 c= m * n.
  exact mul_nat_Subq_L 1 n nat_1 Hn H1 m Hm.
Qed.

(** If m times n = 0 for naturals m and n, then one must be 0. **)
Theorem mul_nat_0_inv : forall m, nat_p m -> forall n, nat_p n -> m * n = 0 -> m = 0 \/ n = 0.
apply nat_inv_impred.
- prove forall n, nat_p n -> 0 * n = 0 -> 0 = 0 \/ n = 0.
  let n. assume Hn _. apply orIL. reflexivity.
- let m.
  assume Hm: nat_p m.
  apply nat_inv_impred.
  + assume _. apply orIR. reflexivity.
  + let n.
    assume Hn: nat_p n.
    prove ordsucc m * ordsucc n = 0 -> ordsucc m = 0 \/ ordsucc n = 0.
    rewrite mul_nat_SR (ordsucc m) n Hn.
    prove ordsucc m + ordsucc m * n = 0 -> ordsucc m = 0 \/ ordsucc n = 0.
    rewrite add_nat_SL m Hm (ordsucc m * n) (mul_nat_p (ordsucc m) (nat_ordsucc m Hm) n Hn).
    prove ordsucc (m + ordsucc m * n) = 0 -> ordsucc m = 0 \/ ordsucc n = 0.
    assume H1: ordsucc (m + ordsucc m * n) = 0.
    prove False.
    exact neq_ordsucc_0 (m + ordsucc m * n) H1.
Qed.

Theorem mul_nat_0m_1n_In: forall m, nat_p m -> forall n, nat_p n -> 0 :e m -> 1 :e n -> m :e m * n.
apply nat_inv_impred.
- let n. assume _. assume H1: 0 :e 0. prove False. exact EmptyE 0 H1.
- let m.
  assume Hm: nat_p m.
  prove forall n, nat_p n -> 0 :e ordsucc m -> 1 :e n -> ordsucc m :e ordsucc m * n.
  apply nat_inv_impred.
  + assume _.
    assume H1: 1 :e 0.
    prove False.
    exact In_no2cycle 0 1 In_0_1 H1.
  + prove forall n, nat_p n -> 0 :e ordsucc m -> 1 :e ordsucc n -> ordsucc m :e ordsucc m * ordsucc n.
    apply nat_inv_impred.
    * assume _.
      assume H1: 1 :e 1.
      prove False.
      exact In_irref 1 H1.
    * let n.
      assume Hn: nat_p n.
      assume _ _.
      prove ordsucc m :e ordsucc m * ordsucc (ordsucc n).
      rewrite mul_nat_SR (ordsucc m) (ordsucc n) (nat_ordsucc n Hn).
      prove ordsucc m :e ordsucc m + ordsucc m * ordsucc n.
      rewrite <- add_nat_0R (ordsucc m) at 1.
      prove ordsucc m + 0 :e ordsucc m + ordsucc m * ordsucc n.
      apply add_nat_In_L (ordsucc m) (nat_ordsucc m Hm) (ordsucc m * ordsucc n) (mul_nat_p (ordsucc m) (nat_ordsucc m Hm) (ordsucc n) (nat_ordsucc n Hn)) 0.
      prove 0 :e ordsucc m * ordsucc n.
      rewrite mul_nat_SL m Hm (ordsucc n) (nat_ordsucc n Hn).
      prove 0 :e m * ordsucc n + ordsucc n.
      rewrite add_nat_SR (m * ordsucc n) n Hn.
      prove 0 :e ordsucc (m * ordsucc n + n).
      apply nat_0_in_ordsucc.
      prove nat_p (m * ordsucc n + n).
      exact add_nat_p (m * ordsucc n) (mul_nat_p m Hm (ordsucc n) (nat_ordsucc n Hn)) n Hn.
Qed.

Theorem nat_le1_cases: forall m, nat_p m -> m c= 1 -> m = 0 \/ m = 1.
apply nat_inv_impred.
- assume _. apply orIL. reflexivity.
- apply nat_inv_impred.
  + assume _. apply orIR. reflexivity.
  + let m. assume Hm.
    assume H1: ordsucc (ordsucc m) c= 1.
    prove False.
    apply In_irref 1.
    prove 1 :e 1.
    apply H1.
    prove 1 :e ordsucc (ordsucc m).
    apply nat_ordsucc_in_ordsucc (ordsucc m) (nat_ordsucc m Hm).
    prove 0 :e ordsucc m.
    exact nat_0_in_ordsucc m Hm.
Qed.

Definition Pi_nat : (set -> set) -> set -> set := fun f n =>
  nat_primrec 1 (fun i r => r * f i) n.

Theorem Pi_nat_0: forall f:set -> set, Pi_nat f 0 = 1.
let f.
exact nat_primrec_0 1 (fun i r => r * f i).
Qed.

Theorem Pi_nat_S: forall f:set -> set, forall n, nat_p n -> Pi_nat f (ordsucc n) = Pi_nat f n * f n.
let f n. assume Hn.
prove Pi_nat f (ordsucc n) = Pi_nat f n * f n.
exact nat_primrec_S 1 (fun i r => r * f i) n Hn.
Qed.

Theorem Pi_nat_p: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, nat_p (f i))
  -> nat_p (Pi_nat f n).
let f.
apply nat_ind.
- assume _. rewrite Pi_nat_0. exact nat_1.
- let n. assume Hn: nat_p n.
  assume IHn: (forall i :e n, nat_p (f i)) -> nat_p (Pi_nat f n).
  assume Hf: forall i :e ordsucc n, nat_p (f i).
  prove nat_p (Pi_nat f (ordsucc n)).
  rewrite Pi_nat_S f n Hn.
  prove nat_p (Pi_nat f n * f n).
  apply mul_nat_p.
  + apply IHn.
    let i. assume Hi: i :e n.
    prove nat_p (f i).
    apply Hf.
    prove i :e ordsucc n.
    apply ordsuccI1. exact Hi.
  + prove nat_p (f n).
    apply Hf.
    prove n :e ordsucc n. apply ordsuccI2.
Qed.

Theorem Pi_nat_0_inv: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, nat_p (f i))
   -> Pi_nat f n = 0
   -> (exists i :e n, f i = 0).
let f.
apply nat_ind.
- assume _.
  assume H1: Pi_nat f 0 = 0.
  prove False.
  apply neq_1_0.
  prove 1 = 0.
  transitivity Pi_nat f 0.
  + prove 1 = Pi_nat f 0. symmetry. exact Pi_nat_0 f.
  + prove Pi_nat f 0 = 0. exact H1.
- let n. assume Hn: nat_p n.
  assume IHn: (forall i :e n, nat_p (f i)) -> Pi_nat f n = 0 -> exists i :e n, f i = 0.
  assume Hf: forall i :e ordsucc n, nat_p (f i).
  rewrite Pi_nat_S f n Hn.
  assume H1: Pi_nat f n * f n = 0.
  prove exists i :e ordsucc n, f i = 0.
  claim L1: forall i :e n, nat_p (f i).
  { let i. assume Hi. apply Hf. apply ordsuccI1. exact Hi. }
  claim L2: nat_p (f n).
  { apply Hf. apply ordsuccI2. }
  claim L3: nat_p (Pi_nat f n).
  { exact Pi_nat_p f n Hn L1. }
  apply mul_nat_0_inv (Pi_nat f n) L3 (f n) L2 H1.
  + assume H2: Pi_nat f n = 0.
    apply IHn L1 H2.
    let i. assume H. apply H.
    assume Hi: i :e n.
    assume H3: f i = 0.
    witness i. apply andI.
    * prove i :e ordsucc n. apply ordsuccI1. exact Hi.
    * prove f i = 0. exact H3.
  + assume H2: f n = 0.
    witness n. 
    apply andI.
    * prove n :e ordsucc n. apply ordsuccI2.
    * prove f n = 0. exact H2.
Qed.

Definition exp_nat : set->set->set := fun n m:set => nat_primrec 1 (fun _ r => n * r) m.

Infix ^ 342 right := exp_nat.

Theorem exp_nat_0 : forall n, n ^ 0 = 1.
let n.
prove nat_primrec 1 (fun _ r => n * r) 0 = 1.
exact nat_primrec_0 1 (fun _ r => n * r).
Qed.

Theorem exp_nat_S : forall n m, nat_p m -> n ^ (ordsucc m) = n * n ^ m.
let n m. assume Hm.
prove nat_primrec 1 (fun _ r => n * r) (ordsucc m) = n * nat_primrec 1 (fun _ r => n * r) m.
exact nat_primrec_S 1 (fun _ r => n * r) m Hm.
Qed.

Theorem exp_nat_p : forall n, nat_p n -> forall m, nat_p m -> nat_p (n ^ m).
let n. assume Hn. apply nat_ind.
- prove nat_p (n ^ 0).
  rewrite exp_nat_0. exact nat_1.
- let m. assume Hm IHm.
  prove nat_p (n ^ ordsucc m).
  rewrite exp_nat_S n m Hm.
  prove nat_p (n * n ^ m).
  exact mul_nat_p n Hn (n ^ m) IHm.
Qed.

Theorem exp_nat_1 : forall n, n ^ 1 = n.
let n.
rewrite exp_nat_S n 0 nat_0.
prove n * n ^ 0 = n.
rewrite exp_nat_0 n.
prove n * 1 = n.
apply mul_nat_1R.
Qed.

End NatMul.

Section form100_52.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.
Infix ^ 342 right := exp_nat.

Theorem Subq_Sing0_1 : {0} c= 1.
exact (fun x H1 => SingE 0 x H1 (fun s _ : set => x :e ordsucc s) (ordsuccI2 x)).
Qed.

Theorem Subq_1_Sing0 : 1 c= {0}.
let x.
assume H1: x :e 1.
prove x :e {0}.
apply ordsuccE 0 x H1.
- assume H2: x :e 0.
  prove False.
  exact (EmptyE x H2).
- assume H2: x = 0.
  rewrite H2.
  prove 0 :e {0}.
  exact (SingI 0).
Qed.

Theorem eq_1_Sing0 : 1 = {0}.
exact (set_ext 1 (Sing 0) Subq_1_Sing0 Subq_Sing0_1).
Qed.

Theorem Power_0_Sing_0 : Power 0 = {0}.
apply set_ext.
- let X.
  assume H1: X :e Power 0.
  prove X :e {0}.
  claim L1: X = 0.
  {
    apply Empty_Subq_eq.
    exact (PowerE 0 X H1).
  }
  rewrite L1.
  prove 0 :e {0}.
  exact (SingI 0).
- let X.
  assume H1: X :e {0}.
  prove X :e Power 0.
  rewrite (SingE 0 X H1).
  prove 0 :e Power 0.
  exact (Empty_In_Power 0).
Qed.

Theorem equip_finite_Power: forall n, nat_p n -> forall X,
  equip X n -> equip (Power X) (2 ^ n).
apply nat_ind.
- let X.
  assume H1: equip X 0.
  prove equip (Power X) (2 ^ 0).
  rewrite equip_0_Empty X H1.
  rewrite exp_nat_0 2.
  prove equip (Power 0) 1.
  rewrite Power_0_Sing_0. rewrite <- eq_1_Sing0.
  apply equip_ref.
- let n.
  assume Hn.
  assume IHn: forall X, equip X n -> equip (Power X) (2 ^ n).
  let X.
  assume H1: equip X (ordsucc n).
  prove equip (Power X) (2 ^ ordsucc n).
  rewrite exp_nat_S 2 n Hn.
  prove equip (Power X) (2 * 2 ^ n).
  claim L2nN: nat_p (2 ^ n).
  { exact exp_nat_p 2 nat_2 n Hn. }
  claim L2no: ordinal (2 ^ n).
  { exact nat_p_ordinal (2 ^ n) L2nN. }
  rewrite mul_nat_com 2 nat_2 (2 ^ n) L2nN.
  prove equip (Power X) (2 ^ n * 2).
  rewrite <- add_nat_1_1_2 at 2.
  prove equip (Power X) (2 ^ n * (1 + 1)).
  rewrite mul_add_nat_distrL (2 ^ n) L2nN 1 nat_1 1 nat_1.
  rewrite mul_nat_1R (2 ^ n).
  prove equip (Power X) (2 ^ n + 2 ^ n).
  claim L1: exists x, x :e X.
  { apply equip_sym X (ordsucc n) H1.
    let f. assume H. apply H. assume H _. apply H.
    assume Hf: forall i :e ordsucc n, f i :e X.
    assume _.
    witness f n.
    apply Hf. apply ordsuccI2.
  }
  apply L1.
  let x. assume Hx.
  claim L2: equip (X :\: {x}) n.
  { apply equip_ordsucc_remove1.
    - exact Hx.
    - prove equip X (ordsucc n). exact H1.
  }
  claim LIH: equip (Power (X :\: {x})) (2 ^ n).
  { exact IHn (X :\: {x}) L2. }
  apply LIH.
  let f.
  assume Hf: bij (Power (X :\: {x})) (2 ^ n) f.
  apply Hf. assume H. apply H.
  assume Hf1: forall Y :e Power (X :\: {x}), f Y :e 2 ^ n.
  assume Hf2: forall Y Z :e Power (X :\: {x}), f Y = f Z -> Y = Z.
  assume Hf3: forall i :e 2 ^ n, exists Y :e Power (X :\: {x}), f Y = i.
  claim LfN: forall Y :e Power (X :\: {x}), nat_p (f Y).
  { let Y. assume HY. exact nat_p_trans (2 ^ n) L2nN (f Y) (Hf1 Y HY). }
  set g:set->set := fun Y => if x :e Y then 2 ^ n + f (Y :\: {x}) else f Y.
  prove equip (Power X) (2 ^ n + 2 ^ n).
  prove exists g:set->set, bij (Power X) (2 ^ n + 2 ^ n) g.
  witness g.
  prove bij (Power X) (2 ^ n + 2 ^ n) g.
  apply bijI.
  + let Y. assume HY: Y :e Power X.
    apply xm (x :e Y).
    * assume H2: x :e Y.
      claim LYx: Y :\: {x} :e Power (X :\: {x}).
      { apply PowerI.
        prove Y :\: {x} c= X :\: {x}.
        let y. assume Hy. apply setminusE Y {x} y Hy.
        assume Hy1: y :e Y.
        assume Hy2: y /:e {x}.
        apply setminusI.
        - prove y :e X. apply PowerE X Y HY. exact Hy1.
        - prove y /:e {x}. exact Hy2.
      }
      prove (if x :e Y then 2 ^ n + f (Y :\: {x}) else f Y) :e 2 ^ n + 2 ^ n.
      rewrite If_i_1 (x :e Y) (2 ^ n + f (Y :\: {x})) (f Y) H2.
      prove 2 ^ n + f (Y :\: {x}) :e 2 ^ n + 2 ^ n.
      claim LfYx2n: f (Y :\: {x}) :e 2 ^ n.
      { exact Hf1 (Y :\: {x}) LYx. }
      rewrite add_nat_com (2 ^ n) L2nN (f (Y :\: {x})) (nat_p_trans (2 ^ n) L2nN (f (Y :\: {x})) LfYx2n).
      prove f (Y :\: {x}) + 2 ^ n :e 2 ^ n + 2 ^ n.
      exact add_nat_In_R (2 ^ n) L2nN (f (Y :\: {x})) LfYx2n (2 ^ n) L2nN.
    * assume H2: x /:e Y.
      claim LY: Y :e Power (X :\: {x}).
      { apply PowerI.
        prove Y c= X :\: {x}.
        let y. assume Hy.
        apply setminusI.
        - prove y :e X. apply PowerE X Y HY. exact Hy.
        - prove y /:e {x}.
          assume Hy2: y :e {x}.
          apply H2.
          prove x :e Y.
          rewrite <- SingE x y Hy2.
          exact Hy.
      }
      prove (if x :e Y then 2 ^ n + f (Y :\: {x}) else f Y) :e 2 ^ n + 2 ^ n.
      rewrite If_i_0 (x :e Y) (2 ^ n + f (Y :\: {x})) (f Y) H2.
      prove f Y :e 2 ^ n + 2 ^ n.
      apply add_nat_Subq_R' (2 ^ n) L2nN (2 ^ n) L2nN.
      prove f Y :e 2 ^ n.
      exact Hf1 Y LY.
  + let Y. assume HY: Y :e Power X.
    let Z. assume HZ: Z :e Power X.
    prove g Y = g Z -> Y = Z.
    prove (if x :e Y then 2 ^ n + f (Y :\: {x}) else f Y)
        = (if x :e Z then 2 ^ n + f (Z :\: {x}) else f Z)
       -> Y = Z.
    claim LYx: Y :\: {x} :e Power (X :\: {x}).
    { apply PowerI.
      prove Y :\: {x} c= X :\: {x}.
      let y. assume Hy. apply setminusE Y {x} y Hy.
      assume Hy1: y :e Y.
      assume Hy2: y /:e {x}.
      apply setminusI.
      - prove y :e X. apply PowerE X Y HY. exact Hy1.
      - prove y /:e {x}. exact Hy2.
    }
    claim LZx: Z :\: {x} :e Power (X :\: {x}).
    { apply PowerI.
      prove Z :\: {x} c= X :\: {x}.
      let z. assume Hz. apply setminusE Z {x} z Hz.
      assume Hz1: z :e Z.
      assume Hz2: z /:e {x}.
      apply setminusI.
      - prove z :e X. apply PowerE X Z HZ. exact Hz1.
      - prove z /:e {x}. exact Hz2.
    }
    claim LfYx2n: f (Y :\: {x}) :e 2 ^ n.
    { exact Hf1 (Y :\: {x}) LYx. }
    claim LfYxN: nat_p (f (Y :\: {x})).
    { exact nat_p_trans (2 ^ n) L2nN (f (Y :\: {x})) LfYx2n. }
    claim LfZx2n: f (Z :\: {x}) :e 2 ^ n.
    { exact Hf1 (Z :\: {x}) LZx. }
    claim LfZxN: nat_p (f (Z :\: {x})).
    { exact nat_p_trans (2 ^ n) L2nN (f (Z :\: {x})) LfZx2n. }
    apply xm (x :e Y).
    * { assume H2: x :e Y.
        rewrite If_i_1 (x :e Y) (2 ^ n + f (Y :\: {x})) (f Y) H2.
        apply xm (x :e Z).
        - assume H3: x :e Z.
          rewrite If_i_1 (x :e Z) (2 ^ n + f (Z :\: {x})) (f Z) H3.
          assume H4: 2 ^ n + f (Y :\: {x}) = 2 ^ n + f (Z :\: {x}).
          prove Y = Z.
          claim LYxZx: Y :\: {x} = Z :\: {x}.
          { apply Hf2.
            - exact LYx.
            - exact LZx.
            - prove f (Y :\: {x}) = f (Z :\: {x}).
              apply add_nat_cancel_R (f (Y :\: {x})) LfYxN
                                     (f (Z :\: {x})) LfZxN
                                     (2 ^ n) L2nN.
              prove f (Y :\: {x}) + 2 ^ n = f (Z :\: {x}) + 2 ^ n.
              rewrite add_nat_com (f (Y :\: {x})) LfYxN (2 ^ n) L2nN.
              rewrite add_nat_com (f (Z :\: {x})) LfZxN (2 ^ n) L2nN.
              prove 2 ^ n + f (Y :\: {x}) = 2 ^ n + f (Z :\: {x}).
              exact H4.
          }
          apply set_ext.
          + let y. assume Hy: y :e Y.
            apply xm (y :e {x}).
            * assume H5: y :e {x}. rewrite SingE x y H5. exact H3.
            * { assume H5: y /:e {x}.
                apply setminusE1 Z {x}.
                prove y :e Z :\: {x}.
                rewrite <- LYxZx.
                prove y :e Y :\: {x}.
                apply setminusI.
                - exact Hy.
                - exact H5.
              }
          + let z. assume Hz: z :e Z.
            apply xm (z :e {x}).
            * assume H5: z :e {x}. rewrite SingE x z H5. exact H2.
            * { assume H5: z /:e {x}.
                apply setminusE1 Y {x}.
                prove z :e Y :\: {x}.
                rewrite LYxZx.
                prove z :e Z :\: {x}.
                apply setminusI.
                - exact Hz.
                - exact H5.
              }
        - assume H3: x /:e Z.
          claim LZ: Z :e Power (X :\: {x}).
          { apply PowerI.
            prove Z c= X :\: {x}.
            let z. assume Hz.
            apply setminusI.
            - prove z :e X. apply PowerE X Z HZ. exact Hz.
            - prove z /:e {x}.
              assume Hz2: z :e {x}.
              apply H3.
              prove x :e Z.
              rewrite <- SingE x z Hz2.
              exact Hz.
          }
          rewrite If_i_0 (x :e Z) (2 ^ n + f (Z :\: {x})) (f Z) H3.
          assume H4: 2 ^ n + f (Y :\: {x}) = f Z.
          prove False.
          apply In_irref (f Z).
          prove f Z :e f Z.
          rewrite <- H4 at 2.
          prove f Z :e 2 ^ n + f (Y :\: {x}).
          apply add_nat_Subq_R' (2 ^ n) L2nN (f (Y :\: {x})) LfYxN.
          prove f Z :e 2 ^ n.
          exact Hf1 Z LZ.
      }
    * { assume H2: x /:e Y.
        claim LY: Y :e Power (X :\: {x}).
        { apply PowerI.
          prove Y c= X :\: {x}.
          let y. assume Hy.
          apply setminusI.
          - prove y :e X. apply PowerE X Y HY. exact Hy.
          - prove y /:e {x}.
            assume Hy2: y :e {x}.
            apply H2.
            prove x :e Y.
            rewrite <- SingE x y Hy2.
            exact Hy.
        }
        rewrite If_i_0 (x :e Y) (2 ^ n + f (Y :\: {x})) (f Y) H2.
        apply xm (x :e Z).
        - assume H3: x :e Z.
          rewrite If_i_1 (x :e Z) (2 ^ n + f (Z :\: {x})) (f Z) H3.
          assume H4: f Y = 2 ^ n + f (Z :\: {x}).
          prove False.
          apply In_irref (f Y).
          prove f Y :e f Y.
          rewrite H4 at 2.
          prove f Y :e 2 ^ n + f (Z :\: {x}).
          apply add_nat_Subq_R' (2 ^ n) L2nN (f (Z :\: {x})) LfZxN.
          prove f Y :e 2 ^ n.
          exact Hf1 Y LY.
        - assume H3: x /:e Z.
          rewrite If_i_0 (x :e Z) (2 ^ n + f (Z :\: {x})) (f Z) H3.
          assume H4: f Y = f Z.
          prove Y = Z.
          apply Hf2.
          + prove Y :e Power (X :\: {x}).
            apply PowerI.
            let y. assume Hy: y :e Y.
            apply setminusI.
            * prove y :e X. exact PowerE X Y HY y Hy.
            * assume H5: y :e {x}.
              apply H2.
              prove x :e Y.
              rewrite <- SingE x y H5.
              exact Hy.
          + prove Z :e Power (X :\: {x}).
            apply PowerI.
            let z. assume Hz: z :e Z.
            apply setminusI.
            * prove z :e X. exact PowerE X Z HZ z Hz.
            * assume H5: z :e {x}.
              apply H3.
              prove x :e Z.
              rewrite <- SingE x z H5.
              exact Hz.
          + exact H4.
      }
  + let i. assume Hi: i :e 2 ^ n + 2 ^ n.
    prove exists Y :e Power X, g Y = i.
    claim LiN: nat_p i.
    { exact nat_p_trans (2 ^ n + 2 ^ n) (add_nat_p (2 ^ n) L2nN (2 ^ n) L2nN) i Hi. }
    apply ordinal_In_Or_Subq i (2 ^ n) (nat_p_ordinal i LiN) L2no.
    * { assume H2: i :e 2 ^ n.
        apply Hf3 i H2.
        let Y. assume H. apply H.
        assume HY: Y :e Power (X :\: {x}).
        assume HYi: f Y = i.
        witness Y. apply andI.
        - prove Y :e Power X. apply PowerI.
          let y. assume Hy: y :e Y.
          apply setminusE1 X {x} y.
          prove y :e X :\: {x}.
          apply PowerE (X :\: {x}) Y HY.
          prove y :e Y.
          exact Hy.
        - prove g Y = i.
          prove (if x :e Y then 2 ^ n + f (Y :\: {x}) else f Y) = i.
          claim LxnY: x /:e Y.
          { assume H3: x :e Y.
            claim LxXx: x :e X :\: {x}.
            { apply PowerE (X :\: {x}) Y HY. exact H3. }
            apply setminusE2 X {x} x LxXx.
            prove x :e {x}.
            apply SingI.
          }
          rewrite If_i_0 (x :e Y) (2 ^ n + f (Y :\: {x})) (f Y) LxnY.
          exact HYi.
      }
    * { assume H2: 2 ^ n c= i.
        apply nat_Subq_add_ex (2 ^ n) L2nN i LiN H2.
        let k. assume H. apply H.
        assume Hk: nat_p k.
        assume Hik2n: i = k + 2 ^ n.
        claim L3: k :e 2 ^ n.
        { apply ordinal_In_Or_Subq k (2 ^ n) (nat_p_ordinal k Hk) L2no.
          - assume H3: k :e 2 ^ n. exact H3.
          - assume H3: 2 ^ n c= k. prove False.
            apply In_irref i.
            prove i :e i.
            rewrite Hik2n at 2.
            prove i :e k + 2 ^ n.
            apply add_nat_Subq_R (2 ^ n) L2nN k Hk H3 (2 ^ n) L2nN.
            prove i :e 2 ^ n + 2 ^ n.
            exact Hi.
        }
        apply Hf3 k L3.
        let Y. assume H. apply H.
        assume HY: Y :e Power (X :\: {x}).
        assume HYk: f Y = k.
        claim LxnY: x /:e Y.
        { assume H3: x :e Y.
          claim LxXx: x :e X :\: {x}.
          { apply PowerE (X :\: {x}) Y HY. exact H3. }
          apply setminusE2 X {x} x LxXx.
          prove x :e {x}.
          apply SingI.
        }
        claim LxYx: x :e Y :\/: {x}.
        { apply binunionI2. apply SingI. }
        claim LYxxY: (Y :\/: {x}) :\: {x} = Y.
        { apply set_ext.
          - let u.
            assume Hu: u :e (Y :\/: {x}) :\: {x}.
            apply setminusE (Y :\/: {x}) {x} u Hu.
            assume Hu1: u :e Y :\/: {x}.
            assume Hu2: u /:e {x}.
            apply binunionE Y {x} u Hu1.
            + assume HuY: u :e Y. exact HuY.
            + assume Hux: u :e {x}. prove False. exact Hu2 Hux.
          - let y. assume Hy: y :e Y.
            prove y :e (Y :\/: {x}) :\: {x}.
            apply setminusI.
            + apply binunionI1. exact Hy.
            + assume Hyx: y :e {x}.
              apply LxnY.
              prove x :e Y.
              rewrite <- SingE x y Hyx. exact Hy.
        }
        witness (Y :\/: {x}).
        apply andI.
        - prove Y :\/: {x} :e Power X.
          apply PowerI.
          apply binunion_Subq_min.
          + prove Y c= X.
            apply Subq_tra Y (X :\: {x}) X (PowerE (X :\: {x}) Y HY).
            apply setminus_Subq.
          + prove {x} c= X.
            let u. assume Hu: u :e {x}.
            rewrite SingE x u Hu.
            prove x :e X.
            exact Hx.
        - prove g (Y :\/: {x}) = i.
          prove (if x :e Y :\/: {x} then 2 ^ n + f ((Y :\/: {x}) :\: {x}) else f (Y :\/: {x})) = i.
          rewrite If_i_1 (x :e Y :\/: {x}) (2 ^ n + f ((Y :\/: {x}) :\: {x})) (f (Y :\/: {x})) LxYx.
          prove 2 ^ n + f ((Y :\/: {x}) :\: {x}) = i.
          rewrite LYxxY.
          prove 2 ^ n + f Y = i.
          rewrite HYk.
          prove 2 ^ n + k = i.
          rewrite add_nat_com (2 ^ n) L2nN k Hk.
          symmetry.
          exact Hik2n.
      }
Qed.

End form100_52.

Theorem ZF_closed_E : forall U, ZF_closed U ->
 forall p:prop,
 (Union_closed U ->
  Power_closed U ->
  Repl_closed U -> p)
 -> p.
exact (fun U C p v => C p (fun C H3 => C p (fun H1 H2 => v H1 H2 H3))).
Qed.

Theorem ZF_Union_closed : forall U, ZF_closed U ->
  forall X :e U, Union X :e U.
exact (fun U C => ZF_closed_E U C (forall X :e U, Union X :e U) (fun H _ _ => H)).
Qed.

Theorem ZF_Power_closed : forall U, ZF_closed U ->
  forall X :e U, Power X :e U.
exact (fun U C => ZF_closed_E U C (forall X :e U, Power X :e U) (fun _ H _ => H)).
Qed.

Theorem ZF_Repl_closed : forall U, ZF_closed U ->
  forall X :e U, forall F:set->set, (forall x :e X, F x :e U) -> {F x|x:eX} :e U.
exact (fun U C => ZF_closed_E U C (forall X :e U, forall F:set->set, (forall x :e X, F x :e U) -> {F x|x :e X} :e U) (fun _ _ H => H)).
Qed.

Theorem ZF_UPair_closed : forall U, ZF_closed U ->
  forall x y :e U, {x,y} :e U.
let U.
assume C: ZF_closed U.
let x.
assume Hx: x :e U.
let y.
assume Hy: y :e U.
prove {x,y} :e U.
claim L1: {if x :e X then x else y|X :e Power (Power x)} = {x,y}.
{
  apply set_ext.
  - prove {if x :e X then x else y|X :e Power (Power x)} c= {x,y}.
    let z.
    assume Hz: z :e {if x :e X then x else y|X :e Power (Power x)}.
    prove z :e {x,y}.
    apply (ReplE_impred (Power (Power x)) (fun X => if x :e X then x else y) z Hz).
    let X. assume _.
    prove z = (if x :e X then x else y) -> z :e {x,y}.
    apply (xm (x :e X)).
    + assume H2: x :e X.
      rewrite (If_i_1 (x :e X) x y H2).
      prove (z = x -> z :e {x,y}).
      assume H3: z = x.
      rewrite H3.
      exact (UPairI1 x y).
    + assume H2: x /:e X.
      rewrite (If_i_0 (x :e X) x y H2).
      prove (z = y -> z :e {x,y}).
      assume H3: z = y.
      rewrite H3.
      exact (UPairI2 x y).
  - prove {x,y} c= {if x :e X then x else y|X :e Power (Power x)}.
    let z.
    assume Hz : z :e {x,y}.
    prove z :e {if x :e X then x else y|X :e Power (Power x)}.
    claim L1a: (if x :e (Power x) then x else y) :e {if x :e X then x else y|X :e Power (Power x)}.
    {
      apply (ReplI (Power (Power x)) (fun X => if x :e X then x else y) (Power x)).
      prove Power x :e Power (Power x).
      exact (Self_In_Power (Power x)).
    }
    claim L1b: (if x :e Empty then x else y) :e {if x :e X then x else y|X :e Power (Power x)}.
    {
      apply (ReplI (Power (Power x)) (fun X => if x :e X then x else y) Empty).
      prove Empty :e Power (Power x).
      exact (Empty_In_Power (Power x)).
    }
    apply (UPairE z x y Hz).
    + assume H1: z = x.
      rewrite H1.
      prove x :e {if x :e X then x else y|X :e Power (Power x)}.
      rewrite <- (If_i_1 (x :e (Power x)) x y (Self_In_Power x)) at 1.
      exact L1a.
    + assume H1: z = y.
      rewrite H1.
      prove y :e {if x :e X then x else y|X :e Power (Power x)}.
      rewrite <- (If_i_0 (x :e Empty) x y (EmptyE x)) at 1.
      exact L1b.
}
prove {x,y} :e U.
rewrite <- L1.
prove {if x :e X then x else y|X :e Power (Power x)} :e U.
claim L2: Power (Power x) :e U.
{
  exact (ZF_Power_closed U C (Power x) (ZF_Power_closed U C x Hx)).
}
claim L3: forall X :e Power (Power x), (if x :e X then x else y) :e U.
{
  let X. assume _.
  prove (if x :e X then x else y) :e U.
  apply (xm (x :e X)).
  - assume H1: x :e X.
    rewrite (If_i_1 (x :e X) x y H1).
    prove x :e U.
    exact Hx.
  - assume H1: x /:e X.
    rewrite (If_i_0 (x :e X) x y H1).
    prove y :e U.
    exact Hy.
}
exact (ZF_Repl_closed U C (Power (Power x)) L2 (fun X => if x :e X then x else y) L3).
Qed.

Theorem ZF_Sing_closed : forall U, ZF_closed U ->
  forall x :e U, {x} :e U.
exact (fun U C x H => ZF_UPair_closed U C x H x H).
Qed.

Theorem ZF_binunion_closed : forall U, ZF_closed U ->
  forall X Y :e U, (X :\/: Y) :e U.
exact (fun U C X HX Y HY => ZF_Union_closed U C {X,Y} (ZF_UPair_closed U C X HX Y HY)). 
Qed.

Theorem ZF_ordsucc_closed : forall U, ZF_closed U ->
  forall x :e U, ordsucc x :e U.
exact (fun U C x H => ZF_binunion_closed U C x H {x} (ZF_Sing_closed U C x H)).
Qed.

Theorem nat_p_UnivOf_Empty : forall n:set, nat_p n -> n :e UnivOf Empty.
apply nat_ind.
- prove 0 :e UnivOf Empty.
  exact (UnivOf_In Empty).
- let n.
  assume Hn: nat_p n.
  assume IHn: n :e UnivOf Empty.
  prove ordsucc n :e UnivOf Empty.
  exact (ZF_ordsucc_closed (UnivOf Empty) (UnivOf_ZF_closed Empty) n IHn).
Qed.

(* Unicode omega "3c9" *)
(* Parameter omega "39cdf86d83c7136517f803d29d0c748ea45a274ccbf9b8488f9cda3e21f4b47c" "6fc30ac8f2153537e397b9ff2d9c981f80c151a73f96cf9d56ae2ee27dfd1eb2" *)
Definition omega : set := {n :e UnivOf Empty|nat_p n}.

Theorem omega_nat_p : forall n :e omega, nat_p n.
exact (fun n H => SepE2 (UnivOf Empty) nat_p n H).
Qed.

Theorem nat_p_omega : forall n:set, nat_p n -> n :e omega.
let n.
assume H: nat_p n.
prove n :e {n :e UnivOf Empty|nat_p n}.
apply SepI.
- prove n :e UnivOf Empty. exact (nat_p_UnivOf_Empty n H).
- prove nat_p n. exact H.
Qed.

Theorem omega_ordsucc : forall n :e omega, ordsucc n :e omega.
let n. assume Hn.
apply nat_p_omega.
apply nat_ordsucc.
apply omega_nat_p.
exact Hn.
Qed.

Theorem form100_22_v2: forall f:set -> set, ~inj (Power omega) omega f.
exact form100_63_injCantor omega.
Qed.

Theorem form100_22_v3: forall g:set -> set, ~surj omega (Power omega) g.
let g. assume H1. apply H1.
assume H1: forall n :e omega, g n :e Power omega.
assume H2: forall X :e Power omega, exists n :e omega, g n = X.
set D := {n :e omega | n /:e g n}.
claim L1: D :e Power omega.
{ apply PowerI.
  let n. assume Hn: n :e D.
  prove n :e omega.
  exact SepE1 omega (fun n => n /:e g n) n Hn.
}
apply H2 D L1.
let n. assume H3. apply H3.
assume H3: n :e omega.
assume H4: g n = D.
claim L2: n /:e D.
{ assume H5: n :e D.
  apply SepE2 omega (fun n => n /:e g n) n H5.
  prove n :e g n. rewrite H4. exact H5.
}
apply L2. prove n :e D. apply SepI.
- exact H3.
- prove n /:e g n. rewrite H4. exact L2.
Qed.

Theorem form100_22_v1: ~equip omega (Power omega).
assume H1: equip omega (Power omega).
apply H1.
let g. assume H2: bij omega (Power omega) g.
apply form100_22_v3 g.
prove surj omega (Power omega) g.
apply bij_surj. exact H2.
Qed.

Theorem omega_TransSet : TransSet omega.
let n.
assume Hn: n :e omega.
let m.
assume Hm: m :e n.
prove m :e omega.
apply nat_p_omega.
prove nat_p m.
apply (nat_p_trans n).
- prove nat_p n. exact (omega_nat_p n Hn).
- prove m :e n. exact Hm.
Qed.

Theorem omega_ordinal : ordinal omega.
prove TransSet omega /\ forall n :e omega, TransSet n.
apply andI.
- exact omega_TransSet.
- let n.
  assume Hn: n :e omega.
  prove TransSet n.
  apply ordinal_TransSet.
  prove ordinal n.
  apply nat_p_ordinal.
  prove nat_p n.
  exact (omega_nat_p n Hn).
Qed.

Theorem ordsucc_omega_ordinal: ordinal (ordsucc omega).
exact ordinal_ordsucc omega omega_ordinal.
Qed.

Definition finite : set -> prop := fun X => exists n :e omega, equip X n.

Theorem nat_finite: forall n, nat_p n -> finite n.
let n. assume Hn: nat_p n.
prove exists n' :e omega, equip n n'.
witness n. apply andI.
- apply nat_p_omega. exact Hn.
- prove equip n n. apply equip_ref.
Qed.

Theorem finite_ind : forall p:set -> prop,
    p Empty
 -> (forall X y, finite X -> y /:e X -> p X -> p (X :\/: {y}))
 -> forall X, finite X -> p X.
let p. assume H1 H2.
claim L1: forall n, nat_p n -> forall X, equip X n -> p X.
{ apply nat_ind.
  - let X. assume H3: equip X 0.
    rewrite equip_0_Empty X H3. exact H1.
  - let n. assume Hn.
    assume IHn: forall X, equip X n -> p X.
    let X. assume H3: equip X (ordsucc n).
    apply equip_sym X (ordsucc n) H3.
    let f. assume Hf: bij (ordsucc n) X f.
    apply bijE (ordsucc n) X f Hf.
    assume Hf1: forall i :e ordsucc n, f i :e X.
    assume Hf2: forall i j :e ordsucc n, f i = f j -> i = j.
    assume Hf3: forall x :e X, exists i :e ordsucc n, f i = x.
    set Z := {f i|i :e n}.
    set y := f n.
    claim L1a: X = Z :\/: {y}.
    { apply set_ext.
      - let x. assume Hx: x :e X.
        apply Hf3 x Hx.
        let i. assume H. apply H.
        assume Hi: i :e ordsucc n.
        assume H4: f i = x.
        apply ordsuccE n i Hi.
        + assume H5: i :e n.
          apply binunionI1.
          prove x :e Z. rewrite <- H4.
          prove f i :e Z. apply ReplI. exact H5.
        + assume H5: i = n.
          apply binunionI2.
          prove x :e {y}. rewrite <- H4. rewrite H5.
          exact SingI (f n).
      - let x. assume Hx: x :e Z :\/: {y}.
        apply binunionE Z {y} x Hx.
        + assume H4: x :e Z.
          apply ReplE_impred n f x H4.
          let i. assume Hi: i :e n.
          assume H5: x = f i.
          prove x :e X. rewrite H5.
          prove f i :e X.
          exact Hf1 i (ordsuccI1 n i Hi).
        + assume H4: x :e {y}.
          rewrite SingE y x H4.
          prove f n :e X.
          exact Hf1 n (ordsuccI2 n).
    }
    claim L1b: equip Z n.
    { apply equip_sym.
      prove exists f:set -> set, bij n Z f.
      witness f. apply bijI.
      - let i. assume Hi. prove f i :e {f i|i :e n}. apply ReplI. exact Hi.
      - let i. assume Hi. let j. assume Hj.
        apply Hf2.
        + apply ordsuccI1. exact Hi.
        + apply ordsuccI1. exact Hj.
      - apply ReplE'.
        let i. assume Hi: i :e n.
        prove exists i' :e n, f i' = f i.
        witness i. apply andI.
        + exact Hi.
        + reflexivity.
    }
    rewrite L1a.
    prove p (Z :\/: {y}).
    apply H2 Z y.
    + prove finite Z.
      prove exists n :e omega, equip Z n.
      witness n. apply andI.
      * exact nat_p_omega n Hn.
      * exact L1b.
    + prove y /:e Z.
      assume H4: y :e Z.
      apply ReplE_impred n f y H4.
      let i. assume Hi: i :e n.
      assume H5: y = f i.
      apply In_irref n.
      prove n :e n.
      rewrite Hf2 n (ordsuccI2 n) i (ordsuccI1 n i Hi) H5 at 1.
      prove i :e n. exact Hi.
    + prove p Z. exact IHn Z L1b.
}
let X. assume H3. apply H3.
let n. assume H. apply H.
assume Hn: n :e omega.
assume H4: equip X n.
exact L1 n (omega_nat_p n Hn) X H4.
Qed.

Theorem finite_Empty: finite 0.
prove exists n :e omega, equip 0 n.
witness 0. apply andI.
- exact nat_p_omega 0 nat_0.
- apply equip_ref.
Qed.

Theorem Sing_finite: forall x, finite {x}.
let x.
prove exists n :e omega, equip {x} n.
witness 1. apply andI.
- exact nat_p_omega 1 nat_1.
- exact equip_Sing_1 x.
Qed.

Theorem adjoin_finite: forall X y, finite X -> finite (X :\/: {y}).
let X y. assume H1. apply H1.
let n. assume H. apply H.
assume Hn: n :e omega.
assume H2: equip X n.
apply equip_sym X n H2.
let f. assume Hf: bij n X f.
apply bijE n X f Hf.
assume Hf1: forall i :e n, f i :e X.
assume Hf2: forall i j :e n, f i = f j -> i = j.
assume Hf3: forall x :e X, exists i :e n, f i = x.
apply xm (y :e X).
- assume H3: y :e X.
  claim L1: X :\/: {y} = X.
  { apply set_ext.
    - let x. assume Hx. apply binunionE X {y} x Hx.
      + assume H4. exact H4.
      + assume H4: x :e {y}. rewrite SingE y x H4. exact H3.
    - apply binunion_Subq_1.
  }
  rewrite L1.
  exact H1.
- assume H3: y /:e X.
  prove exists m :e omega, equip (X :\/: {y}) m.
  witness ordsucc n. apply andI.
  + apply omega_ordsucc. exact Hn.
  + prove equip (X :\/: {y}) (ordsucc n).
    apply equip_sym.
    prove exists g:set -> set, bij (ordsucc n) (X :\/: {y}) g.
    claim Lg: exists g:set -> set, (forall i :e n, g i = f i) /\ g n = y.
    { witness (fun i : set => if i :e n then f i else y).
      apply andI.
      - let i. assume Hi. exact If_i_1 (i :e n) (f i) y Hi.
      - exact If_i_0 (n :e n) (f n) y (In_irref n).
    }
    apply Lg.
    let g. assume H. apply H.
    assume Hg1 Hg2.
    witness g.
    apply bijI.
    * { prove forall i :e ordsucc n, g i :e X :\/: {y}.
        let i. assume Hi. apply ordsuccE n i Hi.
        - assume H4: i :e n. apply binunionI1. rewrite Hg1 i H4.
          prove f i :e X. exact Hf1 i H4.
        - assume H4: i = n. apply binunionI2. rewrite H4. rewrite Hg2.
          apply SingI.
      }
    * { prove forall i j :e ordsucc n, g i = g j -> i = j.
        let i. assume Hi. let j. assume Hj.
        apply ordsuccE n i Hi.
        - assume H4: i :e n. rewrite Hg1 i H4.
          apply ordsuccE n j Hj.
          + assume H5: j :e n. rewrite Hg1 j H5.
            exact Hf2 i H4 j H5.
          + assume H5: j = n. rewrite H5. rewrite Hg2.
            assume H6: f i = y. prove False.
            apply H3. prove y :e X. rewrite <- H6.
            exact Hf1 i H4.
        - assume H4: i = n. rewrite H4. rewrite Hg2.
          apply ordsuccE n j Hj.
          + assume H5: j :e n. rewrite Hg1 j H5.
            assume H6: y = f j. prove False.
            apply H3. prove y :e X. rewrite H6.
            exact Hf1 j H5.
          + assume H5: j = n. rewrite H5.
            assume _. prove n = n. reflexivity.
      }
    * { prove forall x :e X :\/: {y}, exists i :e ordsucc n, g i = x.
        let x. assume Hx.
        apply binunionE X {y} x Hx.
        - assume H4: x :e X. apply Hf3 x H4.
          let i. assume H. apply H.
          assume Hi: i :e n. assume H5: f i = x.
          witness i. apply andI.
          + apply ordsuccI1. exact Hi.
          + prove g i = x. rewrite Hg1 i Hi. exact H5.
        - assume H4: x :e {y}.
          witness n. apply andI.
          + apply ordsuccI2.
          + prove g n = x. rewrite SingE y x H4. exact Hg2.
      }
Qed.

Theorem binunion_finite: forall X, finite X -> forall Y, finite Y -> finite (X :\/: Y).
let X. assume HX.
apply finite_ind.
- prove finite (X :\/: 0).
  rewrite binunion_idr X. exact HX.
- let Y z.
  assume HY: finite Y.
  assume Hz: z /:e Y.
  assume IH: finite (X :\/: Y).
  prove finite (X :\/: (Y :\/: {z})).
  rewrite binunion_asso.
  prove finite ((X :\/: Y) :\/: {z}).
  apply adjoin_finite. exact IH.
Qed.

Theorem famunion_nat_finite : forall X:set -> set, forall n, nat_p n -> (forall i :e n, finite (X i)) -> finite (\/_ i :e n, X i).
let X. apply nat_ind.
- assume _.
  prove finite (\/_ i :e 0, X i).
  rewrite famunion_Empty.
  exact finite_Empty.
- let n. assume Hn.
  assume IHn: (forall i :e n, finite (X i)) -> finite (\/_ i :e n, X i).
  assume H1: forall i :e ordsucc n, finite (X i).
  prove finite (\/_ i :e ordsucc n, X i).
  claim L1: (\/_ i :e ordsucc n, X i) = (\/_ i :e n, X i) :\/: X n.
  { apply set_ext.
    - let z. assume Hz: z :e \/_ i :e ordsucc n, X i.
      apply famunionE_impred (ordsucc n) X z Hz.
      let i. assume Hi: i :e ordsucc n.
      assume H2: z :e X i.
      apply ordsuccE n i Hi.
      + assume H3: i :e n. apply binunionI1.
        exact famunionI n X i z H3 H2.
      + assume H3: i = n. apply binunionI2. rewrite <- H3. exact H2.
    - let z. apply binunionE'.
      + assume Hz. apply famunionE_impred n X z Hz.
        let i. assume Hi: i :e n.
        assume H2: z :e X i.
        apply famunionI (ordsucc n) X i z.
        * apply ordsuccI1. exact Hi.
        * exact H2.
      + assume Hz. apply famunionI (ordsucc n) X n z.
        * apply ordsuccI2.
        * exact Hz.
  }
  rewrite L1.
  prove finite ((\/_ i :e n, X i) :\/: X n).
  apply binunion_finite.
  + apply IHn.
    let i. assume Hi: i :e n. apply H1. apply ordsuccI1. exact Hi.
  + apply H1 n. apply ordsuccI2.
Qed.

Theorem Subq_finite : forall X, finite X -> forall Y, Y c= X -> finite Y.
apply finite_ind.
- let Y. assume H1: Y c= 0.
  prove finite Y.
  rewrite Empty_Subq_eq Y H1. exact finite_Empty.
- let X z.
  assume HX: finite X.
  assume Hz: z /:e X.
  assume IH: forall Y, Y c= X -> finite Y.
  let Y.
  assume H1: Y c= X :\/: {z}.
  prove finite Y.
  apply xm (z :e Y).
  + assume H2: z :e Y.
    claim L1: Y = (Y :\: {z}) :\/: {z}.
    { apply set_ext.
      - let w. assume Hw: w :e Y.
        apply xm (w :e {z}).
        + assume H3: w :e {z}. apply binunionI2. exact H3.
        + assume H3: w /:e {z}. apply binunionI1. apply setminusI.
          * exact Hw.
          * exact H3.
      - let w. assume Hw: w :e (Y :\: {z}) :\/: {z}.
        apply binunionE (Y :\: {z}) {z} w Hw.
        + assume H3: w :e Y :\: {z}.
          exact setminusE1 Y {z} w H3.
        + assume H3: w :e {z}.
          prove w :e Y. rewrite SingE z w H3. exact H2.
    }
    rewrite L1.
    apply adjoin_finite.
    prove finite (Y :\: {z}).
    apply IH.
    let y. assume Hy: y :e Y :\: {z}.
    apply setminusE Y {z} y Hy.
    assume Hy1: y :e Y.
    assume Hy2: y /:e {z}.
    prove y :e X.
    apply binunionE X {z} y (H1 y Hy1).
    * assume H3: y :e X. exact H3.
    * assume H3: y :e {z}. prove False. apply Hy2. exact H3.
  + assume H2: z /:e Y.
    apply IH.
    let y. assume Hy: y :e Y.
    prove y :e X.
    apply binunionE X {z} y (H1 y Hy).
    * assume H3: y :e X. exact H3.
    * assume H3: y :e {z}.
      prove False. apply H2.
      prove z :e Y. rewrite <- SingE z y H3.
      exact Hy.
Qed.

Definition infinite : set -> prop := fun A => ~finite A.

Section InfinitePrimes.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Definition divides_nat : set -> set -> prop :=
  fun m n => m :e omega /\ n :e omega /\ exists k :e omega, m * k = n.

Theorem divides_nat_ref: forall n, nat_p n -> divides_nat n n.
let n. assume Hn.
claim Ln: n :e omega.
{ exact nat_p_omega n Hn. }
prove n :e omega /\ n :e omega /\ exists k :e omega, n * k = n.
apply and3I.
- exact Ln.
- exact Ln.
- witness 1. apply andI.
  + prove 1 :e omega. exact nat_p_omega 1 nat_1.
  + prove n * 1 = n.
    exact mul_nat_1R n.
Qed.

Theorem divides_nat_tra: forall k m n, divides_nat k m -> divides_nat m n -> divides_nat k n.
let k m n.
assume H1: divides_nat k m.
assume H2: divides_nat m n.
apply H1. assume H. apply H.
assume H1a: k :e omega.
assume H1b: m :e omega.
assume H1c: exists u :e omega, k * u = m.
apply H1c.
let u. assume H. apply H.
assume Hu: u :e omega.
assume H1d: k * u = m.
apply H2. assume H. apply H.
assume H2a: m :e omega.
assume H2b: n :e omega.
assume H2c: exists v :e omega, m * v = n.
apply H2c.
let v. assume H. apply H.
assume Hv: v :e omega.
assume H2d: m * v = n.
prove k :e omega /\ n :e omega /\ exists w :e omega, k * w = n.
apply and3I.
- exact H1a.
- exact H2b.
- witness u * v. apply andI.
  + prove u * v :e omega.
    apply nat_p_omega.
    apply mul_nat_p.
    * apply omega_nat_p. exact Hu.
    * apply omega_nat_p. exact Hv.
  + prove k * (u * v) = n.
    rewrite <- mul_nat_asso k (omega_nat_p k H1a) u (omega_nat_p u Hu) v (omega_nat_p v Hv).
    prove (k * u) * v = n.
    rewrite H1d.
    prove m * v = n.
    exact H2d.
Qed.

Definition prime_nat : set -> prop :=
  fun n => n :e omega /\ 1 :e n /\ forall k :e omega, divides_nat k n -> k = 1 \/ k = n.

Theorem divides_nat_mulR: forall m n :e omega, divides_nat m (m * n).
let m. assume Hm. let n. assume Hn.
prove m :e omega /\ m * n :e omega /\ exists k :e omega, m * k = m * n.
apply and3I.
- exact Hm.
- apply nat_p_omega. apply mul_nat_p.
  + apply omega_nat_p. exact Hm.
  + apply omega_nat_p. exact Hn.
- witness n. apply andI.
  + exact Hn.
  + reflexivity.
Qed.

Theorem divides_nat_mulL: forall m n :e omega, divides_nat n (m * n).
let m. assume Hm. let n. assume Hn.
rewrite mul_nat_com m (omega_nat_p m Hm) n (omega_nat_p n Hn).
prove divides_nat n (n * m).
exact divides_nat_mulR n Hn m Hm.
Qed.

Theorem Pi_nat_divides: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, nat_p (f i))
   -> (forall i :e n, divides_nat (f i) (Pi_nat f n)).
let f.
apply nat_ind.
- assume _. let i. assume Hi: i :e 0. prove False. exact EmptyE i Hi.
- let n. assume Hn: nat_p n.
  assume IHn: (forall i :e n, nat_p (f i))
           -> (forall i :e n, divides_nat (f i) (Pi_nat f n)).
  assume Hf: forall i :e ordsucc n, nat_p (f i).
  claim L1: forall i :e n, nat_p (f i).
  { let i. assume Hi. apply Hf. apply ordsuccI1. exact Hi. }
  claim L2: nat_p (Pi_nat f n).
  { exact Pi_nat_p f n Hn L1. }
  claim L3: nat_p (f n).
  { apply Hf. apply ordsuccI2. }
  let i. assume Hi: i :e ordsucc n.
  rewrite Pi_nat_S f n Hn.
  prove divides_nat (f i) (Pi_nat f n * f n).
  apply ordsuccE n i Hi.
  + assume H1: i :e n.
    apply divides_nat_tra (f i) (Pi_nat f n).
    * prove divides_nat (f i) (Pi_nat f n).
      exact IHn L1 i H1.
    * prove divides_nat (Pi_nat f n) (Pi_nat f n * f n).
      exact divides_nat_mulR (Pi_nat f n) (nat_p_omega (Pi_nat f n) L2)
                             (f n) (nat_p_omega (f n) L3).
  + assume H1: i = n. rewrite H1.
    prove divides_nat (f n) (Pi_nat f n * f n).
    exact divides_nat_mulL (Pi_nat f n) (nat_p_omega (Pi_nat f n) L2)
                           (f n) (nat_p_omega (f n) L3).
Qed.

Definition composite_nat : set -> prop :=
  fun n => n :e omega /\ exists k m :e omega, 1 :e k /\ 1 :e m /\ k * m = n.

Theorem prime_nat_or_composite_nat: forall n :e omega, 1 :e n -> prime_nat n \/ composite_nat n.
let n. assume Hn.
assume H1: 1 :e n.
apply xm (composite_nat n).
- assume H2: composite_nat n.
  apply orIR. exact H2.
- assume H2: ~composite_nat n.
  apply orIL.
  prove n :e omega /\ 1 :e n /\ forall k :e omega, divides_nat k n -> k = 1 \/ k = n.
  apply and3I.
  + exact Hn.
  + exact H1.
  + let k. assume Hk.
    assume Hkn: divides_nat k n.
    apply Hkn. assume _ H. apply H.
    let m. assume H. apply H.
    assume Hm: m :e omega.
    assume Hkm: k * m = n.
    prove k = 1 \/ k = n.
    apply dneg.
    assume H3: ~(k = 1 \/ k = n).
    claim L1k: 1 :e k.
    { apply ordinal_In_Or_Subq 1 k (nat_p_ordinal 1 nat_1) (nat_p_ordinal k (omega_nat_p k Hk)).
      - assume H4: 1 :e k. exact H4.
      - assume H4: k c= 1. prove False.
        apply nat_le1_cases k (omega_nat_p k Hk) H4.
        + assume H4: k = 0.
          claim Ln0: n = 0.
          { transitivity k * m.
            - prove n = k * m. symmetry. exact Hkm.
            - prove k * m = 0. rewrite H4.
              prove 0 * m = 0.
              exact mul_nat_0L m (omega_nat_p m Hm).
          }
          apply In_no2cycle 0 1 In_0_1.
          prove 1 :e 0.
          rewrite <- Ln0 at 2.
          exact H1.
        + assume H4: k = 1. apply H3. apply orIL. exact H4.
    }
    claim L1m: 1 :e m.
    { apply ordinal_In_Or_Subq 1 m (nat_p_ordinal 1 nat_1) (nat_p_ordinal m (omega_nat_p m Hm)).
      - assume H4: 1 :e m. exact H4.
      - assume H4: m c= 1. prove False.
        apply nat_le1_cases m (omega_nat_p m Hm) H4.
        + assume H4: m = 0.
          claim Ln0: n = 0.
          { transitivity k * m.
            - prove n = k * m. symmetry. exact Hkm.
            - prove k * m = 0. rewrite H4.
              prove k * 0 = 0.
              exact mul_nat_0R k.
          }
          apply In_no2cycle 0 1 In_0_1.
          prove 1 :e 0.
          rewrite <- Ln0 at 2.
          exact H1.
        + assume H4: m = 1. apply H3. apply orIR.
          prove k = n.
          transitivity k * m.
          * prove k = k * m.
            rewrite H4. symmetry.
            exact mul_nat_1R k.
          * prove k * m = n. exact Hkm.
    }
    apply H2.
    prove composite_nat n.
    prove n :e omega /\ exists k m :e omega, 1 :e k /\ 1 :e m /\ k * m = n.
    apply andI.
    * exact Hn.
    * { witness k. apply andI.
        - exact Hk.
        - witness m. apply andI.
          + exact Hm.
          + prove 1 :e k /\ 1 :e m /\ k * m = n.
            apply and3I.
            * exact L1k.
            * exact L1m.
            * exact Hkm.
      }
Qed.

Theorem prime_nat_divisor_ex: forall n, nat_p n -> 1 :e n -> exists p, prime_nat p /\ divides_nat p n.
apply nat_complete_ind.
let n. assume Hn.
assume IHn: forall k :e n, 1 :e k -> exists p, prime_nat p /\ divides_nat p k.
assume H1: 1 :e n.
apply prime_nat_or_composite_nat n (nat_p_omega n Hn) H1.
- assume H1: prime_nat n. witness n. apply andI.
  + exact H1.
  + prove divides_nat n n. apply divides_nat_ref. exact Hn.
- assume H1: composite_nat n.
  apply H1.
  assume _ H. apply H.
  let k. assume H. apply H.
  assume Hk: k :e omega. assume H. apply H.
  let m. assume H. apply H.
  assume Hm: m :e omega. assume H. apply H. assume H. apply H.
  assume H1k: 1 :e k.
  assume H1m: 1 :e m.
  assume Hkm: k * m = n.
  claim Lk: k :e n.
  { rewrite <- Hkm.
    prove k :e k * m.
    apply mul_nat_0m_1n_In k (omega_nat_p k Hk) m (omega_nat_p m Hm).
    - prove 0 :e k. apply nat_trans k (omega_nat_p k Hk) 1 H1k 0 In_0_1.
    - prove 1 :e m. exact H1m.
  }
  apply IHn k Lk H1k.
  let p. assume H. apply H.
  assume Hp: prime_nat p.
  assume Hpk: divides_nat p k.
  witness p. apply andI.
  + exact Hp.
  + prove divides_nat p n.
    apply divides_nat_tra p k n Hpk.
    prove divides_nat k n.
    rewrite <- Hkm.
    prove divides_nat k (k * m).
    apply divides_nat_mulR.
    * prove k :e omega. exact Hk.
    * prove m :e omega. exact Hm.
Qed.

Theorem nat_1In_not_divides_ordsucc: forall m n, 1 :e m -> divides_nat m n -> ~divides_nat m (ordsucc n).
let m n.
assume H1m: 1 :e m.
assume H1: divides_nat m n.
assume H2: divides_nat m (ordsucc n).
apply H1. assume H. apply H.
assume Hm: m :e omega.
assume Hn: n :e omega.
assume H. apply H.
let k. assume H. apply H.
assume Hk: k :e omega.
assume Hmk: m * k = n.
apply H2. assume _ H. apply H.
let k'. assume H. apply H.
assume Hk': k' :e omega.
assume Hmk': m * k' = ordsucc n.
claim Lm: nat_p m.
{ exact omega_nat_p m Hm. }
claim Ln: nat_p n.
{ exact omega_nat_p n Hn. }
claim Lk: nat_p k.
{ exact omega_nat_p k Hk. }
claim Lk': nat_p k'.
{ exact omega_nat_p k' Hk'. }
claim L1: 1 + n = ordsucc n.
{ rewrite add_nat_SL 0 nat_0 n Ln.
  prove ordsucc (0 + n) = ordsucc n.
  f_equal.
  exact add_nat_0L n Ln.
}
claim L2: m * k' :e m + n.
{ rewrite Hmk'.
  prove ordsucc n :e m + n.
  rewrite <- L1.
  prove 1 + n :e m + n.
  exact add_nat_In_R m Lm 1 H1m n Ln.
}
claim L3: m + n c= m * k'.
{ rewrite <- Hmk.
  prove m + m * k c= m * k'.
  rewrite <- mul_nat_SR m k Lk.
  prove m * ordsucc k c= m * k'.
  apply mul_nat_Subq_L.
  - apply nat_ordsucc. exact Lk.
  - exact Lk'.
  - prove ordsucc k c= k'.
    apply ordinal_In_Or_Subq k k' (nat_p_ordinal k Lk) (nat_p_ordinal k' Lk').
    + assume H3: k :e k'.
      exact ordinal_ordsucc_In_Subq k' (nat_p_ordinal k' Lk') k H3.
    + assume H3: k' c= k. prove False.
      claim L3a: ordsucc n c= n.
      { rewrite <- Hmk'. rewrite <- Hmk.
        prove m * k' c= m * k.
        exact mul_nat_Subq_L k' k Lk' Lk H3 m Lm.
      }
      apply In_irref n.
      prove n :e n.
      apply L3a.
      prove n :e ordsucc n.
      apply ordsuccI2.
  - exact Lm.
}
apply In_irref (m * k').
apply L3.
exact L2.
Qed.

Definition primes : set := {n :e omega|prime_nat n}.

Theorem form100_11_infinite_primes: infinite primes.
assume H1: finite primes.
apply H1.
let n. assume H. apply H.
assume Hn: n :e omega.
assume H2: equip primes n.
apply equip_sym primes n H2.
let f. assume H. apply H. assume H. apply H.
assume Hf1: forall i :e n, f i :e primes.
assume Hf2: forall i j :e n, f i = f j -> i = j.
assume Hf3: forall p :e primes, exists i :e n, f i = p.
set p := ordsucc (Pi_nat f n).
claim L1: forall i :e n, nat_p (f i).
{ let i. assume Hi.
  apply omega_nat_p.
  prove f i :e omega.
  exact SepE1 omega prime_nat (f i) (Hf1 i Hi).
}
claim L2: 0 /:e primes.
{ assume H1: 0 :e primes.
  apply SepE2 omega prime_nat 0 H1.
  assume H _. apply H.
  assume _.
  assume H2: 1 :e 0.
  exact In_no2cycle 1 0 H2 In_0_1.
}
claim LPN: nat_p (Pi_nat f n).
{ exact Pi_nat_p f n (omega_nat_p n Hn) L1. }
claim LpN: nat_p p.
{ apply nat_ordsucc. exact LPN. }
claim Lpo: p :e omega.
{ apply nat_p_omega. exact LpN. }
claim L3: forall q, prime_nat q -> ~divides_nat q p.
{ let q.
  assume Hq: prime_nat q.
  assume Hqp: divides_nat q p.
  claim LqP: q :e primes.
  { apply Hq. assume H _. apply H.
    assume Hqo: q :e omega. assume _.
    exact SepI omega prime_nat q Hqo Hq.
  }
  apply Hf3 q LqP.
  let i. assume H. apply H.
  assume Hi: i :e n.
  assume H3: f i = q.
  claim LfiP: f i :e primes.
  { exact Hf1 i Hi. }
  apply SepE omega prime_nat (f i) LfiP.
  assume H4: f i :e omega.
  assume H5: prime_nat (f i).
  apply H5. assume H. apply H.
  assume _.
  assume H6: 1 :e f i.
  assume H7: forall k :e omega, divides_nat k (f i) -> k = 1 \/ k = f i.
  apply nat_1In_not_divides_ordsucc (f i) (Pi_nat f n) H6.
  - prove divides_nat (f i) (Pi_nat f n).
    exact Pi_nat_divides f n (omega_nat_p n Hn) L1 i Hi.
  - prove divides_nat (f i) p.
    rewrite H3.
    exact Hqp.
}
claim L1p: 1 :e p.
{ prove 1 :e ordsucc (Pi_nat f n).
  apply nat_ordsucc_in_ordsucc (Pi_nat f n) LPN.
  prove 0 :e Pi_nat f n.
  apply ordinal_In_Or_Subq 0 (Pi_nat f n) ordinal_Empty (nat_p_ordinal (Pi_nat f n) LPN).
  - assume H3: 0 :e Pi_nat f n. exact H3.
  - assume H3: Pi_nat f n c= 0.
    claim LP0: Pi_nat f n = 0.
    { exact Empty_Subq_eq (Pi_nat f n) H3. }
    apply Pi_nat_0_inv f n (omega_nat_p n Hn) L1 LP0.
    let i. assume H. apply H.
    assume Hi: i :e n.
    assume H4: f i = 0.
    apply L2.
    prove 0 :e primes.
    rewrite <- H4.
    prove f i :e primes.
    exact Hf1 i Hi.
}
claim LpP: prime_nat p.
{ prove prime_nat p.
  prove p :e omega /\ 1 :e p /\ forall k :e omega, divides_nat k p -> k = 1 \/ k = p.
  apply and3I.
  - exact Lpo.
  - exact L1p.
  - let k. assume Hk: k :e omega.
    assume Hkp: divides_nat k p.
    prove k = 1 \/ k = p.
    apply orIL.
    prove k = 1.
    apply ordinal_In_Or_Subq 1 k (nat_p_ordinal 1 nat_1) (nat_p_ordinal k (omega_nat_p k Hk)).
    + assume H3: 1 :e k.
      apply prime_nat_divisor_ex k (omega_nat_p k Hk) H3.
      let q. assume H. apply H.
      assume Hq: prime_nat q.
      assume Hqk: divides_nat q k.
      apply L3 q Hq.
      prove divides_nat q p.
      exact divides_nat_tra q k p Hqk Hkp.
    + assume H3: k c= 1.
      apply nat_le1_cases k (omega_nat_p k Hk) H3.
      * assume H4: k = 0. prove False. apply Hkp. assume _ H. apply H.
        let m. assume H. apply H.
        assume Hm: m :e omega.
        assume Hkm: k * m = p.
        claim Lp0: p = 0.
        { transitivity k * m.
          - prove p = k * m. symmetry. exact Hkm.
          - prove k * m = 0. rewrite H4.
            prove 0 * m = 0.
            exact mul_nat_0L m (omega_nat_p m Hm).
        }
        apply In_no2cycle 0 1 In_0_1.
        prove 1 :e 0.
        rewrite <- Lp0 at 2.
        exact L1p.
      * assume H4: k = 1. exact H4.
}
apply L3 p LpP.
prove divides_nat p p.
apply divides_nat_ref.
exact LpN.
Qed.

End InfinitePrimes.

Section InfiniteRamsey.

Infix + 360 right := add_nat.

Theorem atleastp_omega_infinite: forall X, atleastp omega X -> infinite X.
let X.
assume HX: atleastp omega X.
assume HXfin: finite X.
apply HXfin.
let n. assume H. apply H.
assume Hn: n :e omega.
assume H1: equip X n.
prove False.
apply Pigeonhole_not_atleastp_ordsucc n (omega_nat_p n Hn).
prove atleastp (ordsucc n) n.
apply atleastp_tra (ordsucc n) X n.
- prove atleastp (ordsucc n) X.
  apply atleastp_tra (ordsucc n) omega X.
  + apply Subq_atleastp.
    prove ordsucc n c= omega.
    let i. assume Hi: i :e ordsucc n.
    apply nat_p_omega.
    prove nat_p i.
    exact nat_p_trans (ordsucc n) (nat_ordsucc n (omega_nat_p n Hn)) i Hi.
  + prove atleastp omega X. exact HX.
- prove atleastp X n.
  apply equip_atleastp.
  exact H1.
Qed.

Theorem infinite_remove1: forall X, infinite X -> forall y, infinite (X :\: {y}).
let X. assume HX. let y.
assume H1: finite (X :\: {y}).
apply xm (y :e X).
- assume H2: y :e X.
  claim L1: X = (X :\: {y}) :\/: {y}.
  { exact binunion_remove1_eq X y H2. }
  apply HX.
  prove finite X.
  rewrite L1.
  apply binunion_finite.
  + exact H1.
  + apply Sing_finite.
- assume H2: y /:e X.
  claim L2: X = X :\: {y}.
  { apply set_ext.
    - prove X c= X :\: {y}.
      let x. assume Hx: x :e X.
      apply setminusI.
      + exact Hx.
      + assume H3: x :e {y}.
        apply H2.
        prove y :e X.
        rewrite <- SingE y x H3.
        exact Hx.
    - apply setminus_Subq.
  }
  apply HX.
  prove finite X.
  rewrite L2.
  exact H1.
Qed.

Theorem infinite_Finite_Subq_ex: forall X, infinite X ->
  forall n, nat_p n -> exists Y c= X, equip Y n.
let X. assume HX.
apply nat_ind.
- prove exists Y c= X, equip Y 0.
  witness 0. apply andI.
  + apply Subq_Empty.
  + prove equip 0 0. apply equip_ref.
- let n. assume Hn.
  assume IHn: exists Y c= X, equip Y n.
  prove exists Y c= X, equip Y (ordsucc n).
  apply IHn.
  let Y. assume H. apply H.
  assume HY: Y c= X.
  assume HYn: equip Y n.
  apply HYn.
  let f.
  assume Hf: bij Y n f.
  apply Hf. assume H. apply H.
  assume Hf1: forall y :e Y, f y :e n.
  assume Hf2: forall y y' :e Y, f y = f y' -> y = y'.
  assume Hf3: forall i :e n, exists y :e Y, f y = i.
  claim L1: exists z :e X, z /:e Y.
  { apply dneg.
    assume H1: ~exists z :e X, z /:e Y.
    claim L1a: Y = X.
    { apply set_ext.
      - exact HY.
      - let z. assume HzX: z :e X.
        apply dneg.
        assume HzY: z /:e Y.
        apply H1.
        witness z. apply andI.
        + exact HzX.
        + exact HzY.
    }
    apply HX.
    prove finite X.
    prove exists m :e omega, equip X m.
    witness n. apply andI.
    - exact nat_p_omega n Hn.
    - prove equip X n.
      rewrite <- L1a.
      exact HYn.
  }
  apply L1.
  let z. assume H. apply H.
  assume HzX: z :e X.
  assume HzY: z /:e Y.
  witness Y :\/: {z}.
  apply andI.
  + prove Y :\/: {z} c= X.
    apply binunion_Subq_min.
    * exact HY.
    * prove {z} c= X.
      let w. assume Hw: w :e {z}.
      rewrite SingE z w Hw.
      exact HzX.
  + prove equip (Y :\/: {z}) (ordsucc n).
    claim Lg: exists g:set->set, (forall y :e Y, g y = f y) /\ g z = n.
    { set g : set -> set := fun y => if y :e Y then f y else n.
      witness g. apply andI.
      - let y. assume Hy. exact If_i_1 (y :e Y) (f y) n Hy.
      - exact If_i_0 (z :e Y) (f z) n HzY.
    }
    apply Lg.
    let g. assume H. apply H.
    assume HgY: forall y :e Y, g y = f y.
    assume Hgz: g z = n.
    prove exists g:set -> set, bij (Y :\/: {z}) (ordsucc n) g.
    witness g.
    prove bij (Y :\/: {z}) (ordsucc n) g.
    prove (forall u :e Y :\/: {z}, g u :e ordsucc n)
       /\ (forall u v :e Y :\/: {z}, g u = g v -> u = v)
       /\ (forall i :e ordsucc n, exists u :e Y :\/: {z}, g u = i).
    apply and3I.
    * { let u. assume Hu.
        apply binunionE Y {z} u Hu.
        - assume H1: u :e Y.
          prove g u :e ordsucc n.
          apply ordsuccI1.
          rewrite HgY u H1.
          exact Hf1 u H1.
        - assume H1: u :e {z}.
          prove g u :e ordsucc n.
          rewrite SingE z u H1.
          rewrite Hgz. apply ordsuccI2.
      }
    * { let u. assume Hu. let v. assume Hv.
        apply binunionE Y {z} u Hu.
        - assume H1: u :e Y.
          rewrite HgY u H1.
          apply binunionE Y {z} v Hv.
          + assume H2: v :e Y.
            rewrite HgY v H2.
            exact Hf2 u H1 v H2.
          + assume H2: v :e {z}.
            rewrite SingE z v H2. rewrite Hgz.
            assume H3: f u = n.
            prove False.
            apply In_irref n.
            rewrite <- H3 at 1.
            exact Hf1 u H1.
        - assume H1: u :e {z}.
          rewrite SingE z u H1. rewrite Hgz.
          apply binunionE Y {z} v Hv.
          + assume H2: v :e Y.
            rewrite HgY v H2.
            assume H3: n = f v.
            prove False.
            apply In_irref n.
            rewrite H3 at 1.
            exact Hf1 v H2.
          + assume H2: v :e {z}.
            assume _.
            prove z = v.
            symmetry.
            exact SingE z v H2.
      }
    * { let i. assume Hi: i :e ordsucc n.
        apply ordsuccE n i Hi.
        - assume H1: i :e n.
          apply Hf3 i H1.
          let y. assume H. apply H.
          assume Hy: y :e Y.
          assume Hfyi: f y = i.
          witness y. apply andI.
          + prove y :e Y :\/: {z}.
            apply binunionI1. exact Hy.
          + prove g y = i.
            rewrite HgY y Hy.
            exact Hfyi.
        - assume H1: i = n.
          witness z. apply andI.
          + prove z :e Y :\/: {z}. apply binunionI2. apply SingI.
          + prove g z = i. rewrite H1. exact Hgz.
      }
Qed.

Theorem infiniteRamsey_lem: forall X, forall f g f':set -> set,
    infinite X
 -> (forall Z c= X, infinite Z -> f Z c= Z /\ infinite (f Z))
 -> (forall Z c= X, infinite Z -> g Z :e Z /\ g Z /:e f Z)
 -> f' 0 = f X
 -> (forall m, nat_p m -> f' (ordsucc m) = f (f' m))
 -> (forall m, nat_p m -> f' m c= X /\ infinite (f' m))
 /\ (forall m m' :e omega, m c= m' -> f' m' c= f' m)
 /\ (forall m m' :e omega, g (f' m) = g (f' m') -> m = m').
let X f g f'.
assume HX: infinite X.
assume Hf1: forall Z c= X, infinite Z -> f Z c= Z /\ infinite (f Z).
assume Hg1: forall Z c= X, infinite Z -> g Z :e Z /\ g Z /:e f Z.
assume Hf'0: f' 0 = f X.
assume Hf'S: forall m, nat_p m -> f' (ordsucc m) = f (f' m).
claim Lf'1: forall m, nat_p m -> f' m c= X /\ infinite (f' m).
{ apply nat_ind.
  - rewrite Hf'0.
    prove f X c= X /\ infinite (f X).
    exact Hf1 X (fun u H => H) HX.
  - let m. assume Hm.
    assume IHm. apply IHm.
    assume IHm1: f' m c= X.
    assume IHm2: infinite (f' m).
    prove f' (ordsucc m) c= X /\ infinite (f' (ordsucc m)).
    rewrite Hf'S m Hm.
    prove f (f' m) c= X /\ infinite (f (f' m)).
    apply Hf1 (f' m) IHm1 IHm2.
    assume H3: f (f' m) c= f' m.
    assume H4: infinite (f (f' m)).
    apply andI.
    + apply Subq_tra (f (f' m)) (f' m) X H3.
      exact IHm1.
    + exact H4.
}
claim Lgf'mm'addSubq: forall m :e omega, forall m', nat_p m' -> f' (m + m') c= f' m.
{ let m. assume Hm.
  apply nat_ind.
  - prove f' (m + 0) c= f' m.
    rewrite add_nat_0R m.
    exact Subq_ref (f' m).
  - let m'. assume Hm'.
    assume IHm': f' (m + m') c= f' m.
    prove f' (m + ordsucc m') c= f' m.
    rewrite add_nat_SR m m' Hm'.
    prove f' (ordsucc (m + m')) c= f' m.
    rewrite Hf'S (m + m') (add_nat_p m (omega_nat_p m Hm) m' Hm').
    prove f (f' (m + m')) c= f' m.
    apply Subq_tra (f (f' (m + m'))) (f' (m + m')) (f' m).
    + apply Lf'1 (m + m') (add_nat_p m (omega_nat_p m Hm) m' Hm').
      assume Hfmm'X: f' (m + m') c= X.
      assume Hfmm'inf: infinite (f' (m + m')).
      apply Hf1 (f' (m + m')) Hfmm'X Hfmm'inf.
      assume H3: f (f' (m + m')) c= f' (m + m').
      assume _.
      exact H3.
    + exact IHm'.
}
claim Lgf'mm'Subq: forall m m' :e omega, m c= m' -> f' m' c= f' m.
{ let m. assume Hm: m :e omega. let m'. assume Hm': m' :e omega.
  assume Hmm': m c= m'.
  apply nat_Subq_add_ex m (omega_nat_p m Hm) m' (omega_nat_p m' Hm') Hmm'.
  let k. assume H. apply H.
  assume Hk: nat_p k.
  assume Hm'km: m' = k + m.
  prove f' m' c= f' m.
  rewrite Hm'km.
  prove f' (k + m) c= f' m.
  rewrite add_nat_com k Hk m (omega_nat_p m Hm).
  prove f' (m + k) c= f' m.
  exact Lgf'mm'addSubq m Hm k Hk.
}
claim Lgf'injlem: forall m :e omega, forall m' :e m, g (f' m') <> g (f' m).
{ let m. assume Hm: m :e omega.
  let m'. assume Hm': m' :e m.
  assume H3: g (f' m') = g (f' m).
  claim LmN: nat_p m.
  { apply omega_nat_p. exact Hm. }
  claim Lmo: ordinal m.
  { apply nat_p_ordinal. exact LmN. }
  claim Lm'N: nat_p m'.
  { exact nat_p_trans m (omega_nat_p m Hm) m' Hm'. }
  claim Lf'mff'm': f' m c= f (f' m').
  { apply Hf'S m' Lm'N (fun u _ => f' m c= u).
    prove f' m c= f' (ordsucc m').
    apply Lgf'mm'Subq (ordsucc m') (omega_ordsucc m' (nat_p_omega m' Lm'N)) m Hm.
    prove ordsucc m' c= m.
    exact ordinal_ordsucc_In_Subq m Lmo m' Hm'.
  }
  apply Lf'1 m (omega_nat_p m Hm).
  assume H4: f' m c= X.
  assume H5: infinite (f' m).
  apply Hg1 (f' m) H4 H5.
  assume H6: g (f' m) :e f' m.
  assume _.
  apply Lf'1 m' Lm'N.
  assume H7: f' m' c= X.
  assume H8: infinite (f' m').
  apply Hg1 (f' m') H7 H8.
  assume _.
  assume H9: g (f' m') /:e f (f' m').
  apply H9.
  prove g (f' m') :e f (f' m').
  rewrite H3.
  prove g (f' m) :e f (f' m').
  exact Lf'mff'm' (g (f' m)) H6.
}
apply and3I.
- exact Lf'1.
- exact Lgf'mm'Subq.
- let m. assume Hm: m :e omega.
  let m'. assume Hm': m' :e omega.
  assume Hgf'mm': g (f' m) = g (f' m').
  apply ordinal_trichotomy_or_impred m m' (nat_p_ordinal m (omega_nat_p m Hm)) (nat_p_ordinal m' (omega_nat_p m' Hm')).
  + assume Hmm': m :e m'. prove False.
    apply Lgf'injlem m' Hm' m Hmm'.
    prove g (f' m) = g (f' m').
    exact Hgf'mm'.
  + assume Hmm': m = m'. exact Hmm'.
  + assume Hm'm: m' :e m. prove False.
    apply Lgf'injlem m Hm m' Hm'm.
    prove g (f' m') = g (f' m).
    symmetry.
    exact Hgf'mm'.
Qed.

Theorem infiniteRamsey: forall c, nat_p c -> forall n, nat_p n ->
  forall X, infinite X -> forall C:set -> set,
    (forall Y c= X, equip Y n -> C Y :e c)
 -> exists H c= X, exists i :e c, infinite H /\ forall Y c= H, equip Y n -> C Y = i.
apply nat_ind.
- let n. assume Hn.
  let X. assume HX: infinite X.
  let C.
  assume H1: forall Y c= X, equip Y n -> C Y :e 0.
  prove False.
  apply infinite_Finite_Subq_ex X HX n Hn.
  let Y. assume H. apply H.
  assume HY: Y c= X.
  assume HYn: equip Y n.
  apply EmptyE (C Y).
  prove C Y :e 0.
  exact H1 Y HY HYn.
- let c. assume Hc: nat_p c.
  assume IHc: forall n, nat_p n ->
        forall X, infinite X
     -> forall C:set -> set,
        (forall Y c= X, equip Y n -> C Y :e c)
     -> exists H c= X, exists i :e c, infinite H /\ forall Y c= H, equip Y n -> C Y = i.
  prove forall n, nat_p n ->
        forall X, infinite X
     -> forall C:set -> set,
        (forall Y c= X, equip Y n -> C Y :e ordsucc c)
     -> exists H c= X, exists i :e ordsucc c, infinite H /\ forall Y c= H, equip Y n -> C Y = i.
  apply nat_ind.
  + let X.
    assume HX: infinite X.
    let C.
    assume H1: forall Y c= X, equip Y 0 -> C Y :e ordsucc c.
    prove exists H c= X, exists i :e ordsucc c, infinite H /\ forall Y c= H, equip Y 0 -> C Y = i.
    witness X. apply andI.
    * prove X c= X. exact Subq_ref X.
    * { witness C 0. apply andI.
        - prove C 0 :e ordsucc c.
          apply H1 0.
          + prove 0 c= X. apply Subq_Empty.
          + prove equip 0 0. apply equip_ref.
        - prove infinite X /\ forall Y c= X, equip Y 0 -> C Y = C 0.
          apply andI.
          + exact HX.
          + let Y. assume HY: Y c= X.
            assume HY0: equip Y 0.
            prove C Y = C 0.
            f_equal.
            prove Y = 0.
            exact equip_0_Empty Y HY0.
      }
  + let n.
    assume Hn: nat_p n.
    assume IHn: forall X, infinite X -> forall C:set -> set,
        (forall Y c= X, equip Y n -> C Y :e ordsucc c)
     -> exists H c= X, exists i :e ordsucc c, infinite H /\ forall Y c= H, equip Y n -> C Y = i.
    let X.
    assume HX: infinite X.
    let C.
    assume H1: forall Y c= X, equip Y (ordsucc n) -> C Y :e ordsucc c.
    prove exists H c= X, exists i :e ordsucc c, infinite H /\ forall Y c= H, equip Y (ordsucc n) -> C Y = i.
    apply dneg.
    assume H2: ~exists H c= X, exists i :e ordsucc c, infinite H /\ forall Y c= H, equip Y (ordsucc n) -> C Y = i.
    claim L1: forall X' c= X, infinite X' ->
              exists X'' c= X', exists x :e X', x /:e X'' /\ infinite X'' /\ forall Y c= X'', equip Y n -> C (Y :\/: {x}) = c.
    { let X'.
      assume HX'X: X' c= X.
      assume HX': infinite X'.
      apply dneg.
      assume H2': ~exists X'' c= X', exists x :e X', x /:e X'' /\ infinite X'' /\ forall Y c= X'', equip Y n -> C (Y :\/: {x}) = c.
      claim L1a: exists x, x :e X'.
      { apply dneg.
        assume H3: ~exists x, x :e X'.
        claim L1a1: X' = 0.
        { apply Empty_eq.
          let x. assume Hx: x :e X'.
          apply H3.
          witness x. exact Hx.
        }
        apply HX'.
        prove finite X'.
        rewrite L1a1.
        exact finite_Empty.
      }
      apply L1a.
      let x.
      assume Hx: x :e X'.
      claim LX'xinf: infinite (X' :\: {x}).
      { apply infinite_remove1. exact HX'. }
      set C' : set->set := fun Y => C (Y :\/: {x}).
      claim LC'Sc: forall Y c= X' :\: {x}, equip Y n -> C' Y :e ordsucc c.
      { let Y.
        assume H3: Y c= X' :\: {x}.
        assume H4: equip Y n.
        prove C (Y :\/: {x}) :e ordsucc c.
        apply H1.
        - prove Y :\/: {x} c= X.
          apply binunion_Subq_min.
          + prove Y c= X.
            apply Subq_tra Y (X' :\: {x}) X H3.
            prove X' :\: {x} c= X.
            apply Subq_tra (X' :\: {x}) X' X.
            * apply setminus_Subq.
            * prove X' c= X. exact HX'X.
          + prove {x} c= X.
            let y. assume Hy: y :e {x}.
            rewrite SingE x y Hy.
            prove x :e X.
            apply HX'X.
            exact Hx.
        - prove equip (Y :\/: {x}) (ordsucc n).
          apply equip_sym.
          apply equip_adjoin_ordsucc.
          + prove x /:e Y.
            assume H5: x :e Y.
            apply setminusE2 X' {x} x (H3 x H5).
            prove x :e {x}.
            apply SingI.
          + prove equip n Y. apply equip_sym. exact H4.
      }
      claim L1b: forall Z c= X', infinite Z -> exists Z' c= Z, exists y :e Z, y /:e Z' /\ infinite Z' /\ forall Y c= Z', equip Y n -> C (Y :\/: {y}) :e c.
      { apply dneg.
        assume H3: ~forall Z c= X', infinite Z -> exists Z' c= Z, exists y :e Z, y /:e Z' /\ infinite Z' /\ forall Y c= Z', equip Y n -> C (Y :\/: {y}) :e c.
        apply IHn (X' :\: {x}) LX'xinf C' LC'Sc.
        let H'. assume H. apply H.
        assume HH'X': H' c= X' :\: {x}.
        assume H. apply H.
        let i. assume H. apply H.
        assume Hi: i :e ordsucc c. assume H. apply H.
        assume HH'inf: infinite H'.
        assume HH'hom: forall Y c= H', equip Y n -> C (Y :\/: {x}) = i.
        apply ordsuccE c i Hi.
        - assume H4: i :e c.
          apply H3.
          let Z.
          assume HZX': Z c= X'.
          assume HZ: infinite Z.
          apply dneg.
          assume H5: ~exists Z' c= Z, exists y :e Z, y /:e Z' /\ infinite Z' /\ forall Y c= Z', equip Y n -> C (Y :\/: {y}) :e c.
          claim L1b1: exists y, y :e Z.
          { apply dneg.
            assume H6: ~exists y, y :e Z.
            claim L1b1a: Z = 0.
            { apply Empty_eq.
              let y. assume Hy: y :e Z.
              apply H6.
              witness y. exact Hy.
            }
            apply HZ.
            prove finite Z.
            rewrite L1b1a.
            exact finite_Empty.
          }
          apply L1b1.
          let y. assume Hy: y :e Z.
          claim LZyinf: infinite (Z :\: {y}).
          { apply infinite_remove1. exact HZ. }
          claim LZyX': Z :\: {y} c= X'.
          { apply Subq_tra (Z :\: {y}) Z X'.
            - apply setminus_Subq.
            - exact HZX'.
          }
          claim LZyX: Z :\: {y} c= X.
          { exact Subq_tra (Z :\: {y}) X' X LZyX' HX'X. }
          set C'' : set->set := fun Y => C (Y :\/: {y}).
          claim LC''Sc: forall Y c= Z :\: {y}, equip Y n -> C'' Y :e ordsucc c.
          { let Y.
            assume H6: Y c= Z :\: {y}.
            assume H7: equip Y n.
            prove C (Y :\/: {y}) :e ordsucc c.
            apply H1.
            - prove Y :\/: {y} c= X.
              apply binunion_Subq_min.
              + prove Y c= X.
                apply Subq_tra Y (Z :\: {y}) X H6.
                prove Z :\: {y} c= X.
                exact LZyX.
                    + prove {y} c= X.
                let z. assume Hz: z :e {y}.
                rewrite SingE y z Hz.
                prove y :e X.
                apply HX'X.
                prove y :e X'.
                apply HZX'.
                prove y :e Z.
                exact Hy.
            - prove equip (Y :\/: {y}) (ordsucc n).
              apply equip_sym.
              apply equip_adjoin_ordsucc.
              + prove y /:e Y.
                assume H8: y :e Y.
                apply setminusE2 Z {y} y (H6 y H8).
                prove y :e {y}.
                apply SingI.
              + prove equip n Y. apply equip_sym. exact H7.
          }
          apply IHn (Z :\: {y}) LZyinf C'' LC''Sc.
          let H'. assume H. apply H.
          assume HH'Zy: H' c= Z :\: {y}.
          assume H. apply H.
          let i. assume H. apply H.
          assume Hi: i :e ordsucc c. assume H. apply H.
          assume HH'inf: infinite H'.
          assume HH'hom: forall Y c= H', equip Y n -> C (Y :\/: {y}) = i.
          apply ordsuccE c i Hi.
          + assume H6: i :e c.
            apply H5.
            witness H'. apply andI.
            * prove H' c= Z.
              apply Subq_tra H' (Z :\: {y}) Z HH'Zy.
              apply setminus_Subq.
            * { prove exists y :e Z, y /:e H' /\ infinite H' /\ forall Y c= H', equip Y n -> C (Y :\/: {y}) :e c.
                witness y. apply andI.
                - exact Hy.
                - apply and3I.
                  + assume H7: y :e H'.
                    apply setminusE2 Z {y} y (HH'Zy y H7).
                    apply SingI.
                  + exact HH'inf.
                  + let Y.
                    assume H7: Y c= H'.
                    assume H8: equip Y n.
                    rewrite HH'hom Y H7 H8.
                    prove i :e c. exact H6.
              }
          + assume H6: i = c.
            apply H2'.
            witness H'.
            apply andI.
            * prove H' c= X'.
              apply Subq_tra H' (Z :\: {y}) X' HH'Zy.
              prove Z :\: {y} c= X'.
              exact LZyX'.
            * { witness y. apply andI.
                - prove y :e X'.
                  apply HZX'.
                  exact Hy.
                - apply and3I.
                  + prove y /:e H'.
                    assume H7: y :e H'.
                    apply setminusE2 Z {y} y (HH'Zy y H7).
                    apply SingI.
                  + prove infinite H'. exact HH'inf.
                  + rewrite <- H6. exact HH'hom.
              }
        - assume H4: i = c.
          apply H2'.
          witness H'.
          apply andI.
          + prove H' c= X'.
            apply Subq_tra H' (X' :\: {x}) X' HH'X'.
            prove X' :\: {x} c= X'.
            apply setminus_Subq.
          + witness x. apply andI.
            * prove x :e X'. exact Hx.
            * { apply and3I.
                - prove x /:e H'.
                  assume H5: x :e H'.
                  apply setminusE2 X' {x} x (HH'X' x H5).
                  apply SingI.
                - prove infinite H'. exact HH'inf.
                - rewrite <- H4. exact HH'hom.
              }
        }
        set f:set->set := fun Z => Eps_i (fun Z' => Z' c= Z /\ exists y :e Z, y /:e Z' /\ infinite Z' /\ forall Y c= Z', equip Y n -> C (Y :\/: {y}) :e c).
        claim Lf1: forall Z c= X', infinite Z -> f Z c= Z /\ exists y :e Z, y /:e f Z /\ infinite (f Z) /\ forall Y c= f Z, equip Y n -> C (Y :\/: {y}) :e c.
        { let Z. assume HZ1 HZ2.
          exact Eps_i_ex (fun Z' => Z' c= Z /\ exists y :e Z, y /:e Z' /\ infinite Z' /\ forall Y c= Z', equip Y n -> C (Y :\/: {y}) :e c) (L1b Z HZ1 HZ2).
        }
        claim Lf1a: forall Z c= X', infinite Z -> f Z c= Z /\ infinite (f Z).
        { let Z. assume HZ1 HZ2.
	  apply Lf1 Z HZ1 HZ2.
	  assume H3: f Z c= Z.
	  assume H. apply H.
          let y. assume H. apply H.
          assume Hy: y :e Z. assume H. apply H.
          assume H4: y /:e f Z /\ infinite (f Z).
          assume _.
	  apply H4.
	  assume _.
	  assume H5: infinite (f Z).
	  apply andI.
	  - exact H3.
	  - exact H5.
	}
        set g:set->set := fun Z => Eps_i (fun y => y :e Z /\ (y /:e f Z /\ forall Y c= f Z, equip Y n -> C (Y :\/: {y}) :e c)).
        claim Lg1: forall Z c= X', infinite Z -> g Z :e Z /\ (g Z /:e f Z /\ forall Y c= f Z, equip Y n -> C (Y :\/: {g Z}) :e c).
        { let Z. assume HZ1 HZ2.
          apply Lf1 Z HZ1 HZ2.
          assume H3: f Z c= Z.
          assume H. apply H.
          let y. assume H. apply H.
          assume Hy: y :e Z. assume H. apply H. assume H. apply H.
          assume H4: y /:e f Z.
          assume H5: infinite (f Z).
          assume H6: forall Y c= f Z, equip Y n -> C (Y :\/: {y}) :e c.
          claim Ly: y :e Z /\ (y /:e f Z /\ forall Y c= f Z, equip Y n -> C (Y :\/: {y}) :e c).
          { apply andI.
            - exact Hy.
            - apply andI.
              + exact H4.
              + exact H6.
          }
          exact Eps_i_ax (fun y => y :e Z /\ (y /:e f Z /\ forall Y c= f Z, equip Y n -> C (Y :\/: {y}) :e c)) y Ly.
        }
        claim Lg1a: forall Z c= X', infinite Z -> g Z :e Z /\ g Z /:e f Z.
	{ let Z. assume HZ1 HZ2.
          apply Lg1 Z HZ1 HZ2.
	  assume H3: g Z :e Z.
	  assume H. apply H.
	  assume H4: g Z /:e f Z.
	  assume _.
	  apply andI.
	  - exact H3.
	  - exact H4.
	}
        claim Lf': exists f':set -> set, f' 0 = f X' /\ forall m, nat_p m -> f' (ordsucc m) = f (f' m).
        { witness nat_primrec (f X') (fun _ Z => f Z).
          apply andI.
          - exact nat_primrec_0 (f X') (fun _ Z => f Z).
          - exact nat_primrec_S (f X') (fun _ Z => f Z).
        }
        apply Lf'.
        let f'. assume H. apply H.
        assume Hf'0 Hf'S.
	apply infiniteRamsey_lem X' f g f' HX' Lf1a Lg1a Hf'0 Hf'S.
	assume H. apply H.
	assume Hf'1: forall m, nat_p m -> f' m c= X' /\ infinite (f' m).
	assume Hgf'mm'Subq: forall m m' :e omega, m c= m' -> f' m' c= f' m.
        assume Hgf'inj: forall m m' :e omega, g (f' m) = g (f' m') -> m = m'.
        set H' := {g (f' n)|n :e omega}.
        claim LH'X: H' c= X.
        { let u. assume Hu: u :e H'.
          apply ReplE_impred omega (fun n => g (f' n)) u Hu.
          let m.
          assume Hm: m :e omega.
          assume Hue: u = g (f' m).
          rewrite Hue.
          prove g (f' m) :e X.
          apply Hf'1 m (omega_nat_p m Hm).
          assume Hf'mX': f' m c= X'.
          assume Hf'minf: infinite (f' m).
          apply Lg1 (f' m) Hf'mX' Hf'minf.
          assume Hgf'm: g (f' m) :e f' m.
          assume _.
          apply HX'X.
          apply Hf'mX'.
          exact Hgf'm.
        }
        claim LH'inf: infinite H'.
        { apply atleastp_omega_infinite.
          prove atleastp omega H'.
          prove exists g:set->set, inj omega H' g.
          witness (fun n:set => g (f' n)).
          prove (forall m :e omega, g (f' m) :e H')
             /\ (forall m m' :e omega, g (f' m) = g (f' m') -> m = m').
          apply andI.
          - let m. assume Hm: m :e omega.
            prove g (f' m) :e {g (f' n)|n :e omega}.
            exact ReplI omega (fun n => g (f' n)) m Hm.
          - exact Hgf'inj.
        }
        claim LCSnlem: forall m, nat_p m
              -> forall Y c= H', equip Y (ordsucc n)
              -> g (f' m) :e Y -> (forall k :e m, g (f' k) /:e Y)
              -> C Y :e c.
        { let m. assume Hm. let Y.
          assume HYH': Y c= H'.
          assume HYSn: equip Y (ordsucc n).
          assume Hgf'mY: g (f' m) :e Y.
          assume Hgf'kY: forall k :e m, g (f' k) /:e Y.
          apply Hf'1 m Hm.
          assume Hf'mX': f' m c= X'.
          assume Hf'minf: infinite (f' m).
          apply Lg1 (f' m) Hf'mX' Hf'minf.
          assume Hgf'mf'm: g (f' m) :e f' m.
          assume H. apply H.
          assume Hgf'mff'm: g (f' m) /:e f (f' m).
          assume Hgf'mc: forall Y c= f (f' m), equip Y n -> C (Y :\/: {g (f' m)}) :e c.
          claim Lmo: ordinal m.
          { apply nat_p_ordinal. exact Hm. }
          prove C Y :e c.
          rewrite binunion_remove1_eq Y (g (f' m)) Hgf'mY.
          prove C ((Y :\: {g (f' m)}) :\/: {g (f' m)}) :e c.
          apply Hgf'mc.
          - prove Y :\: {g (f' m)} c= f (f' m).
            let u. assume Hu: u :e Y :\: {g (f' m)}.
            claim Luf'Sm: u :e f' (ordsucc m).
            { apply setminusE Y {g (f' m)} u Hu.
              assume Hu1: u :e Y.
              assume Hu2: u /:e {g (f' m)}.
              apply ReplE_impred omega (fun n => g (f' n)) u (HYH' u Hu1).
              let k.
              assume Hk: k :e omega.
              assume Huk: u = g (f' k).
              prove u :e f' (ordsucc m).
              claim Lko: ordinal k.
              { apply nat_p_ordinal. apply omega_nat_p. exact Hk. }
              apply ordinal_trichotomy_or_impred k m Lko Lmo.
              - assume Hkm: k :e m. prove False.
                apply Hgf'kY k Hkm.
                prove g (f' k) :e Y.
                rewrite <- Huk.
                exact Hu1.
              - assume Hkm: k = m. prove False.
                apply Hu2.
                rewrite Huk.
                prove g (f' k) :e {g (f' m)}.
                rewrite Hkm.
                apply SingI.
              - assume Hmk: m :e k.
                prove u :e f' (ordsucc m).
                apply Hgf'mm'Subq (ordsucc m) (omega_ordsucc m (nat_p_omega m Hm)) k Hk.
                + prove ordsucc m c= k.
                  exact ordinal_ordsucc_In_Subq k Lko m Hmk.
                + prove u :e f' k.
                  rewrite Huk.
                  prove g (f' k) :e f' k.
                  apply Hf'1 k (omega_nat_p k Hk).
                  assume Hf'kX': f' k c= X'.
                  assume Hf'kinf: infinite (f' k).
                  apply Lg1 (f' k) Hf'kX' Hf'kinf.
                  assume Hgf'kf'k: g (f' k) :e f' k.
                  assume _.
                  exact Hgf'kf'k.
            }
                prove u :e f (f' m).
            exact Hf'S m Hm (fun w _ => u :e w) Luf'Sm.
          - prove equip (Y :\: {g (f' m)}) n.
            apply equip_ordsucc_remove1.
            + exact Hgf'mY.
            + prove equip Y (ordsucc n). exact HYSn.
        }
        claim LCSn: forall Y c= H', equip Y (ordsucc n) -> C Y :e c.
        { let Y.
          assume HYH': Y c= H'.
          assume HYSn: equip Y (ordsucc n).
          prove C Y :e c.
          set p : set -> prop := fun m => m :e omega /\ g (f' m) :e Y.
          claim Lpne: exists m, ordinal m /\ p m.
          { apply equip_sym Y (ordsucc n) HYSn.
            let h.
            assume Hh: bij (ordsucc n) Y h.
            apply Hh. assume H _. apply H.
            assume Hh1: forall i :e ordsucc n, h i :e Y.
            assume _.
            claim LhnY: h n :e Y.
            { apply Hh1. apply ordsuccI2. }
            apply ReplE_impred omega (fun n => g (f' n)) (h n) (HYH' (h n) LhnY).
            let m.
            assume Hm: m :e omega.
            assume Hhnm: h n = g (f' m).
            witness m.
            apply andI.
            - prove ordinal m. apply nat_p_ordinal. apply omega_nat_p. exact Hm.
            - prove m :e omega /\ g (f' m) :e Y.
              apply andI.
              + exact Hm.
              + rewrite <- Hhnm. exact LhnY.
          }
          apply least_ordinal_ex p Lpne.
          let m. assume H. apply H. assume H. apply H.
          assume Hmo: ordinal m.
          assume Hpm: m :e omega /\ g (f' m) :e Y.
          assume Hpk: forall k :e m, ~(k :e omega /\ g (f' k) :e Y).
          apply Hpm.
          assume Hm: m :e omega.
          assume Hgf'm: g (f' m) :e Y.
          prove C Y :e c.
          apply LCSnlem m (omega_nat_p m Hm) Y HYH' HYSn Hgf'm.
          let k. assume Hk: k :e m.
          prove g (f' k) /:e Y.
          assume Hgf'k: g (f' k) :e Y.
          apply Hpk k Hk. apply andI.
          - prove k :e omega.
            apply nat_p_omega.
            exact nat_p_trans m (omega_nat_p m Hm) k Hk.
          - prove g (f' k) :e Y. exact Hgf'k.
        }
        apply IHc (ordsucc n) (nat_ordsucc n Hn) H' LH'inf C LCSn.
        let H''. assume H. apply H.
        assume HH''H': H'' c= H'. assume H. apply H.
        let i. assume H. apply H.
        assume Hi: i :e c. assume H. apply H.
        assume HH''inf: infinite H''.
        assume HH''hom: forall Y c= H'', equip Y (ordsucc n) -> C Y = i.
        apply H2.
        witness H''. apply andI.
        + prove H'' c= X.
          exact Subq_tra H'' H' X HH''H' LH'X.
        + witness i. apply andI.
          * prove i :e ordsucc c. apply ordsuccI1. exact Hi.
          * { apply andI.
              - prove infinite H''. exact HH''inf.
              - prove forall Y c= H'', equip Y (ordsucc n) -> C Y = i.
                exact HH''hom.
            }
    }
    set f:set->set := fun X' => Eps_i (fun X'' => X'' c= X' /\ exists x :e X', x /:e X'' /\ infinite X'' /\ forall Y c= X'', equip Y n -> C (Y :\/: {x}) = c).
    claim Lf1: forall X' c= X, infinite X' -> f X' c= X' /\ exists x :e X', x /:e f X' /\ infinite (f X') /\ forall Y c= f X', equip Y n -> C (Y :\/: {x}) = c.
    { let X'. assume HX'X HX'inf.
      exact Eps_i_ex (fun X'' => X'' c= X' /\ exists x :e X', x /:e X'' /\ infinite X'' /\ forall Y c= X'', equip Y n -> C (Y :\/: {x}) = c) (L1 X' HX'X HX'inf).
    }
    claim Lf1a: forall Z c= X, infinite Z -> f Z c= Z /\ infinite (f Z).
    { let Z. assume HZ1 HZ2.
      apply Lf1 Z HZ1 HZ2.
      assume H3: f Z c= Z.
      assume H. apply H.
      let y. assume H. apply H.
      assume Hy: y :e Z. assume H. apply H.
      assume H4: y /:e f Z /\ infinite (f Z).
      assume _.
      apply H4.
      assume _.
      assume H5: infinite (f Z).
      apply andI.
      - exact H3.
      - exact H5.
    }
    set g:set->set := fun X' => Eps_i (fun x => x :e X' /\ (x /:e f X' /\ forall Y c= f X', equip Y n -> C (Y :\/: {x}) = c)).
    claim Lg1: forall X' c= X, infinite X' -> g X' :e X' /\ (g X' /:e f X' /\ forall Y c= f X', equip Y n -> C (Y :\/: {g X'}) = c).
    { let X'. assume HX'X HX'inf.
       apply Lf1 X' HX'X HX'inf.
       assume HfX'X': f X' c= X'. assume H. apply H.
       let x. assume H. apply H.
       assume Hx: x :e X'. assume H. apply H. assume H. apply H.
       assume HxfX': x /:e f X'.
       assume HfX'inf: infinite (f X').
       assume HfX'hom: forall Y c= f X', equip Y n -> C (Y :\/: {x}) = c.
       claim Lg1': x :e X' /\ (x /:e f X' /\ forall Y c= f X', equip Y n -> C (Y :\/: {x}) = c).
       { apply andI.
         - exact Hx.
         - apply andI.
           + exact HxfX'.
           + exact HfX'hom.
       }
       exact Eps_i_ax (fun x => x :e X' /\ (x /:e f X' /\ forall Y c= f X', equip Y n -> C (Y :\/: {x}) = c)) x Lg1'.
    }
    claim Lg1a: forall Z c= X, infinite Z -> g Z :e Z /\ g Z /:e f Z.
    { let Z. assume HZ1 HZ2.
      apply Lg1 Z HZ1 HZ2.
      assume H3: g Z :e Z.
      assume H. apply H.
      assume H4: g Z /:e f Z.
      assume _.
      apply andI.
      - exact H3.
      - exact H4.
    }
    claim Lf': exists f':set -> set, f' 0 = f X /\ forall m, nat_p m -> f' (ordsucc m) = f (f' m).
    { witness nat_primrec (f X) (fun _ Z => f Z).
      apply andI.
      - exact nat_primrec_0 (f X) (fun _ Z => f Z).
      - exact nat_primrec_S (f X) (fun _ Z => f Z).
    }
    apply Lf'.
    let f'. assume H. apply H.
    assume Hf'0 Hf'S.
    apply infiniteRamsey_lem X f g f' HX Lf1a Lg1a Hf'0 Hf'S.
    assume H. apply H.
    assume Hf'1: forall m, nat_p m -> f' m c= X /\ infinite (f' m).
    assume Hgf'mm'Subq: forall m m' :e omega, m c= m' -> f' m' c= f' m.
    assume Hgf'inj: forall m m' :e omega, g (f' m) = g (f' m') -> m = m'.
    set H' := {g (f' n)|n :e omega}.
    claim Lf'1: forall m, nat_p m -> f' m c= X /\ infinite (f' m).
    { apply nat_ind.
      - rewrite Hf'0.
        prove f X c= X /\ infinite (f X).
        apply Lf1 X (fun u H => H) HX.
        assume H3: f X c= X.
        assume H. apply H.
        let y. assume H. apply H. assume _ H. apply H. assume H. apply H.
        assume _.
        assume H4: infinite (f X).
        assume _.
        prove f X c= X /\ infinite (f X).
        apply andI.
        + exact H3.
        + exact H4.
      - let m. assume Hm.
        assume IHm. apply IHm.
        assume IHm1: f' m c= X.
        assume IHm2: infinite (f' m).
        prove f' (ordsucc m) c= X /\ infinite (f' (ordsucc m)).
        rewrite Hf'S m Hm.
        prove f (f' m) c= X /\ infinite (f (f' m)).
        apply Lf1 (f' m) IHm1 IHm2.
        assume H3: f (f' m) c= f' m.
        assume H. apply H.
        let y. assume H. apply H. assume _ H. apply H. assume H. apply H.
        assume _.
        assume H4: infinite (f (f' m)).
        assume _.
        apply andI.
        + apply Subq_tra (f (f' m)) (f' m) X H3.
          exact IHm1.
        + exact H4.
    }
    claim Lgf'mm'addSubq: forall m :e omega, forall m', nat_p m' -> f' (m + m') c= f' m.
    { let m. assume Hm.
      apply nat_ind.
      - prove f' (m + 0) c= f' m.
        rewrite add_nat_0R m.
        exact Subq_ref (f' m).
      - let m'. assume Hm'.
        assume IHm': f' (m + m') c= f' m.
        prove f' (m + ordsucc m') c= f' m.
        rewrite add_nat_SR m m' Hm'.
        prove f' (ordsucc (m + m')) c= f' m.
        rewrite Hf'S (m + m') (add_nat_p m (omega_nat_p m Hm) m' Hm').
        prove f (f' (m + m')) c= f' m.
        apply Subq_tra (f (f' (m + m'))) (f' (m + m')) (f' m).
        + apply Lf'1 (m + m') (add_nat_p m (omega_nat_p m Hm) m' Hm').
          assume Hfmm'X: f' (m + m') c= X.
          assume Hfmm'inf: infinite (f' (m + m')).
          apply Lf1 (f' (m + m')) Hfmm'X Hfmm'inf.
          assume H3: f (f' (m + m')) c= f' (m + m').
          assume _.
          exact H3.
        + exact IHm'.
    }
    claim Lgf'mm'Subq: forall m m' :e omega, m c= m' -> f' m' c= f' m.
    { let m. assume Hm: m :e omega.
      let m'. assume Hm': m' :e omega.
      assume Hmm': m c= m'.
      apply nat_Subq_add_ex m (omega_nat_p m Hm) m' (omega_nat_p m' Hm') Hmm'.
      let k. assume H. apply H.
      assume Hk: nat_p k.
      assume Hm'km: m' = k + m.
      prove f' m' c= f' m.
      rewrite Hm'km.
      prove f' (k + m) c= f' m.
      rewrite add_nat_com k Hk m (omega_nat_p m Hm).
      prove f' (m + k) c= f' m.
      exact Lgf'mm'addSubq m Hm k Hk.
    }
    claim Lgf'injlem: forall m :e omega, forall m' :e m, g (f' m') <> g (f' m).
    { let m. assume Hm: m :e omega.
      let m'. assume Hm': m' :e m.
      assume H3: g (f' m') = g (f' m).
      claim LmN: nat_p m.
      { apply omega_nat_p. exact Hm. }
      claim Lmo: ordinal m.
      { apply nat_p_ordinal. exact LmN. }
      claim Lm'N: nat_p m'.
      { exact nat_p_trans m (omega_nat_p m Hm) m' Hm'. }
      claim Lf'mff'm': f' m c= f (f' m').
      { apply Hf'S m' Lm'N (fun u _ => f' m c= u).
        prove f' m c= f' (ordsucc m').
        apply Lgf'mm'Subq (ordsucc m') (omega_ordsucc m' (nat_p_omega m' Lm'N)) m Hm.
        prove ordsucc m' c= m.
        exact ordinal_ordsucc_In_Subq m Lmo m' Hm'.
      }
      apply Lf'1 m (omega_nat_p m Hm).
      assume H4: f' m c= X.
      assume H5: infinite (f' m).
      apply Lg1 (f' m) H4 H5.
      assume H6: g (f' m) :e f' m.
      assume _.
      apply Lf'1 m' Lm'N.
      assume H7: f' m' c= X.
      assume H8: infinite (f' m').
      apply Lg1 (f' m') H7 H8.
      assume _ H. apply H.
      assume H9: g (f' m') /:e f (f' m').
      assume _.
      apply H9.
      prove g (f' m') :e f (f' m').
      rewrite H3.
      prove g (f' m) :e f (f' m').
      exact Lf'mff'm' (g (f' m)) H6.
    }
    claim Lgf'inj: forall m m' :e omega, g (f' m) = g (f' m') -> m = m'.
    { let m. assume Hm: m :e omega.
      let m'. assume Hm': m' :e omega.
      assume Hgf'mm': g (f' m) = g (f' m').
      apply ordinal_trichotomy_or_impred m m' (nat_p_ordinal m (omega_nat_p m Hm)) (nat_p_ordinal m' (omega_nat_p m' Hm')).
      - assume Hmm': m :e m'. prove False.
        apply Lgf'injlem m' Hm' m Hmm'.
        prove g (f' m) = g (f' m').
        exact Hgf'mm'.
      - assume Hmm': m = m'. exact Hmm'.
      - assume Hm'm: m' :e m. prove False.
        apply Lgf'injlem m Hm m' Hm'm.
        prove g (f' m') = g (f' m).
        symmetry.
        exact Hgf'mm'.
    }
    claim LH'X: H' c= X.
    { let u. assume Hu: u :e H'.
      apply ReplE_impred omega (fun n => g (f' n)) u Hu.
      let m.
      assume Hm: m :e omega.
      assume Hue: u = g (f' m).
      rewrite Hue.
      prove g (f' m) :e X.
      apply Lf'1 m (omega_nat_p m Hm).
      assume Hf'mX: f' m c= X.
      assume Hf'minf: infinite (f' m).
      apply Lg1 (f' m) Hf'mX Hf'minf.
      assume Hgf'm: g (f' m) :e f' m.
      assume _.
      apply Hf'mX.
      exact Hgf'm.
    }
    claim LH'inf: infinite H'.
    { apply atleastp_omega_infinite.
      prove atleastp omega H'.
      prove exists g:set->set, inj omega H' g.
      witness (fun n:set => g (f' n)).
      prove (forall m :e omega, g (f' m) :e H')
         /\ (forall m m' :e omega, g (f' m) = g (f' m') -> m = m').
      apply andI.
      - let m. assume Hm: m :e omega.
        prove g (f' m) :e {g (f' n)|n :e omega}.
        exact ReplI omega (fun n => g (f' n)) m Hm.
      - exact Lgf'inj.
    }
    claim LCSnlem: forall m, nat_p m
          -> forall Y c= H', equip Y (ordsucc n)
          -> g (f' m) :e Y -> (forall k :e m, g (f' k) /:e Y)
          -> C Y = c.
    { let m. assume Hm. let Y.
      assume HYH': Y c= H'.
      assume HYSn: equip Y (ordsucc n).
      assume Hgf'mY: g (f' m) :e Y.
      assume Hgf'kY: forall k :e m, g (f' k) /:e Y.
      apply Lf'1 m Hm.
      assume Hf'mX: f' m c= X.
      assume Hf'minf: infinite (f' m).
      apply Lg1 (f' m) Hf'mX Hf'minf.
      assume Hgf'mf'm: g (f' m) :e f' m.
      assume H. apply H.
      assume Hgf'mff'm: g (f' m) /:e f (f' m).
      assume Hgf'mc: forall Y c= f (f' m), equip Y n -> C (Y :\/: {g (f' m)}) = c.
      claim Lmo: ordinal m.
      { apply nat_p_ordinal. exact Hm. }
      prove C Y = c.
      rewrite binunion_remove1_eq Y (g (f' m)) Hgf'mY.
      prove C ((Y :\: {g (f' m)}) :\/: {g (f' m)}) = c.
      apply Hgf'mc.
      - prove Y :\: {g (f' m)} c= f (f' m).
        let u. assume Hu: u :e Y :\: {g (f' m)}.
        claim Luf'Sm: u :e f' (ordsucc m).
        { apply setminusE Y {g (f' m)} u Hu.
          assume Hu1: u :e Y.
          assume Hu2: u /:e {g (f' m)}.
          apply ReplE_impred omega (fun n => g (f' n)) u (HYH' u Hu1).
          let k.
          assume Hk: k :e omega.
          assume Huk: u = g (f' k).
          prove u :e f' (ordsucc m).
          claim Lko: ordinal k.
          { apply nat_p_ordinal. apply omega_nat_p. exact Hk. }
          apply ordinal_trichotomy_or_impred k m Lko Lmo.
          - assume Hkm: k :e m. prove False.
            apply Hgf'kY k Hkm.
            prove g (f' k) :e Y.
            rewrite <- Huk.
            exact Hu1.
          - assume Hkm: k = m. prove False.
            apply Hu2.
            rewrite Huk.
            prove g (f' k) :e {g (f' m)}.
            rewrite Hkm.
            apply SingI.
          - assume Hmk: m :e k.
            prove u :e f' (ordsucc m).
            apply Lgf'mm'Subq (ordsucc m) (omega_ordsucc m (nat_p_omega m Hm)) k Hk.
            + prove ordsucc m c= k.
              exact ordinal_ordsucc_In_Subq k Lko m Hmk.
            + prove u :e f' k.
              rewrite Huk.
              prove g (f' k) :e f' k.
              apply Lf'1 k (omega_nat_p k Hk).
              assume Hf'kX: f' k c= X.
              assume Hf'kinf: infinite (f' k).
              apply Lg1 (f' k) Hf'kX Hf'kinf.
              assume Hgf'kf'k: g (f' k) :e f' k.
              assume _.
              exact Hgf'kf'k.
        }
        prove u :e f (f' m).
        exact Hf'S m Hm (fun w _ => u :e w) Luf'Sm.
      - prove equip (Y :\: {g (f' m)}) n.
        apply equip_ordsucc_remove1.
        + exact Hgf'mY.
        + prove equip Y (ordsucc n). exact HYSn.
    }
    claim LCSn: forall Y c= H', equip Y (ordsucc n) -> C Y = c.
    { let Y.
      assume HYH': Y c= H'.
      assume HYSn: equip Y (ordsucc n).
      prove C Y = c.
      set p : set -> prop := fun m => m :e omega /\ g (f' m) :e Y.
      claim Lpne: exists m, ordinal m /\ p m.
      { apply equip_sym Y (ordsucc n) HYSn.
        let h.
        assume Hh: bij (ordsucc n) Y h.
        apply Hh. assume H _. apply H.
        assume Hh1: forall i :e ordsucc n, h i :e Y.
        assume _.
        claim LhnY: h n :e Y.
        { apply Hh1. apply ordsuccI2. }
        apply ReplE_impred omega (fun n => g (f' n)) (h n) (HYH' (h n) LhnY).
        let m.
        assume Hm: m :e omega.
        assume Hhnm: h n = g (f' m).
        witness m.
        apply andI.
        - prove ordinal m. apply nat_p_ordinal. apply omega_nat_p. exact Hm.
        - prove m :e omega /\ g (f' m) :e Y.
          apply andI.
          + exact Hm.
          + rewrite <- Hhnm. exact LhnY.
      }
      apply least_ordinal_ex p Lpne.
      let m. assume H. apply H. assume H. apply H.
      assume Hmo: ordinal m.
      assume Hpm: m :e omega /\ g (f' m) :e Y.
      assume Hpk: forall k :e m, ~(k :e omega /\ g (f' k) :e Y).
      apply Hpm.
      assume Hm: m :e omega.
      assume Hgf'm: g (f' m) :e Y.
      prove C Y = c.
      apply LCSnlem m (omega_nat_p m Hm) Y HYH' HYSn Hgf'm.
      let k. assume Hk: k :e m.
      prove g (f' k) /:e Y.
      assume Hgf'k: g (f' k) :e Y.
      apply Hpk k Hk. apply andI.
      - prove k :e omega.
        apply nat_p_omega.
        exact nat_p_trans m (omega_nat_p m Hm) k Hk.
      - prove g (f' k) :e Y. exact Hgf'k.
    }
    apply H2.
    witness H'. apply andI.
    * prove H' c= X. exact LH'X.
    * { witness c. apply andI.
        - apply ordsuccI2.
        - apply andI.
          + prove infinite H'. exact LH'inf.
          + exact LCSn.
      }
Qed.

End InfiniteRamsey.

(*** Injection of set into itself that will correspond to x |-> (1,x) after pairing is defined. ***)
Definition Inj1 : set -> set := In_rec_i (fun X f => {0} :\/: {f x|x :e X}).

Theorem Inj1_eq : forall X:set, Inj1 X = {0} :\/: {Inj1 x|x :e X}.
claim L1: forall X:set, forall g h:set->set, (forall x :e X, g x = h x)
                         -> {0} :\/: {g x|x :e X} = {0} :\/: {h x|x :e X}.
{
  let X g h.
   assume H: forall x :e X, g x = h x.
   claim L1a: {g x|x :e X} = {h x|x :e X}.
   {
     exact (ReplEq_ext X g h H).
   }
   prove {0} :\/: {g x|x :e X} = {0} :\/: {h x|x :e X}.
   rewrite L1a.
   reflexivity.
}
exact (In_rec_i_eq (fun X f => {0} :\/: {f x|x :e X}) L1).
Qed.

Theorem Inj1I1 : forall X:set, 0 :e Inj1 X.
let X.
rewrite (Inj1_eq X).
prove 0 :e {0} :\/: {Inj1 x|x :e X}.
apply binunionI1.
apply SingI.
Qed.

Theorem Inj1I2 : forall X x:set, x :e X -> Inj1 x :e Inj1 X.
let X x.
assume H: x :e X.
rewrite (Inj1_eq X).
prove Inj1 x :e {0} :\/: {Inj1 x|x :e X}.
apply binunionI2.
exact (ReplI X Inj1 x H).
Qed.

Theorem Inj1E : forall X y:set, y :e Inj1 X -> y = 0 \/ exists x :e X, y = Inj1 x.
let X y.
rewrite (Inj1_eq X).
assume H1: y :e {0} :\/: {Inj1 x|x :e X}.
prove y = 0 \/ exists x :e X, y = Inj1 x.
apply (binunionE {0} {Inj1 x|x :e X} y H1).
- assume H2: y :e {0}.
  apply orIL.
  exact (SingE 0 y H2).
- assume H2: y :e {Inj1 x|x :e X}.
  apply orIR.
  prove exists x :e X, y = Inj1 x.
  exact (ReplE X Inj1 y H2).
Qed.

Theorem Inj1NE1 : forall x:set, Inj1 x <> 0.
let x.
assume H1: Inj1 x = 0.
apply (EmptyE 0).
prove 0 :e 0.
rewrite <- H1 at 2.
prove 0 :e Inj1 x.
exact (Inj1I1 x).
Qed.

Theorem Inj1NE2 : forall x:set, Inj1 x /:e {0}.
let x.
assume H1: Inj1 x :e {0}.
exact (Inj1NE1 x (SingE 0 (Inj1 x) H1)).
Qed.

(*** Injection of set into itself that will correspond to x |-> (0,x) after pairing is defined. ***)
Definition Inj0 : set -> set := fun X => {Inj1 x|x :e X}.

Theorem Inj0I : forall X x:set, x :e X -> Inj1 x :e Inj0 X.
exact (fun X x H => ReplI X Inj1 x H).
Qed.

Theorem Inj0E : forall X y:set, y :e Inj0 X -> exists x:set, x :e X /\ y = Inj1 x.
exact (fun X y H => ReplE X Inj1 y H).
Qed.

(*** Unj : Left inverse of Inj1 and Inj0 ***)
Definition Unj : set -> set := In_rec_i (fun X f => {f x|x :e X :\: {0}}).

Theorem Unj_eq : forall X:set, Unj X = {Unj x|x :e X :\: {0}}.
claim L1: forall X:set, forall g h:set->set, (forall x :e X, g x = h x) -> {g x|x :e X :\: {0}} = {h x|x :e X :\: {0}}.
{
  let X g h.
  assume H1: forall x :e X, g x = h x.
  prove {g x|x :e X :\: {0}} = {h x|x :e X :\: {0}}.
  apply (ReplEq_ext (X :\: {0}) g h).
  let x.
  assume H2: x :e X :\: {0}.
  prove g x = h x.
  apply H1.
  prove x :e X.
  exact (setminusE1 X {0} x H2).
}
exact (In_rec_i_eq (fun X f => {f x|x :e X :\: {0}}) L1).
Qed.

Theorem Unj_Inj1_eq : forall X:set, Unj (Inj1 X) = X.
apply In_ind.
let X.
assume IH: forall x :e X, Unj (Inj1 x) = x.
prove Unj (Inj1 X) = X.
rewrite Unj_eq.
prove {Unj x|x :e Inj1 X :\: {0}} = X.
apply set_ext.
- prove {Unj x|x :e Inj1 X :\: {0}} c= X.
  let x.
  assume H1: x :e {Unj x|x :e Inj1 X :\: {0}}.
  prove x :e X.
  apply (ReplE_impred (Inj1 X :\: {0}) Unj x H1).
  let y.
  assume H2: y :e Inj1 X :\: {0}.
  assume H3: x = Unj y.
  rewrite H3.
  prove Unj y :e X.
  apply (setminusE (Inj1 X) {0} y H2).
  assume H4: y :e Inj1 X.
  assume H5: y /:e {0}.
  apply (Inj1E X y H4).
  + assume H6: y = 0.
    prove False.
    apply H5.
    rewrite H6.
    prove 0 :e {0}.
    apply SingI.
  + assume H6: exists x :e X, y = Inj1 x.
    apply (exandE_i (fun x => x :e X) (fun x => y = Inj1 x) H6).
    let z.
    assume H7: z :e X.
    assume H8: y = Inj1 z.
    rewrite H8.
    prove Unj (Inj1 z) :e X.
    rewrite (IH z H7).
    prove z :e X.
    exact H7.
- prove X c= {Unj x|x :e Inj1 X :\: {0}}.
  let x.
  assume H1: x :e X.
  prove x :e {Unj x|x :e Inj1 X :\: {0}}.
  rewrite <- (IH x H1).
  prove Unj (Inj1 x) :e {Unj x|x :e Inj1 X :\: {0}}.
  apply (ReplI (Inj1 X :\: {0}) Unj).
  prove Inj1 x :e Inj1 X :\: {0}.
  apply setminusI.
  + exact (Inj1I2 X x H1).
  + prove Inj1 x /:e {0}.
    exact (Inj1NE2 x).
Qed.

Theorem Inj1_inj : forall X Y:set, Inj1 X = Inj1 Y -> X = Y.
let X Y.
assume H1: Inj1 X = Inj1 Y.
prove X = Y.
rewrite <- (Unj_Inj1_eq X).
rewrite <- (Unj_Inj1_eq Y).
rewrite H1.
reflexivity.
Qed.

Theorem Unj_Inj0_eq : forall X:set, Unj (Inj0 X) = X.
let X.
rewrite (Unj_eq (Inj0 X)).
prove {Unj x|x :e Inj0 X :\: {0}} = X.
apply set_ext.
- prove {Unj x|x :e Inj0 X :\: {0}} c= X.
  let x.
  assume H1: x :e {Unj x|x :e Inj0 X :\: {0}}.
  prove x :e X.
  apply (ReplE_impred (Inj0 X :\: {0}) Unj x H1).
  let y.
  assume H2: y :e Inj0 X :\: {0}.
  assume H3: x = Unj y.
  apply (setminusE (Inj0 X) {0} y H2).
  assume H4: y :e {Inj1 x|x :e X}.
  assume H5: y /:e {0}.
  apply (ReplE_impred X Inj1 y H4).
  let z.
  assume H6: z :e X.
  assume H7: y = Inj1 z.
  claim L1: x = z.
  {
    rewrite H3.
    prove Unj y = z.
    rewrite H7.
    prove Unj (Inj1 z) = z.
    exact (Unj_Inj1_eq z).
  }
  prove x :e X.
  rewrite L1.
  prove z :e X.
  exact H6.
- prove X c= {Unj x|x :e Inj0 X :\: {0}}.
  let x.
  assume H1: x :e X.
  prove x :e {Unj x|x :e Inj0 X :\: {0}}.
  rewrite <- (Unj_Inj1_eq x).
  prove Unj (Inj1 x) :e {Unj x|x :e Inj0 X :\: {0}}.
  apply (ReplI (Inj0 X :\: {0}) Unj).
  prove Inj1 x :e Inj0 X :\: {0}.
  apply setminusI.
  + prove Inj1 x :e {Inj1 x|x :e X}.
    apply ReplI.
    exact H1.
  + prove Inj1 x /:e {0}.
    exact (Inj1NE2 x).
Qed.

Theorem Inj0_inj : forall X Y:set, Inj0 X = Inj0 Y -> X = Y.
let X Y.
assume H1: Inj0 X = Inj0 Y.
prove X = Y.
rewrite <- (Unj_Inj0_eq X).
rewrite <- (Unj_Inj0_eq Y).
rewrite H1.
reflexivity.
Qed.

Theorem Inj0_0 : Inj0 0 = 0.
exact (Repl_Empty Inj1).
Qed.

Theorem Inj0_Inj1_neq : forall X Y:set, Inj0 X <> Inj1 Y.
let X Y.
assume H1 : Inj0 X = Inj1 Y.
claim L1: 0 :e Inj1 Y.
{ exact (Inj1I1 Y). }
claim L2: 0 :e Inj0 X.
{ rewrite H1. exact L1. }
apply (Inj0E X 0 L2).
let x.
assume H2: x :e X /\ 0 = Inj1 x.
apply Inj1NE1 x.
symmetry.
exact andER (x :e X) (0 = Inj1 x) H2.
Qed.

(*** setsum ***)
Definition setsum : set -> set -> set := fun X Y => {Inj0 x|x :e X} :\/: {Inj1 y|y :e Y}.
(* Unicode :+: "002b" *)
Infix :+: 450 left := setsum.

Theorem Inj0_setsum : forall X Y x:set, x :e X -> Inj0 x :e X :+: Y.
let X Y x.
assume H: x :e X.
prove Inj0 x :e {Inj0 x|x :e X} :\/: {Inj1 y|y :e Y}.
apply binunionI1.
prove Inj0 x :e {Inj0 x|x :e X}.
apply ReplI.
exact H.
Qed.

Theorem Inj1_setsum : forall X Y y:set, y :e Y -> Inj1 y :e X :+: Y.
let X Y y.
assume H: y :e Y.
prove Inj1 y :e {Inj0 x|x :e X} :\/: {Inj1 y|y :e Y}.
apply binunionI2.
prove Inj1 y :e {Inj1 y|y :e Y}.
apply ReplI.
exact H.
Qed.

Theorem setsum_Inj_inv : forall X Y z:set, z :e X :+: Y -> (exists x :e X, z = Inj0 x) \/ (exists y :e Y, z = Inj1 y).
let X Y z.
assume H1 : z :e {Inj0 x|x :e X} :\/: {Inj1 y|y :e Y}.
apply (binunionE {Inj0 x|x :e X} {Inj1 y|y :e Y} z H1).
- assume H2: z :e {Inj0 x|x :e X}.
  apply orIL.
  exact (ReplE X Inj0 z H2).
- assume H2: z :e {Inj1 y|y :e Y}.
  apply orIR.
  exact (ReplE Y Inj1 z H2).
Qed.

Theorem Inj0_setsum_0L : forall X:set, 0 :+: X = Inj0 X.
let X. apply set_ext.
- let z.
  assume H1: z :e 0 :+: X.
  prove z :e Inj0 X.
  apply (setsum_Inj_inv 0 X z H1).
  + assume H2: exists x :e 0, z = Inj0 x.
    apply (exandE_i (fun x => x :e 0) (fun x => z = Inj0 x) H2).
    let x.
    assume H3: x :e 0.
    prove False.
    exact (EmptyE x H3).
  + assume H2: exists x :e X, z = Inj1 x.
    apply (exandE_i (fun x => x :e X) (fun x => z = Inj1 x) H2).
    let x.
    assume H3: x :e X.
    assume H4: z = Inj1 x.
    rewrite H4.
    prove Inj1 x :e Inj0 X.
    exact (Inj0I X x H3).
- let z.
  assume H1: z :e Inj0 X.
  prove z :e 0 :+: X.
  apply (exandE_i (fun x => x :e X) (fun x => z = Inj1 x) (Inj0E X z H1)).
  let x.
  assume H2: x :e X.
  assume H3: z = Inj1 x.
  rewrite H3.
  prove Inj1 x :e 0 :+: X.
  apply Inj1_setsum.
  exact H2.
Qed.

Theorem Inj1_setsum_1L : forall X:set, 1 :+: X = Inj1 X.
let X. apply set_ext.
- let z.
  assume H1: z :e 1 :+: X.
  prove z :e Inj1 X.
  apply (setsum_Inj_inv 1 X z H1).
  + assume H2: exists x :e 1, z = Inj0 x.
    apply (exandE_i (fun x => x :e 1) (fun x => z = Inj0 x) H2).
    let x.
    assume H3: x :e 1.
    assume H4: z = Inj0 x.
    rewrite H4.
    prove Inj0 x :e Inj1 X.
    claim L1: x = 0.
    { exact (SingE 0 x (Subq_1_Sing0 x H3)). }
    rewrite L1.
    prove Inj0 0 :e Inj1 X.
    rewrite Inj0_0.
    prove 0 :e Inj1 X.
    exact (Inj1I1 X).
  + assume H2: exists x :e X, z = Inj1 x.
    apply (exandE_i (fun x => x :e X) (fun x => z = Inj1 x) H2).
    let x.
    assume H3: x :e X.
    assume H4: z = Inj1 x.
    rewrite H4.
    prove Inj1 x :e Inj1 X.
    exact (Inj1I2 X x H3).
- let z.
  assume H1: z :e Inj1 X.
  prove z :e 1 :+: X.
  apply (Inj1E X z H1).
  + assume H2: z = 0.
    rewrite H2.
    prove 0 :e 1 :+: X.
    rewrite <- Inj0_0 at 1. (*** This is a little tricky. Recall that 1 is notation for ordsucc 0, so without "at 1" this hidden 0 would also be rewritten. ***)
    prove Inj0 0 :e 1 :+: X.
    apply Inj0_setsum.
    prove 0 :e 1.
    exact In_0_1.
  + assume H2: exists x :e X, z = Inj1 x.
    apply (exandE_i (fun x => x :e X) (fun x => z = Inj1 x) H2).
    let x.
    assume H2: x :e X.
    assume H3: z = Inj1 x.
    rewrite H3.
    prove Inj1 x :e 1 :+: X.
    apply Inj1_setsum.
    exact H2.
Qed.

Section pair_setsum.
Let pair := setsum.
Definition proj0 : set -> set := fun Z => {Unj z|z :e Z, exists x:set, Inj0 x = z}.
Definition proj1 : set -> set := fun Z => {Unj z|z :e Z, exists y:set, Inj1 y = z}.

Theorem Inj0_pair_0_eq : Inj0 = pair 0.
apply (func_ext set set).
let x.
symmetry.
prove 0 :+: x = Inj0 x.
exact (Inj0_setsum_0L x).
Qed.

Theorem Inj1_pair_1_eq : Inj1 = pair 1.
apply (func_ext set set).
let x.
symmetry.
prove 1 :+: x = Inj1 x.
exact (Inj1_setsum_1L x).
Qed.

Theorem pairI0 : forall X Y x, x :e X -> pair 0 x :e pair X Y.
rewrite <- Inj0_pair_0_eq.
exact Inj0_setsum.
Qed.

Theorem pairI1 : forall X Y y, y :e Y -> pair 1 y :e pair X Y.
rewrite <- Inj1_pair_1_eq.
exact Inj1_setsum.
Qed.

Theorem pairE : forall X Y z, z :e pair X Y -> (exists x :e X, z = pair 0 x) \/ (exists y :e Y, z = pair 1 y).
rewrite <- Inj0_pair_0_eq.
rewrite <- Inj1_pair_1_eq.
exact setsum_Inj_inv.
Qed.

Theorem pairE0 : forall X Y x, pair 0 x :e pair X Y -> x :e X.
let X Y x.
assume H1: pair 0 x :e pair X Y.
prove x :e X.
apply (pairE X Y (pair 0 x) H1).
- rewrite <- Inj0_pair_0_eq.
  assume H2: exists x' :e X, Inj0 x = Inj0 x'.
  apply (exandE_i (fun x' => x' :e X) (fun x' => Inj0 x = Inj0 x') H2).
  let x'.
  assume H3: x' :e X.
  assume H4: Inj0 x = Inj0 x'.
  prove x :e X.
  rewrite (Inj0_inj x x' H4).
  prove x' :e X.
  exact H3.
- rewrite <- Inj0_pair_0_eq.
  rewrite <- Inj1_pair_1_eq.
  assume H2: exists y :e Y, Inj0 x = Inj1 y.
  prove False.
  apply (exandE_i (fun y => y :e Y) (fun y => Inj0 x = Inj1 y) H2).
  let y.
  assume _.
  assume H3: Inj0 x = Inj1 y.
  exact (Inj0_Inj1_neq x y H3).
Qed.

Theorem pairE1 : forall X Y y, pair 1 y :e pair X Y -> y :e Y.
let X Y y.
assume H1: pair 1 y :e pair X Y.
prove y :e Y.
apply (pairE X Y (pair 1 y) H1).
- rewrite <- Inj0_pair_0_eq.
  rewrite <- Inj1_pair_1_eq.
  assume H2: exists x :e X, Inj1 y = Inj0 x.
  prove False.
  apply (exandE_i (fun x => x :e X) (fun x => Inj1 y = Inj0 x) H2).
  let x.
  assume _.
  assume H3: Inj1 y = Inj0 x.
  apply (Inj0_Inj1_neq x y).
  symmetry.
  exact H3.
- rewrite <- Inj1_pair_1_eq.
  assume H2: exists y' :e Y, Inj1 y = Inj1 y'.
  apply (exandE_i (fun y' => y' :e Y) (fun y' => Inj1 y = Inj1 y') H2).
  let y'.
  assume H3: y' :e Y.
  assume H4: Inj1 y = Inj1 y'.
  prove y :e Y.
  rewrite (Inj1_inj y y' H4).
  prove y' :e Y.
  exact H3.
Qed.

Theorem proj0I : forall w u:set, pair 0 u :e w -> u :e proj0 w.
rewrite <- Inj0_pair_0_eq.
let w u.
assume H1: Inj0 u :e w.
prove u :e {Unj z|z :e w, exists x:set, Inj0 x = z}.
rewrite <- (Unj_Inj0_eq u).
prove Unj (Inj0 u) :e {Unj z|z :e w, exists x:set, Inj0 x = z}.
apply (ReplSepI w (fun z => exists x:set, Inj0 x = z) Unj (Inj0 u)).
- prove Inj0 u :e w.
  exact H1.
- prove exists x, Inj0 x = Inj0 u.
  witness u.
  reflexivity.
Qed.

Theorem proj0E : forall w u:set, u :e proj0 w -> pair 0 u :e w.
let w u.
assume H1: u :e {Unj z|z :e w, exists x:set, Inj0 x = z}.
rewrite <- Inj0_pair_0_eq.
prove Inj0 u :e w.
apply (ReplSepE_impred w (fun z => exists x:set, Inj0 x = z) Unj u H1).
let z.
assume H2: z :e w.
assume H3: exists x, Inj0 x = z.
assume H4: u = Unj z.
apply H3.
let x.
assume H5: Inj0 x = z.
prove Inj0 u :e w.
rewrite H4.
prove Inj0 (Unj z) :e w.
rewrite <- H5.
prove Inj0 (Unj (Inj0 x)) :e w.
rewrite Unj_Inj0_eq.
prove Inj0 x :e w.
rewrite H5.
exact H2.
Qed.

Theorem proj1I : forall w u:set, pair 1 u :e w -> u :e proj1 w.
rewrite <- Inj1_pair_1_eq.
let w u.
assume H1: Inj1 u :e w.
prove u :e {Unj z|z :e w, exists y:set, Inj1 y = z}.
rewrite <- (Unj_Inj1_eq u).
prove Unj (Inj1 u) :e {Unj z|z :e w, exists y:set, Inj1 y = z}.
apply (ReplSepI w (fun z => exists y:set, Inj1 y = z) Unj (Inj1 u)).
- prove Inj1 u :e w.
  exact H1.
- prove exists y, Inj1 y = Inj1 u.
  witness u.
  reflexivity.
Qed.

Theorem proj1E : forall w u:set, u :e proj1 w -> pair 1 u :e w.
let w u.
assume H1: u :e {Unj z|z :e w, exists y:set, Inj1 y = z}.
rewrite <- Inj1_pair_1_eq.
prove Inj1 u :e w.
apply (ReplSepE_impred w (fun z => exists y:set, Inj1 y = z) Unj u H1).
let z.
assume H2: z :e w.
assume H3: exists y, Inj1 y = z.
assume H4: u = Unj z.
apply H3.
let y.
assume H5: Inj1 y = z.
prove Inj1 u :e w.
rewrite H4.
prove Inj1 (Unj z) :e w.
rewrite <- H5.
prove Inj1 (Unj (Inj1 y)) :e w.
rewrite Unj_Inj1_eq.
prove Inj1 y :e w.
rewrite H5.
exact H2.
Qed.

Theorem proj0_pair_eq : forall X Y:set, proj0 (pair X Y) = X.
let X Y. apply set_ext.
- prove proj0 (pair X Y) c= X.
  let u.
  assume H1: u :e proj0 (pair X Y).
  prove u :e X.
  apply (pairE0 X Y u).
  prove pair 0 u :e pair X Y.
  exact (proj0E (pair X Y) u H1).
- prove X c= proj0 (pair X Y).
  let u.
  assume H1: u :e X.
  prove u :e proj0 (pair X Y).
  apply proj0I.
  prove pair 0 u :e pair X Y.
  apply pairI0.
  prove u :e X.
  exact H1.
Qed.

Theorem proj1_pair_eq : forall X Y:set, proj1 (pair X Y) = Y.
let X Y. apply set_ext.
- prove proj1 (pair X Y) c= Y.
  let u.
  assume H1: u :e proj1 (pair X Y).
  prove u :e Y.
  apply (pairE1 X Y u).
  prove pair 1 u :e pair X Y.
  exact (proj1E (pair X Y) u H1).
- prove Y c= proj1 (pair X Y).
  let u.
  assume H1: u :e Y.
  prove u :e proj1 (pair X Y).
  apply proj1I.
  prove pair 1 u :e pair X Y.
  apply pairI1.
  prove u :e Y.
  exact H1.
Qed.

Opaque add_nat mul_nat omega ordsucc setminus binintersect ReplSep Sep famunion binunion Sing UPair exactly1of2 If_i If_ii If_iii Descr_Vo1 Descr_iii Descr_ii inv In_rec_i In_rec_ii In_rec_iii.

(*** Sigma X Y = {(x,y) | x in X, y in Y x} ***)
Definition Sigma : set -> (set -> set) -> set :=
fun X Y => \/_ x :e X, {pair x y|y :e Y x}.
(* Unicode Sigma_ "2211" *)
Binder+ Sigma_ , := Sigma.

Theorem Sigma_eta_proj0_proj1 : forall X:set, forall Y:set -> set, forall z :e (Sigma_ x :e X, Y x), pair (proj0 z) (proj1 z) = z /\ proj0 z :e X /\ proj1 z :e Y (proj0 z).
let X Y z.
assume H1: z :e Sigma_ x :e X, Y x.
claim L1: exists x :e X, z :e {pair x y|y :e Y x}.
{ exact (famunionE X (fun x => {pair x y|y :e Y x}) z H1). }
apply (exandE_i (fun x => x :e X) (fun x => z :e {pair x y|y :e Y x}) L1).
let x.
assume H2: x :e X.
assume H3: z :e {pair x y|y :e Y x}.
apply (ReplE_impred (Y x) (pair x) z H3).
let y.
assume H4: y :e Y x.
assume H5: z = pair x y.
rewrite H5.
prove pair (proj0 (pair x y)) (proj1 (pair x y)) = pair x y /\ proj0 (pair x y) :e X /\ proj1 (pair x y) :e Y (proj0 (pair x y)).
rewrite proj0_pair_eq.
prove pair x (proj1 (pair x y)) = pair x y /\ x :e X /\ proj1 (pair x y) :e Y x.
rewrite proj1_pair_eq.
prove pair x y = pair x y /\ x :e X /\ y :e Y x.
apply and3I.
- prove pair x y = pair x y.
  reflexivity.
- prove x :e X.
  exact H2.
- prove y :e Y x.
  exact H4.
Qed.

Theorem proj0_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> proj0 z :e X.
let X Y z.
assume H1: z :e Sigma_ x :e X, Y x.
apply (and3E (pair (proj0 z) (proj1 z) = z) (proj0 z :e X) (proj1 z :e Y (proj0 z)) (Sigma_eta_proj0_proj1 X Y z H1)).
assume _ H2 _.
exact H2.
Qed.

Theorem proj1_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> proj1 z :e Y (proj0 z).
let X Y z.
assume H1: z :e Sigma_ x :e X, Y x.
apply (and3E (pair (proj0 z) (proj1 z) = z) (proj0 z :e X) (proj1 z :e Y (proj0 z)) (Sigma_eta_proj0_proj1 X Y z H1)).
assume _ _ H2.
exact H2.
Qed.

Theorem pair_Sigma : forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, pair x y :e Sigma_ x :e X, Y x.
let X Y x.
assume Hx: x :e X.
let y.
assume Hy: y :e Y x.
prove pair x y :e \/_ x :e X, {pair x y|y :e Y x}.
apply (famunionI X (fun x => {pair x y|y :e Y x}) x (pair x y)).
- prove x :e X.
  exact Hx.
- prove pair x y :e {pair x y|y :e Y x}.
  apply ReplI.
  prove y :e Y x.
  exact Hy.
Qed.

Theorem pair_Sigma_E1 : forall X:set, forall Y:set->set, forall x y:set, pair x y :e (Sigma_ x :e X, Y x) -> y :e Y x.
let X Y x y.
assume H1: pair x y :e Sigma_ x :e X, Y x.
prove y :e Y x.
rewrite <- (proj0_pair_eq x y).
prove y :e Y (proj0 (pair x y)).
rewrite <- (proj1_pair_eq x y) at 1.
prove proj1 (pair x y) :e Y (proj0 (pair x y)).
exact (proj1_Sigma X Y (pair x y) H1).
Qed.

Theorem Sigma_E : forall X:set, forall Y:set->set, forall z:set, z :e (Sigma_ x :e X, Y x) -> exists x :e X, exists y :e Y x, z = pair x y.
let X Y z.
assume Hz: z :e Sigma_ x :e X, Y x.
apply (and3E (pair (proj0 z) (proj1 z) = z) (proj0 z :e X) (proj1 z :e Y (proj0 z)) (Sigma_eta_proj0_proj1 X Y z Hz)).
assume H1: pair (proj0 z) (proj1 z) = z.
assume H2: proj0 z :e X.
assume H3: proj1 z :e Y (proj0 z).
witness (proj0 z).
apply andI.
- prove proj0 z :e X. exact H2.
- witness (proj1 z).
  apply andI.
  + prove proj1 z :e Y (proj0 z). exact H3.
  + prove z = pair (proj0 z) (proj1 z).
    symmetry.
    exact H1.
Qed.

Definition setprod : set->set->set := fun X Y:set => Sigma_ x :e X, Y.
(* Unicode :*: "2a2f" *)
Infix :*: 440 left := setprod.
(*** lam X F = {(x,y) | x :e X, y :e F x} = \/_{x :e X} {(x,y) | y :e (F x)} = Sigma X F ***)
Let lam : set -> (set -> set) -> set := Sigma.
(***  ap f x = {proj1 z | z :e f,  exists y, z = pair x y}} ***)
Definition ap : set -> set -> set := fun f x => {proj1 z|z :e f, exists y:set, z = pair x y}.
Notation SetImplicitOp ap.
Notation SetLam Sigma.

Theorem lamI : forall X:set, forall F:set->set, forall x :e X, forall y :e F x, pair x y :e fun x :e X => F x.
exact pair_Sigma.
Qed.

Theorem lamE : forall X:set, forall F:set->set, forall z:set, z :e (fun x :e X => F x) -> exists x :e X, exists y :e F x, z = pair x y.
exact Sigma_E.
Qed.

Theorem apI : forall f x y, pair x y :e f -> y :e f x.
let f x y.
assume H1: pair x y :e f.
prove y :e {proj1 z|z :e f, exists y:set, z = pair x y}.
rewrite <- (proj1_pair_eq x y).
prove proj1 (pair x y) :e {proj1 z|z :e f, exists y:set, z = pair x y}.
apply (ReplSepI f (fun z => exists y:set, z = pair x y) proj1 (pair x y) H1).
prove exists y':set, pair x y = pair x y'.
witness y.
reflexivity.
Qed.

Theorem apE : forall f x y, y :e f x -> pair x y :e f.
let f x y.
assume H1: y :e {proj1 z|z :e f, exists y:set, z = pair x y}.
prove pair x y :e f.
apply (ReplSepE_impred f (fun z => exists y:set, z = pair x y) proj1 y H1).
let z.
assume Hz: z :e f.
assume H1: exists y:set, z = pair x y.
assume H2: y = proj1 z.
apply H1.
let v.
assume H3: z = pair x v.
claim L1: y = v.
{
  rewrite H2.
  rewrite H3.
  prove proj1 (pair x v) = v.
  apply proj1_pair_eq.
}
claim L2: z = pair x y.
{
  rewrite L1.
  exact H3.
}
rewrite <- L2.
exact Hz.
Qed.

Theorem beta : forall X:set, forall F:set -> set, forall x:set, x :e X -> (fun x :e X => F x) x = F x.
let X F x.
assume Hx: x :e X.
apply set_ext.
- let w.
  assume Hw: w :e (fun x :e X => F x) x.
  claim L1: pair x w :e (fun x :e X => F x).
  { exact (apE (fun x :e X => F x) x w Hw). }
  exact (pair_Sigma_E1 X F x w L1).
- let w.
  assume Hw: w :e F x.
  prove w :e (fun x :e X => F x) x.
  apply apI.
  prove pair x w :e fun x :e X => F x.
  prove pair x w :e Sigma_ x :e X, F x.
  apply pair_Sigma.
  + exact Hx.
  + exact Hw.
Qed.

Theorem proj0_ap_0 : forall u, proj0 u = u 0.
let u. apply set_ext.
- let w.
  assume H1: w :e proj0 u.
  prove w :e u 0.
  apply apI.
  prove pair 0 w :e u.
  apply proj0E.
  prove w :e proj0 u.
  exact H1.
- let w.
  assume H1: w :e u 0.
  prove w :e proj0 u.
  apply proj0I.
  prove pair 0 w :e u.
  apply apE.
  prove w :e u 0.
  exact H1.
Qed.

Theorem proj1_ap_1 : forall u, proj1 u = u 1.
let u. apply set_ext.
- let w.
  assume H1: w :e proj1 u.
  prove w :e u 1.
  apply apI.
  prove pair 1 w :e u.
  apply proj1E.
  prove w :e proj1 u.
  exact H1.
- let w.
  assume H1: w :e u 1.
  prove w :e proj1 u.
  apply proj1I.
  prove pair 1 w :e u.
  apply apE.
  prove w :e u 1.
  exact H1.
Qed.

Theorem pair_ap_0 : forall x y:set, (pair x y) 0 = x.
let x y.
rewrite <- (proj0_ap_0 (pair x y)).
prove proj0 (pair x y) = x.
apply proj0_pair_eq.
Qed.

Theorem pair_ap_1 : forall x y:set, (pair x y) 1 = y.
let x y.
rewrite <- (proj1_ap_1 (pair x y)).
prove proj1 (pair x y) = y.
apply proj1_pair_eq.
Qed.

Theorem ap0_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> (z 0) :e X.
let X Y z.
rewrite <- proj0_ap_0.
apply proj0_Sigma.
Qed.

Theorem ap1_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> (z 1) :e (Y (z 0)).
let X Y z.
rewrite <- proj0_ap_0.
rewrite <- proj1_ap_1.
apply proj1_Sigma.
Qed.

Definition pair_p:set->prop
:= fun u:set => pair (u 0) (u 1) = u.

Theorem pair_p_I : forall x y, pair_p (pair x y).
let x y.
prove pair (pair x y 0) (pair x y 1) = pair x y.
rewrite pair_ap_0.
rewrite pair_ap_1.
reflexivity.
Qed.

Theorem Subq_2_UPair01 : 2 c= {0,1}.
let x.
assume H1: x :e 2.
apply ordsuccE 1 x H1.
- assume H2: x :e 1.
  claim L1: x = 0.
  { exact (SingE 0 x (Subq_1_Sing0 x H2)). }
  prove x :e {0,1}.
  rewrite L1.
  prove 0 :e {0,1}.
  exact (UPairI1 0 1).
- assume H2: x = 1.
  prove x :e {0,1}.
  rewrite H2.
  prove 1 :e {0,1}.
  exact (UPairI2 0 1).
Qed.

Theorem tuple_pair : forall x y:set, pair x y = (x,y).
let x y. apply set_ext.
- let z.
  assume Hz: z :e pair x y.
  apply (pairE x y z Hz).
  + assume H1: exists u :e x, z = pair 0 u.
    apply (exandE_i (fun u => u :e x) (fun u => z = pair 0 u) H1).
    let u.
    assume Hu: u :e x.
    assume H2: z = pair 0 u.
    prove z :e (x,y).
    prove z :e fun i :e 2 => if i = 0 then x else y.
    rewrite H2.
    prove pair 0 u :e fun i :e 2 => if i = 0 then x else y.
    apply (lamI 2 (fun i => if i = 0 then x else y) 0 In_0_2 u).
    prove u :e if 0 = 0 then x else y.
    rewrite (If_i_1 (0 = 0) x y (fun q H => H)).
    prove u :e x.
    exact Hu.
  + assume H1: exists u :e y, z = pair 1 u.
    apply (exandE_i (fun u => u :e y) (fun u => z = pair 1 u) H1).
    let u.
    assume Hu: u :e y.
    assume H2: z = pair 1 u.
    prove z :e (x,y).
    prove z :e fun i :e 2 => if i = 0 then x else y.
    rewrite H2.
    prove pair 1 u :e fun i :e 2 => if i = 0 then x else y.
    apply (lamI 2 (fun i => if i = 0 then x else y) 1 In_1_2 u).
    prove u :e if 1 = 0 then x else y.
    rewrite (If_i_0 (1 = 0) x y neq_1_0).
    prove u :e y.
    exact Hu.
- let z.
  assume Hz: z :e (x,y).
  prove z :e pair x y.
  claim L1: exists i :e 2, exists w :e (if i = 0 then x else y), z = pair i w.
  { exact (lamE 2 (fun i => if i = 0 then x else y) z Hz). }
  apply (exandE_i (fun i => i :e 2) (fun i => exists w :e (if i = 0 then x else y), z = pair i w) L1).
  let i.
  assume Hi: i :e 2.
  assume H1: exists w :e (if i = 0 then x else y), z = pair i w.
  apply (exandE_i (fun w => w :e if i = 0 then x else y) (fun w => z = pair i w) H1).
  let w.
  assume Hw: w :e if i = 0 then x else y.
  assume H2: z = pair i w.
  prove z :e pair x y.
  rewrite H2.
  prove pair i w :e pair x y.
  claim L2: i :e {0,1}.
  { exact (Subq_2_UPair01 i Hi). }
  apply (UPairE i 0 1 L2).
  + assume Hi0: i = 0.
    rewrite Hi0.
    prove pair 0 w :e pair x y.
    apply pairI0.
    prove w :e x.
    claim L3: (if i = 0 then x else y) = x.
    { exact (If_i_1 (i = 0) x y Hi0). }
    rewrite <- L3.
    exact Hw.
  + assume Hi1: i = 1.
    rewrite Hi1.
    prove pair 1 w :e pair x y.
    apply pairI1.
    prove w :e y.
    claim L3: (if i = 0 then x else y) = y.
    {
      rewrite Hi1.
      exact (If_i_0 (1 = 0) x y neq_1_0).
    }
    rewrite <- L3.
    exact Hw.
Qed.

Definition Pi : set -> (set -> set) -> set := fun X Y => {f :e Power (Sigma_ x :e X, Union (Y x)) | forall x :e X, f x :e Y x}.
(* Unicode Pi_ "220f" *)
Binder+ Pi_ , := Pi.

Theorem PiI : forall X:set, forall Y:set->set, forall f:set,
    (forall u :e f, pair_p u /\ u 0 :e X) -> (forall x :e X, f x :e Y x) -> f :e Pi_ x :e X, Y x.
let X Y f.
assume H1: forall u :e f, pair_p u /\ u 0 :e X.
assume H2: forall x :e X, f x :e Y x.
prove f :e {f :e Power (Sigma_ x :e X, Union (Y x)) | forall x :e X, f x :e Y x}.
apply SepI.
- prove f :e Power (Sigma_ x :e X, Union (Y x)).
  apply PowerI.
  prove f c= Sigma_ x :e X, Union (Y x).
  let z.
  assume Hz: z :e f.
  prove z :e Sigma_ x :e X, Union (Y x).
  apply (H1 z Hz).
  assume H3: pair (z 0) (z 1) = z.
  assume H4: z 0 :e X.
  rewrite <- H3.
  prove pair (z 0) (z 1) :e Sigma_ x :e X, Union (Y x).
  apply pair_Sigma.
  + prove z 0 :e X.
    exact H4.
  + prove z 1 :e Union (Y (z 0)).
    apply (UnionI (Y (z 0)) (z 1) (f (z 0))).
    * prove z 1 :e f (z 0).
      apply apI.
      prove pair (z 0) (z 1) :e f.
      rewrite H3.
      exact Hz.
    * prove f (z 0) :e Y (z 0).
      exact (H2 (z 0) H4).
- prove forall x :e X, f x :e Y x.
  exact H2.
Qed.

Theorem lam_Pi : forall X:set, forall Y:set -> set, forall F:set -> set,
 (forall x :e X, F x :e Y x) -> (fun x :e X => F x) :e (Pi_ x :e X, Y x).
let X Y F.
assume H1: forall x :e X, F x :e Y x.
prove (fun x :e X => F x) :e (Pi_ x :e X, Y x).
apply PiI.
- prove forall u :e (fun x :e X => F x), pair_p u /\ u 0 :e X.
  let u.
  assume Hu: u :e fun x :e X => F x.
  claim L1: exists x :e X, exists y :e F x, u = pair x y.
  {
    exact (lamE X F u Hu).
  }
  apply (exandE_i (fun x => x :e X) (fun x => exists y :e F x, u = pair x y) L1).
  let x.
  assume Hx: x :e X.
  assume H2: exists y :e F x, u = pair x y.
  apply (exandE_i (fun y => y :e F x) (fun y => u = pair x y) H2).
  let y.
  assume Hy: y :e F x.
  assume H3: u = pair x y.
  apply andI.
  + prove pair_p u.
    rewrite H3.
    apply pair_p_I.
  + prove u 0 :e X.
    rewrite H3.
    prove pair x y 0 :e X.
    rewrite pair_ap_0.
    prove x :e X.
    exact Hx.
- prove forall x :e X, (fun x :e X => F x) x :e Y x.
  let x.
  assume Hx: x :e X.
  rewrite (beta X F x Hx).
  prove F x :e Y x.
  exact (H1 x Hx).
Qed.

Theorem ap_Pi : forall X:set, forall Y:set -> set, forall f:set, forall x:set, f :e (Pi_ x :e X, Y x) -> x :e X -> f x :e Y x.
let X Y f x.
assume Hf: f :e Pi_ x :e X, Y x.
exact (SepE2 (Power (Sigma_ x :e X, Union (Y x))) (fun f => forall x :e X, f x :e Y x) f Hf x).
Qed.

Definition setexp : set->set->set := fun X Y:set => Pi_ y :e Y, X.
(* Superscript :^: *)
Infix :^: 430 left := setexp.

Theorem pair_tuple_fun : pair = (fun x y => (x,y)).
apply func_ext set (set -> set). let x.
apply func_ext set set. let y.
prove pair x y = (x,y).
apply tuple_pair.
Qed.

Section Tuples.
Variable x0 x1: set.

Theorem tuple_2_0_eq: (x0,x1) 0 = x0.
rewrite beta 2 (fun i => if i = 0 then x0 else x1) 0 In_0_2.
apply If_i_1. reflexivity.
Qed.

Theorem tuple_2_1_eq: (x0,x1) 1 = x1.
rewrite beta 2 (fun i => if i = 0 then x0 else x1) 1 In_1_2.
apply If_i_0. apply neq_1_0.
Qed.

End Tuples.

Theorem ReplEq_setprod_ext : forall X Y, forall F G:set -> set -> set, (forall x :e X, forall y :e Y, F x y = G x y) -> {F (w 0) (w 1)|w :e X :*: Y} = {G (w 0) (w 1)|w :e X :*: Y}.
let X Y F G.
assume H1: forall x :e X, forall y :e Y, F x y = G x y.
apply ReplEq_ext (X :*: Y) (fun w => F (w 0) (w 1)) (fun w => G (w 0) (w 1)).
prove forall w :e X :*: Y, F (w 0) (w 1) = G (w 0) (w 1).
let w. assume Hw: w :e X :*: Y.
apply H1.
- prove w 0 :e X. exact ap0_Sigma X (fun _ => Y) w Hw.
- prove w 1 :e Y. exact ap1_Sigma X (fun _ => Y) w Hw.
Qed.

Theorem lamI2 : forall X, forall F:set->set, forall x :e X, forall y :e F x, (x,y) :e fun x :e X => F x.
prove (forall X, forall F:set->set, forall x :e X, forall y :e F x, ((fun x y:set => (x,y)) x y) :e fun x :e X => F x).
rewrite <- pair_tuple_fun.
exact lamI.
Qed.

Theorem tuple_2_Sigma : forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, (x,y) :e Sigma_ x :e X, Y x.
exact lamI2.
Qed.

Theorem tuple_2_setprod : forall X:set, forall Y:set, forall x :e X, forall y :e Y, (x,y) :e X :*: Y.
exact fun X Y x Hx y Hy => tuple_2_Sigma X (fun _ => Y) x Hx y Hy.
Qed.

End pair_setsum.
(* Unicode Sigma_ "2211" *)
Binder+ Sigma_ , := Sigma.
(* Unicode :*: "2a2f" *)
Infix :*: 440 left := setprod.
(* Unicode Pi_ "220f" *)
Binder+ Pi_ , := Pi.
(* Superscript :^: *)
Infix :^: 430 left := setexp.
(* Parameter DescrR_i_io_1 "1f005fdad5c6f98763a15a5e5539088f5d43b7d1be866b0b204fda1ce9ed9248" "1d3fd4a14ef05bd43f5c147d7966cf05fd2fed808eea94f56380454b9a6044b2" *)
Definition DescrR_i_io_1 : (set->(set->prop)->prop) -> set := fun R => Eps_i (fun x => (exists y:set -> prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z)).
(* Parameter DescrR_i_io_2 "28d8599686476258c12dcc5fc5f5974335febd7d5259e1a8e5918b7f9b91ca03" "768eb2ad186988375e6055394e36e90c81323954b8a44eb08816fb7a84db2272" *)
Definition DescrR_i_io_2 : (set->(set->prop)->prop) -> set->prop := fun R => Descr_Vo1 (fun y => R (DescrR_i_io_1 R) y).

Theorem DescrR_i_io_12 : forall R:set->(set->prop)->prop, (exists x, (exists y:set->prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z)) -> R (DescrR_i_io_1 R) (DescrR_i_io_2 R).
let R.
assume H1: exists x, (exists y:set->prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z).
claim L1: (exists y:set->prop, R (DescrR_i_io_1 R) y) /\ (forall y z:set -> prop, R (DescrR_i_io_1 R) y -> R (DescrR_i_io_1 R) z -> y = z).
{ exact (Eps_i_ex (fun x => (exists y:set->prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z)) H1). }
apply L1.
assume H2 H3.
exact Descr_Vo1_prop (fun y => R (DescrR_i_io_1 R) y) H2 H3.
Qed.

(** Conway describes this way of formalizing in ZF in an appendix to Part Zero of his book,
    but rejects formalization in favor of "Mathematician's Liberation."
 **)
Definition PNoEq_ : set -> (set -> prop) -> (set -> prop) -> prop
 := fun alpha p q => forall beta :e alpha, p beta <-> q beta.

Theorem PNoEq_ref_ : forall alpha, forall p:set -> prop, PNoEq_ alpha p p.
let alpha p beta.
assume H2.
apply iff_refl.
Qed.

Theorem PNoEq_sym_ : forall alpha, forall p q:set -> prop, PNoEq_ alpha p q -> PNoEq_ alpha q p.
let alpha p q.
assume H1.
let beta. assume H2.
apply iff_sym.
exact H1 beta H2.
Qed.

Theorem PNoEq_tra_ : forall alpha, forall p q r:set -> prop, PNoEq_ alpha p q -> PNoEq_ alpha q r -> PNoEq_ alpha p r.
let alpha p q r.
assume H1 H2.
let beta. assume H3.
apply iff_trans (p beta) (q beta).
- exact H1 beta H3.
- exact H2 beta H3.
Qed.

Theorem PNoEq_antimon_ : forall p q:set -> prop, forall alpha, ordinal alpha -> forall beta :e alpha, PNoEq_ alpha p q -> PNoEq_ beta p q.
let p q alpha. assume Ha. let beta. assume Hb H1.
let gamma.
assume H2: gamma :e beta.
prove p gamma <-> q gamma.
apply H1.
prove gamma :e alpha.
apply Ha. assume Ha1 _. exact Ha1 beta Hb gamma H2.
Qed.

Definition PNoLt_ : set -> (set -> prop) -> (set -> prop) -> prop
 := fun alpha p q => exists beta :e alpha, PNoEq_ beta p q /\ ~p beta /\ q beta.

Theorem PNoLt_E_ : forall alpha, forall p q:set -> prop, PNoLt_ alpha p q ->
  forall R:prop, (forall beta, beta :e alpha -> PNoEq_ beta p q -> ~p beta -> q beta -> R) -> R.
let alpha p q. assume H1. let R. assume H2.
apply H1.
let beta. assume H3. apply H3.
assume H4: beta :e alpha.
assume H5. apply H5. assume H5. apply H5.
assume H6 H7 H8.
exact H2 beta H4 H6 H7 H8.
Qed.

Theorem PNoLt_irref_ : forall alpha, forall p:set -> prop, ~PNoLt_ alpha p p.
let alpha p. assume H1. apply H1.
let beta. assume H2. apply H2.
assume _ H3. apply H3. assume H3. apply H3.
assume _ H4 H5. exact H4 H5.
Qed.

Theorem PNoLt_mon_ : forall p q:set -> prop, forall alpha, ordinal alpha -> forall beta :e alpha, PNoLt_ beta p q -> PNoLt_ alpha p q.
let p q alpha. assume Ha. let beta. assume Hb H1.
apply H1. let gamma. assume H2. apply H2.
assume H2: gamma :e beta.
assume H3.
prove exists beta :e alpha, PNoEq_ beta p q /\ ~p beta /\ q beta.
witness gamma. apply andI.
- prove gamma :e alpha. apply Ha. assume Ha1 _. exact Ha1 beta Hb gamma H2.
- exact H3.
Qed.

Theorem PNoLt_trichotomy_or_ : forall p q:set -> prop, forall alpha, ordinal alpha
  -> PNoLt_ alpha p q \/ PNoEq_ alpha p q \/ PNoLt_ alpha q p.
let p q.
apply ordinal_ind.
let alpha. assume Ha.
assume IH: forall beta :e alpha, PNoLt_ beta p q \/ PNoEq_ beta p q \/ PNoLt_ beta q p.
apply xm (PNoEq_ alpha p q).
- assume H1: PNoEq_ alpha p q.
  apply orIL. apply orIR. exact H1.
- assume H1: ~PNoEq_ alpha p q.
  claim L1: exists beta, ~(beta :e alpha -> (p beta <-> q beta)).
  { exact not_all_ex_demorgan_i (fun beta => beta :e alpha -> (p beta <-> q beta)) H1. }
  apply L1. let beta. assume H2: ~(beta :e alpha -> (p beta <-> q beta)).
  claim L2: beta :e alpha /\ ~(p beta <-> q beta).
  { apply xm (beta :e alpha).
    - assume H3: beta :e alpha.
      apply xm (p beta <-> q beta).
      + assume H4: p beta <-> q beta.
        prove False.
        apply H2. assume _. exact H4.
      + assume H4: ~(p beta <-> q beta).
        apply andI.
        * exact H3.
        * exact H4.
    - assume H3: beta /:e alpha.
      prove False.
      apply H2.
      assume H4. prove False. exact H3 H4.
  }
  apply L2.
  assume H3: beta :e alpha.
  assume H4: ~(p beta <-> q beta).
  apply IH beta H3. assume H5. apply H5.
  + assume H5: PNoLt_ beta p q. apply orIL. apply orIL.
    exact PNoLt_mon_ p q alpha Ha beta H3 H5.
  + assume H5: PNoEq_ beta p q.
    apply xm (p beta).
    * { assume H6: p beta.
        apply xm (q beta).
        - assume H7: q beta.
          prove False. apply H4. apply iffI.
          + assume _. exact H7.
          + assume _. exact H6.
        - assume H7: ~q beta.
          apply orIR.
          prove exists beta :e alpha, PNoEq_ beta q p /\ ~q beta /\ p beta.
          witness beta. apply andI.
          + exact H3.
          + apply and3I.
            * apply PNoEq_sym_. exact H5.
            * exact H7.
            * exact H6.
      }
    * { assume H6: ~p beta.
        apply xm (q beta).
        - assume H7: q beta.
          apply orIL. apply orIL.
          prove exists beta :e alpha, PNoEq_ beta p q /\ ~p beta /\ q beta.
          witness beta. apply andI.
          + exact H3.
          + apply and3I.
            * exact H5.
            * exact H6.
            * exact H7.
        - assume H7: ~q beta.
          prove False. apply H4. apply iffI.
          + assume H8. prove False. exact H6 H8.
          + assume H8. prove False. exact H7 H8.
      }
  + assume H5: PNoLt_ beta q p. apply orIR.
    exact PNoLt_mon_ q p alpha Ha beta H3 H5.
Qed.

(* Parameter PNoLt "2336eb45d48549dd8a6a128edc17a8761fd9043c180691483bcf16e1acc9f00a" "8f57a05ce4764eff8bc94b278352b6755f1a46566cd7220a5488a4a595a47189" *)
Definition PNoLt : set -> (set -> prop) -> set -> (set -> prop) -> prop
 := fun alpha p beta q =>
        PNoLt_ (alpha :/\: beta) p q
     \/ alpha :e beta /\ PNoEq_ alpha p q /\ q alpha
     \/ beta :e alpha /\ PNoEq_ beta p q /\ ~p beta.

Theorem PNoLtI1 : forall alpha beta, forall p q:set -> prop,
  PNoLt_ (alpha :/\: beta) p q -> PNoLt alpha p beta q.
let alpha beta p q. assume H1.
prove PNoLt_ (alpha :/\: beta) p q
   \/ alpha :e beta /\ PNoEq_ alpha p q /\ q alpha
   \/ beta :e alpha /\ PNoEq_ beta p q /\ ~p beta.
apply or3I1. exact H1.
Qed.

Theorem PNoLtI2 : forall alpha beta, forall p q:set -> prop,
  alpha :e beta -> PNoEq_ alpha p q -> q alpha -> PNoLt alpha p beta q.
let alpha beta p q. assume H1 H2 H3.
prove PNoLt_ (alpha :/\: beta) p q
   \/ alpha :e beta /\ PNoEq_ alpha p q /\ q alpha
   \/ beta :e alpha /\ PNoEq_ beta p q /\ ~p beta.
apply or3I2. apply and3I.
- exact H1.
- exact H2.
- exact H3.
Qed.

Theorem PNoLtI3 : forall alpha beta, forall p q:set -> prop,
  beta :e alpha -> PNoEq_ beta p q -> ~p beta -> PNoLt alpha p beta q.
let alpha beta p q. assume H1 H2 H3.
prove PNoLt_ (alpha :/\: beta) p q
   \/ alpha :e beta /\ PNoEq_ alpha p q /\ q alpha
   \/ beta :e alpha /\ PNoEq_ beta p q /\ ~p beta.
apply or3I3. apply and3I.
- exact H1.
- exact H2.
- exact H3.
Qed.

Theorem PNoLtE : forall alpha beta, forall p q:set -> prop,
  PNoLt alpha p beta q ->
  forall R:prop,
      (PNoLt_ (alpha :/\: beta) p q -> R)
   -> (alpha :e beta -> PNoEq_ alpha p q -> q alpha -> R)
   -> (beta :e alpha -> PNoEq_ beta p q -> ~p beta -> R)
   -> R.
let alpha beta p q.
assume H1. let R. assume HC1 HC2 HC3.
apply H1. assume H1. apply H1.
- exact HC1.
- assume H1. apply H1. assume H1. apply H1. exact HC2.
- assume H1. apply H1. assume H1. apply H1. exact HC3.
Qed.

Theorem PNoLt_irref : forall alpha, forall p:set -> prop, ~PNoLt alpha p alpha p.
let alpha p. assume H1.
apply PNoLtE alpha alpha p p H1.
- assume H1: PNoLt_ (alpha :/\: alpha) p p.
  exact PNoLt_irref_ (alpha :/\: alpha) p H1.
- assume H1: alpha :e alpha. prove False.
  exact In_irref alpha H1.
- assume H1: alpha :e alpha. prove False.
  exact In_irref alpha H1.
Qed.

Theorem PNoLt_trichotomy_or : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q \/ PNoLt beta q alpha p.
let alpha beta p q. assume Ha Hb.
apply Ha. assume Ha1 _.
apply Hb. assume Hb1 _.
claim Lab: ordinal (alpha :/\: beta).
{ exact ordinal_binintersect alpha beta Ha Hb. }
apply PNoLt_trichotomy_or_ p q (alpha :/\: beta) Lab. assume H1. apply H1.
- assume H1: PNoLt_ (alpha :/\: beta) p q.
  apply or3I1. apply PNoLtI1. exact H1.
- assume H1: PNoEq_ (alpha :/\: beta) p q.
  apply ordinal_trichotomy_or alpha beta Ha Hb. assume H2. apply H2.
  + assume H2: alpha :e beta.
    claim L1: alpha :/\: beta = alpha.
    { exact binintersect_Subq_eq_1 alpha beta (Hb1 alpha H2). }
    claim L2: PNoEq_ alpha p q.
    { rewrite <- L1. exact H1. }
    apply xm (q alpha).
    * { assume H3: q alpha.
        apply or3I1.
        apply PNoLtI2.
        - exact H2.
        - prove PNoEq_ alpha p q. exact L2.
        - exact H3.
      }
    * { assume H3: ~q alpha.
        apply or3I3.
        apply PNoLtI3.
        - exact H2.
        - prove PNoEq_ alpha q p. apply PNoEq_sym_. exact L2.
        - exact H3.
      }
  + assume H2: alpha = beta.
    claim L1: alpha :/\: beta = alpha.
    { rewrite <- H2. exact binintersect_Subq_eq_1 alpha alpha (Subq_ref alpha). }
    claim L2: PNoEq_ alpha p q.
    { rewrite <- L1. exact H1. }
    apply or3I2. apply andI.
    * exact H2.
    * prove PNoEq_ alpha p q. exact L2.
  + assume H2: beta :e alpha.
    claim L1: alpha :/\: beta = beta.
    { rewrite binintersect_com.
      exact binintersect_Subq_eq_1 beta alpha (Ha1 beta H2).
    }
    claim L2: PNoEq_ beta p q.
    { rewrite <- L1. exact H1. }
    apply xm (p beta).
    * { assume H3: p beta.
        apply or3I3.
        apply PNoLtI2.
        - exact H2.
        - prove PNoEq_ beta q p. apply PNoEq_sym_. exact L2.
        - exact H3.
      }
    * { assume H3: ~p beta.
        apply or3I1.
        apply PNoLtI3.
        - exact H2.
        - prove PNoEq_ beta p q. exact L2.
        - exact H3.
      }
- assume H1: PNoLt_ (alpha :/\: beta) q p.
  apply or3I3. apply PNoLtI1. rewrite binintersect_com. exact H1.
Qed.

Theorem PNoLtEq_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoEq_ beta q r -> PNoLt alpha p beta r.
let alpha beta. assume Ha Hb.
let p q r.
assume Hpq Hqr.
apply PNoLtE alpha beta p q Hpq.
- assume Hpq1: PNoLt_ (alpha :/\: beta) p q.
  apply Hpq1. let delta. assume Hpq2. apply Hpq2.
  assume Hd: delta :e alpha :/\: beta.
  apply binintersectE alpha beta delta Hd.
  assume Hd1 Hd2.
  assume Hpq3. apply Hpq3. assume Hpq3. apply Hpq3.
  assume Hpq3: PNoEq_ delta p q.
  assume Hpq4: ~p delta.
  assume Hpq5: q delta.
  prove PNoLt alpha p beta r.
  apply PNoLtI1.
  prove exists delta :e alpha :/\: beta, PNoEq_ delta p r /\ ~p delta /\ r delta.
  witness delta. apply andI.
  + exact Hd.
  + apply and3I.
    * { prove PNoEq_ delta p r. apply PNoEq_tra_ delta p q r.
        - prove PNoEq_ delta p q. exact Hpq3.
        - prove PNoEq_ delta q r.
          apply PNoEq_antimon_ q r beta Hb delta Hd2.
          prove PNoEq_ beta q r.
          exact Hqr.
      }
    * prove ~p delta. exact Hpq4.
    * prove r delta. exact iffEL (q delta) (r delta) (Hqr delta Hd2) Hpq5.
- assume Hpq1: alpha :e beta.
  assume Hpq2: PNoEq_ alpha p q.
  assume Hpq3: q alpha.
  prove PNoLt alpha p beta r.
  apply PNoLtI2.
  + prove alpha :e beta. exact Hpq1.
  + prove PNoEq_ alpha p r. apply PNoEq_tra_ alpha p q r.
    * exact Hpq2.
    * prove PNoEq_ alpha q r.
      apply PNoEq_antimon_ q r beta Hb alpha Hpq1.
      exact Hqr.
  + prove r alpha.
    exact iffEL (q alpha) (r alpha) (Hqr alpha Hpq1) Hpq3.
- assume Hpq1: beta :e alpha.
  assume Hpq2: PNoEq_ beta p q.
  assume Hpq3: ~p beta.
  prove PNoLt alpha p beta r.
  apply PNoLtI3.
  + prove beta :e alpha. exact Hpq1.
  + prove PNoEq_ beta p r. apply PNoEq_tra_ beta p q r.
    * exact Hpq2.
    * exact Hqr.
  + prove ~p beta. exact Hpq3.
Qed.

Theorem PNoEqLt_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoEq_ alpha p q -> PNoLt alpha q beta r -> PNoLt alpha p beta r.
let alpha beta. assume Ha Hb.
let p q r.
assume Hpq Hqr.
apply PNoLtE alpha beta q r Hqr.
- assume Hqr1: PNoLt_ (alpha :/\: beta) q r.
  apply Hqr1. let delta. assume Hqr2. apply Hqr2.
  assume Hd: delta :e alpha :/\: beta.
  apply binintersectE alpha beta delta Hd.
  assume Hd1 Hd2.
  assume Hqr3. apply Hqr3. assume Hqr3. apply Hqr3.
  assume Hqr3: PNoEq_ delta q r.
  assume Hqr4: ~q delta.
  assume Hqr5: r delta.
  prove PNoLt alpha p beta r.
  apply PNoLtI1.
  prove exists delta :e alpha :/\: beta, PNoEq_ delta p r /\ ~p delta /\ r delta.
  witness delta. apply andI.
  + exact Hd.
  + apply and3I.
    * { prove PNoEq_ delta p r. apply PNoEq_tra_ delta p q r.
        - prove PNoEq_ delta p q.
          apply PNoEq_antimon_ p q alpha Ha delta Hd1.
          prove PNoEq_ alpha p q.
          exact Hpq.
        - prove PNoEq_ delta q r. exact Hqr3.
      }
    * prove ~p delta.
      assume H1: p delta.
      apply Hqr4.
      prove q delta.
      exact iffEL (p delta) (q delta) (Hpq delta Hd1) H1.
    * prove r delta. exact Hqr5.
- assume Hqr1: alpha :e beta.
  assume Hqr2: PNoEq_ alpha q r.
  assume Hqr3: r alpha.
  prove PNoLt alpha p beta r.
  apply PNoLtI2.
  + prove alpha :e beta. exact Hqr1.
  + prove PNoEq_ alpha p r. apply PNoEq_tra_ alpha p q r.
    * exact Hpq.
    * exact Hqr2.
  + prove r alpha. exact Hqr3.
- assume Hqr1: beta :e alpha.
  assume Hqr2: PNoEq_ beta q r.
  assume Hqr3: ~q beta.
  prove PNoLt alpha p beta r.
  apply PNoLtI3.
  + prove beta :e alpha. exact Hqr1.
  + prove PNoEq_ beta p r. apply PNoEq_tra_ beta p q r.
    * apply PNoEq_antimon_ p q alpha Ha beta Hqr1. exact Hpq.
    * exact Hqr2.
  + prove ~p beta.
    assume H1: p beta.
    apply Hqr3.
    exact iffEL (p beta) (q beta) (Hpq beta Hqr1) H1.
Qed.

Theorem PNoLt_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoLt beta q gamma r -> PNoLt alpha p gamma r.
let alpha beta gamma. assume Ha Hb Hc.
apply Ha. assume Ha1 _.
apply Hc. assume Hc1 _.
let p q r.
assume Hpq Hqr.
apply PNoLtE alpha beta p q Hpq.
- assume Hpq1: PNoLt_ (alpha :/\: beta) p q.
  apply Hpq1. let delta. assume Hpq2. apply Hpq2.
  assume Hd: delta :e alpha :/\: beta.
  apply binintersectE alpha beta delta Hd.
  assume Hd1 Hd2.
  assume Hpq3. apply Hpq3. assume Hpq3. apply Hpq3.
  assume Hpq3: PNoEq_ delta p q.
  assume Hpq4: ~p delta.
  assume Hpq5: q delta.
  claim Ld: ordinal delta.
  { exact ordinal_Hered beta Hb delta Hd2. }
  apply PNoLtE beta gamma q r Hqr.
  + assume Hqr1: PNoLt_ (beta :/\: gamma) q r.
    apply Hqr1. let eps. assume Hqr2. apply Hqr2.
    assume He: eps :e beta :/\: gamma.
    apply binintersectE beta gamma eps He.
    assume He1 He2.
    assume Hqr3. apply Hqr3. assume Hqr3. apply Hqr3.
    assume Hqr3: PNoEq_ eps q r.
    assume Hqr4: ~q eps.
    assume Hqr5: r eps.
    claim Le: ordinal eps.
    { exact ordinal_Hered beta Hb eps He1. }
    prove PNoLt alpha p gamma r.
    apply PNoLtI1.
    prove exists delta :e alpha :/\: gamma, PNoEq_ delta p r /\ ~p delta /\ r delta.
    apply ordinal_trichotomy_or delta eps Ld Le. assume H1. apply H1.
    * { assume H1: delta :e eps.
        witness delta. apply andI.
        - prove delta :e alpha :/\: gamma. apply binintersectI.
          + exact Hd1.
          + prove delta :e gamma. exact Hc1 eps He2 delta H1.
        - apply and3I.
          + prove PNoEq_ delta p r.
            apply PNoEq_tra_ delta p q r.
            * prove PNoEq_ delta p q. exact Hpq3.
            * prove PNoEq_ delta q r.
              apply PNoEq_antimon_ q r eps Le delta H1.
              prove PNoEq_ eps q r. exact Hqr3.
          + prove ~p delta. exact Hpq4.
          + prove r delta.
            exact iffEL (q delta) (r delta) (Hqr3 delta H1) Hpq5.
      }
    * { assume H1: delta = eps.
        witness delta. apply andI.
        - prove delta :e alpha :/\: gamma. apply binintersectI.
          + exact Hd1.
          + prove delta :e gamma. rewrite H1. exact He2.
        - apply and3I.
          + prove PNoEq_ delta p r.
            apply PNoEq_tra_ delta p q r.
            * prove PNoEq_ delta p q. exact Hpq3.
            * prove PNoEq_ delta q r. rewrite H1. exact Hqr3.
          + prove ~p delta. exact Hpq4.
          + prove r delta. rewrite H1. exact Hqr5.
      }
    * { assume H1: eps :e delta.
        witness eps. apply andI.
        - prove eps :e alpha :/\: gamma. apply binintersectI.
          + prove eps :e alpha. exact Ha1 delta Hd1 eps H1.
          + exact He2.
        - apply and3I.
          + prove PNoEq_ eps p r.
            apply PNoEq_tra_ eps p q r.
            * prove PNoEq_ eps p q. apply PNoEq_antimon_ p q delta Ld eps H1.
              prove PNoEq_ delta p q. exact Hpq3.
            * prove PNoEq_ eps q r. exact Hqr3.
          + prove ~p eps.
            assume H2: p eps.
            apply Hqr4.
            exact iffEL (p eps) (q eps) (Hpq3 eps H1) H2.
          + prove r eps. exact Hqr5.
      }
  + assume Hqr1: beta :e gamma.
    assume Hqr2: PNoEq_ beta q r.
    assume Hqr3: r beta.
    apply PNoLtI1.
    prove exists delta :e alpha :/\: gamma, PNoEq_ delta p r /\ ~p delta /\ r delta.
    witness delta. apply andI.
    * { prove delta :e alpha :/\: gamma. apply binintersectI.
        - exact Hd1.
        - prove delta :e gamma. exact Hc1 beta Hqr1 delta Hd2.
      }
    * { apply and3I.
        - prove PNoEq_ delta p r.
          apply PNoEq_tra_ delta p q r.
          + prove PNoEq_ delta p q. exact Hpq3.
          + prove PNoEq_ delta q r.
            apply PNoEq_antimon_ q r beta Hb delta Hd2.
            prove PNoEq_ beta q r. exact Hqr2.
        - prove ~p delta. exact Hpq4.
        - prove r delta.
          exact iffEL (q delta) (r delta) (Hqr2 delta Hd2) Hpq5.
      }
  + assume Hqr1: gamma :e beta.
    assume Hqr2: PNoEq_ gamma q r.
    assume Hqr3: ~q gamma.
    apply ordinal_trichotomy_or delta gamma Ld Hc. assume H1. apply H1.
    * { assume H1: delta :e gamma.
        prove PNoLt alpha p gamma r.
        apply PNoLtI1.
        prove exists delta :e alpha :/\: gamma, PNoEq_ delta p r /\ ~p delta /\ r delta.
        witness delta. apply andI.
        - prove delta :e alpha :/\: gamma. apply binintersectI.
          + exact Hd1.
          + prove delta :e gamma. exact H1.
        - apply and3I.
          + prove PNoEq_ delta p r.
            apply PNoEq_tra_ delta p q r.
            * prove PNoEq_ delta p q. exact Hpq3.
            * prove PNoEq_ delta q r.
              apply PNoEq_antimon_ q r gamma Hc delta H1.
              prove PNoEq_ gamma q r. exact Hqr2.
          + prove ~p delta. exact Hpq4.
          + prove r delta.
            exact iffEL (q delta) (r delta) (Hqr2 delta H1) Hpq5.
      }
    * { assume H1: delta = gamma.
        apply PNoLtI3.
        - prove gamma :e alpha. rewrite <- H1. exact Hd1.
        - prove PNoEq_ gamma p r. apply PNoEq_tra_ gamma p q r.
          + prove PNoEq_ gamma p q. rewrite <- H1. exact Hpq3.
          + prove PNoEq_ gamma q r. exact Hqr2.
        - prove ~p gamma. rewrite <- H1. exact Hpq4.
      }
    * { assume H1: gamma :e delta.
        apply PNoLtI3.
        - prove gamma :e alpha. exact Ha1 delta Hd1 gamma H1.
        - prove PNoEq_ gamma p r. apply PNoEq_tra_ gamma p q r.
          + prove PNoEq_ gamma p q.
            apply PNoEq_antimon_ p q delta Ld gamma H1.
            exact Hpq3.
          + prove PNoEq_ gamma q r. exact Hqr2.
        - prove ~p gamma.
          assume H2: p gamma.
          apply Hqr3.
          prove q gamma.
          exact iffEL (p gamma) (q gamma) (Hpq3 gamma H1) H2.
      }
- assume Hpq1: alpha :e beta.
  assume Hpq2: PNoEq_ alpha p q.
  assume Hpq3: q alpha.
  apply PNoLtE beta gamma q r Hqr.
  + assume Hqr1: PNoLt_ (beta :/\: gamma) q r.
    apply Hqr1. let eps. assume Hqr2. apply Hqr2.
    assume He: eps :e beta :/\: gamma.
    apply binintersectE beta gamma eps He.
    assume He1 He2.
    assume Hqr3. apply Hqr3. assume Hqr3. apply Hqr3.
    assume Hqr3: PNoEq_ eps q r.
    assume Hqr4: ~q eps.
    assume Hqr5: r eps.
    claim Le: ordinal eps.
    { exact ordinal_Hered beta Hb eps He1. }
    apply ordinal_trichotomy_or alpha eps Ha Le. assume H1. apply H1.
    * { assume H1: alpha :e eps.
        prove PNoLt alpha p gamma r.
        apply PNoLtI2.
        - prove alpha :e gamma. exact Hc1 eps He2 alpha H1.
        - prove PNoEq_ alpha p r. apply PNoEq_tra_ alpha p q r.
          + prove PNoEq_ alpha p q. exact Hpq2.
          + prove PNoEq_ alpha q r.
            apply PNoEq_antimon_ q r eps Le alpha H1.
            prove PNoEq_ eps q r.
            exact Hqr3.
        - prove r alpha.
          exact iffEL (q alpha) (r alpha) (Hqr3 alpha H1) Hpq3.
      }
    * { assume H1: alpha = eps.
        prove PNoLt alpha p gamma r.
        apply PNoLtI2.
        - prove alpha :e gamma. rewrite H1. exact He2.
        - prove PNoEq_ alpha p r. apply PNoEq_tra_ alpha p q r.
          + prove PNoEq_ alpha p q. exact Hpq2.
          + prove PNoEq_ alpha q r. rewrite H1.
            prove PNoEq_ eps q r.
            exact Hqr3.
        - prove r alpha. rewrite H1. exact Hqr5.
      }
    * { assume H1: eps :e alpha.
        prove PNoLt alpha p gamma r.
        apply PNoLtI1.
        prove exists delta :e alpha :/\: gamma, PNoEq_ delta p r /\ ~p delta /\ r delta.
        witness eps. apply andI.
        - prove eps :e alpha :/\: gamma. apply binintersectI.
          + exact H1.
          + exact He2.
        - apply and3I.
          + prove PNoEq_ eps p r. apply PNoEq_tra_ eps p q r.
            * prove PNoEq_ eps p q.
              apply PNoEq_antimon_ p q alpha Ha eps H1.
              prove PNoEq_ alpha p q.
              exact Hpq2.
            * prove PNoEq_ eps q r. exact Hqr3.
          + prove ~p eps.
            assume H2: p eps.
            apply Hqr4.
            prove q eps.
            exact iffEL (p eps) (q eps) (Hpq2 eps H1) H2.
          + prove r eps. exact Hqr5.
      }
  + assume Hqr1: beta :e gamma.
    assume Hqr2: PNoEq_ beta q r.
    assume Hqr3: r beta.
    apply PNoLtI2.
    * prove alpha :e gamma. exact Hc1 beta Hqr1 alpha Hpq1.
    * { prove PNoEq_ alpha p r. apply PNoEq_tra_ alpha p q r.
        - exact Hpq2.
        - apply PNoEq_antimon_ q r beta Hb alpha Hpq1.
          exact Hqr2.
      }
    * prove r alpha. exact iffEL (q alpha) (r alpha) (Hqr2 alpha Hpq1) Hpq3.
  + assume Hqr1: gamma :e beta.
    assume Hqr2: PNoEq_ gamma q r.
    assume Hqr3: ~q gamma.
    prove PNoLt alpha p gamma r.
    apply ordinal_trichotomy_or alpha gamma Ha Hc. assume H1. apply H1.
    * { assume H1: alpha :e gamma.
        apply PNoLtI2.
        - prove alpha :e gamma. exact H1.
        - prove PNoEq_ alpha p r. apply PNoEq_tra_ alpha p q r.
          + exact Hpq2.
          + apply PNoEq_antimon_ q r gamma Hc alpha H1.
            exact Hqr2.
        - prove r alpha.
          exact iffEL (q alpha) (r alpha) (Hqr2 alpha H1) Hpq3.
      }
    * assume H1: alpha = gamma. prove False. apply Hqr3. rewrite <- H1. exact Hpq3.
    * { assume H1: gamma :e alpha.
        apply PNoLtI3.
        - prove gamma :e alpha. exact H1.
        - prove PNoEq_ gamma p r. apply PNoEq_tra_ gamma p q r.
          + apply PNoEq_antimon_ p q alpha Ha gamma H1.
            exact Hpq2.
          + exact Hqr2.
        - prove ~p gamma.
          assume H2: p gamma.
          apply Hqr3. prove q gamma.
          exact iffEL (p gamma) (q gamma) (Hpq2 gamma H1) H2.
      }
- assume Hpq1: beta :e alpha.
  assume Hpq2: PNoEq_ beta p q.
  assume Hpq3: ~p beta.
  apply PNoLtE beta gamma q r Hqr.
  + assume Hqr1: PNoLt_ (beta :/\: gamma) q r.
    apply Hqr1. let eps. assume Hqr2. apply Hqr2.
    assume He: eps :e beta :/\: gamma.
    apply binintersectE beta gamma eps He.
    assume He1 He2.
    assume Hqr3. apply Hqr3. assume Hqr3. apply Hqr3.
    assume Hqr3: PNoEq_ eps q r.
    assume Hqr4: ~q eps.
    assume Hqr5: r eps.
    prove PNoLt alpha p gamma r.
    apply PNoLtI1.
    prove exists delta :e alpha :/\: gamma, PNoEq_ delta p r /\ ~p delta /\ r delta.
    witness eps. apply andI.
    * { prove eps :e alpha :/\: gamma. apply binintersectI.
        - prove eps :e alpha. exact Ha1 beta Hpq1 eps He1.
        - exact He2.
      }
    * { apply and3I.
        - prove PNoEq_ eps p r. apply PNoEq_tra_ eps p q r.
          + prove PNoEq_ eps p q.
            apply PNoEq_antimon_ p q beta Hb eps He1.
            exact Hpq2.
          + exact Hqr3.
        - prove ~p eps.
          assume H1: p eps.
          apply Hqr4.
          prove q eps.
          exact iffEL (p eps) (q eps) (Hpq2 eps He1) H1.
        - prove r eps. exact Hqr5.
      }
  + assume Hqr1: beta :e gamma.
    assume Hqr2: PNoEq_ beta q r.
    assume Hqr3: r beta.
    apply PNoLtI1.
    prove exists delta :e alpha :/\: gamma, PNoEq_ delta p r /\ ~p delta /\ r delta.
    witness beta. apply andI.
    * { apply binintersectI.
        - exact Hpq1.
        - exact Hqr1.
      }
    * { apply and3I.
        - apply PNoEq_tra_ beta p q r.
          + exact Hpq2.
          + exact Hqr2.
        - prove ~p beta. exact Hpq3.
        - prove r beta. exact Hqr3.
      }
  + assume Hqr1: gamma :e beta.
    assume Hqr2: PNoEq_ gamma q r.
    assume Hqr3: ~q gamma.
    apply PNoLtI3.
    * prove gamma :e alpha. exact Ha1 beta Hpq1 gamma Hqr1.
    * { prove PNoEq_ gamma p r. apply PNoEq_tra_ gamma p q r.
        - prove PNoEq_ gamma p q.
          apply PNoEq_antimon_ p q beta Hb gamma Hqr1.
          exact Hpq2.
        - exact Hqr2.
      }
    * prove ~p gamma.
      assume H1: p gamma.
      apply Hqr3. prove q gamma.
      exact iffEL (p gamma) (q gamma) (Hpq2 gamma Hqr1) H1.
Qed.

Definition PNoLe : set -> (set -> prop) -> set -> (set -> prop) -> prop
   := fun alpha p beta q => PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q.

Theorem PNoLeI1 : forall alpha beta, forall p q:set -> prop,
   PNoLt alpha p beta q -> PNoLe alpha p beta q.
let alpha beta p q.
assume H1.
prove PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q.
apply orIL. exact H1.
Qed.

Theorem PNoLeI2 : forall alpha, forall p q:set -> prop,
   PNoEq_ alpha p q -> PNoLe alpha p alpha q.
let alpha p q.
assume H1.
prove PNoLt alpha p alpha q \/ alpha = alpha /\ PNoEq_ alpha p q.
apply orIR. apply andI.
- reflexivity.
- exact H1.
Qed.

Theorem PNoLe_ref : forall alpha, forall p:set -> prop, PNoLe alpha p alpha p.
let alpha p.
apply PNoLeI2.
apply PNoEq_ref_.
Qed.

Theorem PNoLe_antisym : forall alpha beta, ordinal alpha -> ordinal beta ->
 forall p q:set -> prop,
 PNoLe alpha p beta q -> PNoLe beta q alpha p -> alpha = beta /\ PNoEq_ alpha p q.
let alpha beta. assume Ha Hb.
let p q.
assume H1: PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q.
assume H2: PNoLt beta q alpha p \/ beta = alpha /\ PNoEq_ beta q p.
apply H1.
- assume H1: PNoLt alpha p beta q.
  prove False.
  apply H2.
  + assume H2: PNoLt beta q alpha p.
    apply PNoLt_irref alpha p.
    apply PNoLt_tra alpha beta alpha Ha Hb Ha p q p.
    * exact H1.
    * exact H2.
  + assume H2. apply H2.
    assume H2a: beta = alpha.
    assume H2b: PNoEq_ beta q p.
    apply PNoLtE alpha beta p q H1.
    * assume Hpq1: PNoLt_ (alpha :/\: beta) p q.
      apply Hpq1. let delta. assume Hpq2. apply Hpq2.
      assume Hd: delta :e alpha :/\: beta.
      apply binintersectE alpha beta delta Hd.
      assume Hd1 Hd2.
      assume Hpq3. apply Hpq3. assume Hpq3. apply Hpq3.
      assume Hpq3: PNoEq_ delta p q.
      assume Hpq4: ~p delta.
      assume Hpq5: q delta.
      apply Hpq4.
      exact iffEL (q delta) (p delta) (H2b delta Hd2) Hpq5.
    * assume Hpq1: alpha :e beta.
      assume Hpq2: PNoEq_ alpha p q.
      assume Hpq3: q alpha.
      apply In_irref alpha.
      rewrite <- H2a at 2.
      exact Hpq1.
    * assume Hpq1: beta :e alpha.
      assume Hpq2: PNoEq_ beta p q.
      assume Hpq3: ~p beta.
      apply In_irref alpha.
      rewrite <- H2a at 1.
      exact Hpq1.
- assume H1. exact H1.
Qed.

Theorem PNoLtLe_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoLe beta q gamma r -> PNoLt alpha p gamma r.
let alpha beta gamma. assume Ha Hb Hc.
let p q r.
assume H1: PNoLt alpha p beta q.
assume H2: PNoLt beta q gamma r \/ beta = gamma /\ PNoEq_ beta q r.
apply H2.
- assume H2: PNoLt beta q gamma r.
  exact PNoLt_tra alpha beta gamma Ha Hb Hc p q r H1 H2.
- assume H2. apply H2.
  assume H2a: beta = gamma.
  assume H2b: PNoEq_ beta q r.
  prove PNoLt alpha p gamma r.
  rewrite <- H2a.
  prove PNoLt alpha p beta r.
  exact PNoLtEq_tra alpha beta Ha Hb p q r H1 H2b.
Qed.

Theorem PNoLeLt_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLe alpha p beta q -> PNoLt beta q gamma r -> PNoLt alpha p gamma r.
let alpha beta gamma. assume Ha Hb Hc.
let p q r.
assume H1: PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q.
assume H2: PNoLt beta q gamma r.
apply H1.
- assume H1: PNoLt alpha p beta q.
  exact PNoLt_tra alpha beta gamma Ha Hb Hc p q r H1 H2.
- assume H1. apply H1.
  assume H1a: alpha = beta.
  assume H1b: PNoEq_ alpha p q.
  prove PNoLt alpha p gamma r.
  rewrite H1a.
  prove PNoLt beta p gamma r.
  apply PNoEqLt_tra beta gamma Hb Hc p q r.
  + prove PNoEq_ beta p q. rewrite <- H1a. exact H1b.
  + exact H2.
Qed.

Theorem PNoEqLe_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoEq_ alpha p q -> PNoLe alpha q beta r -> PNoLe alpha p beta r.
let alpha beta. assume Ha Hb.
let p q r.
assume Hpq.
assume Hqr: PNoLt alpha q beta r \/ alpha = beta /\ PNoEq_ alpha q r.
prove PNoLt alpha p beta r \/ alpha = beta /\ PNoEq_ alpha p r.
apply Hqr.
- assume Hqr1.
  apply orIL.
  exact PNoEqLt_tra alpha beta Ha Hb p q r Hpq Hqr1.
- assume Hqr. apply Hqr.
  assume Hqr1: alpha = beta.
  assume Hqr2: PNoEq_ alpha q r.
  apply orIR.
  apply andI.
  + exact Hqr1.
  + exact PNoEq_tra_ alpha p q r Hpq Hqr2.
Qed.

Theorem PNoLe_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLe alpha p beta q -> PNoLe beta q gamma r -> PNoLe alpha p gamma r.
let alpha beta gamma. assume Ha Hb Hc.
let p q r.
assume H1: PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q.
assume H2: PNoLe beta q gamma r.
apply H1.
- assume H1: PNoLt alpha p beta q.
  prove PNoLt alpha p gamma r \/ alpha = gamma /\ PNoEq_ alpha p r.
  apply orIL.
  exact PNoLtLe_tra alpha beta gamma Ha Hb Hc p q r H1 H2.
- assume H1. apply H1.
  assume H1a: alpha = beta.
  assume H1b: PNoEq_ alpha p q.
  prove PNoLe alpha p gamma r.
  rewrite H1a.
  prove PNoLe beta p gamma r.
  claim L1: PNoEq_ beta p q.
  { rewrite <- H1a. exact H1b. }
  exact PNoEqLe_tra beta gamma Hb Hc p q r L1 H2.
Qed.

Definition PNo_downc : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
 := fun L alpha p => exists beta, ordinal beta /\ exists q:set -> prop, L beta q /\ PNoLe alpha p beta q.
Definition PNo_upc : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
 := fun R alpha p => exists beta, ordinal beta /\ exists q:set -> prop, R beta q /\ PNoLe beta q alpha p.

Theorem PNoLe_downc : forall L:set -> (set -> prop) -> prop, forall alpha beta, forall p q:set -> prop,
  ordinal alpha -> ordinal beta ->
  PNo_downc L alpha p -> PNoLe beta q alpha p -> PNo_downc L beta q.
let L alpha beta p q. assume Ha Hb.
assume H1: PNo_downc L alpha p.
assume H2: PNoLe beta q alpha p.
prove PNo_downc L beta q.
apply H1. let gamma. assume H3. apply H3.
assume Hc: ordinal gamma. assume H3. apply H3.
let r. assume H3. apply H3.
assume H3: L gamma r.
assume H4: PNoLe alpha p gamma r.
prove exists delta, ordinal delta /\ exists r:set -> prop, L delta r /\ PNoLe beta q delta r.
witness gamma. apply andI.
- exact Hc.
- witness r. apply andI.
  + exact H3.
  + exact PNoLe_tra beta alpha gamma Hb Ha Hc q p r H2 H4.
Qed.

Theorem PNo_downc_ref : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, L alpha p -> PNo_downc L alpha p.
let L alpha. assume Ha. let p.
assume H1: L alpha p.
prove exists beta, ordinal beta /\ exists q:set -> prop, L beta q /\ PNoLe alpha p beta q.
witness alpha. apply andI.
- exact Ha.
- witness p. apply andI.
  + exact H1.
  + apply PNoLe_ref.
Qed.

Theorem PNo_upc_ref : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, R alpha p -> PNo_upc R alpha p.
let R alpha. assume Ha. let p.
assume H1: R alpha p.
prove exists beta, ordinal beta /\ exists q:set -> prop, R beta q /\ PNoLe beta q alpha p.
witness alpha. apply andI.
- exact Ha.
- witness p. apply andI.
  + exact H1.
  + apply PNoLe_ref.
Qed.

Theorem PNoLe_upc : forall R:set -> (set -> prop) -> prop, forall alpha beta, forall p q:set -> prop,
  ordinal alpha -> ordinal beta ->
  PNo_upc R alpha p -> PNoLe alpha p beta q -> PNo_upc R beta q.
let R alpha beta p q. assume Ha Hb.
assume H1: PNo_upc R alpha p.
assume H2: PNoLe alpha p beta q.
prove PNo_upc R beta q.
apply H1. let gamma. assume H3. apply H3.
assume Hc: ordinal gamma. assume H3. apply H3.
let r. assume H3. apply H3.
assume H3: R gamma r.
assume H4: PNoLe gamma r alpha p.
prove exists delta, ordinal delta /\ exists r:set -> prop, R delta r /\ PNoLe delta r beta q.
witness gamma. apply andI.
- exact Hc.
- witness r. apply andI.
  + exact H3.
  + exact PNoLe_tra gamma alpha beta Hc Ha Hb r p q H4 H2.
Qed.

Definition PNoLt_pwise : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> prop
  := fun L R => forall gamma, ordinal gamma -> forall p:set -> prop, L gamma p -> forall delta, ordinal delta -> forall q:set -> prop, R delta q -> PNoLt gamma p delta q.

Theorem PNoLt_pwise_downc_upc : forall L R:set -> (set -> prop) -> prop,
    PNoLt_pwise L R -> PNoLt_pwise (PNo_downc L) (PNo_upc R).
let L R. assume HLR.
prove PNoLt_pwise (PNo_downc L) (PNo_upc R).
let gamma. assume Hc. let p. assume Hp.
let delta. assume Hd. let q. assume Hq.
apply Hp. let alpha. assume H1. apply H1.
assume H2: ordinal alpha. assume H3. apply H3.
let p2. assume H3. apply H3.
assume H4: L alpha p2.
assume H5: PNoLe gamma p alpha p2.
apply Hq. let beta. assume H6. apply H6.
assume H7: ordinal beta. assume H8. apply H8.
let q2. assume H9. apply H9.
assume H10: R beta q2.
assume H11: PNoLe beta q2 delta q.
claim L1: PNoLt gamma p delta q.
{ apply PNoLeLt_tra gamma alpha delta Hc H2 Hd p p2 q H5.
  prove PNoLt alpha p2 delta q.
  apply PNoLtLe_tra alpha beta delta H2 H7 Hd p2 q2 q (HLR alpha H2 p2 H4 beta H7 q2 H10).
  prove PNoLe beta q2 delta q.
  exact H11.
}
apply PNoLt_trichotomy_or delta gamma q p Hd Hc. assume H12. apply H12.
- assume H12: PNoLt delta q gamma p.
  apply PNoLt_irref gamma p.
  prove PNoLt gamma p gamma p.
  apply PNoLt_tra gamma delta gamma Hc Hd Hc p q p L1.
  exact H12.
- assume H12: delta = gamma /\ PNoEq_ delta q p.
  apply PNoLt_irref delta q.
  prove PNoLt delta q delta q.
  apply PNoLeLt_tra delta gamma delta Hd Hc Hd q p q.
  + prove PNoLe delta q gamma p.
    prove PNoLt delta q gamma p \/ delta = gamma /\ PNoEq_ delta q p.
    apply orIR. exact H12.
  + prove PNoLt gamma p delta q. exact L1.
- assume H12: PNoLt gamma p delta q.
  exact H12.
Qed.

Definition PNo_rel_strict_upperbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L alpha p =>
       forall beta :e alpha, forall q:set -> prop, PNo_downc L beta q -> PNoLt beta q alpha p.
Definition PNo_rel_strict_lowerbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun R alpha p =>
       forall beta :e alpha, forall q:set -> prop, PNo_upc R beta q -> PNoLt alpha p beta q.
Definition PNo_rel_strict_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_rel_strict_upperbd L alpha p /\ PNo_rel_strict_lowerbd R alpha p.

Theorem PNoEq_rel_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L alpha q.
let L alpha. assume Ha. let p q.
assume Hpq: PNoEq_ alpha p q.
assume H1: PNo_rel_strict_upperbd L alpha p.
prove PNo_rel_strict_upperbd L alpha q.
let beta. assume Hb: beta :e alpha.
let r. assume H2: PNo_downc L beta r.
claim Lb: ordinal beta.
{ exact ordinal_Hered alpha Ha beta Hb. }
prove PNoLt beta r alpha q.
apply PNoLtEq_tra beta alpha Lb Ha r p q.
- prove PNoLt beta r alpha p.
  exact H1 beta Hb r H2.
- prove PNoEq_ alpha p q. exact Hpq.
Qed.

Theorem PNo_rel_strict_upperbd_antimon : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L beta p.
let L alpha. assume Ha. let p beta. assume Hb.
apply Ha. assume Ha1 _.
claim Lb: ordinal beta.
{ exact ordinal_Hered alpha Ha beta Hb. }
claim Lbt: TransSet beta.
{ apply Lb. assume H2 _. exact H2. }
assume H1: forall gamma :e alpha, forall q:set -> prop, PNo_downc L gamma q -> PNoLt gamma q alpha p.
prove forall gamma :e beta, forall q:set -> prop, PNo_downc L gamma q -> PNoLt gamma q beta p.
let gamma. assume Hc. let q. assume H4.
prove PNoLt gamma q beta p.
claim Lca: gamma :e alpha.
{ exact Ha1 beta Hb gamma Hc. }
claim L1: PNoLt gamma q alpha p.
{ apply H1.
  - prove gamma :e alpha. exact Lca.
  - prove PNo_downc L gamma q. exact H4.
}
apply PNoLtE gamma alpha q p L1.
+ assume H5: PNoLt_ (gamma :/\: alpha) q p.
  claim L2: gamma :/\: alpha = gamma.
  { apply binintersect_Subq_eq_1. exact Ha1 gamma Lca. }
  claim L3: gamma :/\: beta = gamma.
  { apply binintersect_Subq_eq_1. exact Lbt gamma Hc. }
  apply PNoLtI1.
  rewrite L3.
  rewrite <- L2.
  exact H5.
+ assume H5: gamma :e alpha.
  assume H6: PNoEq_ gamma q p.
  assume H7: p gamma.
  apply PNoLtI2.
  * prove gamma :e beta. exact Hc.
  * prove PNoEq_ gamma q p. exact H6.
  * prove p gamma. exact H7.
+ assume H5: alpha :e gamma.
  prove False.
  exact In_no2cycle alpha gamma H5 Lca.
Qed.

Theorem PNoEq_rel_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R alpha q.
let R alpha. assume Ha. let p q.
assume Hpq: PNoEq_ alpha p q.
assume H1: PNo_rel_strict_lowerbd R alpha p.
prove PNo_rel_strict_lowerbd R alpha q.
let beta. assume Hb: beta :e alpha.
let r. assume H2: PNo_upc R beta r.
claim Lb: ordinal beta.
{ exact ordinal_Hered alpha Ha beta Hb. }
prove PNoLt alpha q beta r.
apply PNoEqLt_tra alpha beta Ha Lb q p r.
- prove PNoEq_ alpha q p. apply PNoEq_sym_. exact Hpq.
- prove PNoLt alpha p beta r.
  exact H1 beta Hb r H2.
Qed.

Theorem PNo_rel_strict_lowerbd_antimon : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R beta p.
let R alpha. assume Ha. let p beta. assume Hb.
apply Ha. assume Ha1 _.
claim Lb: ordinal beta.
{ exact ordinal_Hered alpha Ha beta Hb. }
claim Lbt: TransSet beta.
{ apply Lb. assume H2 _. exact H2. }
assume H1: forall gamma :e alpha, forall q:set -> prop, PNo_upc R gamma q -> PNoLt alpha p gamma q.
prove forall gamma :e beta, forall q:set -> prop, PNo_upc R gamma q -> PNoLt beta p gamma q.
let gamma. assume Hc. let q. assume H4.
prove PNoLt beta p gamma q.
claim Lca: gamma :e alpha.
{ exact Ha1 beta Hb gamma Hc. }
claim L1: PNoLt alpha p gamma q.
{ apply H1.
  - prove gamma :e alpha. exact Lca.
  - prove PNo_upc R gamma q. exact H4.
}
apply PNoLtE alpha gamma p q L1.
+ assume H5: PNoLt_ (alpha :/\: gamma) p q.
  claim L2: alpha :/\: gamma = gamma.
  { rewrite binintersect_com. apply binintersect_Subq_eq_1. exact Ha1 gamma Lca. }
  claim L3: beta :/\: gamma = gamma.
  { rewrite binintersect_com. apply binintersect_Subq_eq_1. exact Lbt gamma Hc. }
  apply PNoLtI1.
  rewrite L3.
  rewrite <- L2.
  exact H5.
+ assume H5: alpha :e gamma.
  prove False.
  exact In_no2cycle alpha gamma H5 Lca.
+ assume H5: gamma :e alpha.
  assume H6: PNoEq_ gamma p q.
  assume H7: ~p gamma.
  apply PNoLtI3.
  * prove gamma :e beta. exact Hc.
  * prove PNoEq_ gamma p q. exact H6.
  * prove ~p gamma. exact H7.
Qed.

Theorem PNoEq_rel_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R alpha q.
let L R alpha. assume Ha. let p q. assume Hpq H1.
apply H1. assume H2 H3.
prove PNo_rel_strict_upperbd L alpha q /\ PNo_rel_strict_lowerbd R alpha q.
apply andI.
- exact PNoEq_rel_strict_upperbd L alpha Ha p q Hpq H2.
- exact PNoEq_rel_strict_lowerbd R alpha Ha p q Hpq H3.
Qed.

Theorem PNo_rel_strict_imv_antimon : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R beta p.
let L R alpha. assume Ha. let p beta. assume Hb H1.
apply H1. assume H2 H3.
prove PNo_rel_strict_upperbd L beta p /\ PNo_rel_strict_lowerbd R beta p.
apply andI.
- exact PNo_rel_strict_upperbd_antimon L alpha Ha p beta Hb H2.
- exact PNo_rel_strict_lowerbd_antimon R alpha Ha p beta Hb H3.
Qed.

Definition PNo_rel_strict_uniq_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_rel_strict_imv L R alpha p /\ forall q:set -> prop, PNo_rel_strict_imv L R alpha q -> PNoEq_ alpha p q.
Definition PNo_rel_strict_split_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p =>
         PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta /\ delta <> alpha)
      /\ PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta \/ delta = alpha).

Theorem PNo_extend0_eq : forall alpha, forall p:set -> prop, PNoEq_ alpha p (fun delta => p delta /\ delta <> alpha).
let alpha p.
set p0 : set -> prop := fun delta => p delta /\ delta <> alpha.
let beta. assume Hb: beta :e alpha.
prove p beta <-> p0 beta.
apply iffI.
- assume H1: p beta.
  prove p beta /\ beta <> alpha.
  apply andI.
  + exact H1.
  + prove beta <> alpha.
    assume H2: beta = alpha.
    apply In_irref alpha. rewrite <- H2 at 1. exact Hb.
- assume H1: p0 beta.
  apply H1. assume H2 _. exact H2.
Qed.

Theorem PNo_extend1_eq : forall alpha, forall p:set -> prop, PNoEq_ alpha p (fun delta => p delta \/ delta = alpha).
let alpha p.
set p1 : set -> prop := fun delta => p delta \/ delta = alpha.
let beta. assume Hb: beta :e alpha.
prove p beta <-> p1 beta.
apply iffI.
- assume H1: p beta.
  prove p beta \/ beta = alpha.
  apply orIL. exact H1.
- assume H1: p1 beta.
  apply H1.
  + assume H2: p beta. exact H2.
  + assume H2: beta = alpha.
    prove False.
    apply In_irref alpha. rewrite <- H2 at 1. exact Hb.
Qed.

Theorem PNo_rel_imv_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha ->
      (exists p:set -> prop, PNo_rel_strict_uniq_imv L R alpha p)
   \/ (exists tau :e alpha, exists p:set -> prop, PNo_rel_strict_split_imv L R tau p).
let L R. assume HLR.
claim LLR: PNoLt_pwise (PNo_downc L) (PNo_upc R).
{ exact PNoLt_pwise_downc_upc L R HLR. }
apply ordinal_ind.
let alpha. assume Ha. apply Ha. assume Ha1 _.
assume IH: forall gamma :e alpha,
      (exists p:set -> prop, PNo_rel_strict_uniq_imv L R gamma p)
   \/ (exists tau :e gamma, exists p:set -> prop, PNo_rel_strict_split_imv L R tau p).
apply dneg.
assume HNC: ~((exists p:set -> prop, PNo_rel_strict_uniq_imv L R alpha p)
   \/ (exists tau :e alpha, exists p:set -> prop, PNo_rel_strict_split_imv L R tau p)).
apply not_or_and_demorgan (exists p:set -> prop, PNo_rel_strict_uniq_imv L R alpha p) (exists tau :e alpha, exists p:set -> prop, PNo_rel_strict_split_imv L R tau p) HNC.
assume HNC1: ~(exists p:set -> prop, PNo_rel_strict_uniq_imv L R alpha p).
assume HNC2: ~(exists tau :e alpha, exists p:set -> prop, PNo_rel_strict_split_imv L R tau p).
claim LIH: forall gamma :e alpha, exists p:set -> prop, PNo_rel_strict_uniq_imv L R gamma p.
{ let gamma.
  assume Hc: gamma :e alpha.
  apply IH gamma Hc.
  - assume H1. exact H1.
  - assume H1: exists tau :e gamma, exists p:set -> prop, PNo_rel_strict_split_imv L R tau p.
    apply H1.
    let tau.
    assume H2. apply H2.
    assume Ht: tau :e gamma.
    assume H2. apply H2.
    let p.
    assume H3: PNo_rel_strict_split_imv L R tau p.
    apply HNC2.
    witness tau. apply andI.
    + prove tau :e alpha. exact Ha1 gamma Hc tau Ht.
    + witness p. prove PNo_rel_strict_split_imv L R tau p. exact H3.
}
apply ordinal_lim_or_succ alpha Ha.
- assume H1: forall beta :e alpha, ordsucc beta :e alpha.
  set pl : set -> prop := fun delta => forall p:set -> prop, PNo_rel_strict_imv L R (ordsucc delta) p -> p delta.
  claim Lpl1 : forall gamma, ordinal gamma -> gamma :e alpha -> PNo_rel_strict_uniq_imv L R gamma pl.
  { apply ordinal_ind.
    let gamma.
    assume Hc: ordinal gamma.
    assume IH2: forall delta :e gamma, delta :e alpha -> PNo_rel_strict_uniq_imv L R delta pl.
    assume Hc1: gamma :e alpha.
    apply LIH gamma Hc1.
    let p. assume Hp. apply Hp.
    assume Hp1: PNo_rel_strict_imv L R gamma p.
    apply Hp1. assume Hp1a Hp1b.
    assume Hp2: forall q:set -> prop, PNo_rel_strict_imv L R gamma q -> PNoEq_ gamma p q.
    claim Lplpe: PNoEq_ gamma pl p.
    { let delta. assume Hd: delta :e gamma.
      apply ordinal_ordsucc_In_eq gamma delta Hc Hd.
      - assume Hsd: ordsucc delta :e gamma.
        claim Lsda: ordsucc delta :e alpha.
        { exact Ha1 gamma Hc1 (ordsucc delta) Hsd. }
        apply IH2 (ordsucc delta) Hsd Lsda.
        assume Hpl1: PNo_rel_strict_imv L R (ordsucc delta) pl.
        assume Hpl2: forall q:set -> prop, PNo_rel_strict_imv L R (ordsucc delta) q -> PNoEq_ (ordsucc delta) pl q.
        prove pl delta <-> p delta.
        apply Hpl2 p.
        + prove PNo_rel_strict_imv L R (ordsucc delta) p.
          exact PNo_rel_strict_imv_antimon L R gamma Hc p (ordsucc delta) Hsd Hp1.
        + prove delta :e ordsucc delta. apply ordsuccI2.
      - assume Hsd: gamma = ordsucc delta.
        prove pl delta <-> p delta.
        apply iffI.
        + assume H2: pl delta.
          prove p delta.
          apply H2 p.
          prove PNo_rel_strict_imv L R (ordsucc delta) p.
          rewrite <- Hsd.
          exact Hp1.
        + assume H2: p delta.
          let q.
          rewrite <- Hsd.
          assume Hq: PNo_rel_strict_imv L R gamma q.
          prove q delta.
          exact iffEL (p delta) (q delta) (Hp2 q Hq delta Hd) H2.
    }
    prove PNo_rel_strict_uniq_imv L R gamma pl.
    prove PNo_rel_strict_imv L R gamma pl /\ forall q:set -> prop, PNo_rel_strict_imv L R gamma q -> PNoEq_ gamma pl q.
    apply andI.
    - prove PNo_rel_strict_imv L R gamma pl.
      prove PNo_rel_strict_upperbd L gamma pl /\ PNo_rel_strict_lowerbd R gamma pl.
      apply andI.
      + prove PNo_rel_strict_upperbd L gamma pl.
        let beta. assume Hb: beta :e gamma.
        let q. assume Hq: PNo_downc L beta q.
        claim Lb: ordinal beta.
        { exact ordinal_Hered gamma Hc beta Hb. }
        prove PNoLt beta q gamma pl.
        apply PNoLtEq_tra beta gamma Lb Hc q p pl.
        * prove PNoLt beta q gamma p. exact Hp1a beta Hb q Hq.
        * prove PNoEq_ gamma p pl. apply PNoEq_sym_. exact Lplpe.
      + prove PNo_rel_strict_lowerbd R gamma pl.
        let beta. assume Hb: beta :e gamma.
        let q. assume Hq: PNo_upc R beta q.
        claim Lb: ordinal beta.
        { exact ordinal_Hered gamma Hc beta Hb. }
        prove PNoLt gamma pl beta q.
        apply PNoEqLt_tra gamma beta Hc Lb pl p q.
        * prove PNoEq_ gamma pl p. exact Lplpe.
        * prove PNoLt gamma p beta q. exact Hp1b beta Hb q Hq.
    - prove forall q:set -> prop, PNo_rel_strict_imv L R gamma q -> PNoEq_ gamma pl q.
      let q.
      assume Hq: PNo_rel_strict_imv L R gamma q.
      prove PNoEq_ gamma pl q.
      apply PNoEq_tra_ gamma pl p q.
      + prove PNoEq_ gamma pl p. exact Lplpe.
      + prove PNoEq_ gamma p q. exact Hp2 q Hq.
  }
  claim Lpl2 : forall gamma :e alpha, PNo_rel_strict_uniq_imv L R gamma pl.
  { let gamma. assume Hc: gamma :e alpha.
    claim Lc: ordinal gamma.
    { exact ordinal_Hered alpha Ha gamma Hc. }
    exact Lpl1 gamma Lc Hc.
  }
  apply HNC1.
  witness pl.
  prove PNo_rel_strict_uniq_imv L R alpha pl.
  prove PNo_rel_strict_imv L R alpha pl /\ forall q:set -> prop, PNo_rel_strict_imv L R alpha q -> PNoEq_ alpha pl q.
  apply andI.
  + prove PNo_rel_strict_imv L R alpha pl.
    prove PNo_rel_strict_upperbd L alpha pl /\ PNo_rel_strict_lowerbd R alpha pl.
    apply andI.
    * { prove PNo_rel_strict_upperbd L alpha pl.
        let beta. assume Hb: beta :e alpha.
        let q. assume Hq: PNo_downc L beta q.
        claim Lb: ordinal beta.
        { exact ordinal_Hered alpha Ha beta Hb. }
        claim Lsb: ordinal (ordsucc beta).
        { exact ordinal_ordsucc beta Lb. }
        prove PNoLt beta q alpha pl.
        apply PNoLt_trichotomy_or beta alpha q pl Lb Ha. assume H2. apply H2.
        - assume H2: PNoLt beta q alpha pl. exact H2.
        - assume H2. apply H2. assume H2: beta = alpha. prove False.
          apply In_irref alpha. rewrite <- H2 at 1. exact Hb.
        - assume H2: PNoLt alpha pl beta q.
          apply PNoLtE alpha beta pl q H2.
          + assume H3: PNoLt_ (alpha :/\: beta) pl q.
            apply H3.
            let gamma. assume H4. apply H4.
            assume Hc: gamma :e alpha :/\: beta.
            apply binintersectE alpha beta gamma Hc.
            assume Hc1 Hc2.
            assume H5. apply H5. assume H5. apply H5.
            assume H5: PNoEq_ gamma pl q.
            assume H6: ~pl gamma.
            assume H7: q gamma.
            claim Lc: ordinal gamma.
            { exact ordinal_Hered beta Lb gamma Hc2. }
            claim Lsc: ordinal (ordsucc gamma).
            { exact ordinal_ordsucc gamma Lc. }
            prove False.
            apply H6.
            prove pl gamma.
            let p.
            assume Hp: PNo_rel_strict_imv L R (ordsucc gamma) p.
            prove p gamma.
            apply Hp. assume Hp1 Hp2.
            claim Lqp: PNoLt gamma q (ordsucc gamma) p.
            { apply Hp1 gamma (ordsuccI2 gamma) q.
              prove PNo_downc L gamma q.
              apply PNoLe_downc L beta gamma q q Lb Lc.
              - prove PNo_downc L beta q. exact Hq.
              - prove PNoLe gamma q beta q.
                apply PNoLeI1.
                prove PNoLt gamma q beta q.
                apply PNoLtI2.
                + prove gamma :e beta. exact Hc2.
                + prove PNoEq_ gamma q q. apply PNoEq_ref_.
                + prove q gamma. exact H7.
            }
            apply PNoLtE gamma (ordsucc gamma) q p Lqp.
            * assume H6: PNoLt_ (gamma :/\: ordsucc gamma) q p.
              apply H6.
              let delta. assume H7. apply H7.
              assume Hd: delta :e gamma :/\: ordsucc gamma.
              apply binintersectE gamma (ordsucc gamma) delta Hd.
              assume Hd1 Hd2.
              assume H7. apply H7. assume H7. apply H7.
              assume H7: PNoEq_ delta q p.
              assume H8: ~q delta.
              assume H9: p delta.
              claim Ld: ordinal delta.
              { exact ordinal_Hered gamma Lc delta Hd1. }
              claim Lda: delta :e alpha.
              { exact Ha1 gamma Hc1 delta Hd1. }
              claim Lsda: ordsucc delta :e alpha.
              { exact H1 delta Lda. }
              claim Lpld: pl delta.
              { apply Lpl2 (ordsucc delta) Lsda.
                assume _.
                assume Hpl3: forall q:set -> prop, PNo_rel_strict_imv L R (ordsucc delta) q -> PNoEq_ (ordsucc delta) pl q.
                claim Lpld1: PNoEq_ (ordsucc delta) pl p.
                { apply Hpl3 p.
                  prove PNo_rel_strict_imv L R (ordsucc delta) p.
                  apply PNo_rel_strict_imv_antimon L R (ordsucc gamma) Lsc p.
                  - prove ordsucc delta :e ordsucc gamma.
                    apply ordinal_ordsucc_In.
                    + exact Lc.
                    + prove delta :e gamma.
                      exact Hd1.
                  - exact Hp.
                }
                exact iffER (pl delta) (p delta) (Lpld1 delta (ordsuccI2 delta)) H9.
              }
              claim Lnpld: ~pl delta.
              { assume H10: pl delta.
                apply H8.
                exact iffEL (pl delta) (q delta) (H5 delta Hd1) H10.
              }
              prove False. exact Lnpld Lpld.
            * assume H6: gamma :e ordsucc gamma.
              assume H7: PNoEq_ gamma q p.
              assume H8: p gamma.
              exact H8.
            * assume H6: ordsucc gamma :e gamma.
              prove False.
              exact In_no2cycle gamma (ordsucc gamma) (ordsuccI2 gamma) H6.
          + assume H3: alpha :e beta. prove False.
            exact In_no2cycle beta alpha Hb H3.
          + assume H3: beta :e alpha.
            assume H4: PNoEq_ beta pl q.
            assume H5: ~pl beta.
            prove False.
            apply H5.
            prove pl beta.
            let p.
            assume Hp: PNo_rel_strict_imv L R (ordsucc beta) p.
            prove p beta.
            apply Hp. assume Hp1 Hp2.
            claim Lqp: PNoLt beta q (ordsucc beta) p.
            { exact Hp1 beta (ordsuccI2 beta) q Hq. }
            apply PNoLtE beta (ordsucc beta) q p Lqp.
            * assume H6: PNoLt_ (beta :/\: ordsucc beta) q p.
              apply H6.
              let delta. assume H7. apply H7.
              assume Hd: delta :e beta :/\: ordsucc beta.
              apply binintersectE beta (ordsucc beta) delta Hd.
              assume Hd1 Hd2.
              assume H7. apply H7. assume H7. apply H7.
              assume H7: PNoEq_ delta q p.
              assume H8: ~q delta.
              assume H9: p delta.
              claim Ld: ordinal delta.
              { exact ordinal_Hered beta Lb delta Hd1. }
              claim Lda: delta :e alpha.
              { exact Ha1 beta Hb delta Hd1. }
              claim Lsda: ordsucc delta :e alpha.
              { exact H1 delta Lda. }
              claim Lpld: pl delta.
              { apply Lpl2 (ordsucc delta) Lsda.
                assume _.
                assume Hpl3: forall q:set -> prop, PNo_rel_strict_imv L R (ordsucc delta) q -> PNoEq_ (ordsucc delta) pl q.
                claim Lpld1: PNoEq_ (ordsucc delta) pl p.
                { apply Hpl3 p.
                  prove PNo_rel_strict_imv L R (ordsucc delta) p.
                  apply PNo_rel_strict_imv_antimon L R (ordsucc beta) Lsb p.
                  - prove ordsucc delta :e ordsucc beta.
                    apply ordinal_ordsucc_In.
                    + exact Lb.
                    + prove delta :e beta.
                      exact Hd1.
                  - exact Hp.
                }
                exact iffER (pl delta) (p delta) (Lpld1 delta (ordsuccI2 delta)) H9.
              }
              claim Lnpld: ~pl delta.
              { assume H10: pl delta.
                apply H8.
                exact iffEL (pl delta) (q delta) (H4 delta Hd1) H10.
              }
              prove False. exact Lnpld Lpld.
            * assume H6: beta :e ordsucc beta.
              assume H7: PNoEq_ beta q p.
              assume H8: p beta.
              exact H8.
            * assume H6: ordsucc beta :e beta.
              prove False.
              exact In_no2cycle beta (ordsucc beta) (ordsuccI2 beta) H6.
      }
    * { prove PNo_rel_strict_lowerbd R alpha pl.
        let beta. assume Hb: beta :e alpha.
        let q. assume Hq: PNo_upc R beta q.
        claim Lb: ordinal beta.
        { exact ordinal_Hered alpha Ha beta Hb. }
        claim Lsb: ordinal (ordsucc beta).
        { exact ordinal_ordsucc beta Lb. }
        claim Lsba: ordsucc beta :e alpha.
        { exact H1 beta Hb. }
        prove PNoLt alpha pl beta q.
        apply PNoLt_trichotomy_or alpha beta pl q Ha Lb. assume H2. apply H2.
        - assume H2: PNoLt alpha pl beta q. exact H2.
        - assume H2. apply H2. assume H2: alpha = beta. prove False.
          apply In_irref alpha. rewrite H2 at 1. exact Hb.
        - assume H2: PNoLt beta q alpha pl.
          apply PNoLtE beta alpha q pl H2.
          + assume H3: PNoLt_ (beta :/\: alpha) q pl.
            apply H3.
            let gamma. assume H4. apply H4.
            assume Hc: gamma :e beta :/\: alpha.
            apply binintersectE beta alpha gamma Hc.
            assume Hc2 Hc1.
            assume H5. apply H5. assume H5. apply H5.
            assume H5: PNoEq_ gamma q pl.
            assume H6: ~q gamma.
            assume H7: pl gamma.
            claim Lc: ordinal gamma.
            { exact ordinal_Hered beta Lb gamma Hc2. }
            claim Lsc: ordinal (ordsucc gamma).
            { exact ordinal_ordsucc gamma Lc. }
            claim Lsca: ordsucc gamma :e alpha.
            { exact H1 gamma Hc1. }
            prove False.
            apply Lpl2 (ordsucc gamma) Lsca.
            assume Hpl2: PNo_rel_strict_imv L R (ordsucc gamma) pl.
            assume _.
            apply Hpl2.
            assume _.
            assume Hpl2b: PNo_rel_strict_lowerbd R (ordsucc gamma) pl.
            claim Lplq: PNoLt (ordsucc gamma) pl gamma q.
            { apply Hpl2b gamma (ordsuccI2 gamma) q.
              prove PNo_upc R gamma q.
              apply PNoLe_upc R beta gamma q q Lb Lc.
              - prove PNo_upc R beta q. exact Hq.
              - prove PNoLe beta q gamma q.
                apply PNoLeI1 beta gamma q q.
                prove PNoLt beta q gamma q.
                apply PNoLtI3.
                + prove gamma :e beta. exact Hc2.
                + prove PNoEq_ gamma q q. apply PNoEq_ref_.
                + prove ~q gamma. exact H6.
            }
            claim Lqpl: PNoLt gamma q (ordsucc gamma) pl.
            { apply PNoLtI2.
              - prove gamma :e ordsucc gamma. apply ordsuccI2.
              - prove PNoEq_ gamma q pl. exact H5.
              - prove pl gamma. exact H7.
            }
            prove False.
            apply PNoLt_irref gamma q.
            exact PNoLt_tra gamma (ordsucc gamma) gamma Lc Lsc Lc q pl q Lqpl Lplq.
          + assume H3: beta :e alpha.
            assume H4: PNoEq_ beta q pl.
            assume H5: pl beta.
            apply Lpl2 (ordsucc beta) Lsba.
            assume Hpl2: PNo_rel_strict_imv L R (ordsucc beta) pl.
            assume _.
            apply Hpl2.
            assume _.
            assume Hpl2b: PNo_rel_strict_lowerbd R (ordsucc beta) pl.
            claim Lplq: PNoLt (ordsucc beta) pl beta q.
            { apply Hpl2b beta (ordsuccI2 beta) q.
              prove PNo_upc R beta q.
              exact Hq.
            }
            claim Lqpl: PNoLt beta q (ordsucc beta) pl.
            { apply PNoLtI2.
              - prove beta :e ordsucc beta. apply ordsuccI2.
              - prove PNoEq_ beta q pl. exact H4.
              - prove pl beta. exact H5.
            }
            prove False.
            apply PNoLt_irref beta q.
            exact PNoLt_tra beta (ordsucc beta) beta Lb Lsb Lb q pl q Lqpl Lplq.
          + assume H3: alpha :e beta. prove False.
            exact In_no2cycle beta alpha Hb H3.
      }
  + prove forall q:set -> prop, PNo_rel_strict_imv L R alpha q -> PNoEq_ alpha pl q.
    let q.
    assume Hq: PNo_rel_strict_imv L R alpha q.
    let gamma.
    assume Hc: gamma :e alpha.
    prove pl gamma <-> q gamma.
    claim Lsca: ordsucc gamma :e alpha.
    { exact H1 gamma Hc. }
    apply Lpl2 (ordsucc gamma) Lsca.
    assume _.
    assume Hpl3: forall q:set -> prop, PNo_rel_strict_imv L R (ordsucc gamma) q -> PNoEq_ (ordsucc gamma) pl q.
    apply Hpl3.
    * prove PNo_rel_strict_imv L R (ordsucc gamma) q.
      exact PNo_rel_strict_imv_antimon L R alpha Ha q (ordsucc gamma) Lsca Hq.
    * prove gamma :e ordsucc gamma. apply ordsuccI2.
- assume H1: exists beta :e alpha, alpha = ordsucc beta.
  apply H1.
  let beta. assume H1. apply H1.
  assume Hb: beta :e alpha.
  assume Hab: alpha = ordsucc beta.
  claim Lb: ordinal beta.
  { exact ordinal_Hered alpha Ha beta Hb. }
  claim Lsb: ordinal (ordsucc beta).
  { rewrite <- Hab. exact Ha. }
  claim Lbsb1: beta :/\: ordsucc beta = beta.
  { apply binintersect_Subq_eq_1. apply ordsuccI1. }
  claim Lbsb2: ordsucc beta :/\: beta = beta.
  { rewrite binintersect_com. exact Lbsb1. }
  apply LIH beta Hb.
  let p.
  assume Hp: PNo_rel_strict_uniq_imv L R beta p.
  apply Hp.
  assume Hp0: PNo_rel_strict_imv L R beta p.
  apply Hp0.
  assume Hp1: forall gamma :e beta, forall q:set -> prop, PNo_downc L gamma q -> PNoLt gamma q beta p.
  assume Hp2: forall gamma :e beta, forall q:set -> prop, PNo_upc R gamma q -> PNoLt beta p gamma q.
  assume Hp3: forall q:set -> prop, PNo_rel_strict_imv L R beta q -> PNoEq_ beta p q.
  set p0 : set -> prop := fun delta => p delta /\ delta <> beta.
  set p1 : set -> prop := fun delta => p delta \/ delta = beta.
  claim Lp0e: PNoEq_ beta p0 p.
  { let gamma. assume Hc: gamma :e beta.
    prove p0 gamma <-> p gamma.
    apply iffI.
    - assume H2: p gamma /\ gamma <> beta. prove p gamma. apply H2. assume H2 _. exact H2.
    - assume H2: p gamma. prove p gamma /\ gamma <> beta. apply andI.
      + exact H2.
      + assume H3: gamma = beta. apply In_irref beta. rewrite <- H3 at 1. exact Hc.
  }
  claim Lp0b: ~p0 beta.
  { assume H2: p beta /\ beta <> beta. apply H2. assume _ H2. apply H2. reflexivity. }
  claim Lp0p: PNoLt (ordsucc beta) p0 beta p.
  { apply PNoLtI3.
    - prove beta :e ordsucc beta. apply ordsuccI2.
    - prove PNoEq_ beta p0 p. exact Lp0e.
    - prove ~p0 beta. exact Lp0b.
  }
  claim Lp1e: PNoEq_ beta p p1.
  { let gamma. assume Hc: gamma :e beta.
    prove p gamma <-> p1 gamma.
    apply iffI.
    - assume H2: p gamma. prove p gamma \/ gamma = beta. apply orIL. exact H2.
    - assume H2: p gamma \/ gamma = beta. prove p gamma. apply H2.
      + assume H3: p gamma. exact H3.
      + assume H3: gamma = beta. prove False. apply In_irref beta. rewrite <- H3 at 1. exact Hc.
  }
  claim Lp1b: p1 beta.
  { prove p beta \/ beta = beta. apply orIR. reflexivity. }
  claim Lpp1: PNoLt beta p (ordsucc beta) p1.
  { apply PNoLtI2.
    - prove beta :e ordsucc beta. apply ordsuccI2.
    - prove PNoEq_ beta p p1. exact Lp1e.
    - prove p1 beta. exact Lp1b.
  }
  claim Lnotboth: ~(PNo_rel_strict_imv L R alpha p0 /\ PNo_rel_strict_imv L R alpha p1).
  { rewrite Hab. assume H2.
    apply HNC2. witness beta. apply andI.
    - prove beta :e alpha. exact Hb.
    - witness p.
      prove PNo_rel_strict_split_imv L R beta p.
      exact H2.
  }
  claim Lcases : (forall q:set -> prop, PNo_downc L beta q -> ~PNoEq_ beta p q)
              \/ (forall q:set -> prop, PNo_upc R beta q -> ~PNoEq_ beta p q).
  {  rewrite eq_or_nand.
     assume H2. apply H2.
     assume H2: ~(forall q:set -> prop, PNo_downc L beta q -> ~PNoEq_ beta p q).
     assume H3: ~(forall q:set -> prop, PNo_upc R beta q -> ~PNoEq_ beta p q).
     apply H2.
     let q0.
     assume H4: PNo_downc L beta q0.
     assume H5: PNoEq_ beta p q0.
     apply H3.
     let q1.
     assume H6: PNo_upc R beta q1.
     assume H7: PNoEq_ beta p q1.
     claim L2: PNoLt beta q0 beta q1.
     { exact LLR beta Lb q0 H4 beta Lb q1 H6. }
     apply PNoLt_irref beta q0.
     apply PNoLtLe_tra beta beta beta Lb Lb Lb q0 q1 q0 L2.
     prove PNoLe beta q1 beta q0.
     prove PNoLt beta q1 beta q0 \/ beta = beta /\ PNoEq_ beta q1 q0.
     apply orIR.
     apply andI.
     - reflexivity.
     - prove PNoEq_ beta q1 q0. apply PNoEq_tra_ beta q1 p q0.      
       + prove PNoEq_ beta q1 p. apply PNoEq_sym_. exact H7.
       + prove PNoEq_ beta p q0. exact H5.
  }
  prove False.
  apply Lcases.
  + assume H2: forall q:set -> prop, PNo_downc L beta q -> ~PNoEq_ beta p q.
    claim Lp0imv: PNo_rel_strict_imv L R (ordsucc beta) p0.
    { prove PNo_rel_strict_upperbd L (ordsucc beta) p0
         /\ PNo_rel_strict_lowerbd R (ordsucc beta) p0.
      apply andI.
      - let gamma. assume Hc: gamma :e ordsucc beta. let q.
        assume H3: PNo_downc L gamma q.
        claim Lc: ordinal gamma.
        { exact ordinal_Hered (ordsucc beta) Lsb gamma Hc. }
        prove PNoLt gamma q (ordsucc beta) p0.
        apply ordsuccE beta gamma Hc.
        + assume H4: gamma :e beta.
          claim L1: PNoLt gamma q beta p.
          { exact Hp1 gamma H4 q H3. }
          apply PNoLtE gamma beta q p L1.
          * { assume H5: PNoLt_ (gamma :/\: beta) q p.
              apply H5.
              let delta. assume H6. apply H6.
              assume Hd: delta :e gamma :/\: beta.
              assume H6. apply H6. assume H6. apply H6.
              assume H6: PNoEq_ delta q p.
              assume H7: ~q delta.
              assume H8: p delta.
              apply binintersectE gamma beta delta Hd.
              assume Hd1: delta :e gamma.
              assume Hd2: delta :e beta.
              prove PNoLt gamma q (ordsucc beta) p0.
              apply PNoLtI1.
              prove PNoLt_ (gamma :/\: ordsucc beta) q p0.
              prove exists beta :e gamma :/\: ordsucc beta, PNoEq_ beta q p0 /\ ~q beta /\ p0 beta.
              witness delta.
              apply andI.
              - prove delta :e gamma :/\: ordsucc beta. apply binintersectI.
                + exact Hd1.
                + apply ordsuccI1. exact Hd2.
              - apply and3I.
                + prove PNoEq_ delta q p0. apply PNoEq_tra_ delta q p p0.
                  * exact H6.
                  * apply PNoEq_sym_.
                    apply PNoEq_antimon_ p0 p beta Lb delta Hd2.
                    exact Lp0e.
                + prove ~q delta. exact H7.
                + prove p0 delta.
                  prove p delta /\ delta <> beta.
                  apply andI.
                  * exact H8.
                  * assume H9: delta = beta.
                    apply In_irref beta.
                    rewrite <- H9 at 1. exact Hd2.
            }
          * { assume H5: gamma :e beta.
              assume H6: PNoEq_ gamma q p.
              assume H7: p gamma.
              prove PNoLt gamma q (ordsucc beta) p0.
              apply PNoLtI2.
              - prove gamma :e ordsucc beta. apply ordsuccI1. exact H5.
              - prove PNoEq_ gamma q p0.
                apply PNoEq_tra_ gamma q p p0.
                + prove PNoEq_ gamma q p. exact H6.
                + prove PNoEq_ gamma p p0. apply PNoEq_sym_.
                  apply PNoEq_antimon_ p0 p beta Lb gamma H5.
                  exact Lp0e.
              - prove p0 gamma.
                prove p gamma /\ gamma <> beta.
                apply andI.
                + exact H7.
                + assume H8: gamma = beta. apply In_irref gamma. rewrite H8 at 2. exact H5.
            }
          * assume H5: beta :e gamma.
            prove False.
            exact In_no2cycle gamma beta H4 H5.
        + assume H4: gamma = beta.
          rewrite H4.
          prove PNoLt beta q (ordsucc beta) p0.
          apply PNoLt_trichotomy_or beta (ordsucc beta) q p0 Lb Lsb. assume H5. apply H5.
          * assume H5. exact H5.
          * assume H5. apply H5. assume H5: beta = ordsucc beta. prove False.
            apply In_irref beta. rewrite H5 at 2. apply ordsuccI2.
          * { assume H5: PNoLt (ordsucc beta) p0 beta q.
              apply PNoLtE (ordsucc beta) beta p0 q H5.
              - rewrite Lbsb2.
                assume H6: PNoLt_ beta p0 q.
                apply H6.
                let delta. assume H7. apply H7.
                assume Hd: delta :e beta.
                assume H7. apply H7. assume H7. apply H7.
                assume H7: PNoEq_ delta p0 q.
                assume H8: ~p0 delta.
                assume H9: q delta.
                claim Ld: ordinal delta.
                { exact ordinal_Hered beta Lb delta Hd. }
                claim L2: PNoLt beta p delta q.
                { apply PNoLtI3.
                  - prove delta :e beta. exact Hd.
                  - prove PNoEq_ delta p q. apply PNoEq_tra_ delta p p0 q.
                    + prove PNoEq_ delta p p0. apply PNoEq_sym_.
                      apply PNoEq_antimon_ p0 p beta Lb delta Hd.
                      exact Lp0e.
                    + prove PNoEq_ delta p0 q. exact H7.
                  - prove ~p delta.
                    assume H10: p delta.
                    apply H8.
                    prove p delta /\ delta <> beta.
                    apply andI.
                    + exact H10.
                    + assume H11: delta = beta. apply In_irref beta. rewrite <- H11 at 1.
                      exact Hd.
                }
                claim L3: PNoLt delta q beta p.
                { apply Hp1 delta Hd q.
                  prove PNo_downc L delta q. (** This is where I need to use PNo_downc L instead of just L since all I know is PNo_downc L gamma q where gamma=beta here. **)
                  apply PNoLe_downc L gamma delta q q Lc Ld H3.
                  prove PNoLe delta q gamma q.
                  apply PNoLeI1.
                  prove PNoLt delta q gamma q.
                  apply PNoLtI2.
                  - prove delta :e gamma. rewrite H4. exact Hd.
                  - prove PNoEq_ delta q q. apply PNoEq_ref_.
                  - prove q delta. exact H9.
                }
              apply PNoLt_irref delta q.
              prove PNoLt delta q delta q.
              exact PNoLt_tra delta beta delta Ld Lb Ld q p q L3 L2.
              - assume H6: ordsucc beta :e beta. prove False.
                apply In_no2cycle (ordsucc beta) beta H6.
                apply ordsuccI2.
              - assume H6: beta :e ordsucc beta.
                assume H7: PNoEq_ beta p0 q.
                prove False.
                apply H2 q.
                + prove PNo_downc L beta q.
                  rewrite <- H4.
                  exact H3.
                + prove PNoEq_ beta p q.
                  apply PNoEq_tra_ beta p p0 q.
                  * apply PNoEq_sym_. exact Lp0e.
                  * exact H7.
            }
      - let gamma. assume Hc: gamma :e ordsucc beta. let q.
        assume H3: PNo_upc R gamma q.
        claim Lc: ordinal gamma.
        { exact ordinal_Hered (ordsucc beta) Lsb gamma Hc. }
        prove PNoLt (ordsucc beta) p0 gamma q.
        apply ordsuccE beta gamma Hc.
        + assume H4: gamma :e beta.
          apply PNoLt_tra (ordsucc beta) beta gamma Lsb Lb Lc p0 p q Lp0p.
          prove PNoLt beta p gamma q.
          apply Hp2 gamma H4 q.
          prove PNo_upc R gamma q.
          exact H3.
        + assume H4: gamma = beta.
          rewrite H4.
          prove PNoLt (ordsucc beta) p0 beta q.
          apply PNoLt_trichotomy_or beta (ordsucc beta) q p0 Lb Lsb. assume H5. apply H5.
          * { assume H5: PNoLt beta q (ordsucc beta) p0.
              apply PNoLtE beta (ordsucc beta) q p0 H5.
              - rewrite Lbsb1.
                assume H6: PNoLt_ beta q p0.
                apply H6.
                let delta.
                assume H7. apply H7.
                assume H8: delta :e beta.
                assume H9. apply H9. assume H9. apply H9.
                assume H9: PNoEq_ delta q p0.
                assume H10: ~q delta.
                assume H11: p0 delta.
                prove False.
                claim Ld: ordinal delta.
                { exact ordinal_Hered beta Lb delta H8. }
                claim L4: PNoLt beta p delta q.
                { apply Hp2 delta H8 q.
                  prove PNo_upc R delta q. (** Using PNo_upc R instead of R in an apparently important way. **)
                  apply PNoLe_upc R gamma delta q q Lc Ld H3.
                  prove PNoLe gamma q delta q.
                  apply PNoLeI1.
                  prove PNoLt gamma q delta q.
                  apply PNoLtI3.
                  - prove delta :e gamma. rewrite H4. exact H8.
                  - prove PNoEq_ delta q q. apply PNoEq_ref_.
                  - prove ~q delta. exact H10.
                }
                claim L5: PNoLt delta q beta p.
                { apply PNoLtI2.
                  - prove delta :e beta. exact H8.
                  - prove PNoEq_ delta q p. apply PNoEq_tra_ delta q p0 p.
                    + exact H9.
                    + prove PNoEq_ delta p0 p.
                      apply PNoEq_antimon_ p0 p beta Lb delta H8.
                      exact Lp0e.
                  - prove p delta. apply H11. assume H12 _. exact H12.
                }
                apply PNoLt_irref beta p.
                exact PNoLt_tra beta delta beta Lb Ld Lb p q p L4 L5.
              - assume H6: beta :e ordsucc beta.
                assume H7: PNoEq_ beta q p0.
                assume H8: p beta /\ beta <> beta.
                prove False.
                apply H8. assume _ H9. apply H9. reflexivity.
              - assume H6: ordsucc beta :e beta.
                prove False.
                apply In_no2cycle (ordsucc beta) beta H6.
                apply ordsuccI2.
            }
          * assume H5. apply H5. assume H5: beta = ordsucc beta.
            prove False.
            apply In_irref beta.
            rewrite H5 at 2.
            apply ordsuccI2.
          * assume H5: PNoLt (ordsucc beta) p0 beta q. exact H5.
    }
    apply HNC1.
    witness p0.
    rewrite Hab.
    prove PNo_rel_strict_uniq_imv L R (ordsucc beta) p0.
    prove PNo_rel_strict_imv L R (ordsucc beta) p0
       /\ forall q:set -> prop, PNo_rel_strict_imv L R (ordsucc beta) q -> PNoEq_ (ordsucc beta) p0 q.
    apply andI.
    * exact Lp0imv.
    * { let q. assume Hq: PNo_rel_strict_imv L R (ordsucc beta) q.
        prove PNoEq_ (ordsucc beta) p0 q.
        claim Lqb: PNo_rel_strict_imv L R beta q.
        { exact PNo_rel_strict_imv_antimon L R (ordsucc beta) Lsb q beta (ordsuccI2 beta) Hq. }
        claim Lpqe: PNoEq_ beta p q.
        { exact Hp3 q Lqb. }
        apply xm (q beta).
        - assume Hq1: q beta.
          prove False.
          apply Lnotboth. rewrite Hab.
          apply andI.
          + prove PNo_rel_strict_imv L R (ordsucc beta) p0. exact Lp0imv.
          + prove PNo_rel_strict_imv L R (ordsucc beta) p1.
            apply PNoEq_rel_strict_imv L R (ordsucc beta) Lsb q p1.
            * { prove PNoEq_ (ordsucc beta) q p1.
                let gamma. assume Hc: gamma :e ordsucc beta.
                apply ordsuccE beta gamma Hc.
                - assume H3: gamma :e beta.
                  claim Lpqce: p gamma <-> q gamma.
                  { exact Lpqe gamma H3. }
                  apply Lpqce. assume Hpqc Hqpc.
                  prove q gamma <-> p1 gamma.
                  apply iffI.
                  + assume H4: q gamma.
                    prove p gamma \/ gamma = beta.
                    apply orIL.
                    exact Hqpc H4.
                  + assume H4: p gamma \/ gamma = beta.
                    apply H4.
                    * exact Hpqc.
                    * assume H5: gamma = beta. prove False.
                      apply In_irref beta. rewrite <- H5 at 1. exact H3.
                - assume H3: gamma = beta.
                  prove q gamma <-> p1 gamma.
                  apply iffI.
                  + assume _.
                    prove p gamma \/ gamma = beta.
                    apply orIR. exact H3.
                  + assume _.
                    prove q gamma. rewrite H3. exact Hq1.
              }
            * prove PNo_rel_strict_imv L R (ordsucc beta) q. exact Hq.
        - assume Hq0: ~ q beta.
          prove PNoEq_ (ordsucc beta) p0 q.
          let gamma. assume Hc: gamma :e ordsucc beta.
          apply ordsuccE beta gamma Hc.
          + assume H3: gamma :e beta.
            claim Lpqce: p gamma <-> q gamma.
            { exact Lpqe gamma H3. }
            apply Lpqce. assume Hpqc Hqpc.
            prove p0 gamma <-> q gamma.
            apply iffI.
            * { assume H4: p gamma /\ gamma <> beta.
                apply H4.
                assume H5: p gamma.
                assume _. exact Hpqc H5.
              }
            * { assume H4: q gamma.
                prove p gamma /\ gamma <> beta.
                apply andI.
                - prove p gamma. exact Hqpc H4.
                - prove gamma <> beta. assume H5: gamma = beta.
                  apply In_irref beta. rewrite <- H5 at 1. exact H3.
              }
          + assume H3: gamma = beta.
            prove p0 gamma <-> q gamma.
            apply iffI.
            * assume H4: p gamma /\ gamma <> beta.
              apply H4. assume _ H5. prove False. exact H5 H3.
            * assume H4: q gamma. prove False. apply Hq0.
              prove q beta. rewrite <- H3. exact H4.
      }
  + assume H2: forall q:set -> prop, PNo_upc R beta q -> ~PNoEq_ beta p q.
    claim Lp1imv: PNo_rel_strict_imv L R (ordsucc beta) p1.
    { prove PNo_rel_strict_upperbd L (ordsucc beta) p1
         /\ PNo_rel_strict_lowerbd R (ordsucc beta) p1.
      apply andI.
      - let gamma. assume Hc: gamma :e ordsucc beta. let q.
        assume H3: PNo_downc L gamma q.
        claim Lc: ordinal gamma.
        { exact ordinal_Hered (ordsucc beta) Lsb gamma Hc. }
        prove PNoLt gamma q (ordsucc beta) p1.
        apply ordsuccE beta gamma Hc.
        + assume H4: gamma :e beta.
          apply PNoLt_tra gamma beta (ordsucc beta) Lc Lb Lsb q p p1.
          * prove PNoLt gamma q beta p.
            apply Hp1 gamma H4 q.
            prove PNo_downc L gamma q.
            exact H3.
          * exact Lpp1.
        + assume H4: gamma = beta.
          rewrite H4.
          prove PNoLt beta q (ordsucc beta) p1.
          apply PNoLt_trichotomy_or beta (ordsucc beta) q p1 Lb Lsb. assume H5. apply H5.
          * assume H5: PNoLt beta q (ordsucc beta) p1. exact H5.
          * assume H5. apply H5. assume H5: beta = ordsucc beta.
            prove False.
            apply In_irref beta.
            rewrite H5 at 2.
            apply ordsuccI2.
          * { assume H5: PNoLt (ordsucc beta) p1 beta q.
              apply PNoLtE (ordsucc beta) beta p1 q H5.
              - rewrite Lbsb2.
                assume H6: PNoLt_ beta p1 q.
                apply H6.
                let delta.
                assume H7. apply H7.
                assume H8: delta :e beta.
                assume H9. apply H9. assume H9. apply H9.
                assume H9: PNoEq_ delta p1 q.
                assume H10: ~p1 delta.
                assume H11: q delta.
                prove False.
                claim Ld: ordinal delta.
                { exact ordinal_Hered beta Lb delta H8. }
                claim L4: PNoLt delta q beta p.
                { apply Hp1 delta H8 q.
                  prove PNo_downc L delta q. (** Using PNo_downc L instead of L in an apparently important way. **)
                  apply PNoLe_downc L gamma delta q q Lc Ld H3.
                  prove PNoLe delta q gamma q.
                  apply PNoLeI1.
                  prove PNoLt delta q gamma q.
                  apply PNoLtI2.
                  - prove delta :e gamma. rewrite H4. exact H8.
                  - prove PNoEq_ delta q q. apply PNoEq_ref_.
                  - prove q delta. exact H11.
                }
                claim L5: PNoLt beta p delta q.
                { apply PNoLtI3.
                  - prove delta :e beta. exact H8.
                  - prove PNoEq_ delta p q. apply PNoEq_tra_ delta p p1 q.
                    + prove PNoEq_ delta p p1.
                      apply PNoEq_antimon_ p p1 beta Lb delta H8.
                      exact Lp1e.
                    + exact H9.
                  - prove ~p delta. 
                    assume H12: p delta.
                    apply H10.
                    prove p delta \/ delta = beta.
                    apply orIL. exact H12.
                }
                apply PNoLt_irref beta p.
                exact PNoLt_tra beta delta beta Lb Ld Lb p q p L5 L4.
              - assume H6: ordsucc beta :e beta.
                prove False.
                apply In_no2cycle (ordsucc beta) beta H6.
                apply ordsuccI2.
              - assume H6: beta :e ordsucc beta.
                assume H7: PNoEq_ beta p1 q.
                assume H8: ~p1 beta.
                prove False.
                apply H8.
                prove p beta \/ beta = beta.
                apply orIR. reflexivity.
            }
      - let gamma. assume Hc: gamma :e ordsucc beta. let q.
        assume H3: PNo_upc R gamma q.
        claim Lc: ordinal gamma.
        { exact ordinal_Hered (ordsucc beta) Lsb gamma Hc. }
        prove PNoLt (ordsucc beta) p1 gamma q.
        apply ordsuccE beta gamma Hc.
        + assume H4: gamma :e beta.
          claim L1: PNoLt beta p gamma q.
          { exact Hp2 gamma H4 q H3. }
          apply PNoLtE beta gamma p q L1.
          * { assume H5: PNoLt_ (beta :/\: gamma) p q.
              apply H5.
              let delta. assume H6. apply H6.
              assume Hd: delta :e beta :/\: gamma.
              assume H6. apply H6. assume H6. apply H6.
              assume H6: PNoEq_ delta p q.
              assume H7: ~p delta.
              assume H8: q delta.
              apply binintersectE beta gamma delta Hd.
              assume Hd2: delta :e beta.
              assume Hd1: delta :e gamma.
              prove PNoLt (ordsucc beta) p1 gamma q.
              apply PNoLtI1.
              prove PNoLt_ (ordsucc beta :/\: gamma) p1 q.
              prove exists beta :e ordsucc beta :/\: gamma, PNoEq_ beta p1 q /\ ~p1 beta /\ q beta.
              witness delta.
              apply andI.
              - prove delta :e ordsucc beta :/\: gamma. apply binintersectI.
                + apply ordsuccI1. exact Hd2.
                + exact Hd1.
              - apply and3I.
                + prove PNoEq_ delta p1 q. apply PNoEq_tra_ delta p1 p q.
                  * apply PNoEq_antimon_ p1 p beta Lb delta Hd2.
                    apply PNoEq_sym_.
                    exact Lp1e.
                  * exact H6.
                + prove ~p1 delta.
                  assume H9: p delta \/ delta = beta.
                  prove False.
                  apply H9.
                  * exact H7.
                  * assume H10: delta = beta.
                    apply In_irref beta. rewrite <- H10 at 1. exact Hd2.
                + prove q delta. exact H8.
            }
          * assume H5: beta :e gamma.
            prove False.
            exact In_no2cycle gamma beta H4 H5.
          * { assume H5: gamma :e beta.
              assume H6: PNoEq_ gamma p q. 
              assume H7: ~p gamma.
              prove PNoLt (ordsucc beta) p1 gamma q.
              apply PNoLtI3.
              - prove gamma :e ordsucc beta. apply ordsuccI1. exact H5.
              - prove PNoEq_ gamma p1 q.
                apply PNoEq_tra_ gamma p1 p q.
                + prove PNoEq_ gamma p1 p.
                  apply PNoEq_antimon_ p1 p beta Lb gamma H5.
                  apply PNoEq_sym_.
                  exact Lp1e.
                + prove PNoEq_ gamma p q. exact H6.
              - prove ~p1 gamma.
                assume H8: p gamma \/ gamma = beta.
                apply H8.
                + exact H7.
                + assume H9: gamma = beta.
                  apply In_irref beta.
                  rewrite <- H9 at 1.
                  exact H5.
            }
        + assume H4: gamma = beta.
          rewrite H4.
          prove PNoLt (ordsucc beta) p1 beta q.
          apply PNoLt_trichotomy_or beta (ordsucc beta) q p1 Lb Lsb. assume H5. apply H5.
          * { assume H5: PNoLt beta q (ordsucc beta) p1.
              apply PNoLtE beta (ordsucc beta) q p1 H5.
              - rewrite Lbsb1.
                assume H6: PNoLt_ beta q p1.
                apply H6.
                let delta. assume H7. apply H7.
                assume Hd: delta :e beta.
                assume H7. apply H7. assume H7. apply H7.
                assume H7: PNoEq_ delta q p1.
                assume H8: ~q delta.
                assume H9: p1 delta.
                claim Ld: ordinal delta.
                { exact ordinal_Hered beta Lb delta Hd. }
                claim L2: PNoLt delta q beta p.
                { apply PNoLtI2.
                  - prove delta :e beta. exact Hd.
                  - prove PNoEq_ delta q p. apply PNoEq_tra_ delta q p1 p.
                    + prove PNoEq_ delta q p1. exact H7.
                    + prove PNoEq_ delta p1 p.
                      apply PNoEq_antimon_ p1 p beta Lb delta Hd.
                      apply PNoEq_sym_.
                      exact Lp1e.
                  - prove p delta.
                    apply H9.
                    + assume H10: p delta. exact H10.
                    + assume H10: delta = beta. prove False.
                      apply In_irref beta. rewrite <- H10 at 1. exact Hd.
                }
                claim L3: PNoLt beta p delta q.
                { apply Hp2 delta Hd q.
                  prove PNo_upc R delta q. (** This is where I need to use PNo_upc R instead of just R since all I know is PNo_upc R gamma q where gamma=beta here. **)
                  apply PNoLe_upc R gamma delta q q Lc Ld H3.
                  prove PNoLe gamma q delta q.
                  apply PNoLeI1.
                  prove PNoLt gamma q delta q.
                  apply PNoLtI3.
                  - prove delta :e gamma. rewrite H4. exact Hd.
                  - prove PNoEq_ delta q q. apply PNoEq_ref_.
                  - prove ~q delta. exact H8.
                }
              apply PNoLt_irref delta q.
              prove PNoLt delta q delta q.
              exact PNoLt_tra delta beta delta Ld Lb Ld q p q L2 L3.
              - assume H6: beta :e ordsucc beta.
                assume H7: PNoEq_ beta q p1.
                prove False.
                apply H2 q.
                + prove PNo_upc R beta q.
                  rewrite <- H4.
                  exact H3.
                + prove PNoEq_ beta p q.
                  apply PNoEq_tra_ beta p p1 q.
                  * exact Lp1e.
                  * apply PNoEq_sym_. exact H7.
              - assume H6: ordsucc beta :e beta. prove False.
                apply In_no2cycle (ordsucc beta) beta H6.
                apply ordsuccI2.
            }
          * assume H5. apply H5. assume H5: beta = ordsucc beta. prove False.
            apply In_irref beta. rewrite H5 at 2. apply ordsuccI2.
          * assume H5. exact H5.
    }
    apply HNC1.
    witness p1.
    rewrite Hab.
    prove PNo_rel_strict_uniq_imv L R (ordsucc beta) p1.
    prove PNo_rel_strict_imv L R (ordsucc beta) p1
       /\ forall q:set -> prop, PNo_rel_strict_imv L R (ordsucc beta) q -> PNoEq_ (ordsucc beta) p1 q.
    apply andI.
    * exact Lp1imv.
    * { let q. assume Hq: PNo_rel_strict_imv L R (ordsucc beta) q.
        prove PNoEq_ (ordsucc beta) p1 q.
        claim Lqb: PNo_rel_strict_imv L R beta q.
        { exact PNo_rel_strict_imv_antimon L R (ordsucc beta) Lsb q beta (ordsuccI2 beta) Hq. }
        claim Lpqe: PNoEq_ beta p q.
        { exact Hp3 q Lqb. }
        apply xm (q beta).
        - assume Hq1: q beta.
          prove PNoEq_ (ordsucc beta) p1 q.
          let gamma. assume Hc: gamma :e ordsucc beta.
          apply ordsuccE beta gamma Hc.
          + assume H3: gamma :e beta.
            claim Lpqce: p gamma <-> q gamma.
            { exact Lpqe gamma H3. }
            apply Lpqce. assume Hpqc Hqpc.
            prove p1 gamma <-> q gamma.
            apply iffI.
            * { assume H4: p gamma \/ gamma = beta.
                apply H4.
                - assume H5: p gamma. exact Hpqc H5.
                - assume H5: gamma = beta. prove False.
                  apply In_irref beta. rewrite <- H5 at 1. exact H3.
              }
            * { assume H4: q gamma.
                prove p gamma \/ gamma = beta.
                apply orIL.
                prove p gamma. exact Hqpc H4.
              }
          + assume H3: gamma = beta.
            prove p1 gamma <-> q gamma.
            apply iffI.
            * { assume _. prove q gamma. rewrite H3. prove q beta. exact Hq1. }
            * { assume H4: q gamma. prove p gamma \/ gamma = beta.
                apply orIR. exact H3.
              }
        - assume Hq0: ~ q beta.
          prove False.
          apply Lnotboth. rewrite Hab.
          apply andI.
          + prove PNo_rel_strict_imv L R (ordsucc beta) p0.
            apply PNoEq_rel_strict_imv L R (ordsucc beta) Lsb q p0.
            * { prove PNoEq_ (ordsucc beta) q p0.
                let gamma. assume Hc: gamma :e ordsucc beta.
                apply ordsuccE beta gamma Hc.
                - assume H3: gamma :e beta.
                  claim Lpqce: p gamma <-> q gamma.
                  { exact Lpqe gamma H3. }
                  apply Lpqce. assume Hpqc Hqpc.
                  prove q gamma <-> p0 gamma.
                  apply iffI.
                  + assume H4: q gamma.
                    prove p gamma /\ gamma <> beta.
                    apply andI.
                    * prove p gamma.
                      exact Hqpc H4.
                    * prove gamma <> beta.
                      assume H5: gamma = beta.
                      apply In_irref beta.
                      rewrite <- H5 at 1.
                      exact H3.
                  + assume H4: p gamma /\ gamma <> beta.
                    apply H4. assume H5 _. exact Hpqc H5.
                - assume H3: gamma = beta.
                  prove q gamma <-> p0 gamma.
                  apply iffI.
                  + assume H4: q gamma.
                    prove False.
                    apply Hq0.
                    rewrite <- H3.
                    exact H4.
                  + assume H4: p0 gamma.
                    apply H4.
                    assume _ H5. prove False. apply H5. exact H3.
              }
            * prove PNo_rel_strict_imv L R (ordsucc beta) q. exact Hq.
          + prove PNo_rel_strict_imv L R (ordsucc beta) p1. exact Lp1imv.
      }
Qed.

Definition PNo_lenbdd : set -> (set -> (set -> prop) -> prop) -> prop
  := fun alpha L => forall beta, forall p:set -> prop, L beta p -> beta :e alpha.

Theorem PNo_lenbdd_strict_imv_extend0 : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta /\ delta <> alpha).
let L R.
let alpha. assume Ha. apply Ha. assume Ha1 _.
assume HaL HaR.
let p.
assume Hp1: PNo_rel_strict_imv L R alpha p.
apply Hp1.
assume Hp1a Hp1b.
set p0 : set -> prop := fun delta => p delta /\ delta <> alpha.
claim Lsa: ordinal (ordsucc alpha).
{ exact ordinal_ordsucc alpha Ha. }
claim Lpp0e: PNoEq_ alpha p p0.
{ exact PNo_extend0_eq alpha p. }
prove PNo_rel_strict_upperbd L (ordsucc alpha) p0 /\ PNo_rel_strict_lowerbd R (ordsucc alpha) p0.
apply andI.
- prove PNo_rel_strict_upperbd L (ordsucc alpha) p0.
  let gamma. assume Hc: gamma :e ordsucc alpha.
  let q. assume Hq: PNo_downc L gamma q.
  claim Lc: ordinal gamma.
  { exact ordinal_Hered (ordsucc alpha) Lsa gamma Hc. }
  prove PNoLt gamma q (ordsucc alpha) p0.
  apply Hq.
  let delta. assume Hq1. apply Hq1.
  assume Hd: ordinal delta. assume Hq1. apply Hq1.
  let r. assume Hq1. apply Hq1.
  assume Hr: L delta r.
  assume Hqr: PNoLe gamma q delta r.
  apply PNoLeLt_tra gamma delta (ordsucc alpha) Lc Hd Lsa q r p0 Hqr.
  prove PNoLt delta r (ordsucc alpha) p0.
  claim Lda: delta :e alpha.
  { exact HaL delta r Hr. }
  claim Ldsa: delta :e ordsucc alpha.
  { apply ordsuccI1. exact Lda. }
  claim Ldr: PNo_downc L delta r.
  { exact PNo_downc_ref L delta Hd r Hr. }
  claim Lrp : PNoLt delta r alpha p.
  { exact Hp1a delta Lda r Ldr. }
  apply PNoLt_trichotomy_or delta (ordsucc alpha) r p0 Hd Lsa. assume H1. apply H1.
  + assume H1. exact H1.
  + assume H1. apply H1.
    assume H2: delta = ordsucc alpha.
    prove False.
    apply In_irref delta. rewrite H2 at 2. exact Ldsa.
  + assume H1: PNoLt (ordsucc alpha) p0 delta r.
    prove False.
    apply PNoLt_irref delta r.
    apply PNoLt_tra delta alpha delta Hd Ha Hd r p r Lrp.
    prove PNoLt alpha p delta r.
    apply PNoLtE (ordsucc alpha) delta p0 r H1.
    * { assume H2: PNoLt_ (ordsucc alpha :/\: delta) p0 r.
        apply H2.
        let eps. assume H3. apply H3.
        assume He: eps :e ordsucc alpha :/\: delta.
        apply binintersectE (ordsucc alpha) delta eps He.
        assume He1 He2.
        claim Lea: eps :e alpha.
        { exact Ha1 delta Lda eps He2. }
        assume H3. apply H3. assume H3. apply H3.
        assume H3: PNoEq_ eps p0 r.
        assume H4: ~p0 eps.
        assume H5: r eps.
        apply PNoLtI1.
        prove PNoLt_ (alpha :/\: delta) p r.
        prove exists beta :e alpha :/\: delta, PNoEq_ beta p r /\ ~p beta /\ r beta.
        witness eps.
        apply andI.
        - prove eps :e alpha :/\: delta. apply binintersectI.
          + exact Lea.
          + exact He2.
        - apply and3I.
          + prove PNoEq_ eps p r.
            apply PNoEq_tra_ eps p p0 r.
            * apply PNoEq_antimon_ p p0 alpha Ha eps Lea.
              exact Lpp0e.
            * exact H3.
          + prove ~p eps.
            assume H5: p eps. apply H4.
            prove p eps /\ eps <> alpha.
            apply andI.
            * exact H5.
            * prove eps <> alpha. assume H6: eps = alpha.
              apply In_irref alpha. rewrite <- H6 at 1. exact Lea.
          + prove r eps. exact H5.
      }
    * assume H2: ordsucc alpha :e delta.
      prove False.
      exact In_no2cycle delta (ordsucc alpha) Ldsa H2.
    * { assume H2: delta :e ordsucc alpha.
        assume H3: PNoEq_ delta p0 r.
        assume H4: ~p0 delta.
        apply PNoLtI3 alpha delta p r Lda.
        - prove PNoEq_ delta p r.
          apply PNoEq_tra_ delta p p0 r.
          + apply PNoEq_antimon_ p p0 alpha Ha delta Lda.
            exact Lpp0e.
          + exact H3.
        - prove ~p delta.
          assume H5: p delta. apply H4.
          prove p delta /\ delta <> alpha.
          apply andI.
          + exact H5.
          + prove delta <> alpha. assume H6: delta = alpha.
            apply In_irref alpha. rewrite <- H6 at 1. exact Lda.
      }
- prove PNo_rel_strict_lowerbd R (ordsucc alpha) p0.
  let gamma. assume Hc: gamma :e ordsucc alpha.
  let q. assume Hq: PNo_upc R gamma q.
  claim Lc: ordinal gamma.
  { exact ordinal_Hered (ordsucc alpha) Lsa gamma Hc. }
  prove PNoLt (ordsucc alpha) p0 gamma q.
  apply PNoLt_tra (ordsucc alpha) alpha gamma Lsa Ha Lc p0 p q.
  + prove PNoLt (ordsucc alpha) p0 alpha p.
    apply PNoLtI3.
    * prove alpha :e ordsucc alpha. apply ordsuccI2.
    * prove PNoEq_ alpha p0 p. apply PNoEq_sym_. exact Lpp0e.
    * { prove ~p0 alpha.
        assume H2: p0 alpha. apply H2.
        assume H3: p alpha.
        assume H4: alpha <> alpha. apply H4. reflexivity.
      }
  + prove PNoLt alpha p gamma q.
    apply Hq.
    let delta. assume Hq1. apply Hq1.
    assume Hd: ordinal delta. assume Hq1. apply Hq1.
    let r. assume Hq1. apply Hq1.
    assume Hr: R delta r.
    assume Hrq: PNoLe delta r gamma q.
    claim Ldr: PNo_upc R delta r.
    { exact PNo_upc_ref R delta Hd r Hr. }
    apply (fun H:PNoLt alpha p delta r => PNoLtLe_tra alpha delta gamma Ha Hd Lc p r q H Hrq).
    prove PNoLt alpha p delta r.
    exact Hp1b delta (HaR delta r Hr) r Ldr.
Qed.

Theorem PNo_lenbdd_strict_imv_extend1 : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta \/ delta = alpha).
let L R.
let alpha. assume Ha. apply Ha. assume Ha1 _.
assume HaL HaR.
let p.
assume Hp1: PNo_rel_strict_imv L R alpha p.
apply Hp1.
assume Hp1a Hp1b.
set p1 : set -> prop := fun delta => p delta \/ delta = alpha.
claim Lsa: ordinal (ordsucc alpha).
{ exact ordinal_ordsucc alpha Ha. }
claim Lpp1e: PNoEq_ alpha p p1.
{ exact PNo_extend1_eq alpha p. }
prove PNo_rel_strict_upperbd L (ordsucc alpha) p1 /\ PNo_rel_strict_lowerbd R (ordsucc alpha) p1.
apply andI.
- prove PNo_rel_strict_upperbd L (ordsucc alpha) p1.
  let gamma. assume Hc: gamma :e ordsucc alpha.
  let q. assume Hq: PNo_downc L gamma q.
  claim Lc: ordinal gamma.
  { exact ordinal_Hered (ordsucc alpha) Lsa gamma Hc. }
  prove PNoLt gamma q (ordsucc alpha) p1.
  apply PNoLt_tra gamma alpha (ordsucc alpha) Lc Ha Lsa q p p1.
  + prove PNoLt gamma q alpha p.
    apply Hq.
    let delta. assume Hq1. apply Hq1.
    assume Hd: ordinal delta. assume Hq1. apply Hq1.
    let r. assume Hq1. apply Hq1.
    assume Hr: L delta r.
    assume Hqr: PNoLe gamma q delta r.
    claim Ldr: PNo_downc L delta r.
    { prove exists beta, ordinal beta /\ exists q:set -> prop, L beta q /\ PNoLe delta r beta q.
      witness delta. apply andI.
      - exact Hd.
      - witness r. apply andI.
        + exact Hr.
        + apply PNoLe_ref.
    }
    apply PNoLeLt_tra gamma delta alpha Lc Hd Ha q r p Hqr.
    prove PNoLt delta r alpha p.
    exact Hp1a delta (HaL delta r Hr) r Ldr.
  + prove PNoLt alpha p (ordsucc alpha) p1.
    apply PNoLtI2.
    * prove alpha :e ordsucc alpha. apply ordsuccI2.
    * prove PNoEq_ alpha p p1. exact Lpp1e.
    * prove p1 alpha. prove p alpha \/ alpha = alpha. apply orIR. reflexivity.
- prove PNo_rel_strict_lowerbd R (ordsucc alpha) p1.
  let gamma. assume Hc: gamma :e ordsucc alpha.
  let q. assume Hq: PNo_upc R gamma q.
  claim Lc: ordinal gamma.
  { exact ordinal_Hered (ordsucc alpha) Lsa gamma Hc. }
  prove PNoLt (ordsucc alpha) p1 gamma q.
  apply Hq.
  let delta. assume Hq1. apply Hq1.
  assume Hd: ordinal delta. assume Hq1. apply Hq1.
  let r. assume Hq1. apply Hq1.
  assume Hr: R delta r.
  assume Hrq: PNoLe delta r gamma q.
  apply (fun H:PNoLt (ordsucc alpha) p1 delta r => PNoLtLe_tra (ordsucc alpha) delta gamma Lsa Hd Lc p1 r q H Hrq).
  prove PNoLt (ordsucc alpha) p1 delta r.
  claim Lda: delta :e alpha.
  { exact HaR delta r Hr. }
  claim Ldsa: delta :e ordsucc alpha.
  { apply ordsuccI1. exact Lda. }
  claim Ldr: PNo_upc R delta r.
  { prove exists beta, ordinal beta /\ exists q:set -> prop, R beta q /\ PNoLe beta q delta r.
    witness delta. apply andI.
    - exact Hd.
    - witness r. apply andI.
      + exact Hr.
      + apply PNoLe_ref.
  }
  claim Lpr : PNoLt alpha p delta r.
  { exact Hp1b delta Lda r Ldr. }
  apply PNoLt_trichotomy_or delta (ordsucc alpha) r p1 Hd Lsa. assume H1. apply H1.
  + assume H1: PNoLt delta r (ordsucc alpha) p1.
    prove False.
    apply PNoLt_irref alpha p.
    prove PNoLt alpha p alpha p.
    apply PNoLt_tra alpha delta alpha Ha Hd Ha p r p Lpr.
    prove PNoLt delta r alpha p.
    apply PNoLtE delta (ordsucc alpha) r p1 H1.
    * { assume H2: PNoLt_ (delta :/\: ordsucc alpha) r p1.
        apply H2.
        let eps. assume H3. apply H3.
        assume He: eps :e delta :/\: ordsucc alpha.
        apply binintersectE delta (ordsucc alpha) eps He.
        assume He1 He2.
        claim Lea: eps :e alpha.
        { exact Ha1 delta Lda eps He1. }
        assume H3. apply H3. assume H3. apply H3.
        assume H3: PNoEq_ eps r p1.
        assume H4: ~r eps.
        assume H5: p1 eps.
        apply PNoLtI1.
        prove PNoLt_ (delta :/\: alpha) r p.
        prove exists beta :e delta :/\: alpha, PNoEq_ beta r p /\ ~r beta /\ p beta.
        witness eps.
        apply andI.
        - prove eps :e delta :/\: alpha. apply binintersectI.
          + exact He1.
          + exact Lea.
        - apply and3I.
          + prove PNoEq_ eps r p.
            apply PNoEq_tra_ eps r p1 p.
            * exact H3.
            * apply PNoEq_antimon_ p1 p alpha Ha eps Lea.
              apply PNoEq_sym_. exact Lpp1e.
          + prove ~r eps. exact H4.
          + prove p eps.
            apply H5.
            * exact (fun H => H).
            * assume H6: eps = alpha. prove False.
              apply In_irref alpha. rewrite <- H6 at 1. exact Lea.
      }
    * { assume H2: delta :e ordsucc alpha.
        assume H3: PNoEq_ delta r p1.
        assume H4: p1 delta.
        apply PNoLtI2 delta alpha r p Lda.
        - prove PNoEq_ delta r p.
          apply PNoEq_tra_ delta r p1 p.
          + exact H3.
          + apply PNoEq_antimon_ p1 p alpha Ha delta Lda.
            apply PNoEq_sym_. exact Lpp1e.
        - prove p delta.
          apply H4.
          * exact (fun H => H).
          * assume H5: delta = alpha. prove False.
            apply In_irref alpha. rewrite <- H5 at 1. exact Lda.
      }
    * assume H2: ordsucc alpha :e delta.
      prove False.
      exact In_no2cycle delta (ordsucc alpha) Ldsa H2.
  + assume H1. apply H1.
    assume H2: delta = ordsucc alpha.
    prove False.
    apply In_irref delta. rewrite H2 at 2. exact Ldsa.
  + assume H1. exact H1.
Qed.

Theorem PNo_lenbdd_strict_imv_split : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_split_imv L R alpha p.
let L R.
let alpha. assume Ha.
assume HaL HaR.
let p.
assume Hp1.
prove PNo_rel_strict_split_imv L R alpha p.
exact andI (PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta /\ delta <> alpha))
           (PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta \/ delta = alpha))
           (PNo_lenbdd_strict_imv_extend0 L R alpha Ha HaL HaR p Hp1)
           (PNo_lenbdd_strict_imv_extend1 L R alpha Ha HaL HaR p Hp1).
Qed.

Theorem PNo_rel_imv_bdd_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta :e ordsucc alpha,
      exists p:set -> prop, PNo_rel_strict_split_imv L R beta p.
let L R. assume HLR.
let alpha. assume Ha.
apply Ha. assume Ha1 _.
assume HaL HaR.
claim Lsa: ordinal (ordsucc alpha).
{ exact ordinal_ordsucc alpha Ha. }
apply PNo_rel_imv_ex L R HLR alpha Ha.
- assume H2. apply H2.
  let p. assume Hp: PNo_rel_strict_uniq_imv L R alpha p.
  apply Hp.
  assume Hp1: PNo_rel_strict_imv L R alpha p.
  apply Hp1.
  assume Hp1a Hp1b.
  assume Hp2: forall q:set -> prop, PNo_rel_strict_imv L R alpha q -> PNoEq_ alpha p q.
  witness alpha. apply andI.
  + prove alpha :e ordsucc alpha. apply ordsuccI2.
  + witness p.
    prove PNo_rel_strict_split_imv L R alpha p.
    exact PNo_lenbdd_strict_imv_split L R alpha Ha HaL HaR p Hp1.
- assume H1. apply H1.
  let beta. assume H1. apply H1.
  assume Hb: beta :e alpha. assume H1.
  witness beta. apply andI.
  + prove beta :e ordsucc alpha. apply ordsuccI1. exact Hb.
  + exact H1.
Qed.

Definition PNo_strict_upperbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L alpha p =>
       forall beta, ordinal beta -> forall q:set -> prop, L beta q -> PNoLt beta q alpha p.
Definition PNo_strict_lowerbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun R alpha p =>
       forall beta, ordinal beta -> forall q:set -> prop, R beta q -> PNoLt alpha p beta q.
Definition PNo_strict_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_strict_upperbd L alpha p /\ PNo_strict_lowerbd R alpha p.

Theorem PNoEq_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_upperbd L alpha p -> PNo_strict_upperbd L alpha q.
let L alpha. assume Ha. let p q.
assume Hpq: PNoEq_ alpha p q.
assume H1: PNo_strict_upperbd L alpha p.
prove PNo_strict_upperbd L alpha q.
let beta. assume Hb: ordinal beta.
let r. assume H2: L beta r.
prove PNoLt beta r alpha q.
apply PNoLtEq_tra beta alpha Hb Ha r p q.
- prove PNoLt beta r alpha p.
  exact H1 beta Hb r H2.
- prove PNoEq_ alpha p q. exact Hpq.
Qed.

Theorem PNoEq_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_lowerbd R alpha p -> PNo_strict_lowerbd R alpha q.
let R alpha. assume Ha. let p q.
assume Hpq: PNoEq_ alpha p q.
assume H1: PNo_strict_lowerbd R alpha p.
prove PNo_strict_lowerbd R alpha q.
let beta. assume Hb: ordinal beta.
let r. assume H2: R beta r.
prove PNoLt alpha q beta r.
apply PNoEqLt_tra alpha beta Ha Hb q p r.
- prove PNoEq_ alpha q p. apply PNoEq_sym_. exact Hpq.
- prove PNoLt alpha p beta r.
  exact H1 beta Hb r H2.
Qed.

Theorem PNoEq_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_imv L R alpha p -> PNo_strict_imv L R alpha q.
let L R alpha. assume Ha. let p q. assume Hpq H1.
apply H1. assume H2 H3.
prove PNo_strict_upperbd L alpha q /\ PNo_strict_lowerbd R alpha q.
apply andI.
- exact PNoEq_strict_upperbd L alpha Ha p q Hpq H2.
- exact PNoEq_strict_lowerbd R alpha Ha p q Hpq H3.
Qed.

Theorem PNo_strict_upperbd_imp_rel_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L beta p.
let L alpha.
assume Ha: ordinal alpha.
let beta.
assume Hb: beta :e ordsucc alpha.
let p.
assume H1: PNo_strict_upperbd L alpha p.
let gamma. assume Hc: gamma :e beta.
let q. assume Hq: PNo_downc L gamma q.
apply Ha. assume Ha1 _.
claim Lsa: ordinal (ordsucc alpha).
{ exact ordinal_ordsucc alpha Ha. }
claim Lb: ordinal beta.
{ exact ordinal_Hered (ordsucc alpha) Lsa beta Hb. }
claim Lb1: TransSet beta.
{ apply Lb. assume H _. exact H. }
claim Lc: ordinal gamma.
{ exact ordinal_Hered beta Lb gamma Hc. }
claim Lcb: gamma c= beta.
{ exact Lb1 gamma Hc. }
prove PNoLt gamma q beta p.
apply Hq.
let delta. assume H2. apply H2.
assume Hd: ordinal delta. assume H2. apply H2.
let r. assume H2. apply H2.
assume H2: L delta r.
assume H3: PNoLe gamma q delta r.
claim L1: PNoLt delta r alpha p.
{ exact H1 delta Hd r H2. }
claim L2: PNoLt gamma q alpha p.
{ exact PNoLeLt_tra gamma delta alpha Lc Hd Ha q r p H3 L1. }
claim Lca: gamma :e alpha.
{ apply ordsuccE alpha beta Hb.
  - assume Hb1: beta :e alpha. exact Ha1 beta Hb1 gamma Hc.
  - assume Hb1: beta = alpha. rewrite <- Hb1. exact Hc.
}
claim Lca2: gamma c= alpha.
{ exact Ha1 gamma Lca. }
prove PNoLt gamma q beta p.
apply PNoLt_trichotomy_or gamma beta q p Lc Lb. assume H4. apply H4.
- assume H4. exact H4.
- assume H4. apply H4.
  assume H4: gamma = beta.
  prove False.
  apply In_irref beta. rewrite <- H4 at 1. exact Hc.
- assume H4: PNoLt beta p gamma q.
  prove False.
  apply PNoLtE beta gamma p q H4.
  + rewrite binintersect_com.
    rewrite binintersect_Subq_eq_1 gamma beta Lcb.
    assume H5: PNoLt_ gamma p q.
    apply H5.
    apply PNoLt_irref alpha p.
    apply PNoLt_tra alpha gamma alpha Ha Lc Ha p q p.
    * prove PNoLt alpha p gamma q.
      apply PNoLtI1.
      prove PNoLt_ (alpha :/\: gamma) p q.
      rewrite binintersect_com.
      rewrite binintersect_Subq_eq_1 gamma alpha Lca2.
      prove PNoLt_ gamma p q.
      exact H5.
    * prove PNoLt gamma q alpha p. exact L2.
  + assume H5: beta :e gamma.
    prove False.
    exact In_no2cycle beta gamma H5 Hc.
  + assume H5: gamma :e beta.
    assume H6: PNoEq_ gamma p q.
    assume H7: ~p gamma.
    apply PNoLt_irref alpha p.
    apply PNoLt_tra alpha gamma alpha Ha Lc Ha p q p.
    * { prove PNoLt alpha p gamma q.
        apply PNoLtI3.
        - prove gamma :e alpha. exact Lca.
        - prove PNoEq_ gamma p q. exact H6.
        - prove ~p gamma. exact H7.
      }
    * prove PNoLt gamma q alpha p. exact L2.
Qed.

Theorem PNo_strict_lowerbd_imp_rel_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R beta p.
let R alpha.
assume Ha: ordinal alpha.
let beta.
assume Hb: beta :e ordsucc alpha.
let p.
assume H1: PNo_strict_lowerbd R alpha p.
let gamma. assume Hc: gamma :e beta.
let q. assume Hq: PNo_upc R gamma q.
apply Ha. assume Ha1 _.
claim Lsa: ordinal (ordsucc alpha).
{ exact ordinal_ordsucc alpha Ha. }
claim Lb: ordinal beta.
{ exact ordinal_Hered (ordsucc alpha) Lsa beta Hb. }
claim Lb1: TransSet beta.
{ apply Lb. assume H _. exact H. }
claim Lc: ordinal gamma.
{ exact ordinal_Hered beta Lb gamma Hc. }
claim Lcb: gamma c= beta.
{ exact Lb1 gamma Hc. }
prove PNoLt beta p gamma q.
apply Hq.
let delta. assume H2. apply H2.
assume Hd: ordinal delta. assume H2. apply H2.
let r. assume H2. apply H2.
assume H2: R delta r.
assume H3: PNoLe delta r gamma q.
claim L1: PNoLt alpha p delta r.
{ exact H1 delta Hd r H2. }
claim L2: PNoLt alpha p gamma q.
{ exact PNoLtLe_tra alpha delta gamma Ha Hd Lc p r q L1 H3. }
claim Lca: gamma :e alpha.
{ apply ordsuccE alpha beta Hb.
  - assume Hb1: beta :e alpha. exact Ha1 beta Hb1 gamma Hc.
  - assume Hb1: beta = alpha. rewrite <- Hb1. exact Hc.
}
claim Lca2: gamma c= alpha.
{ exact Ha1 gamma Lca. }
prove PNoLt beta p gamma q.
apply PNoLt_trichotomy_or gamma beta q p Lc Lb. assume H4. apply H4.
- assume H4: PNoLt gamma q beta p.
  prove False.
  apply PNoLtE gamma beta q p H4.
  + rewrite binintersect_Subq_eq_1 gamma beta Lcb.
    assume H5: PNoLt_ gamma q p.
    apply H5.
    apply PNoLt_irref alpha p.
    apply PNoLt_tra alpha gamma alpha Ha Lc Ha p q p.
    * prove PNoLt alpha p gamma q. exact L2.
    * prove PNoLt gamma q alpha p.
      apply PNoLtI1.
      prove PNoLt_ (gamma :/\: alpha) q p.
      rewrite binintersect_Subq_eq_1 gamma alpha Lca2.
      prove PNoLt_ gamma q p.
      exact H5.
  + assume H5: gamma :e beta.
    assume H6: PNoEq_ gamma q p.
    assume H7: p gamma.
    apply PNoLt_irref alpha p.
    apply PNoLt_tra alpha gamma alpha Ha Lc Ha p q p.
    * prove PNoLt alpha p gamma q. exact L2.
    * { prove PNoLt gamma q alpha p.
        apply PNoLtI2.
        - prove gamma :e alpha. exact Lca.
        - prove PNoEq_ gamma q p. exact H6.
        - prove p gamma. exact H7.
      }
  + assume H5: beta :e gamma.
    prove False.
    exact In_no2cycle beta gamma H5 Hc.
- assume H4. apply H4.
  assume H4: gamma = beta.
  prove False.
  apply In_irref beta. rewrite <- H4 at 1. exact Hc.
- assume H4. exact H4.
Qed.

Theorem PNo_strict_imv_imp_rel_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_imv L R alpha p -> PNo_rel_strict_imv L R beta p.
let L R alpha.
assume Ha: ordinal alpha.
let beta.
assume Hb: beta :e ordsucc alpha.
let p.
assume H1: PNo_strict_imv L R alpha p.
apply H1.
assume H2: PNo_strict_upperbd L alpha p.
assume H3: PNo_strict_lowerbd R alpha p.
prove PNo_rel_strict_imv L R beta p.
prove PNo_rel_strict_upperbd L beta p /\ PNo_rel_strict_lowerbd R beta p.
apply andI.
- exact PNo_strict_upperbd_imp_rel_strict_upperbd L alpha Ha beta Hb p H2.
- exact PNo_strict_lowerbd_imp_rel_strict_lowerbd R alpha Ha beta Hb p H3.
Qed.

Theorem PNo_rel_split_imv_imp_strict_imv : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> forall p:set -> prop,
       PNo_rel_strict_split_imv L R alpha p
    -> PNo_strict_imv L R alpha p.
let L R.
let alpha.
assume Ha: ordinal alpha.
let p.
assume Hp: PNo_rel_strict_split_imv L R alpha p.
claim Lsa: ordinal (ordsucc alpha).
{ exact ordinal_ordsucc alpha Ha. }
set p0 : set -> prop := fun delta => p delta /\ delta <> alpha.
set p1 : set -> prop := fun delta => p delta \/ delta = alpha.
apply Hp.
assume Hp0: PNo_rel_strict_imv L R (ordsucc alpha) p0.
assume Hp1: PNo_rel_strict_imv L R (ordsucc alpha) p1.
apply Hp0.
assume Hp0a: PNo_rel_strict_upperbd L (ordsucc alpha) p0.
assume Hp0b: PNo_rel_strict_lowerbd R (ordsucc alpha) p0.
apply Hp1.
assume Hp1a: PNo_rel_strict_upperbd L (ordsucc alpha) p1.
assume Hp1b: PNo_rel_strict_lowerbd R (ordsucc alpha) p1.
claim Lnp0a: ~p0 alpha.
{ assume H10. apply H10.
  assume H11: p alpha.
  assume H12: alpha <> alpha.
  apply H12. reflexivity.
}
claim Lp1a: p1 alpha.
{ prove p alpha \/ alpha = alpha.
  apply orIR. reflexivity.
}
claim Lap0p: PNoLt (ordsucc alpha) p0 alpha p.
{ apply PNoLtI3.
  - apply ordsuccI2.
  - prove PNoEq_ alpha p0 p. apply PNoEq_sym_. apply PNo_extend0_eq.
  - prove ~p0 alpha. exact Lnp0a.
}
claim Lapp1: PNoLt alpha p (ordsucc alpha) p1.
{ apply PNoLtI2.
  - apply ordsuccI2.
  - prove PNoEq_ alpha p p1. apply PNo_extend1_eq.
  - prove p1 alpha. exact Lp1a.
}
prove PNo_strict_upperbd L alpha p /\ PNo_strict_lowerbd R alpha p.
apply andI.
- let beta.
  assume Hb: ordinal beta.
  let q.
  assume Hq: L beta q.
  prove PNoLt beta q alpha p.
  claim L4: PNo_downc L beta q.
  { apply PNo_downc_ref L beta Hb. exact Hq. }
  claim L5: beta :e ordsucc alpha -> PNoLt beta q alpha p.
  { assume H10: beta :e ordsucc alpha.
    apply PNoLt_tra beta (ordsucc alpha) alpha Hb Lsa Ha q p0 p.
    - prove PNoLt beta q (ordsucc alpha) p0.
      apply Hp0a beta H10 q.
      prove PNo_downc L beta q.
      exact L4.
    - exact Lap0p.
  }
  claim L6: forall gamma :e ordsucc alpha, gamma :e beta -> PNoEq_ gamma p q -> q gamma -> p0 gamma.
  { let gamma.
    assume Hc1: gamma :e ordsucc alpha.
    assume Hc2: gamma :e beta.
    assume H10: PNoEq_ gamma p q.
    assume H11: q gamma.
    apply dneg.
    assume HNC: ~p0 gamma.
    claim Lc: ordinal gamma.
    { exact ordinal_Hered beta Hb gamma Hc2. }
    claim L6a: PNoLt gamma q beta q.
    { apply PNoLtI2.
      - exact Hc2.
      - prove PNoEq_ gamma q q.
        apply PNoEq_ref_.
      - prove q gamma. exact H11.
    }
    claim L6b: PNo_downc L gamma q.
    { prove exists delta, ordinal delta /\ exists r:set -> prop, L delta r /\ PNoLe gamma q delta r.
      witness beta. apply andI.
      - exact Hb.
      - witness q. apply andI.
        + exact Hq.
        + apply PNoLeI1. exact L6a.
    }
    claim L6c: PNoLt gamma q (ordsucc alpha) p0.
    { exact Hp0a gamma Hc1 q L6b. }
    claim L6d: PNoLt (ordsucc alpha) p0 gamma q.
    { apply PNoLtI3.
      - exact Hc1.
      - prove PNoEq_ gamma p0 q.
        apply PNoEq_tra_ gamma p0 p q.
        + apply PNoEq_sym_. 
          prove PNoEq_ gamma p p0.
          apply ordsuccE alpha gamma Hc1.
          * assume H12: gamma :e alpha.
            apply PNoEq_antimon_ p p0 alpha Ha gamma H12.
            prove PNoEq_ alpha p p0.
            exact PNo_extend0_eq alpha p.
          * assume H12: gamma = alpha.
            rewrite H12.
            prove PNoEq_ alpha p p0.
            exact PNo_extend0_eq alpha p.
        + exact H10.
      - prove ~p0 gamma. exact HNC.
    }
    apply PNoLt_irref gamma q.
    exact PNoLt_tra gamma (ordsucc alpha) gamma Lc Lsa Lc q p0 q L6c L6d.
  }
  apply PNoLt_trichotomy_or alpha beta p q Ha Hb. assume H10. apply H10.
  + assume H10: PNoLt alpha p beta q.
    apply PNoLtE alpha beta p q H10.
    * assume H11: PNoLt_ (alpha :/\: beta) p q.
      apply H11.
      let gamma. assume H12. apply H12.
      assume Hc: gamma :e alpha :/\: beta.
      assume H12. apply H12. assume H12. apply H12.
      assume H12: PNoEq_ gamma p q.
      assume H13: ~p gamma.
      assume H14: q gamma.
      prove False.
      apply binintersectE alpha beta gamma Hc.
      assume Hc1: gamma :e alpha.
      assume Hc2: gamma :e beta.
      apply L6 gamma (ordsuccI1 alpha gamma Hc1) Hc2 H12 H14.
      assume H15: p gamma. assume _.
      apply H13. exact H15.
    * assume H11: alpha :e beta.
      assume H12: PNoEq_ alpha p q.
      assume H13: q alpha.
      prove False.
      apply Lnp0a.
      prove p0 alpha.
      exact L6 alpha (ordsuccI2 alpha) H11 H12 H13.
    * assume H11: beta :e alpha. assume _ _.
      apply L5. apply ordsuccI1. exact H11.
  + assume H10. apply H10.
    assume H10a: alpha = beta.
    assume H10b: PNoEq_ alpha p q.
    apply L5.
    prove beta :e ordsucc alpha.
    rewrite <- H10a. apply ordsuccI2.
  + assume H10: PNoLt beta q alpha p. exact H10.
- let beta.
  assume Hb: ordinal beta.
  let q.
  assume Hq: R beta q.
  prove PNoLt alpha p beta q.
  claim L4: PNo_upc R beta q.
  { apply PNo_upc_ref R beta Hb. exact Hq. }
  claim L5: beta :e ordsucc alpha -> PNoLt alpha p beta q.
  { assume H10: beta :e ordsucc alpha.
    apply PNoLt_tra alpha (ordsucc alpha) beta Ha Lsa Hb p p1 q.
    - exact Lapp1.
    - prove PNoLt (ordsucc alpha) p1 beta q.
      apply Hp1b beta H10 q.
      prove PNo_upc R beta q.
      exact L4.
  }
  claim L6: forall gamma :e ordsucc alpha, gamma :e beta -> PNoEq_ gamma q p -> p1 gamma -> q gamma.
  { let gamma.
    assume Hc1: gamma :e ordsucc alpha.
    assume Hc2: gamma :e beta.
    assume H10: PNoEq_ gamma q p.
    assume H11: p1 gamma.
    apply dneg.
    assume HNC: ~q gamma.
    claim Lc: ordinal gamma.
    { exact ordinal_Hered beta Hb gamma Hc2. }
    claim L6a: PNoLt beta q gamma q.
    { apply PNoLtI3.
      - exact Hc2.
      - prove PNoEq_ gamma q q.
        apply PNoEq_ref_.
      - prove ~q gamma. exact HNC.
    }
    claim L6b: PNo_upc R gamma q.
    { prove exists delta, ordinal delta /\ exists r:set -> prop, R delta r /\ PNoLe delta r gamma q.
      witness beta. apply andI.
      - exact Hb.
      - witness q. apply andI.
        + exact Hq.
        + apply PNoLeI1. exact L6a.
    }
    claim L6c: PNoLt (ordsucc alpha) p1 gamma q.
    { exact Hp1b gamma Hc1 q L6b. }
    claim L6d: PNoLt gamma q (ordsucc alpha) p1.
    { apply PNoLtI2.
      - exact Hc1.
      - prove PNoEq_ gamma q p1.
        apply PNoEq_tra_ gamma q p p1.
        + exact H10.
        + prove PNoEq_ gamma p p1.
          apply ordsuccE alpha gamma Hc1.
          * assume H12: gamma :e alpha.
            apply PNoEq_antimon_ p p1 alpha Ha gamma H12.
            prove PNoEq_ alpha p p1.
            exact PNo_extend1_eq alpha p.
          * assume H12: gamma = alpha.
            rewrite H12.
            prove PNoEq_ alpha p p1.
            exact PNo_extend1_eq alpha p.
      - prove p1 gamma. exact H11.
    }
    apply PNoLt_irref gamma q.
    exact PNoLt_tra gamma (ordsucc alpha) gamma Lc Lsa Lc q p1 q L6d L6c.
  }
  apply PNoLt_trichotomy_or alpha beta p q Ha Hb. assume H10. apply H10.
  - assume H10. exact H10.
  - assume H10. apply H10.
    assume H10a: alpha = beta.
    assume H10b: PNoEq_ alpha p q.
    apply L5.
    prove beta :e ordsucc alpha.
    rewrite <- H10a. apply ordsuccI2.
  - assume H10: PNoLt beta q alpha p.
    apply PNoLtE beta alpha q p H10.
    + assume H11: PNoLt_ (beta :/\: alpha) q p.
      apply H11.
      let gamma. assume H12. apply H12.
      assume Hc: gamma :e beta :/\: alpha.
      assume H12. apply H12. assume H12. apply H12.
      assume H12: PNoEq_ gamma q p.
      assume H13: ~q gamma.
      assume H14: p gamma.
      prove False.
      apply binintersectE beta alpha gamma Hc.
      assume Hc2: gamma :e beta.
      assume Hc1: gamma :e alpha.
      apply H13.
      apply L6 gamma (ordsuccI1 alpha gamma Hc1) Hc2 H12.
      prove p1 gamma.
      prove p gamma \/ gamma = alpha.
      apply orIL. exact H14.
    + assume H11: beta :e alpha. assume _ _.
      apply L5. apply ordsuccI1. exact H11.
    + assume H11: alpha :e beta.
      assume H12: PNoEq_ alpha q p.
      assume H13: ~q alpha.
      prove False.
      apply H13.
      exact L6 alpha (ordsuccI2 alpha) H11 H12 Lp1a.
Qed.

Theorem PNo_lenbdd_strict_imv_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta :e ordsucc alpha,
      exists p:set -> prop, PNo_strict_imv L R beta p.
let L R. assume HLR.
let alpha. assume Ha.
assume HaL HaR.
apply PNo_rel_imv_bdd_ex L R HLR alpha Ha HaL HaR.
let beta. assume H1. apply H1.
assume Hb: beta :e ordsucc alpha. assume H1. apply H1.
let p.
assume Hp: PNo_rel_strict_split_imv L R beta p.
claim Lsa: ordinal (ordsucc alpha).
{ exact ordinal_ordsucc alpha Ha. }
claim Lb: ordinal beta.
{ exact ordinal_Hered (ordsucc alpha) Lsa beta Hb. }
witness beta. apply andI.
- exact Hb.
- witness p.
  prove PNo_strict_imv L R beta p.
  exact PNo_rel_split_imv_imp_strict_imv L R beta Lb p Hp.
Qed.

Definition PNo_least_rep : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R beta p => ordinal beta
       /\ PNo_strict_imv L R beta p
       /\ forall gamma :e beta,
           forall q:set -> prop, ~PNo_strict_imv L R gamma q.
Definition PNo_least_rep2 : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R beta p => PNo_least_rep L R beta p /\ forall x, x /:e beta -> ~p x.

Theorem PNo_strict_imv_pred_eq : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha -> forall p q:set -> prop,
     PNo_least_rep L R alpha p
  -> PNo_strict_imv L R alpha q
  -> forall beta :e alpha, p beta <-> q beta.
let L R. assume HLR. let alpha. assume Ha. let p q.
assume Hp.
assume Hq.
apply Ha. assume Ha1 _.
apply Hp. assume Hp1. apply Hp1.
assume _.
assume Hp1: PNo_strict_imv L R alpha p.
assume Hp2: forall beta :e alpha, forall r:set -> prop, ~PNo_strict_imv L R beta r.
apply Hp1.
assume Hp1a: PNo_strict_upperbd L alpha p.
assume Hp1b: PNo_strict_lowerbd R alpha p.
apply Hq.
assume Hq1: PNo_strict_upperbd L alpha q.
assume Hq2: PNo_strict_lowerbd R alpha q.
claim L1: forall beta, ordinal beta -> beta :e alpha -> (p beta <-> q beta).
{ apply ordinal_ind.
  let beta. assume Hb1: ordinal beta.
  assume IH: forall gamma :e beta, gamma :e alpha -> (p gamma <-> q gamma).
  assume Hb2: beta :e alpha.
  claim Lbpq: PNoEq_ beta p q.
  { let gamma. assume Hc: gamma :e beta.
    exact IH gamma Hc (Ha1 beta Hb2 gamma Hc).
  }
  prove p beta <-> q beta.
  apply iffI.
  - assume H1: p beta.
    prove q beta.
    apply dneg.
    assume H2: ~q beta.
    claim Lqp: PNoLt beta q alpha p.
    { apply PNoLtI2.
      - prove beta :e alpha. exact Hb2.
      - prove PNoEq_ beta q p. apply PNoEq_sym_. exact Lbpq. (** IH used in pf of Lbpq **)
      - prove p beta. exact H1.
    }
    claim Lqq: PNoLt alpha q beta q.
    { apply PNoLtI3.
      - prove beta :e alpha. exact Hb2.
      - prove PNoEq_ beta q q. apply PNoEq_ref_.
      - prove ~q beta. exact H2.
    }
    apply Hp2 beta Hb2 q.
    prove PNo_strict_imv L R beta q.
    prove PNo_strict_upperbd L beta q /\ PNo_strict_lowerbd R beta q.
    apply andI.
    + let gamma. assume Hc: ordinal gamma. let r. assume Hr: L gamma r.
      prove PNoLt gamma r beta q.
      apply PNoLt_tra gamma alpha beta Hc Ha Hb1 r q q.
      * prove PNoLt gamma r alpha q. exact Hq1 gamma Hc r Hr.
      * prove PNoLt alpha q beta q. exact Lqq.
    + let gamma. assume Hc: ordinal gamma. let r. assume Hr: R gamma r.
      prove PNoLt beta q gamma r.
      apply PNoLt_tra beta alpha gamma Hb1 Ha Hc q p r.
      * prove PNoLt beta q alpha p. exact Lqp.
      * prove PNoLt alpha p gamma r. exact Hp1b gamma Hc r Hr.
  - assume H1: q beta.
    prove p beta.
    apply dneg.
    assume H2: ~p beta.
    claim Lpq: PNoLt alpha p beta q.
    { apply PNoLtI3.
      - prove beta :e alpha. exact Hb2.
      - prove PNoEq_ beta p q. exact Lbpq. (** IH used in pf of Lbpq **)
      - prove ~p beta. exact H2.
    }
    claim Lqq: PNoLt beta q alpha q.
    { apply PNoLtI2.
      - prove beta :e alpha. exact Hb2.
      - prove PNoEq_ beta q q. apply PNoEq_ref_.
      - prove q beta. exact H1.
    }
    apply Hp2 beta Hb2 q.
    prove PNo_strict_imv L R beta q.
    prove PNo_strict_upperbd L beta q /\ PNo_strict_lowerbd R beta q.
    apply andI.
    + let gamma. assume Hc: ordinal gamma. let r. assume Hr: L gamma r.
      prove PNoLt gamma r beta q.
      apply PNoLt_tra gamma alpha beta Hc Ha Hb1 r p q.
      * prove PNoLt gamma r alpha p. exact Hp1a gamma Hc r Hr.
      * prove PNoLt alpha p beta q. exact Lpq.
    + let gamma. assume Hc: ordinal gamma. let r. assume Hr: R gamma r.
      prove PNoLt beta q gamma r.
      apply PNoLt_tra beta alpha gamma Hb1 Ha Hc q q r.
      * prove PNoLt beta q alpha q. exact Lqq.
      * prove PNoLt alpha q gamma r. exact Hq2 gamma Hc r Hr.
}
let beta. assume Hb: beta :e alpha.
exact L1 beta (ordinal_Hered alpha Ha beta Hb) Hb.
Qed.

Theorem PNo_lenbdd_least_rep2_exuniq2 : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta,
        (exists p:set -> prop, PNo_least_rep2 L R beta p)
     /\ (forall p q:set -> prop, PNo_least_rep2 L R beta p -> PNo_least_rep2 L R beta q -> p = q).
let L R. assume HLR. let alpha. assume Ha HaL HaR.
claim L1: exists beta, ordinal beta /\ (exists p:set -> prop, PNo_strict_imv L R beta p) /\ forall gamma :e beta, ~(exists p:set -> prop, PNo_strict_imv L R gamma p).
{ apply least_ordinal_ex (fun beta => exists p:set -> prop, PNo_strict_imv L R beta p).
  prove exists beta, ordinal beta /\ exists p:set -> prop, PNo_strict_imv L R beta p.
  apply PNo_lenbdd_strict_imv_ex L R HLR alpha Ha HaL HaR.
  let beta. assume H1. apply H1.
  assume Hb: beta :e ordsucc alpha.
  assume H1. apply H1.
  let p. assume Hp: PNo_strict_imv L R beta p.
  claim Lsa: ordinal (ordsucc alpha).
  { exact ordinal_ordsucc alpha Ha. }
  witness beta. apply andI.
  - exact ordinal_Hered (ordsucc alpha) Lsa beta Hb.
  - witness p. exact Hp.
}
apply L1.
let beta. assume H1. apply H1. assume H1. apply H1.
assume H1: ordinal beta.
assume H2: exists p:set -> prop, PNo_strict_imv L R beta p.
assume H3: forall gamma :e beta, ~exists p:set -> prop, PNo_strict_imv L R gamma p.
apply H2.
let p. assume Hp: PNo_strict_imv L R beta p.
witness beta.
apply andI.
- witness (fun x => x :e beta /\ p x).
  prove PNo_least_rep L R beta (fun x => x :e beta /\ p x) /\ forall x, x /:e beta -> ~(x :e beta /\ p x).
  apply andI.
  + prove ordinal beta
     /\ PNo_strict_imv L R beta (fun x => x :e beta /\ p x)
     /\ forall gamma :e beta,
         forall q:set -> prop, ~PNo_strict_imv L R gamma q.
    apply and3I.
    * exact H1.
    * { apply PNoEq_strict_imv L R beta H1 p (fun x => x :e beta /\ p x).
        - prove PNoEq_ beta p (fun x => x :e beta /\ p x).
          let x. assume Hx: x :e beta.
          prove p x <-> x :e beta /\ p x.
          apply iffI.
          + assume H4. apply andI.
            * exact Hx.
            * exact H4.
          + assume H4. apply H4. assume _ H5. exact H5.
        - exact Hp.
      }
    * let gamma. assume Hc: gamma :e beta. let q.
      assume H4: PNo_strict_imv L R gamma q.
      prove False.
      apply H3 gamma Hc.
      prove exists p:set -> prop, PNo_strict_imv L R gamma p.
      witness q.
      prove PNo_strict_imv L R gamma q.
      exact H4.
  + prove forall x, x /:e beta -> ~(x :e beta /\ p x).
    let x. assume Hx. assume H4. apply H4. assume H5 _. exact Hx H5.
- let q r.
  assume Hq: PNo_least_rep2 L R beta q.
  assume Hr: PNo_least_rep2 L R beta r.
  apply Hq.
  assume Hq1 Hq2.
  apply Hr.
  assume Hr1 Hr2.
  prove q = r.
  apply pred_ext.
  let x.
  apply xm (x :e beta).
  + assume H4: x :e beta.
    prove q x <-> r x.
    apply Hr1. assume Hr1a. apply Hr1a.
    assume _.
    assume Hr1a: PNo_strict_imv L R beta r.
    assume _.
    exact PNo_strict_imv_pred_eq L R HLR beta H1 q r Hq1 Hr1a x H4.
  + assume H4: x /:e beta.
    apply iffI.
    * assume H5: q x. prove False. apply Hq2 x H4. exact H5.
    * assume H5: r x. prove False. apply Hr2 x H4. exact H5.
Qed.

(* Parameter PNo_bd "1b39e85278dd9e820e7b6258957386ac55934d784aa3702c57a28ec807453b01" "ed76e76de9b58e621daa601cca73b4159a437ba0e73114924cb92ec8044f2aa2" *)
Definition PNo_bd : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set
 := fun L R => DescrR_i_io_1 (PNo_least_rep2 L R).
(* Parameter PNo_pred "be07c39b18a3aa93f066f4c064fee3941ec27cfd07a4728b6209135c77ce5704" "b2d51dcfccb9527e9551b0d0c47d891c9031a1d4ee87bba5a9ae5215025d107a" *)
Definition PNo_pred : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> prop
 := fun L R => DescrR_i_io_2 (PNo_least_rep2 L R).

Theorem PNo_bd_pred_lem : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_least_rep2 L R (PNo_bd L R) (PNo_pred L R).
let L R. assume HLR. let alpha. assume Ha HaL HaR.
exact DescrR_i_io_12
          (PNo_least_rep2 L R)
          (PNo_lenbdd_least_rep2_exuniq2 L R HLR alpha Ha HaL HaR).
Qed.

Theorem PNo_bd_pred : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_least_rep L R (PNo_bd L R) (PNo_pred L R).
let L R. assume HLR. let alpha. assume Ha HaL HaR.
apply PNo_bd_pred_lem L R HLR alpha Ha HaL HaR.
assume H _. exact H.
Qed.

Theorem PNo_bd_In : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_bd L R :e ordsucc alpha.
let L R. assume HLR. let alpha. assume Ha HaL HaR.
apply PNo_bd_pred L R HLR alpha Ha HaL HaR.
assume H1. apply H1.
assume H1: ordinal (PNo_bd L R).
assume H2: PNo_strict_imv L R (PNo_bd L R) (PNo_pred L R).
assume H3: forall gamma :e PNo_bd L R,
           forall q:set -> prop, ~PNo_strict_imv L R gamma q.
apply PNo_lenbdd_strict_imv_ex L R HLR alpha Ha HaL HaR.
let beta. assume H4. apply H4.
assume Hb: beta :e ordsucc alpha.
assume H4. apply H4.
let p. assume Hp: PNo_strict_imv L R beta p.
claim Lsa: ordinal (ordsucc alpha).
{ exact ordinal_ordsucc alpha Ha. }
apply ordinal_In_Or_Subq (PNo_bd L R) (ordsucc alpha) H1 Lsa.
- assume H4: PNo_bd L R :e ordsucc alpha. exact H4.
- assume H4: ordsucc alpha c= PNo_bd L R.
  prove False.
  claim Lb: beta :e PNo_bd L R.
  { apply H4. exact Hb. }
  apply H3 beta Lb p.
  exact Hp.
Qed.

Opaque Sigma Pi ap PNo_pred PNo_bd PNoLt DescrR_i_io_1 DescrR_i_io_2.

Section TaggedSets.
Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Theorem not_TransSet_Sing1 : ~TransSet {1}.
assume H1: TransSet {1}.
claim L1: 0 :e {1}.
{ exact H1 1 (SingI 1) 0 In_0_1. }
apply neq_0_1.
exact SingE 1 0 L1.
Qed.

Theorem not_ordinal_Sing1 : ~ordinal {1}.
assume H1. apply H1. assume H2 _. exact not_TransSet_Sing1 H2.
Qed.

Theorem tagged_not_ordinal : forall y, ~ordinal (y ').
let y.
assume H1: ordinal (y ').
claim L1: {1} :e y '.
{ prove {1} :e y :\/: {{1}}.
  apply binunionI2.
  exact SingI {1}.
}
apply not_ordinal_Sing1.
exact ordinal_Hered (y ') H1 {1} L1.
Qed.

Theorem tagged_notin_ordinal : forall alpha y, ordinal alpha -> (y ') /:e alpha.
let alpha y.
assume H1 H2.
apply tagged_not_ordinal y.
exact ordinal_Hered alpha H1 (y ') H2.
Qed.

Theorem tagged_eqE_Subq : forall alpha beta, ordinal alpha -> alpha ' = beta ' -> alpha c= beta.
let alpha beta.
assume Ha He.
let gamma.
assume Hc: gamma :e alpha.
claim L1: gamma :e beta '.
{ rewrite <- He.
  prove gamma :e alpha :\/: {{1}}.
  apply binunionI1.
  exact Hc.
}
apply binunionE beta {{1}} gamma L1.
- assume H1: gamma :e beta.
  exact H1.
- assume H1: gamma :e {{1}}.
  prove False.
  apply not_ordinal_Sing1.
  rewrite <- SingE {1} gamma H1.
  exact ordinal_Hered alpha Ha gamma Hc.
Qed.

Theorem tagged_eqE_eq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha ' = beta ' -> alpha = beta.
let alpha beta.
assume Ha Hb He.
exact set_ext alpha beta
       (tagged_eqE_Subq alpha beta Ha He)
       (tagged_eqE_Subq beta alpha Hb (fun q => He (fun u v => q v u))).
Qed.

Theorem tagged_ReplE : forall alpha beta, ordinal alpha -> ordinal beta -> beta ' :e {gamma '|gamma :e alpha} -> beta :e alpha.
let alpha beta.
assume Ha Hb.
assume H1: beta ' :e {gamma '|gamma :e alpha}.
apply ReplE_impred alpha (fun gamma => gamma ') (beta ') H1.
let gamma.
assume H2: gamma :e alpha.
assume H3: beta ' = gamma '.
claim L2: beta = gamma.
{ exact tagged_eqE_eq beta gamma Hb (ordinal_Hered alpha Ha gamma H2) H3. }
rewrite L2. exact H2.
Qed.

Theorem ordinal_notin_tagged_Repl : forall alpha Y, ordinal alpha -> alpha /:e {y '|y :e Y}.
let alpha Y.
assume H1: ordinal alpha.
assume H2: alpha :e {y '|y :e Y}.
apply ReplE_impred Y (fun y => y ') alpha H2.
let y.
assume H3: y :e Y.
assume H4: alpha = y '.
apply tagged_not_ordinal y.
prove ordinal (y ').
rewrite <- H4.
exact H1.
Qed.

Definition SNoElts_ : set -> set := fun alpha => alpha :\/: {beta '|beta :e alpha}.

Theorem SNoElts_mon : forall alpha beta, alpha c= beta -> SNoElts_ alpha c= SNoElts_ beta.
let alpha beta.
assume H1: alpha c= beta.
let x.
assume H2: x :e alpha :\/: {gamma '|gamma :e alpha}.
apply binunionE alpha {gamma '|gamma :e alpha} x H2.
- assume H3: x :e alpha.
  prove x :e beta :\/: {gamma '|gamma :e beta}.
  apply binunionI1.
  apply H1.
  exact H3.
- assume H3: x :e {gamma '|gamma :e alpha}.
  prove x :e beta :\/: {gamma '|gamma :e beta}.
  apply binunionI2.
  prove x :e {gamma '|gamma :e beta}.
  apply ReplE_impred alpha (fun gamma => gamma ') x H3.
  let gamma.
  assume H4: gamma :e alpha.
  assume H5: x = gamma '.
  rewrite H5.
  prove gamma ' :e {gamma '|gamma :e beta}.
  exact ReplI beta (fun gamma => gamma ') gamma (H1 gamma H4).
Qed.

Definition SNo_ : set -> set -> prop := fun alpha x =>
    x c= SNoElts_ alpha
 /\ forall beta :e alpha, exactly1of2 (beta ' :e x) (beta :e x).
Definition PSNo : set -> (set -> prop) -> set :=
  fun alpha p => {beta :e alpha|p beta} :\/: {beta '|beta :e alpha, ~p beta}.

Theorem PNoEq_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, PNoEq_ alpha (fun beta => beta :e PSNo alpha p) p.
let alpha. assume Ha: ordinal alpha. let p.
let beta. assume Hb: beta :e alpha.
prove beta :e PSNo alpha p <-> p beta.
apply iffI.
- assume H1: beta :e {beta :e alpha|p beta} :\/: {beta '|beta :e alpha, ~p beta}.
  apply binunionE {beta :e alpha|p beta} {beta '|beta :e alpha, ~p beta} beta H1.
  + assume H2: beta :e {beta :e alpha|p beta}.
    exact SepE2 alpha p beta H2.
  + assume H2: beta :e {beta '|beta :e alpha, ~p beta}.
    prove False.
    apply ReplSepE_impred alpha (fun beta => ~p beta) (fun x => x ') beta H2.
    let gamma. assume Hc: gamma :e alpha.
    assume H3: ~p gamma.
    assume H4: beta = gamma '.
    apply tagged_notin_ordinal alpha gamma Ha.
    prove gamma ' :e alpha.
    rewrite <- H4. exact Hb.
- assume H1: p beta.
  prove beta :e PSNo alpha p.
  prove beta :e {beta :e alpha|p beta} :\/: {beta '|beta :e alpha, ~p beta}.
  apply binunionI1.
  apply SepI.
  + exact Hb.
  + exact H1.
Qed.

Theorem SNo_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, SNo_ alpha (PSNo alpha p).
let alpha. assume Ha. let p.
prove PSNo alpha p c= SNoElts_ alpha
 /\ forall beta :e alpha, exactly1of2 (beta ' :e PSNo alpha p) (beta :e PSNo alpha p).
apply andI.
- let u. assume Hu: u :e PSNo alpha p.
  prove u :e SNoElts_ alpha.
  apply binunionE {beta :e alpha|p beta} {beta '|beta :e alpha, ~p beta} u Hu.
  + assume H1: u :e {beta :e alpha|p beta}. apply SepE alpha p u H1.
    assume H2: u :e alpha.
    assume H3: p u.
    prove u :e alpha :\/: {beta '|beta :e alpha}.
    apply binunionI1.
    exact H2.
  + assume H1: u :e {beta '|beta :e alpha, ~p beta}.
    apply ReplSepE_impred alpha (fun beta => ~p beta) (fun beta => beta ') u H1.
    let beta.
    assume H2: beta :e alpha.
    assume H3: ~p beta.
    assume H4: u = beta '.
    prove u :e alpha :\/: {beta '|beta :e alpha}.
    apply binunionI2.
    prove u :e {beta '|beta :e alpha}.
    rewrite H4.
    exact ReplI alpha (fun beta => beta ') beta H2.
- let beta. assume H1: beta :e alpha.
  claim Lbeta: ordinal beta.
  { exact ordinal_Hered alpha Ha beta H1. }
  prove exactly1of2 (beta ' :e PSNo alpha p) (beta :e PSNo alpha p).
  apply xm (p beta).
  + assume H2: p beta. apply exactly1of2_I2.
    * { prove beta ' /:e PSNo alpha p.
        assume H3: beta ' :e PSNo alpha p.
        apply binunionE {beta :e alpha|p beta} {beta '|beta :e alpha, ~p beta} (beta ') H3.
        - assume H4: beta ' :e {beta :e alpha|p beta}.
          apply SepE alpha p (beta ') H4.
          assume H5: beta ' :e alpha.
          assume H6: p (beta ').
          prove False.
          apply tagged_not_ordinal beta.
          exact ordinal_Hered alpha Ha (beta ') H5.
        - assume H4: beta ' :e {beta '|beta :e alpha, ~p beta}.
          apply ReplSepE_impred alpha (fun beta => ~p beta) (fun beta => beta ') (beta ') H4.
          let gamma.
          assume H5: gamma :e alpha.
          assume H6: ~p gamma.
          assume H7: beta ' = gamma '.
          claim Lgamma: ordinal gamma.
          { exact ordinal_Hered alpha Ha gamma H5. }
          claim L1: beta = gamma.
          { exact tagged_eqE_eq beta gamma Lbeta Lgamma H7. }
          apply H6. prove p gamma. rewrite <- L1. prove p beta. exact H2.
      }
    * prove beta :e {beta :e alpha|p beta} :\/: {beta '|beta :e alpha, ~p beta}.
      apply binunionI1. exact SepI alpha p beta H1 H2.
  + assume H2: ~p beta. apply exactly1of2_I1.
    * prove beta ' :e {beta :e alpha|p beta} :\/: {beta '|beta :e alpha, ~p beta}.
      apply binunionI2.
      exact ReplSepI alpha (fun beta => ~p beta) (fun beta => beta ') beta H1 H2.
    * { prove beta /:e PSNo alpha p.
        assume H3: beta :e PSNo alpha p.
        apply binunionE {beta :e alpha|p beta} {beta '|beta :e alpha, ~p beta} beta H3.
        - assume H4: beta :e {beta :e alpha|p beta}.
          apply SepE alpha p beta H4.
          assume H5: beta :e alpha.
          assume H6: p beta.
          prove False. exact H2 H6.
        - assume H4: beta :e {beta '|beta :e alpha, ~p beta}.
          apply ReplSepE_impred alpha (fun beta => ~p beta) (fun beta => beta ') beta H4.
          let gamma.
          assume H5: gamma :e alpha.
          assume H6: ~p gamma.
          assume H7: beta = gamma '.
          apply tagged_not_ordinal gamma.
          prove ordinal (gamma ').
          rewrite <- H7.
          exact Lbeta.
      }
Qed.

Theorem SNo_PSNo_eta_ : forall alpha x, ordinal alpha -> SNo_ alpha x -> x = PSNo alpha (fun beta => beta :e x).
let alpha x. assume Ha Hx.
apply Hx.
assume Hx1: x c= SNoElts_ alpha.
assume Hx2: forall beta :e alpha, exactly1of2 (beta ' :e x) (beta :e x).
apply set_ext.
- prove x c= PSNo alpha (fun beta => beta :e x).
  let u. assume Hu: u :e x.
  apply binunionE alpha {beta '|beta :e alpha} u (Hx1 u Hu).
  + assume H1: u :e alpha.
    prove u :e {beta :e alpha|beta :e x} :\/: {beta '|beta :e alpha, beta /:e x}.
    apply binunionI1.
    apply SepI.
    * exact H1.
    * exact Hu.
  + assume H1: u :e {beta '|beta :e alpha}.
    apply ReplE_impred alpha (fun beta => beta ') u H1.
    let beta.
    assume H2: beta :e alpha.
    assume H3: u = beta '.
    prove u :e {beta :e alpha|beta :e x} :\/: {beta '|beta :e alpha, beta /:e x}.
    apply binunionI2.
    prove u :e {beta '|beta :e alpha, beta /:e x}.
    rewrite H3.
    prove beta ' :e {beta '|beta :e alpha, beta /:e x}.
    claim L2: beta /:e x.
    { assume H4: beta :e x.
      apply exactly1of2_E (beta ' :e x) (beta :e x) (Hx2 beta H2).
      - assume H5: beta ' :e x.
        assume H6: beta /:e x.
        exact H6 H4.
      - assume H4: beta ' /:e x.
        assume H5: beta :e x.
        apply H4.
        prove (beta ') :e x.
        rewrite <- H3.
        prove u :e x.
        exact Hu.
    }
    exact ReplSepI alpha (fun beta => beta /:e x) (fun beta => beta ') beta H2 L2.
- prove PSNo alpha (fun beta => beta :e x) c= x.
  let u. assume Hu: u :e PSNo alpha (fun beta => beta :e x).
  prove u :e x.
  apply binunionE {beta :e alpha|beta :e x} {beta '|beta :e alpha, beta /:e x} u Hu.
  + assume H1: u :e {beta :e alpha|beta :e x}.
    apply SepE alpha (fun beta => beta :e x) u H1.
    assume H2: u :e alpha.
    assume H3: u :e x.
    exact H3.
  + assume H1: u :e {beta '|beta :e alpha, beta /:e x}.
    apply ReplSepE_impred alpha (fun beta => beta /:e x) (fun beta => beta ') u H1.
    let beta.
    assume H2: beta :e alpha.
    assume H3: beta /:e x.
    assume H4: u = beta '.
    apply exactly1of2_E (beta ' :e x) (beta :e x) (Hx2 beta H2).
    * assume H5: beta ' :e x.
      assume H6: beta /:e x.
      rewrite H4. exact H5.
    * assume H4: beta ' /:e x.
      assume H5: beta :e x.
      prove False.
      exact H3 H5.
Qed.

(* Parameter SNo "87d7604c7ea9a2ae0537066afb358a94e6ac0cd80ba277e6b064422035a620cf" "11faa7a742daf8e4f9aaf08e90b175467e22d0e6ad3ed089af1be90cfc17314b" *)
Definition SNo : set -> prop := fun x => exists alpha, ordinal alpha /\ SNo_ alpha x.

Theorem SNo_SNo : forall alpha, ordinal alpha -> forall z, SNo_ alpha z -> SNo z.
let alpha. assume Ha.
let z. assume Hz: SNo_ alpha z.
prove exists alpha, ordinal alpha /\ SNo_ alpha z.
witness alpha. apply andI.
- exact Ha.
- exact Hz.
Qed.

(* Parameter SNoLev "bf1decfd8f4025a2271f2a64d1290eae65933d0f2f0f04b89520449195f1aeb8" "293b77d05dab711767d698fb4484aab2a884304256765be0733e6bd5348119e8" *)
Definition SNoLev : set -> set := fun x => Eps_i (fun alpha => ordinal alpha /\ SNo_ alpha x).

Theorem SNoLev_uniq_Subq : forall x alpha beta, ordinal alpha -> ordinal beta -> SNo_ alpha x -> SNo_ beta x -> alpha c= beta.
let x alpha beta. assume Ha Hb Hax Hbx.
let gamma. assume Hc: gamma :e alpha.
prove gamma :e beta.
apply Hax. assume Hax1 Hax2.
apply Hbx. assume Hbx1 Hbx2.
claim Lc: ordinal gamma.
{ exact ordinal_Hered alpha Ha gamma Hc. }
apply exactly1of2_or (gamma ' :e x) (gamma :e x) (Hax2 gamma Hc).
- assume H1: gamma ' :e x.
  claim L1: gamma ' :e beta :\/: {delta '|delta :e beta}.
  { exact Hbx1 (gamma ') H1. }
  claim L2: gamma ' :e beta \/ gamma ' :e {delta '|delta :e beta}.
  { exact binunionE beta {delta '|delta :e beta} (gamma ') L1. }
  apply L2.
  + assume H2: gamma ' :e beta.
    prove False.
    exact tagged_notin_ordinal beta gamma Hb H2.
  + assume H2: gamma ' :e {delta '|delta :e beta}.
    exact tagged_ReplE beta gamma Hb Lc H2.
- assume H1: gamma :e x.
  claim L1: gamma :e beta :\/: {delta '|delta :e beta}.
  { exact Hbx1 gamma H1. }
  claim L2: gamma :e beta \/ gamma :e {delta '|delta :e beta}.
  { exact binunionE beta {delta '|delta :e beta} gamma L1. }
  apply L2.
  + assume H2: gamma :e beta.
    exact H2.
  + assume H2: gamma :e {delta '|delta :e beta}.
    prove False.
    exact ordinal_notin_tagged_Repl gamma beta Lc H2.
Qed.

Theorem SNoLev_uniq : forall x alpha beta, ordinal alpha -> ordinal beta -> SNo_ alpha x -> SNo_ beta x -> alpha = beta.
let x alpha beta. assume Ha Hb Hax Hbx.
apply set_ext.
- exact SNoLev_uniq_Subq x alpha beta Ha Hb Hax Hbx.
- exact SNoLev_uniq_Subq x beta alpha Hb Ha Hbx Hax.
Qed.

Theorem SNoLev_prop : forall x, SNo x -> ordinal (SNoLev x) /\ SNo_ (SNoLev x) x.
let x.
assume Hx: SNo x.
exact Eps_i_ex (fun alpha => ordinal alpha /\ SNo_ alpha x) Hx.
Qed.

Theorem SNoLev_ordinal : forall x, SNo x -> ordinal (SNoLev x).
let x. assume Hx. apply SNoLev_prop x Hx. assume H1 _. exact H1.
Qed.

Theorem SNoLev_ : forall x, SNo x -> SNo_ (SNoLev x) x.
let x. assume Hx. apply SNoLev_prop x Hx. assume _ H1. exact H1.
Qed.

Theorem SNo_PSNo_eta : forall x, SNo x -> x = PSNo (SNoLev x) (fun beta => beta :e x).
let x. assume Hx.
apply SNoLev_prop x Hx.
assume Hx1: ordinal (SNoLev x).
assume Hx2: SNo_ (SNoLev x) x.
apply SNo_PSNo_eta_.
- prove ordinal (SNoLev x). exact Hx1.
- prove SNo_ (SNoLev x) x. exact Hx2.
Qed.

Theorem SNoLev_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, SNoLev (PSNo alpha p) = alpha.
let alpha. assume Ha: ordinal alpha.
let p.
claim L1: SNo_ alpha (PSNo alpha p).
{ exact SNo_PSNo alpha Ha p. }
claim L2: SNo (PSNo alpha p).
{ prove exists beta, ordinal beta /\ SNo_ beta (PSNo alpha p).
  witness alpha. apply andI.
  - exact Ha.
  - exact L1.
}
apply SNoLev_prop (PSNo alpha p) L2.
assume H2: ordinal (SNoLev (PSNo alpha p)).
assume H3: SNo_ (SNoLev (PSNo alpha p)) (PSNo alpha p).
exact SNoLev_uniq (PSNo alpha p) (SNoLev (PSNo alpha p)) alpha H2 Ha H3 L1.
Qed.

Theorem SNo_Subq : forall x y, SNo x -> SNo y -> SNoLev x c= SNoLev y -> (forall alpha :e SNoLev x, alpha :e x <-> alpha :e y) -> x c= y.
let x y.
assume Hx Hy H1 H2.
apply SNoLev_ x Hx.
assume Hx2a: x c= SNoElts_ (SNoLev x).
assume Hx2b: forall beta :e SNoLev x, exactly1of2 (beta ' :e x) (beta :e x).
apply SNoLev_ y Hy.
assume Hy2a: y c= SNoElts_ (SNoLev y).
assume Hy2b: forall beta :e SNoLev y, exactly1of2 (beta ' :e y) (beta :e y).
let u. assume Hu: u :e x.
claim L1: u :e SNoLev x :\/: {beta '|beta :e SNoLev x}.
{ exact Hx2a u Hu. }
apply binunionE (SNoLev x) {beta '|beta :e SNoLev x} u L1.
- assume H3: u :e SNoLev x.
  apply H2 u H3.
  assume H4 _. exact H4 Hu.
- assume H3: u :e {beta '|beta :e SNoLev x}.
  apply ReplE_impred (SNoLev x) (fun gamma => gamma ') u H3.
  let beta.
  assume H4: beta :e SNoLev x.
  assume H5: u = beta '.
  claim L3: beta :e SNoLev y.
  { exact H1 beta H4. }
  apply exactly1of2_E (beta ' :e y) (beta :e y) (Hy2b beta L3).
  + assume H6: beta ' :e y.
    assume H7: beta /:e y.
    prove u :e y.
    rewrite H5. exact H6.
  + assume H6: beta ' /:e y.
    assume H7: beta :e y.
    prove False.
    apply exactly1of2_E (beta ' :e x) (beta :e x) (Hx2b beta H4).
    * assume H8: beta ' :e x.
      assume H9: beta /:e x.
      apply H9.
      apply H2 beta H4.
      assume _ H10. exact H10 H7.
    * assume H8: beta ' /:e x.
      assume H9: beta :e x.
      apply H8.
      prove beta ' :e x.
      rewrite <- H5.
      exact Hu.
Qed.

Definition SNoEq_ : set -> set -> set -> prop
 := fun alpha x y => PNoEq_ alpha (fun beta => beta :e x) (fun beta => beta :e y).

Theorem SNoEq_I : forall alpha x y, (forall beta :e alpha, beta :e x <-> beta :e y) -> SNoEq_ alpha x y.
let alpha x y. assume Hxy. exact Hxy.
Qed.

Theorem SNo_eq : forall x y, SNo x -> SNo y -> SNoLev x = SNoLev y -> SNoEq_ (SNoLev x) x y -> x = y.
let x y.
assume Hx Hy H1 H2.
apply set_ext.
- prove x c= y. apply SNo_Subq x y Hx Hy.
  + prove SNoLev x c= SNoLev y. rewrite <- H1. apply Subq_ref.
  + exact H2.
- prove y c= x. apply SNo_Subq y x Hy Hx.
  + prove SNoLev y c= SNoLev x. rewrite H1. apply Subq_ref.
  + let alpha. assume H3: alpha :e SNoLev y.
    prove alpha :e y <-> alpha :e x.
    apply iff_sym.
    prove alpha :e x <-> alpha :e y.
    apply H2 alpha.
    prove alpha :e SNoLev x.
    rewrite H1. exact H3.
Qed.

End TaggedSets.
Definition SNoLt : set -> set -> prop :=
  fun x y => PNoLt (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
Infix < 490 := SNoLt.
Definition SNoLe : set -> set -> prop :=
  fun x y => PNoLe (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem SNoLtLe : forall x y, x < y -> x <= y.
let x y. assume H1.
prove PNoLe (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
apply PNoLeI1.
exact H1.
Qed.

Theorem SNoLeE : forall x y, SNo x -> SNo y -> x <= y -> x < y \/ x = y.
let x y. assume Hx Hy.
assume H1: PNoLe (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
apply H1.
- assume H2: PNoLt (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
  apply orIL.
  exact H2.
- assume H2. apply H2.
  assume H2: SNoLev x = SNoLev y.
  assume H3: PNoEq_ (SNoLev x) (fun beta => beta :e x) (fun beta => beta :e y).
  apply orIR.
  exact SNo_eq x y Hx Hy H2 H3.
Qed.

Theorem SNoEq_sym_ : forall alpha x y, SNoEq_ alpha x y -> SNoEq_ alpha y x.
let alpha x y.
exact PNoEq_sym_ alpha (fun beta => beta :e x) (fun beta => beta :e y).
Qed.

Theorem SNoEq_tra_ : forall alpha x y z, SNoEq_ alpha x y -> SNoEq_ alpha y z -> SNoEq_ alpha x z.
let alpha x y z.
exact PNoEq_tra_ alpha (fun beta => beta :e x) (fun beta => beta :e y) (fun beta => beta :e z).
Qed.

Theorem SNoLtE : forall x y, SNo x -> SNo y -> x < y ->
 forall p:prop,
    (forall z, SNo z -> SNoLev z :e SNoLev x :/\: SNoLev y -> SNoEq_ (SNoLev z) z x -> SNoEq_ (SNoLev z) z y -> x < z -> z < y -> SNoLev z /:e x -> SNoLev z :e y -> p)
 -> (SNoLev x :e SNoLev y -> SNoEq_ (SNoLev x) x y -> SNoLev x :e y -> p)
 -> (SNoLev y :e SNoLev x -> SNoEq_ (SNoLev y) x y -> SNoLev y /:e x -> p)
 -> p.
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hxy: PNoLt (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
let p.
assume Hp1 Hp2 Hp3.
claim LLx: ordinal (SNoLev x).
{ apply SNoLev_ordinal x. exact Hx. }
claim LLy: ordinal (SNoLev y).
{ apply SNoLev_ordinal y. exact Hy. }
apply PNoLtE (SNoLev x) (SNoLev y) (fun beta => beta :e x) (fun beta => beta :e y) Hxy.
- assume H1: PNoLt_ (SNoLev x :/\: SNoLev y) (fun beta => beta :e x) (fun beta => beta :e y).
  apply PNoLt_E_ (SNoLev x :/\: SNoLev y) (fun beta => beta :e x) (fun beta => beta :e y) H1.
  let alpha.
  assume Ha: alpha :e SNoLev x :/\: SNoLev y.
  assume H2: PNoEq_ alpha (fun beta => beta :e x) (fun beta => beta :e y).
  assume H3: alpha /:e x.
  assume H4: alpha :e y.
  apply binintersectE (SNoLev x) (SNoLev y) alpha Ha.
  assume Ha1: alpha :e SNoLev x.
  assume Ha2: alpha :e SNoLev y.
  claim La: ordinal alpha.
  { exact ordinal_Hered (SNoLev x) LLx alpha Ha1. }
  set z := PSNo alpha (fun beta => beta :e x).
  claim L1: SNo_ alpha z.
  { apply SNo_PSNo. exact La. }
  claim L2: SNo z.
  { prove exists alpha, ordinal alpha /\ SNo_ alpha z.
    witness alpha. apply andI.
    - exact La.
    - exact L1.
  }
  apply SNoLev_prop z L2.
  assume Hz1: ordinal (SNoLev z).
  assume Hz2: SNo_ (SNoLev z) z.
  claim L3: SNoLev z = alpha.
  { exact SNoLev_uniq z (SNoLev z) alpha Hz1 La Hz2 L1. }
  claim L4: SNoEq_ alpha z x.
  { prove PNoEq_ alpha (fun beta => beta :e z) (fun beta => beta :e x).
    prove PNoEq_ alpha (fun beta => beta :e PSNo alpha (fun beta => beta :e x)) (fun beta => beta :e x).
    apply PNoEq_PSNo.
    exact La.
  }
  claim L5: SNoEq_ alpha z y.
  { apply SNoEq_tra_ alpha z x y L4.
    prove SNoEq_ alpha x y.
    prove PNoEq_ alpha (fun beta => beta :e x) (fun beta => beta :e y).
    exact H2.
  }
  apply Hp1 z L2.
  + prove SNoLev z :e SNoLev x :/\: SNoLev y.
    rewrite L3. exact Ha.
  + prove SNoEq_ (SNoLev z) z x. rewrite L3. exact L4.
  + prove SNoEq_ (SNoLev z) z y. rewrite L3. exact L5.
  + prove x < z.
    prove PNoLt (SNoLev x) (fun beta => beta :e x) (SNoLev z) (fun beta => beta :e z).
    rewrite L3.
    prove PNoLt (SNoLev x) (fun beta => beta :e x) alpha (fun beta => beta :e z).
    apply PNoLtI3.
    * prove alpha :e SNoLev x.
      exact Ha1.
    * prove PNoEq_ alpha (fun beta => beta :e x) (fun beta => beta :e z).
      apply PNoEq_sym_.
      exact L4.
    * prove alpha /:e x.
      exact H3.
  + prove z < y.
    prove PNoLt (SNoLev z) (fun beta => beta :e z) (SNoLev y) (fun beta => beta :e y).
    rewrite L3.
    prove PNoLt alpha (fun beta => beta :e z) (SNoLev y) (fun beta => beta :e y).
    apply PNoLtI2.
    * prove alpha :e SNoLev y.
      exact Ha2.
    * prove PNoEq_ alpha (fun beta => beta :e z) (fun beta => beta :e y).
      exact L5.
    * prove alpha :e y.
      exact H4.
  + prove SNoLev z /:e x.
    rewrite L3. exact H3.
  + prove SNoLev z :e y.
    rewrite L3. exact H4.
- assume H1: SNoLev x :e SNoLev y.
  assume H2: PNoEq_ (SNoLev x) (fun beta => beta :e x) (fun beta => beta :e y).
  assume H3: SNoLev x :e y.
  apply Hp2.
  + prove SNoLev x :e SNoLev y. exact H1.
  + prove SNoEq_ (SNoLev x) x y. exact H2.
  + prove SNoLev x :e y. exact H3.
- assume H1: SNoLev y :e SNoLev x.
  assume H2: PNoEq_ (SNoLev y) (fun beta => beta :e x) (fun beta => beta :e y).
  assume H3: SNoLev y /:e x.
  apply Hp3.
  + prove SNoLev y :e SNoLev x. exact H1.
  + prove SNoEq_ (SNoLev y) x y. exact H2.
  + prove SNoLev y /:e x. exact H3.
Qed.

(** The analogous thm to PNoLtI1 can be recovered by SNoLt_tra (transitivity) and SNoLtI2 and SNoLtI3. **)
Theorem SNoLtI2 : forall x y,
     SNoLev x :e SNoLev y
  -> SNoEq_ (SNoLev x) x y
  -> SNoLev x :e y
  -> x < y.
let x y.
assume H1 H2 H3.
prove PNoLt (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
apply PNoLtI2.
- exact H1.
- exact H2.
- exact H3.
Qed.

Theorem SNoLtI3 : forall x y,
     SNoLev y :e SNoLev x
  -> SNoEq_ (SNoLev y) x y
  -> SNoLev y /:e x
  -> x < y.
let x y.
assume H1 H2 H3.
prove PNoLt (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
apply PNoLtI3.
- exact H1.
- exact H2.
- exact H3.
Qed.

Theorem SNoLt_irref : forall x, ~SNoLt x x.
let x.
exact PNoLt_irref (SNoLev x) (fun beta => beta :e x).
Qed.

Theorem SNoLt_trichotomy_or : forall x y, SNo x -> SNo y -> x < y \/ x = y \/ y < x.
let x y. assume Hx Hy.
apply PNoLt_trichotomy_or (SNoLev x) (SNoLev y) (fun beta => beta :e x) (fun beta => beta :e y) (SNoLev_ordinal x Hx) (SNoLev_ordinal y Hy). assume H1. apply H1.
- assume H1. apply or3I1. exact H1.
- assume H1. apply H1.
  assume H2: SNoLev x = SNoLev y.
  assume H3: PNoEq_ (SNoLev x) (fun beta => beta :e x) (fun beta => beta :e y).
  apply or3I2. exact SNo_eq x y Hx Hy H2 H3.
- assume H1. apply or3I3. exact H1.
Qed.

Theorem SNoLt_trichotomy_or_impred : forall x y, SNo x -> SNo y ->
  forall p:prop,
      (x < y -> p)
   -> (x = y -> p)
   -> (y < x -> p)
   -> p.
let x y. assume Hx Hy. let p. assume Hp1 Hp2 Hp3.
apply SNoLt_trichotomy_or x y Hx Hy. assume H. apply H.
- exact Hp1.
- exact Hp2.
- exact Hp3.
Qed.

Theorem SNoLt_tra : forall x y z, SNo x -> SNo y -> SNo z -> x < y -> y < z -> x < z.
let x y z. assume Hx Hy Hz Hxy Hyz.
prove PNoLt (SNoLev x) (fun beta => beta :e x) (SNoLev z) (fun beta => beta :e z).
exact PNoLt_tra (SNoLev x) (SNoLev y) (SNoLev z) (SNoLev_ordinal x Hx) (SNoLev_ordinal y Hy) (SNoLev_ordinal z Hz) (fun beta => beta :e x) (fun beta => beta :e y) (fun beta => beta :e z) Hxy Hyz.
Qed.

Theorem SNoLe_ref : forall x, SNoLe x x.
let x. exact PNoLe_ref (SNoLev x) (fun beta => beta :e x).
Qed.

Theorem SNoLe_antisym : forall x y, SNo x -> SNo y -> x <= y -> y <= x -> x = y.
let x y. assume Hx Hy Hxy Hyx.
apply PNoLe_antisym (SNoLev x) (SNoLev y) (SNoLev_ordinal x Hx) (SNoLev_ordinal y Hy) (fun beta => beta :e x) (fun beta => beta :e y) Hxy Hyx.
assume H1: SNoLev x = SNoLev y.
assume H2: PNoEq_ (SNoLev x) (fun beta => beta :e x) (fun beta => beta :e y).
exact SNo_eq x y Hx Hy H1 H2.
Qed.

Theorem SNoLtLe_tra : forall x y z, SNo x -> SNo y -> SNo z -> x < y -> y <= z -> x < z.
let x y z. assume Hx Hy Hz Hxy Hyz.
exact PNoLtLe_tra (SNoLev x) (SNoLev y) (SNoLev z) (SNoLev_ordinal x Hx) (SNoLev_ordinal y Hy) (SNoLev_ordinal z Hz) (fun beta => beta :e x) (fun beta => beta :e y) (fun beta => beta :e z) Hxy Hyz.
Qed.

Theorem SNoLeLt_tra : forall x y z, SNo x -> SNo y -> SNo z -> x <= y -> y < z -> x < z.
let x y z. assume Hx Hy Hz Hxy Hyz.
exact PNoLeLt_tra (SNoLev x) (SNoLev y) (SNoLev z) (SNoLev_ordinal x Hx) (SNoLev_ordinal y Hy) (SNoLev_ordinal z Hz) (fun beta => beta :e x) (fun beta => beta :e y) (fun beta => beta :e z) Hxy Hyz.
Qed.

Theorem SNoLe_tra : forall x y z, SNo x -> SNo y -> SNo z -> x <= y -> y <= z -> x <= z.
let x y z. assume Hx Hy Hz Hxy Hyz.
exact PNoLe_tra (SNoLev x) (SNoLev y) (SNoLev z) (SNoLev_ordinal x Hx) (SNoLev_ordinal y Hy) (SNoLev_ordinal z Hz) (fun beta => beta :e x) (fun beta => beta :e y) (fun beta => beta :e z) Hxy Hyz.
Qed.

Theorem SNoLtLe_or : forall x y, SNo x -> SNo y -> x < y \/ y <= x.
let x y.
assume Hx Hy.
apply SNoLt_trichotomy_or x y Hx Hy. assume H1. apply H1.
- assume H1: x < y. apply orIL. exact H1.
- assume H1: x = y. apply orIR. prove y <= x. rewrite H1. prove y <= y. apply SNoLe_ref.
- assume H1: y < x. apply orIR. prove y <= x. apply SNoLtLe. exact H1.
Qed.

Theorem SNoLt_PSNo_PNoLt : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PSNo alpha p < PSNo beta q -> PNoLt alpha p beta q.
let alpha beta p q.
assume Ha Hb.
prove PNoLt (SNoLev (PSNo alpha p)) (fun gamma => gamma :e PSNo alpha p) (SNoLev (PSNo beta q)) (fun gamma => gamma :e PSNo beta q)
  -> PNoLt alpha p beta q.
rewrite SNoLev_PSNo alpha Ha p.
rewrite SNoLev_PSNo beta Hb q.
assume H1: PNoLt alpha (fun gamma => gamma :e PSNo alpha p) beta (fun gamma => gamma :e PSNo beta q).
apply PNoEqLt_tra alpha beta Ha Hb p (fun gamma => gamma :e PSNo alpha p) q.
- prove PNoEq_ alpha p (fun gamma => gamma :e PSNo alpha p).
  apply PNoEq_sym_.
  apply PNoEq_PSNo.
  exact Ha.
- prove PNoLt alpha (fun gamma => gamma :e PSNo alpha p) beta q.
  apply PNoLtEq_tra alpha beta Ha Hb (fun gamma => gamma :e PSNo alpha p) (fun gamma => gamma :e PSNo beta q) q.
  + exact H1.
  + prove PNoEq_ beta (fun gamma => gamma :e PSNo beta q) q.
    apply PNoEq_PSNo.
    exact Hb.
Qed.

Theorem PNoLt_SNoLt_PSNo : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PNoLt alpha p beta q -> PSNo alpha p < PSNo beta q.
let alpha beta p q.
assume Ha Hb.
assume H1: PNoLt alpha p beta q.
prove PNoLt (SNoLev (PSNo alpha p)) (fun gamma => gamma :e PSNo alpha p) (SNoLev (PSNo beta q)) (fun gamma => gamma :e PSNo beta q).
rewrite SNoLev_PSNo alpha Ha p.
rewrite SNoLev_PSNo beta Hb q.
prove PNoLt alpha (fun gamma => gamma :e PSNo alpha p) beta (fun gamma => gamma :e PSNo beta q).
apply PNoEqLt_tra alpha beta Ha Hb (fun gamma => gamma :e PSNo alpha p) p (fun gamma => gamma :e PSNo beta q).
- prove PNoEq_ alpha (fun gamma => gamma :e PSNo alpha p) p.
  apply PNoEq_PSNo.
  exact Ha.
- prove PNoLt alpha p beta (fun gamma => gamma :e PSNo beta q).
  apply PNoLtEq_tra alpha beta Ha Hb p q (fun gamma => gamma :e PSNo beta q).
  + exact H1.
  + prove PNoEq_ beta q (fun gamma => gamma :e PSNo beta q).
    apply PNoEq_sym_.
    apply PNoEq_PSNo.
    exact Hb.
Qed.

Definition SNoCut : set -> set -> set :=
  fun L R => PSNo (PNo_bd (fun alpha p => ordinal alpha /\ PSNo alpha p :e L) (fun alpha p => ordinal alpha /\ PSNo alpha p :e R)) (PNo_pred (fun alpha p => ordinal alpha /\ PSNo alpha p :e L) (fun alpha p => ordinal alpha /\ PSNo alpha p :e R)).
Definition SNoCutP : set -> set -> prop :=
 fun L R =>
      (forall x :e L, SNo x)
   /\ (forall y :e R, SNo y)
   /\ (forall x :e L, forall y :e R, x < y).

Theorem SNoCutP_SNoCut : forall L R, SNoCutP L R
 -> SNo (SNoCut L R)
 /\ SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y)))
 /\ (forall x :e L, x < SNoCut L R)
 /\ (forall y :e R, SNoCut L R < y)
 /\ (forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z).
let L R.
assume HC: SNoCutP L R.
apply HC. assume HC. apply HC.
assume HL: forall x :e L, SNo x.
assume HR: forall y :e R, SNo y.
assume HLR: forall x :e L, forall y :e R, x < y.
set L' : set -> (set -> prop) -> prop := fun alpha p => ordinal alpha /\ PSNo alpha p :e L.
set R' : set -> (set -> prop) -> prop := fun alpha p => ordinal alpha /\ PSNo alpha p :e R.
set tau := PNo_bd L' R'.
set w := PNo_pred L' R'.
set alpha := \/_ x :e L, ordsucc (SNoLev x).
set beta := \/_ y :e R, ordsucc (SNoLev y).
prove SNo (SNoCut L R)
 /\ SNoLev (SNoCut L R) :e ordsucc (alpha :\/: beta)
 /\ (forall x :e L, x < SNoCut L R)
 /\ (forall y :e R, SNoCut L R < y)
 /\ (forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ PNoEq_ (SNoLev (SNoCut L R)) (fun gamma => gamma :e SNoCut L R) (fun gamma => gamma :e z)).
claim LLR: PNoLt_pwise L' R'.
{ let gamma. assume Hc: ordinal gamma. let p.
  assume H1: L' gamma p. apply H1. assume _ H1.
  let delta. assume Hd: ordinal delta. let q.
  assume H2: R' delta q. apply H2. assume _ H2.
  prove PNoLt gamma p delta q.
  apply SNoLt_PSNo_PNoLt gamma delta p q Hc Hd.
  prove PSNo gamma p < PSNo delta q.
  exact HLR (PSNo gamma p) H1 (PSNo delta q) H2.
}
claim La: ordinal alpha.
{ apply ordinal_famunion L (fun x => ordsucc (SNoLev x)).
  let x. assume Hx: x :e L.
  prove ordinal (ordsucc (SNoLev x)).
  apply ordinal_ordsucc.
  apply SNoLev_ordinal.
  prove SNo x. exact HL x Hx.
}
claim Lb: ordinal beta.
{ apply ordinal_famunion R (fun y => ordsucc (SNoLev y)).
  let y. assume Hy: y :e R.
  prove ordinal (ordsucc (SNoLev y)).
  apply ordinal_ordsucc.
  apply SNoLev_ordinal.
  prove SNo y. exact HR y Hy.
}
claim Lab: ordinal (alpha :\/: beta).
{ apply ordinal_linear alpha beta La Lb.
  - prove alpha c= beta -> ordinal (alpha :\/: beta).
    rewrite Subq_binunion_eq alpha beta.
    prove alpha :\/: beta = beta -> ordinal (alpha :\/: beta).
    assume H1. rewrite H1. exact Lb.
  - prove beta c= alpha -> ordinal (alpha :\/: beta).
    rewrite Subq_binunion_eq beta alpha.
    prove beta :\/: alpha = alpha -> ordinal (alpha :\/: beta).
    assume H1. rewrite binunion_com. rewrite H1. exact La.
}
claim LLab: PNo_lenbdd (alpha :\/: beta) L'.
{ let gamma. let p.
  assume H1. apply H1.
  assume H1: ordinal gamma.
  assume H2: PSNo gamma p :e L.
  prove gamma :e alpha :\/: beta.
  apply binunionI1.
  prove gamma :e \/_ x :e L, ordsucc (SNoLev x).
  apply famunionI L (fun x => ordsucc (SNoLev x)) (PSNo gamma p) gamma.
  + prove PSNo gamma p :e L. exact H2.
  + prove gamma :e ordsucc (SNoLev (PSNo gamma p)).
    rewrite SNoLev_PSNo gamma H1 p.
    prove gamma :e ordsucc gamma. apply ordsuccI2.
}
claim LRab: PNo_lenbdd (alpha :\/: beta) R'.
{ let gamma. let p.
  assume H1. apply H1.
  assume H1: ordinal gamma.
  assume H2: PSNo gamma p :e R.
  prove gamma :e alpha :\/: beta.
  apply binunionI2.
  prove gamma :e \/_ y :e R, ordsucc (SNoLev y).
  apply famunionI R (fun y => ordsucc (SNoLev y)) (PSNo gamma p) gamma.
  + prove PSNo gamma p :e R. exact H2.
  + prove gamma :e ordsucc (SNoLev (PSNo gamma p)).
    rewrite SNoLev_PSNo gamma H1 p.
    prove gamma :e ordsucc gamma. apply ordsuccI2.
}
apply PNo_bd_pred L' R' LLR (alpha :\/: beta) Lab LLab LRab.
assume H1. apply H1.
assume H1: ordinal tau.
assume H2: PNo_strict_imv L' R' tau w.
assume H3: forall gamma :e tau,
           forall q:set -> prop, ~PNo_strict_imv L' R' gamma q.
apply H2.
assume H4: PNo_strict_upperbd L' tau w.
assume H5: PNo_strict_lowerbd R' tau w.
claim LNoC: SNo (SNoCut L R).
{ prove SNo (PSNo tau w).
  prove exists alpha, ordinal alpha /\ SNo_ alpha (PSNo tau w).
  witness tau.
  apply andI.
  - exact H1.
  - prove SNo_ tau (PSNo tau w).
    apply SNo_PSNo tau.
    prove ordinal tau.
    exact H1.
}
claim LLleveqtau: SNoLev (SNoCut L R) = tau.
{ exact SNoLev_PSNo tau H1 (PNo_pred L' R'). }
claim LLbdtau: tau :e ordsucc (alpha :\/: beta).
{ exact PNo_bd_In L' R' LLR (alpha :\/: beta) Lab LLab LRab. }
claim LLbd: SNoLev (SNoCut L R) :e ordsucc (alpha :\/: beta).
{ rewrite LLleveqtau. exact LLbdtau. }
claim LLecw: PNoEq_ tau (fun gamma => gamma :e SNoCut L R) w.
{ prove PNoEq_ tau (fun gamma => gamma :e PSNo tau w) w.
  exact PNoEq_PSNo tau H1 w.
}
claim LLC: ordinal (SNoLev (SNoCut L R)).
{ apply SNoLev_ordinal. exact LNoC. }
claim LL: forall x :e L, x < SNoCut L R.
{ let x. assume Hx: x :e L.
  prove x < SNoCut L R.
  prove x < PSNo tau w.
  claim L1: SNo x.
  { exact HL x Hx. }
  claim LLx: ordinal (SNoLev x).
  { exact SNoLev_ordinal x L1. }
  claim L2: x = PSNo (SNoLev x) (fun gamma => gamma :e x).
  { apply SNo_PSNo_eta. exact L1. }
  claim L3: L' (SNoLev x) (fun gamma => gamma :e x).
  { prove ordinal (SNoLev x) /\ PSNo (SNoLev x) (fun gamma => gamma :e x) :e L.
    apply andI.
    - exact LLx.
    - rewrite <- L2.
      exact Hx.
  }
  prove x < PSNo tau w.
  rewrite L2.
  apply PNoLt_SNoLt_PSNo (SNoLev x) tau (fun gamma => gamma :e x) w LLx H1.
  prove PNoLt (SNoLev x) (fun gamma => gamma :e x) tau w.
  exact H4 (SNoLev x) LLx (fun gamma => gamma :e x) L3.
}
claim LR: forall y :e R, SNoCut L R < y.
{ let y. assume Hy: y :e R.
  prove SNoCut L R < y.
  prove PSNo tau w < y.
  claim L1: SNo y.
  { exact HR y Hy. }
  claim LLy: ordinal (SNoLev y).
  { exact SNoLev_ordinal y L1. }
  claim L2: y = PSNo (SNoLev y) (fun gamma => gamma :e y).
  { apply SNo_PSNo_eta. exact L1. }
  claim L3: R' (SNoLev y) (fun gamma => gamma :e y).
  { prove ordinal (SNoLev y) /\ PSNo (SNoLev y) (fun gamma => gamma :e y) :e R.
    apply andI.
    - exact LLy.
    - rewrite <- L2.
      exact Hy.
  }
  prove PSNo tau w < y.
  rewrite L2.
  apply PNoLt_SNoLt_PSNo tau (SNoLev y) w (fun gamma => gamma :e y) H1 LLy.
  prove PNoLt tau w (SNoLev y) (fun gamma => gamma :e y).
  exact H5 (SNoLev y) LLy (fun gamma => gamma :e y) L3.
}
apply and5I.
- exact LNoC.
- exact LLbd.
- exact LL.
- exact LR.
- prove forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ PNoEq_ (SNoLev (SNoCut L R)) (fun gamma => gamma :e SNoCut L R) (fun gamma => gamma :e z).
  let z. assume Hz: SNo z.
  assume H10: forall x :e L, x < z.
  assume H11: forall y :e R, z < y.
  claim LLz: ordinal (SNoLev z).
  { apply SNoLev_ordinal. exact Hz. }
  claim Lzimv: PNo_strict_imv L' R' (SNoLev z) (fun gamma => gamma :e z).
  { prove PNo_strict_upperbd L' (SNoLev z) (fun gamma => gamma :e z)
       /\ PNo_strict_lowerbd R' (SNoLev z) (fun gamma => gamma :e z).
    apply andI.
    - let gamma. assume Hc: ordinal gamma.
      let q. assume Hq: L' gamma q.
      prove PNoLt gamma q (SNoLev z) (fun gamma => gamma :e z).
      apply Hq.
      assume Hq1: ordinal gamma.
      assume Hq2: PSNo gamma q :e L.
      apply SNoLt_PSNo_PNoLt gamma (SNoLev z) q (fun gamma => gamma :e z) Hc LLz.
      prove PSNo gamma q < PSNo (SNoLev z) (fun gamma => gamma :e z).
      rewrite <- SNo_PSNo_eta z Hz.
      prove PSNo gamma q < z.
      exact H10 (PSNo gamma q) Hq2.
    - let gamma. assume Hc: ordinal gamma.
      let q. assume Hq: R' gamma q.
      prove PNoLt (SNoLev z) (fun gamma => gamma :e z) gamma q.
      apply Hq.
      assume Hq1: ordinal gamma.
      assume Hq2: PSNo gamma q :e R.
      apply SNoLt_PSNo_PNoLt (SNoLev z) gamma (fun gamma => gamma :e z) q LLz Hc.
      prove PSNo (SNoLev z) (fun gamma => gamma :e z) < PSNo gamma q.
      rewrite <- SNo_PSNo_eta z Hz.
      prove z < PSNo gamma q.
      exact H11 (PSNo gamma q) Hq2.
  }
  claim LLznt: SNoLev z /:e tau.
  { assume H12: SNoLev z :e tau.
    exact H3 (SNoLev z) H12 (fun gamma => gamma :e z) Lzimv.
  }
  claim LLzlet : tau c= SNoLev z.
  { apply ordinal_In_Or_Subq (SNoLev z) tau LLz H1.
    - assume H12: SNoLev z :e tau. prove False. exact LLznt H12.
    - assume H12. exact H12.
  }
  prove SNoLev (SNoCut L R) c= SNoLev z /\ PNoEq_ (SNoLev (SNoCut L R)) (fun gamma => gamma :e SNoCut L R) (fun gamma => gamma :e z).
  rewrite LLleveqtau.
  prove tau c= SNoLev z /\ PNoEq_ tau (fun gamma => gamma :e SNoCut L R) (fun gamma => gamma :e z).
  apply andI.
  + prove tau c= SNoLev z.
    exact LLzlet.
  + prove PNoEq_ tau (fun gamma => gamma :e SNoCut L R) (fun gamma => gamma :e z).
    apply PNoLt_trichotomy_or_ w (fun gamma => gamma :e z) tau H1. assume H12. apply H12.
    * { assume H12: PNoLt_ tau w (fun gamma => gamma :e z).
        prove False.
        apply H12.
        let delta. assume H13. apply H13.
        assume Hd: delta :e tau.
        assume H13. apply H13. assume H13. apply H13.
        assume H13: PNoEq_ delta w (fun gamma => gamma :e z).
        assume H14: ~w delta.
        assume H15: delta :e z.
        claim Ld: ordinal delta.
        { exact ordinal_Hered tau H1 delta Hd. }
        claim Lsd: ordinal (ordsucc delta).
        { exact ordinal_ordsucc delta Ld. }
        set z0 : set -> prop := fun eps => eps :e z /\ eps <> delta.
        set z1 : set -> prop := fun eps => eps :e z \/ eps = delta.
        claim Lnz0d: ~z0 delta.
        { assume H10. apply H10.
          assume H11: delta :e z.
          assume H12: delta <> delta.
          apply H12. reflexivity.
        }
        claim Lz1d: z1 delta.
        { prove delta :e z \/ delta = delta.
          apply orIR. reflexivity.
        }
        apply H3 delta Hd (fun gamma => gamma :e z).
        prove PNo_strict_imv L' R' delta (fun gamma => gamma :e z).
        apply PNo_rel_split_imv_imp_strict_imv L' R' delta Ld (fun gamma => gamma :e z).
        prove PNo_rel_strict_split_imv L' R' delta (fun gamma => gamma :e z).
        prove PNo_rel_strict_imv L' R' (ordsucc delta) z0
           /\ PNo_rel_strict_imv L' R' (ordsucc delta) z1.
        apply andI.
        - prove PNo_rel_strict_imv L' R' (ordsucc delta) z0.
          apply PNoEq_rel_strict_imv L' R' (ordsucc delta) Lsd w z0.
          + prove PNoEq_ (ordsucc delta) w z0.
            let eps. assume He: eps :e ordsucc delta.
            apply ordsuccE delta eps He.
            * { assume He1: eps :e delta.
                apply iff_trans (w eps) (eps :e z) (z0 eps).
                - exact H13 eps He1.
                - exact PNo_extend0_eq delta (fun gamma => gamma :e z) eps He1.
              }
            * { assume He1: eps = delta.
                prove w eps <-> z0 eps.
                rewrite He1.
                prove w delta <-> z0 delta.
                apply iffI.
                - assume H16: w delta. prove False. exact H14 H16.
                - assume H16: z0 delta. prove False. exact Lnz0d H16.
              }
          + prove PNo_rel_strict_imv L' R' (ordsucc delta) w.
            apply PNo_strict_imv_imp_rel_strict_imv L' R' tau H1 (ordsucc delta).
            * prove ordsucc delta :e ordsucc tau.
              apply ordinal_ordsucc_In tau H1. exact Hd.
            * prove PNo_strict_imv L' R' tau w. exact H2.
        - prove PNo_rel_strict_imv L' R' (ordsucc delta) z1.
          apply PNoEq_rel_strict_imv L' R' (ordsucc delta) Lsd (fun gamma => gamma :e z) z1.
          + prove PNoEq_ (ordsucc delta) (fun gamma => gamma :e z) z1.
            let eps. assume He: eps :e ordsucc delta.
            apply ordsuccE delta eps He.
            * assume He1: eps :e delta.
              exact PNo_extend1_eq delta (fun gamma => gamma :e z) eps He1.
            * { assume He1: eps = delta.
                prove eps :e z <-> z1 eps.
                rewrite He1.
                prove delta :e z <-> z1 delta.
                apply iffI.
                - assume _. exact Lz1d.
                - assume _. exact H15.
              }
          + prove PNo_rel_strict_imv L' R' (ordsucc delta) (fun gamma => gamma :e z).
            apply PNo_strict_imv_imp_rel_strict_imv L' R' (SNoLev z) LLz (ordsucc delta).
            * prove ordsucc delta :e ordsucc (SNoLev z).
              apply ordinal_ordsucc_In (SNoLev z) LLz.
              prove delta :e SNoLev z.
              apply LLzlet.
              prove delta :e tau. exact Hd.
            * prove PNo_strict_imv L' R' (SNoLev z) (fun gamma => gamma :e z).
              exact Lzimv.
      }
    * { assume H12: PNoEq_ tau w (fun gamma => gamma :e z).
        apply PNoEq_tra_ tau (fun gamma => gamma :e SNoCut L R) w (fun gamma => gamma :e z).
        - prove PNoEq_ tau (fun gamma => gamma :e SNoCut L R) w.
          exact LLecw.
        - prove PNoEq_ tau w (fun gamma => gamma :e z). exact H12.
      }    
    * { assume H12: PNoLt_ tau (fun gamma => gamma :e z) w.
        prove False.
        apply H12.
        let delta. assume H13. apply H13.
        assume Hd: delta :e tau.
        assume H13. apply H13. assume H13. apply H13.
        assume H13: PNoEq_ delta (fun gamma => gamma :e z) w.
        assume H14: delta /:e z.
        assume H15: w delta.
        claim Ld: ordinal delta.
        { exact ordinal_Hered tau H1 delta Hd. }
        claim Lsd: ordinal (ordsucc delta).
        { exact ordinal_ordsucc delta Ld. }
        set z0 : set -> prop := fun eps => eps :e z /\ eps <> delta.
        set z1 : set -> prop := fun eps => eps :e z \/ eps = delta.
        claim Lnz0d: ~z0 delta.
        { assume H10. apply H10.
          assume H11: delta :e z.
          assume H12: delta <> delta.
          apply H12. reflexivity.
        }
        claim Lz1d: z1 delta.
        { prove delta :e z \/ delta = delta.
          apply orIR. reflexivity.
        }
        apply H3 delta Hd (fun gamma => gamma :e z).
        prove PNo_strict_imv L' R' delta (fun gamma => gamma :e z).
        apply PNo_rel_split_imv_imp_strict_imv L' R' delta Ld (fun gamma => gamma :e z).
        prove PNo_rel_strict_split_imv L' R' delta (fun gamma => gamma :e z).
        prove PNo_rel_strict_imv L' R' (ordsucc delta) z0
           /\ PNo_rel_strict_imv L' R' (ordsucc delta) z1.
        apply andI.
        - prove PNo_rel_strict_imv L' R' (ordsucc delta) z0.
          apply PNoEq_rel_strict_imv L' R' (ordsucc delta) Lsd (fun gamma => gamma :e z) z0.
          + prove PNoEq_ (ordsucc delta) (fun gamma => gamma :e z) z0.
            let eps. assume He: eps :e ordsucc delta.
            apply ordsuccE delta eps He.
            * assume He1: eps :e delta.
              exact PNo_extend0_eq delta (fun gamma => gamma :e z) eps He1.
            * { assume He1: eps = delta.
                prove eps :e z <-> z0 eps.
                rewrite He1.
                prove delta :e z <-> z0 delta.
                apply iffI.
                - assume H16: delta :e z. prove False. exact H14 H16.
                - assume H16: z0 delta. prove False. exact Lnz0d H16.
              }
          + prove PNo_rel_strict_imv L' R' (ordsucc delta) (fun gamma => gamma :e z).
            apply PNo_strict_imv_imp_rel_strict_imv L' R' (SNoLev z) LLz (ordsucc delta).
            * prove ordsucc delta :e ordsucc (SNoLev z).
              apply ordinal_ordsucc_In (SNoLev z) LLz.
              prove delta :e SNoLev z.
              apply LLzlet.
              prove delta :e tau. exact Hd.
            * prove PNo_strict_imv L' R' (SNoLev z) (fun gamma => gamma :e z).
              exact Lzimv.
        - prove PNo_rel_strict_imv L' R' (ordsucc delta) z1.
          apply PNoEq_rel_strict_imv L' R' (ordsucc delta) Lsd w z1.
          + prove PNoEq_ (ordsucc delta) w z1.
            let eps. assume He: eps :e ordsucc delta.
            apply ordsuccE delta eps He.
            * { assume He1: eps :e delta.
                apply iff_trans (w eps) (eps :e z) (z1 eps).
                - apply iff_sym. exact H13 eps He1.
                - exact PNo_extend1_eq delta (fun gamma => gamma :e z) eps He1.
              }
            * { assume He1: eps = delta.
                prove w eps <-> z1 eps.
                rewrite He1.
                prove w delta <-> z1 delta.
                apply iffI.
                - assume _. exact Lz1d.
                - assume _. exact H15.
              }
          + prove PNo_rel_strict_imv L' R' (ordsucc delta) w.
            apply PNo_strict_imv_imp_rel_strict_imv L' R' tau H1 (ordsucc delta).
            * prove ordsucc delta :e ordsucc tau.
              apply ordinal_ordsucc_In tau H1. exact Hd.
            * prove PNo_strict_imv L' R' tau w. exact H2.
      }
Qed.

Theorem SNoCutP_SNoCut_impred : forall L R, SNoCutP L R
 -> forall p:prop,
      (SNo (SNoCut L R)
    -> SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y)))
    -> (forall x :e L, x < SNoCut L R)
    -> (forall y :e R, SNoCut L R < y)
    -> (forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z)
    -> p)
   -> p.
let L R. assume HLR. let p. assume Hp.
apply SNoCutP_SNoCut L R HLR.
assume H. apply H. assume H. apply H. assume H. apply H.
exact Hp.
Qed.

Theorem SNoCutP_L_0: forall L, (forall x :e L, SNo x) -> SNoCutP L 0.
let L. assume H1.
prove (forall x :e L, SNo x)
   /\ (forall y :e 0, SNo y)
   /\ (forall x :e L, forall y :e 0, x < y).
apply and3I.
- exact H1.
- let y. assume Hy. prove False. exact EmptyE y Hy.
- let x. assume Hx. let y. assume Hy. prove False. exact EmptyE y Hy.
Qed.

Theorem SNoCutP_0_0: SNoCutP 0 0.
apply SNoCutP_L_0. let x. assume Hx. prove False. exact EmptyE x Hx.
Qed.

Definition SNoS_ : set -> set := fun alpha => {x :e Power (SNoElts_ alpha)|exists beta :e alpha, SNo_ beta x}.

Theorem SNoS_E : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, exists beta :e alpha, SNo_ beta x.
let alpha. assume Ha: ordinal alpha.
let x.
assume H1: x :e SNoS_ alpha.
prove exists beta :e alpha, SNo_ beta x.
exact SepE2 (Power (SNoElts_ alpha)) (fun x => exists beta :e alpha, SNo_ beta x) x H1.
Qed.

Section TaggedSets2.
Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Theorem SNoS_I : forall alpha, ordinal alpha -> forall x, forall beta :e alpha, SNo_ beta x -> x :e SNoS_ alpha.
let alpha. assume Ha: ordinal alpha.
let x.
let beta.
assume Hb: beta :e alpha.
assume H1: SNo_ beta x.
apply H1.
assume H2: x c= SNoElts_ beta.
assume H3: forall gamma :e beta, exactly1of2 (gamma ' :e x) (gamma :e x).
prove x :e SNoS_ alpha.
prove x :e {x :e Power (SNoElts_ alpha)|exists gamma :e alpha, SNo_ gamma x}.
apply SepI.
- prove x :e Power (SNoElts_ alpha).
  apply PowerI.
  prove x c= SNoElts_ alpha.
  apply Subq_tra x (SNoElts_ beta) (SNoElts_ alpha) H2.
  prove SNoElts_ beta c= SNoElts_ alpha.
  apply SNoElts_mon.
  apply Ha. assume Ha1 _. exact Ha1 beta Hb.
- prove exists gamma :e alpha, SNo_ gamma x.
  witness beta. apply andI.
  + exact Hb.
  + exact H1.
Qed.

Theorem SNoS_I2 : forall x y, SNo x -> SNo y -> SNoLev x :e SNoLev y -> x :e SNoS_ (SNoLev y).
let x y.
assume Hx Hy Hxy.
exact SNoS_I (SNoLev y) (SNoLev_ordinal y Hy) x (SNoLev x) Hxy (SNoLev_ x Hx).
Qed.  

Theorem SNoS_Subq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta -> SNoS_ alpha c= SNoS_ beta.
let alpha beta. assume Ha Hb Hab.
let x. assume Hx: x :e SNoS_ alpha.
apply SNoS_E alpha Ha x Hx.
let gamma. assume Hc. apply Hc.
assume Hc1: gamma :e alpha.
assume Hc2: SNo_ gamma x.
exact SNoS_I beta Hb x gamma (Hab gamma Hc1) Hc2.
Qed.

Theorem SNoLev_uniq2 : forall alpha, ordinal alpha -> forall x, SNo_ alpha x -> SNoLev x = alpha.
let alpha. assume Ha.
let x. assume Hx.
apply SNoLev_prop x (SNo_SNo alpha Ha x Hx).
assume Hx1: ordinal (SNoLev x).
assume Hx2: SNo_ (SNoLev x) x.
apply SNoLev_uniq x.
- exact Hx1.
- exact Ha.
- exact Hx2.
- exact Hx.
Qed.

Theorem SNoS_E2 : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha,
 forall p:prop,
     (SNoLev x :e alpha -> ordinal (SNoLev x) -> SNo x -> SNo_ (SNoLev x) x -> p)
  -> p.
let alpha. assume Ha. let x. assume Hx.
let p. assume Hp.
apply SNoS_E alpha Ha x Hx.
let beta. assume H1. apply H1.
assume Hb: beta :e alpha.
assume H1: SNo_ beta x.
claim Lb: ordinal beta.
{ exact ordinal_Hered alpha Ha beta Hb. }
claim Lx: SNo x.
{ exact SNo_SNo beta Lb x H1. }
apply SNoLev_prop x Lx.
assume Hx1: ordinal (SNoLev x).
assume Hx2: SNo_ (SNoLev x) x.
claim Lxb: SNoLev x = beta.
{ exact SNoLev_uniq2 beta Lb x H1. }
claim Lxa: SNoLev x :e alpha.
{ rewrite Lxb. exact Hb. }
exact Hp Lxa Hx1 Lx Hx2.
Qed.

Theorem SNoS_In_neq : forall w, SNo w -> forall x :e SNoS_ (SNoLev w), x <> w.
let w. assume Hw: SNo w. let x. assume Hx: x :e SNoS_ (SNoLev w).
assume Hxw: x = w.
apply SNoLev_prop w Hw.
assume Hw1: ordinal (SNoLev w).
assume Hw2: SNo_ (SNoLev w) w.
apply SNoS_E2 (SNoLev w) Hw1 x Hx.
assume Hx1: SNoLev x :e SNoLev w.
assume Hx2: ordinal (SNoLev x).
assume Hx3: SNo x.
assume Hx4: SNo_ (SNoLev x) x.
prove False.
apply In_irref (SNoLev x).
rewrite Hxw at 2. exact Hx1.
Qed.

Theorem SNoS_SNoLev : forall z, SNo z -> z :e SNoS_ (ordsucc (SNoLev z)).
let z. assume Hz: SNo z.
apply SNoLev_prop z Hz.
assume Hz1: ordinal (SNoLev z).
assume Hz2: SNo_ (SNoLev z) z.
exact SNoS_I (ordsucc (SNoLev z)) (ordinal_ordsucc (SNoLev z) Hz1) z (SNoLev z) (ordsuccI2 (SNoLev z)) Hz2.
Qed.

Definition SNoL : set -> set := fun z => {x :e SNoS_ (SNoLev z) | x < z}.
Definition SNoR : set -> set := fun z => {y :e SNoS_ (SNoLev z) | z < y}.

Theorem SNoCutP_SNoL_SNoR: forall z, SNo z -> SNoCutP (SNoL z) (SNoR z).
let z. assume Hz: SNo z.
set L := SNoL z.
set R := SNoR z.
claim LLz: ordinal (SNoLev z).
{ exact SNoLev_ordinal z Hz. }
claim L1: forall x :e L, SNo x.
{ let x. assume Hx: x :e L.
  prove exists alpha, ordinal alpha /\ SNo_ alpha x.
  claim L1a: x :e SNoS_ (SNoLev z).
  { exact SepE1 (SNoS_ (SNoLev z)) (fun x => x < z) x Hx. }
  apply SNoS_E (SNoLev z) LLz x L1a.
  let beta. assume H1. apply H1.
  assume Hb: beta :e SNoLev z.
  assume H1: SNo_ beta x.
  witness beta. apply andI.
  - exact ordinal_Hered (SNoLev z) LLz beta Hb.
  - exact H1.
}
claim L2: forall y :e R, SNo y.
{ let y. assume Hy: y :e R.
  prove exists alpha, ordinal alpha /\ SNo_ alpha y.
  claim L2a: y :e SNoS_ (SNoLev z).
  { exact SepE1 (SNoS_ (SNoLev z)) (fun y => z < y) y Hy. }
  apply SNoS_E (SNoLev z) LLz y L2a.
  let beta. assume H1. apply H1.
  assume Hb: beta :e SNoLev z.
  assume H1: SNo_ beta y.
  witness beta. apply andI.
  - exact ordinal_Hered (SNoLev z) LLz beta Hb.
  - exact H1.
}
claim L3: forall x :e L, forall y :e R, x < y.
{ let x. assume Hx. let y. assume Hy.
  apply SNoLt_tra x z y (L1 x Hx) Hz (L2 y Hy).
  - prove x < z. exact SepE2 (SNoS_ (SNoLev z)) (fun x => x < z) x Hx.
  - prove z < y. exact SepE2 (SNoS_ (SNoLev z)) (fun y => z < y) y Hy.
}
prove SNoCutP L R.
prove (forall x :e L, SNo x)
   /\ (forall y :e R, SNo y)
   /\ (forall x :e L, forall y :e R, x < y).
apply and3I.
- exact L1.
- exact L2.
- exact L3.
Qed.

Theorem SNoL_E : forall x, SNo x -> forall w :e SNoL x,
  forall p:prop,
       (SNo w -> SNoLev w :e SNoLev x -> w < x -> p)
    -> p.
let x. assume Hx: SNo x.
let w. assume Hw: w :e SNoL x.
let p. assume Hp.
apply SepE (SNoS_ (SNoLev x)) (fun w => w < x) w Hw.
assume Hw1: w :e SNoS_ (SNoLev x).
assume Hw2: w < x.
apply SNoS_E2 (SNoLev x) (SNoLev_ordinal x Hx) w Hw1.
assume Hw3: SNoLev w :e SNoLev x.
assume Hw4: ordinal (SNoLev w).
assume Hw5: SNo w.
assume Hw6: SNo_ (SNoLev w) w.
exact Hp Hw5 Hw3 Hw2.
Qed.

Theorem SNoR_E : forall x, SNo x -> forall z :e SNoR x,
  forall p:prop,
       (SNo z -> SNoLev z :e SNoLev x -> x < z -> p)
    -> p.
let x. assume Hx: SNo x.
let z. assume Hz: z :e SNoR x.
let p. assume Hp.
apply SepE (SNoS_ (SNoLev x)) (fun z => x < z) z Hz.
assume Hz1: z :e SNoS_ (SNoLev x).
assume Hz2: x < z.
apply SNoS_E2 (SNoLev x) (SNoLev_ordinal x Hx) z Hz1.
assume Hz3: SNoLev z :e SNoLev x.
assume Hz4: ordinal (SNoLev z).
assume Hz5: SNo z.
assume Hz6: SNo_ (SNoLev z) z.
exact Hp Hz5 Hz3 Hz2.
Qed.

Theorem SNoL_SNoS_ : forall z, SNoL z c= SNoS_ (SNoLev z).
let z. exact Sep_Subq (SNoS_ (SNoLev z)) (fun x => x < z).
Qed.

Theorem SNoR_SNoS_ : forall z, SNoR z c= SNoS_ (SNoLev z).
let z. exact Sep_Subq (SNoS_ (SNoLev z)) (fun y => z < y).
Qed.

Theorem SNoL_SNoS : forall x, SNo x -> forall w :e SNoL x, w :e SNoS_ (SNoLev x).
let x. assume Hx. let w. assume Hw: w :e SNoL x.
apply SNoL_E x Hx w Hw.
assume Hw1: SNo w.
assume Hw2: SNoLev w :e SNoLev x.
assume Hw3: w < x.
prove w :e SNoS_ (SNoLev x).
exact SNoS_I2 w x Hw1 Hx Hw2.
Qed.

Theorem SNoR_SNoS : forall x, SNo x -> forall z :e SNoR x, z :e SNoS_ (SNoLev x).
let x. assume Hx. let z. assume Hz: z :e SNoR x.
apply SNoR_E x Hx z Hz.
assume Hz1: SNo z.
assume Hz2: SNoLev z :e SNoLev x.
assume Hz3: x < z.
prove z :e SNoS_ (SNoLev x).
exact SNoS_I2 z x Hz1 Hx Hz2.
Qed.

Theorem SNoL_I : forall z, SNo z -> forall x, SNo x -> SNoLev x :e SNoLev z -> x < z -> x :e SNoL z.
let z. assume Hz. let x. assume Hx Hxz1 Hxz2.
prove x :e SNoL z.
prove x :e {x :e SNoS_ (SNoLev z) | x < z}.
apply SepI.
- prove x :e SNoS_ (SNoLev z).
  exact SNoS_I2 x z Hx Hz Hxz1.
- prove x < z. exact Hxz2.
Qed.

Theorem SNoR_I : forall z, SNo z -> forall y, SNo y -> SNoLev y :e SNoLev z -> z < y -> y :e SNoR z.
let z. assume Hz. let y. assume Hy Hyz Hzy.
prove y :e SNoR z.
prove y :e {y :e SNoS_ (SNoLev z) | z < y}.
apply SepI.
- prove y :e SNoS_ (SNoLev z).
  exact SNoS_I2 y z Hy Hz Hyz.
- prove z < y. exact Hzy.
Qed.

Theorem SNo_eta : forall z, SNo z -> z = SNoCut (SNoL z) (SNoR z).
let z. assume Hz: SNo z.
set L := SNoL z.
set R := SNoR z.
claim LLz: ordinal (SNoLev z).
{ exact SNoLev_ordinal z Hz. }
claim LC: SNoCutP L R.
{ exact SNoCutP_SNoL_SNoR z Hz. }
apply SNoCutP_SNoCut L R LC.
assume H1. apply H1. assume H1. apply H1. assume H1. apply H1.
assume H1: SNo (SNoCut L R).
assume H2: SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume H3: forall x :e L, x < SNoCut L R.
assume H4: forall y :e R, SNoCut L R < y.
assume H5: forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ PNoEq_ (SNoLev (SNoCut L R)) (fun gamma => gamma :e SNoCut L R) (fun gamma => gamma :e z).
claim L4: ordinal (SNoLev (SNoCut L R)).
{ apply SNoLev_ordinal. exact H1. }
claim L5: forall x :e L, x < z.
{ let x. assume Hx: x :e L.
  exact SepE2 (SNoS_ (SNoLev z)) (fun x => x < z) x Hx.
}
claim L6: forall y :e R, z < y.
{ let y. assume Hy: y :e R.
  exact SepE2 (SNoS_ (SNoLev z)) (fun y => z < y) y Hy.
}
apply H5 z Hz L5 L6.
assume H6: SNoLev (SNoCut L R) c= SNoLev z.
assume H7: PNoEq_ (SNoLev (SNoCut L R)) (fun gamma => gamma :e SNoCut L R) (fun gamma => gamma :e z).
claim L7: SNoLev (SNoCut L R) = SNoLev z.
{ apply ordinal_trichotomy_or (SNoLev (SNoCut L R)) (SNoLev z) L4 LLz. assume H8. apply H8.
  - assume H8: SNoLev (SNoCut L R) :e SNoLev z.
    prove False.
    apply SNoLt_trichotomy_or z (SNoCut L R) Hz H1. assume H9. apply H9.
    + assume H9: z < SNoCut L R.
      apply SNoLt_irref (SNoCut L R).
      apply H4.
      prove SNoCut L R :e R.
      prove SNoCut L R :e {y :e SNoS_ (SNoLev z) | z < y}.
      apply SepI.
      * apply SNoS_I (SNoLev z) LLz (SNoCut L R) (SNoLev (SNoCut L R)) H8.
        prove SNo_ (SNoLev (SNoCut L R)) (SNoCut L R).
        exact SNoLev_ (SNoCut L R) H1.
      * prove z < SNoCut L R. exact H9.
    + assume H9: z = SNoCut L R.
      apply In_irref (SNoLev z). rewrite H9 at 1. exact H8.
    + assume H9: SNoCut L R < z.
      apply SNoLt_irref (SNoCut L R).
      apply H3.
      prove SNoCut L R :e L.
      prove SNoCut L R :e {x :e SNoS_ (SNoLev z) | x < z}.
      apply SepI.
      * apply SNoS_I (SNoLev z) LLz (SNoCut L R) (SNoLev (SNoCut L R)) H8.
        prove SNo_ (SNoLev (SNoCut L R)) (SNoCut L R).
        exact SNoLev_ (SNoCut L R) H1.
      * prove SNoCut L R < z. exact H9.
  - assume H8: SNoLev (SNoCut L R) = SNoLev z.
    exact H8.
  - assume H8: SNoLev z :e SNoLev (SNoCut L R).
    prove False.
    apply In_irref (SNoLev z).
    apply H6.
    exact H8.
}
prove z = SNoCut L R.
symmetry.
prove SNoCut L R = z.
apply SNo_eq.
- prove SNo (SNoCut L R). exact H1.
- prove SNo z. exact Hz.
- prove SNoLev (SNoCut L R) = SNoLev z. exact L7.
- prove forall alpha :e SNoLev (SNoCut L R), alpha :e SNoCut L R <-> alpha :e z.
  exact H7.
Qed.

Theorem SNoCutP_SNo_SNoCut : forall L R, SNoCutP L R -> SNo (SNoCut L R).
let L R.
assume H1: SNoCutP L R.
apply SNoCutP_SNoCut L R H1.
assume H2 _. apply H2. assume H2 _. apply H2.
assume H2 _. apply H2.
assume H2 _. exact H2.
Qed.

Theorem SNoCutP_SNoCut_L : forall L R, SNoCutP L R -> forall x :e L, x < SNoCut L R.
let L R.
assume H1: SNoCutP L R.
apply SNoCutP_SNoCut L R H1.
assume H2 _. apply H2. assume H2 _. apply H2.
assume _ H2. exact H2.
Qed.

Theorem SNoCutP_SNoCut_R : forall L R, SNoCutP L R -> forall y :e R, SNoCut L R < y.
let L R.
assume H1: SNoCutP L R.
apply SNoCutP_SNoCut L R H1.
assume H2 _. apply H2. assume _ H2. exact H2.
Qed.

Theorem SNoCutP_SNoCut_fst : forall L R, SNoCutP L R ->
 forall z, SNo z
   -> (forall x :e L, x < z)
   -> (forall y :e R, z < y)
   -> SNoLev (SNoCut L R) c= SNoLev z
   /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z.
let L R.
assume H1: SNoCutP L R.
apply SNoCutP_SNoCut L R H1.
assume _ H2. exact H2.
Qed.

Theorem SNoCut_Le : forall L1 R1 L2 R2, SNoCutP L1 R1 -> SNoCutP L2 R2
  -> (forall w :e L1, w < SNoCut L2 R2)
  -> (forall z :e R2, SNoCut L1 R1 < z)
  -> SNoCut L1 R1 <= SNoCut L2 R2.
let L1 R1 L2 R2.
assume HLR1 HLR2.
assume H1: forall w :e L1, w < SNoCut L2 R2.
assume H2: forall z :e R2, SNoCut L1 R1 < z.
apply HLR1. assume HLR1a. apply HLR1a.
assume HLR1a: forall x :e L1, SNo x.
assume HLR1b: forall y :e R1, SNo y.
assume HLR1c: forall x :e L1, forall y :e R1, x < y.
apply HLR2. assume HLR2a. apply HLR2a.
assume HLR2a: forall x :e L2, SNo x.
assume HLR2b: forall y :e R2, SNo y.
assume HLR2c: forall x :e L2, forall y :e R2, x < y.
set alpha := \/_ x :e L1, ordsucc (SNoLev x).
set beta := \/_ y :e R1, ordsucc (SNoLev y).
set gamma := \/_ x :e L2, ordsucc (SNoLev x).
set delta := \/_ y :e R2, ordsucc (SNoLev y).
apply SNoCutP_SNoCut L1 R1 HLR1.
assume H3. apply H3. assume H3. apply H3. assume H3. apply H3.
assume H3: SNo (SNoCut L1 R1).
assume H4: SNoLev (SNoCut L1 R1) :e ordsucc (alpha :\/: beta).
assume H5: forall x :e L1, x < SNoCut L1 R1.
assume H6: forall y :e R1, SNoCut L1 R1 < y.
assume H7: forall z, SNo z -> (forall x :e L1, x < z) -> (forall y :e R1, z < y) -> SNoLev (SNoCut L1 R1) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L1 R1)) (SNoCut L1 R1) z.
apply SNoCutP_SNoCut L2 R2 HLR2.
assume H8. apply H8. assume H8. apply H8. assume H8. apply H8.
assume H8: SNo (SNoCut L2 R2).
assume H9: SNoLev (SNoCut L2 R2) :e ordsucc (gamma :\/: delta).
assume H10: forall x :e L2, x < SNoCut L2 R2.
assume H11: forall y :e R2, SNoCut L2 R2 < y.
assume H12: forall z, SNo z -> (forall x :e L2, x < z) -> (forall y :e R2, z < y) -> SNoLev (SNoCut L2 R2) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L2 R2)) (SNoCut L2 R2) z.
apply SNoLtLe_or (SNoCut L2 R2) (SNoCut L1 R1) H8 H3.
- assume H13: SNoCut L2 R2 < SNoCut L1 R1.
  prove False.
  apply SNoLtE (SNoCut L2 R2) (SNoCut L1 R1) H8 H3 H13.
  + let z.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev (SNoCut L2 R2) :/\: SNoLev (SNoCut L1 R1).
    assume Hz3: SNoEq_ (SNoLev z) z (SNoCut L2 R2).
    assume Hz4: SNoEq_ (SNoLev z) z (SNoCut L1 R1).
    assume Hz5: (SNoCut L2 R2) < z.
    assume Hz6: z < (SNoCut L1 R1).
    assume Hz7: SNoLev z /:e (SNoCut L2 R2).
    assume Hz8: SNoLev z :e (SNoCut L1 R1).
    claim LzL1: forall x :e L1, x < z.
    { let x. assume Hx: x :e L1.
      apply SNoLt_tra x (SNoCut L2 R2) z (HLR1a x Hx) H8 Hz1.
      - prove x < SNoCut L2 R2. exact H1 x Hx.
      - prove SNoCut L2 R2 < z. exact Hz5.
    }
    claim LzR1: forall y :e R1, z < y.
    { let y. assume Hy: y :e R1.
      apply SNoLt_tra z (SNoCut L1 R1) y Hz1 H3 (HLR1b y Hy).
      - prove z < SNoCut L1 R1. exact Hz6.
      - prove SNoCut L1 R1 < y. exact H6 y Hy.
    }
    apply H7 z Hz1 LzL1 LzR1.
    assume H14: SNoLev (SNoCut L1 R1) c= SNoLev z.
    assume _.
    apply In_irref (SNoLev z).
    apply H14.
    prove SNoLev z :e SNoLev (SNoCut L1 R1).
    exact binintersectE2 (SNoLev (SNoCut L2 R2)) (SNoLev (SNoCut L1 R1)) (SNoLev z) Hz2.
  + assume H14: SNoLev (SNoCut L2 R2) :e SNoLev (SNoCut L1 R1).
    assume H15: SNoEq_ (SNoLev (SNoCut L2 R2)) (SNoCut L2 R2) (SNoCut L1 R1).
    assume H16: SNoLev (SNoCut L2 R2) :e (SNoCut L1 R1).
    set z := SNoCut L2 R2.
    claim LzR1: forall y :e R1, z < y.
    { let y. assume Hy: y :e R1.
      apply SNoLt_tra z (SNoCut L1 R1) y H8 H3 (HLR1b y Hy).
      - prove z < SNoCut L1 R1. exact H13.
      - prove SNoCut L1 R1 < y. exact H6 y Hy.
    }
    apply H7 z H8 H1 LzR1.
    assume H17: SNoLev (SNoCut L1 R1) c= SNoLev z.
    assume _.
    apply In_irref (SNoLev z).
    apply H17.
    prove SNoLev z :e SNoLev (SNoCut L1 R1).
    exact H14.
  + assume H14: SNoLev (SNoCut L1 R1) :e SNoLev (SNoCut L2 R2).
    assume H15: SNoEq_ (SNoLev (SNoCut L1 R1)) (SNoCut L2 R2) (SNoCut L1 R1).
    assume H16: SNoLev (SNoCut L1 R1) /:e (SNoCut L2 R2).
    set z := SNoCut L1 R1.
    claim LzL2: forall x :e L2, x < z.
    { let x. assume Hx: x :e L2.
      apply SNoLt_tra x (SNoCut L2 R2) z (HLR2a x Hx) H8 H3.
      - prove x < SNoCut L2 R2. exact H10 x Hx.
      - prove SNoCut L2 R2 < z. exact H13.
    }
    apply H12 z H3 LzL2 H2.
    assume H17: SNoLev (SNoCut L2 R2) c= SNoLev z.
    assume _.
    apply In_irref (SNoLev z).
    apply H17.
    prove SNoLev z :e SNoLev (SNoCut L2 R2).
    exact H14.
- assume H13: SNoCut L1 R1 <= SNoCut L2 R2. exact H13.
Qed.

Theorem SNoCut_ext : forall L1 R1 L2 R2, SNoCutP L1 R1 -> SNoCutP L2 R2
  -> (forall w :e L1, w < SNoCut L2 R2)
  -> (forall z :e R1, SNoCut L2 R2 < z)
  -> (forall w :e L2, w < SNoCut L1 R1)
  -> (forall z :e R2, SNoCut L1 R1 < z)
  -> SNoCut L1 R1 = SNoCut L2 R2.
let L1 R1 L2 R2.
assume HLR1 HLR2.
assume H1: forall w :e L1, w < SNoCut L2 R2.
assume H2: forall z :e R1, SNoCut L2 R2 < z.
assume H3: forall w :e L2, w < SNoCut L1 R1.
assume H4: forall z :e R2, SNoCut L1 R1 < z.
claim LNLR1: SNo (SNoCut L1 R1).
{ exact SNoCutP_SNo_SNoCut L1 R1 HLR1. }
claim LNLR2: SNo (SNoCut L2 R2).
{ exact SNoCutP_SNo_SNoCut L2 R2 HLR2. }
apply SNoLe_antisym (SNoCut L1 R1) (SNoCut L2 R2) LNLR1 LNLR2.
- prove SNoCut L1 R1 <= SNoCut L2 R2.
  exact SNoCut_Le L1 R1 L2 R2 HLR1 HLR2 H1 H4.
- prove SNoCut L2 R2 <= SNoCut L1 R1.
  exact SNoCut_Le L2 R2 L1 R1 HLR2 HLR1 H3 H2.
Qed.

Theorem SNoLt_SNoL_or_SNoR_impred: forall x y, SNo x -> SNo y -> x < y ->
 forall p:prop,
    (forall z :e SNoL y, z :e SNoR x -> p)
 -> (x :e SNoL y -> p)
 -> (y :e SNoR x -> p)
 -> p.
let x y. assume Hx Hy Hxy. let p. assume Hp1 Hp2 Hp3.
apply SNoLtE x y Hx Hy Hxy.
- let z. assume Hz1 Hz2 _ _ Hz3 Hz4 _ _.
  apply binintersectE (SNoLev x) (SNoLev y) (SNoLev z) Hz2.
  assume Hz2a Hz2b.
  apply Hp1 z.
  + prove z :e SNoL y. exact SNoL_I y Hy z Hz1 Hz2b Hz4.
  + prove z :e SNoR x. exact SNoR_I x Hx z Hz1 Hz2a Hz3.
- assume H1 _ _.
  apply Hp2.
  exact SNoL_I y Hy x Hx H1 Hxy.
- assume H1 _ _.
  apply Hp3.
  exact SNoR_I x Hx y Hy H1 Hxy.
Qed.

Theorem SNoL_or_SNoR_impred: forall x y, SNo x -> SNo y ->
 forall p:prop,
    (x = y -> p)
 -> (forall z :e SNoL y, z :e SNoR x -> p)
 -> (x :e SNoL y -> p)
 -> (y :e SNoR x -> p)
 -> (forall z :e SNoR y, z :e SNoL x -> p)
 -> (x :e SNoR y -> p)
 -> (y :e SNoL x -> p)
 -> p.
let x y. assume Hx Hy.
let p. assume Hp1 Hp2 Hp3 Hp4 Hp5 Hp6 Hp7.
apply SNoLt_trichotomy_or_impred x y Hx Hy.
- assume H1: x < y.
  apply SNoLt_SNoL_or_SNoR_impred x y Hx Hy H1.
  + exact Hp2.
  + exact Hp3.
  + exact Hp4.
- assume H1: x = y. exact Hp1 H1.
- assume H1: y < x.
  apply SNoLt_SNoL_or_SNoR_impred y x Hy Hx H1.
  + let z. assume H2 H3. exact Hp5 z H3 H2.
  + exact Hp7.
  + exact Hp6.
Qed.

Theorem SNoL_SNoCutP_ex: forall L R, SNoCutP L R -> forall w :e SNoL (SNoCut L R), exists w' :e L, w <= w'.
let L R. assume HLR.
set y := SNoCut L R.
let w.
assume Hw: w :e SNoL y.
apply dneg.
assume HC: ~exists w' :e L, w <= w'.
apply HLR.
assume H. apply H.
assume HL HR HLR'.
apply SNoCutP_SNoCut_impred L R HLR.
assume H1: SNo y.
assume H2: SNoLev y :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume H3: forall w :e L, w < y.
assume H4: forall z :e R, y < z.
assume H5: forall u, SNo u -> (forall w :e L, w < u) -> (forall z :e R, u < z) -> SNoLev y c= SNoLev u /\ SNoEq_ (SNoLev y) y u.
apply SNoL_E y H1 w Hw.
assume Hw1 Hw2 Hw3.
claim L1: SNoLev y c= SNoLev w /\ SNoEq_ (SNoLev y) y w.
{ apply H5 w Hw1.
  - let w'. assume Hw': w' :e L.
    prove w' < w.
    apply SNoLtLe_or w' w (HL w' Hw') Hw1.
    + assume H6. exact H6.
    + assume H6: w <= w'. apply HC. witness w'. apply andI.
      * exact Hw'.
      * exact H6.
  - let z. assume Hz: z :e R.
    prove w < z.
    apply SNoLt_tra w y z Hw1 H1 (HR z Hz) Hw3.
    prove y < z.
    exact H4 z Hz.
}
apply In_irref (SNoLev w).
prove SNoLev w :e SNoLev w.
apply andEL (SNoLev y c= SNoLev w) (SNoEq_ (SNoLev y) y w) L1.
prove SNoLev w :e SNoLev y.
exact Hw2.
Qed.

Theorem SNoR_SNoCutP_ex: forall L R, SNoCutP L R -> forall z :e SNoR (SNoCut L R), exists z' :e R, z' <= z.
let L R. assume HLR.
set y := SNoCut L R.
let z.
assume Hz: z :e SNoR y.
apply dneg.
assume HC: ~exists z' :e R, z' <= z.
apply HLR.
assume H. apply H.
assume HL HR HLR'.
apply SNoCutP_SNoCut_impred L R HLR.
assume H1: SNo y.
assume H2: SNoLev y :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume H3: forall w :e L, w < y.
assume H4: forall z :e R, y < z.
assume H5: forall u, SNo u -> (forall w :e L, w < u) -> (forall z :e R, u < z) -> SNoLev y c= SNoLev u /\ SNoEq_ (SNoLev y) y u.
apply SNoR_E y H1 z Hz.
assume Hz1 Hz2 Hz3.
claim L1: SNoLev y c= SNoLev z /\ SNoEq_ (SNoLev y) y z.
{ apply H5 z Hz1.
  - let w. assume Hw: w :e L.
    prove w < z.
    apply SNoLt_tra w y z (HL w Hw) H1 Hz1.
    + prove w < y. exact H3 w Hw.
    + prove y < z. exact Hz3.
  - let z'. assume Hz': z' :e R.
    prove z < z'.
    apply SNoLtLe_or z z' Hz1 (HR z' Hz').
    + assume H6. exact H6.
    + assume H6: z' <= z. apply HC. witness z'. apply andI.
      * exact Hz'.
      * exact H6.
}
apply In_irref (SNoLev z).
prove SNoLev z :e SNoLev z.
apply andEL (SNoLev y c= SNoLev z) (SNoEq_ (SNoLev y) y z) L1.
prove SNoLev z :e SNoLev y.
exact Hz2.
Qed.

Theorem ordinal_SNo_ : forall alpha, ordinal alpha -> SNo_ alpha alpha.
let alpha.
assume Ha: ordinal alpha.
prove alpha c= SNoElts_ alpha
   /\ forall beta :e alpha, exactly1of2 (beta ' :e alpha) (beta :e alpha).
apply andI.
- prove alpha c= SNoElts_ alpha.
  let beta. assume Hb: beta :e alpha.
  prove beta :e alpha :\/: {beta '|beta :e alpha}.
  apply binunionI1.
  exact Hb.
- prove forall beta :e alpha, exactly1of2 (beta ' :e alpha) (beta :e alpha).
  let beta. assume Hb: beta :e alpha.
  apply exactly1of2_I2.
  + prove beta ' /:e alpha.
    assume H1: beta ' :e alpha.
    prove False.
    apply tagged_not_ordinal beta.
    prove ordinal (beta ').
    exact ordinal_Hered alpha Ha (beta ') H1.
  + prove beta :e alpha. exact Hb.
Qed.

Theorem ordinal_SNo : forall alpha, ordinal alpha -> SNo alpha.
let alpha.
assume Ha: ordinal alpha.
prove exists beta, ordinal beta /\ SNo_ beta alpha.
witness alpha. apply andI.
- exact Ha.
- exact ordinal_SNo_ alpha Ha.
Qed.

Theorem ordinal_SNoLev : forall alpha, ordinal alpha -> SNoLev alpha = alpha.
let alpha.
assume Ha: ordinal alpha.
apply SNoLev_prop alpha (ordinal_SNo alpha Ha).
assume H1: ordinal (SNoLev alpha).
assume H2: SNo_ (SNoLev alpha) alpha.
exact SNoLev_uniq alpha (SNoLev alpha) alpha H1 Ha H2 (ordinal_SNo_ alpha Ha).
Qed.

Theorem ordinal_SNoLev_max : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e alpha -> z < alpha.
let alpha.
assume Ha: ordinal alpha.
let z.
assume Hz: SNo z.
assume Hz2: SNoLev z :e alpha.
claim La1: SNo alpha.
{ exact ordinal_SNo alpha Ha. }
claim La2: SNoLev alpha = alpha.
{ exact ordinal_SNoLev alpha Ha. }
prove z < alpha.
apply SNoLt_trichotomy_or z alpha Hz (ordinal_SNo alpha Ha).
assume H1. apply H1.
- assume H1: z < alpha. exact H1.
- assume H1: z = alpha.
  prove False. apply In_irref alpha.
  rewrite <- La2 at 1.
  prove SNoLev alpha :e alpha.
  rewrite <- H1 at 1.
  prove SNoLev z :e alpha.
  exact Hz2.
- assume H1: alpha < z.
  prove False.
  apply SNoLtE alpha z La1 Hz H1.
  + let w.
    rewrite La2.
    assume Hw: SNo w.
    assume H2: SNoLev w :e alpha :/\: SNoLev z.
    assume H3: SNoEq_ (SNoLev w) w alpha.
    assume H4: SNoEq_ (SNoLev w) w z.
    assume H5: alpha < w.
    assume H6: w < z.
    assume H7: SNoLev w /:e alpha.
    prove False.
    apply H7.
    exact binintersectE1 alpha (SNoLev z) (SNoLev w) H2.
  + rewrite La2.
    assume H2: alpha :e SNoLev z.
    prove False.
    exact In_no2cycle alpha (SNoLev z) H2 Hz2.
  + rewrite La2.
    assume H2: SNoLev z :e alpha.
    assume H3: SNoEq_ (SNoLev z) alpha z.
    assume H4: SNoLev z /:e alpha.
    exact H4 H2.
Qed.

Theorem ordinal_SNoL : forall alpha, ordinal alpha -> SNoL alpha = SNoS_ alpha.
let alpha.
assume Ha: ordinal alpha.
claim La1: SNo alpha.
{ exact ordinal_SNo alpha Ha. }
claim La2: SNoLev alpha = alpha.
{ exact ordinal_SNoLev alpha Ha. }
apply set_ext.
- let x. assume Hx: x :e SNoL alpha.
  apply SNoL_E alpha La1 x Hx.
  assume Hx1: SNo x.
  assume Hx2: SNoLev x :e SNoLev alpha.
  assume Hx3: x < alpha.
  prove x :e SNoS_ alpha.
  rewrite <- La2.
  prove x :e SNoS_ (SNoLev alpha).
  apply SNoS_I2 x alpha Hx1 La1.
  prove SNoLev x :e SNoLev alpha.
  exact Hx2.
- let x. assume Hx: x :e SNoS_ alpha.
  apply SNoS_E2 alpha Ha x Hx.
  assume Hx1: SNoLev x :e alpha.
  assume Hx2: ordinal (SNoLev x).
  assume Hx3: SNo x.
  assume Hx4: SNo_ (SNoLev x) x.
  prove x :e SNoL alpha.
  apply SNoL_I alpha La1 x Hx3.
  + prove SNoLev x :e SNoLev alpha. rewrite La2. exact Hx1.
  + prove x < alpha.
    exact ordinal_SNoLev_max alpha Ha x Hx3 Hx1.
Qed.

Theorem ordinal_SNoR : forall alpha, ordinal alpha -> SNoR alpha = Empty.
let alpha.
assume Ha: ordinal alpha.
claim La1: SNo alpha.
{ exact ordinal_SNo alpha Ha. }
claim La2: SNoLev alpha = alpha.
{ exact ordinal_SNoLev alpha Ha. }
apply Empty_Subq_eq.
let x. assume Hx: x :e SNoR alpha.
apply SNoR_E alpha La1 x Hx.
assume Hx1: SNo x.
rewrite La2.
assume Hx2: SNoLev x :e alpha.
assume Hx3: alpha < x.
prove False.
apply SNoLt_irref x.
apply SNoLt_tra x alpha x Hx1 La1 Hx1.
- prove x < alpha.
  exact ordinal_SNoLev_max alpha Ha x Hx1 Hx2.
- prove alpha < x. exact Hx3.
Qed.

Theorem nat_p_SNo: forall n, nat_p n -> SNo n.
let n. assume Hn.
apply ordinal_SNo.
prove ordinal n.
apply nat_p_ordinal.
exact Hn.
Qed.

Theorem omega_SNo: forall n :e omega, SNo n.
let n. assume Hn.
apply nat_p_SNo.
apply omega_nat_p.
exact Hn.
Qed.

Theorem omega_SNoS_omega : omega c= SNoS_ omega.
let n. assume Hn: n :e omega.
apply SNoS_I omega omega_ordinal n n.
- exact Hn.
- prove SNo_ n n. rewrite <- ordinal_SNoLev n (nat_p_ordinal n (omega_nat_p n Hn)) at 1.
  prove SNo_ (SNoLev n) n. apply SNoLev_. apply omega_SNo. exact Hn.
Qed.

Theorem ordinal_In_SNoLt : forall alpha, ordinal alpha -> forall beta :e alpha, beta < alpha.
let alpha.
assume Ha: ordinal alpha.
let beta.
assume Hb: beta :e alpha.
claim Lb: ordinal beta.
{ exact ordinal_Hered alpha Ha beta Hb. }
claim Lb1: SNo beta.
{ exact ordinal_SNo beta Lb. }
claim Lb2: SNoLev beta = beta.
{ exact ordinal_SNoLev beta Lb. }
apply ordinal_SNoLev_max alpha Ha beta Lb1.
prove SNoLev beta :e alpha.
rewrite Lb2. exact Hb.
Qed.

Theorem ordinal_SNoLev_max_2 : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e ordsucc alpha -> z <= alpha.
let alpha.
assume Ha: ordinal alpha.
apply Ha. assume Ha1 _.
let z.
assume Hz: SNo z.
assume Hz2: SNoLev z :e ordsucc alpha.
claim La1: SNo alpha.
{ exact ordinal_SNo alpha Ha. }
claim La2: SNoLev alpha = alpha.
{ exact ordinal_SNoLev alpha Ha. }
apply ordsuccE alpha (SNoLev z) Hz2.
- assume Hz3: SNoLev z :e alpha.
  prove z <= alpha.
  apply SNoLtLe.
  prove z < alpha.
  exact ordinal_SNoLev_max alpha Ha z Hz Hz3.
- assume Hz3: SNoLev z = alpha.
  apply dneg.
  assume H1: ~(z <= alpha).
  claim L1: forall beta, ordinal beta -> beta :e alpha -> beta :e z.
  { apply ordinal_ind.
    let beta.
    assume Hb: ordinal beta.
    assume IH: forall gamma :e beta, gamma :e alpha -> gamma :e z.
    assume Hb2: beta :e alpha.
    apply dneg.
    assume H2: beta /:e z.
    apply H1.
    apply SNoLtLe.
    prove z < alpha.
    claim Lb1: SNo beta.
    { exact ordinal_SNo beta Hb. }
    claim Lb2: SNoLev beta = beta.
    { exact ordinal_SNoLev beta Hb. }
    apply SNoLt_tra z beta alpha Hz Lb1 La1.
    - prove z < beta. apply SNoLtI3.
      + prove SNoLev beta :e SNoLev z.
        rewrite Lb2. rewrite Hz3.
        prove beta :e alpha.
        exact Hb2.
      + prove SNoEq_ (SNoLev beta) z beta.
        rewrite Lb2.
        let gamma. assume Hc: gamma :e beta.
        prove gamma :e z <-> gamma :e beta.
        apply iffI.
        * assume _. exact Hc.
        * assume _.
          prove gamma :e z.
          apply IH gamma Hc.
          prove gamma :e alpha.
          exact Ha1 beta Hb2 gamma Hc.
      + prove SNoLev beta /:e z.
        rewrite Lb2. prove beta /:e z. exact H2.
    - prove beta < alpha.
      exact ordinal_In_SNoLt alpha Ha beta Hb2.
  }
  claim L2: alpha c= z.
  { let beta. assume Hb: beta :e alpha.
    exact L1 beta (ordinal_Hered alpha Ha beta Hb) Hb.
  }
  claim L3: z = alpha.
  { apply SNo_eq z alpha Hz La1.
    - prove SNoLev z = SNoLev alpha. rewrite La2. exact Hz3.
    - prove SNoEq_ (SNoLev z) z alpha.
      rewrite Hz3.
      let beta. assume Hb: beta :e alpha.
      prove beta :e z <-> beta :e alpha.
      apply iffI.
      + assume _. exact Hb.
      + assume _. exact L2 beta Hb.
  }
  apply H1.
  prove z <= alpha.
  rewrite L3.
  prove alpha <= alpha.
  apply SNoLe_ref.
Qed.

Theorem ordinal_Subq_SNoLe : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta -> alpha <= beta.
let alpha beta. assume Ha Hb Hab.
claim L1: alpha :e ordsucc beta.
{ apply ordinal_In_Or_Subq alpha beta Ha Hb.
  - assume H1: alpha :e beta. apply ordsuccI1. exact H1.
  - assume H1: beta c= alpha.
    claim L1a: alpha = beta.
    { apply set_ext.
      - exact Hab.
      - exact H1.
    }
    rewrite L1a. apply ordsuccI2.
}
claim La1: SNo alpha.
{ exact ordinal_SNo alpha Ha. }
claim La2: SNoLev alpha = alpha.
{ exact ordinal_SNoLev alpha Ha. }
apply ordinal_SNoLev_max_2 beta Hb alpha La1.
prove SNoLev alpha :e ordsucc beta.
rewrite La2. exact L1.
Qed.

Theorem ordinal_SNoLt_In : forall alpha beta, ordinal alpha -> ordinal beta -> alpha < beta -> alpha :e beta.
let alpha beta. assume Ha Hb.
assume H1.
apply ordinal_In_Or_Subq alpha beta Ha Hb.
- assume H2. exact H2.
- assume H2: beta c= alpha.
  prove False. apply SNoLt_irref alpha.
  prove alpha < alpha.
  apply SNoLtLe_tra alpha beta alpha (ordinal_SNo alpha Ha) (ordinal_SNo beta Hb) (ordinal_SNo alpha Ha) H1.
  prove beta <= alpha.
  exact ordinal_Subq_SNoLe beta alpha Hb Ha H2.
Qed.

Theorem omega_nonneg : forall m :e omega, 0 <= m.
let m. assume Hm.
apply ordinal_Subq_SNoLe 0 m ordinal_Empty (nat_p_ordinal m (omega_nat_p m Hm)).
prove 0 c= m. apply Subq_Empty.
Qed.

Theorem SNo_0 : SNo 0.
exact ordinal_SNo 0 ordinal_Empty.
Qed.

Theorem SNo_1 : SNo 1.
apply ordinal_SNo. apply nat_p_ordinal. exact nat_1.
Qed.

Theorem SNo_2 : SNo 2.
apply ordinal_SNo. apply nat_p_ordinal. exact nat_2.
Qed.

Theorem SNoLev_0 : SNoLev 0 = 0.
exact ordinal_SNoLev 0 ordinal_Empty.
Qed.

Theorem SNoCut_0_0: SNoCut 0 0 = 0.
apply SNoCutP_SNoCut_impred 0 0 SNoCutP_0_0.
assume H1: SNo (SNoCut 0 0).
rewrite famunion_Empty (fun x => ordsucc (SNoLev x)).
rewrite binunion_idl 0.
assume H2: SNoLev (SNoCut 0 0) :e 1.
assume _ _ _.
claim L1: SNoLev (SNoCut 0 0) = 0.
{ apply cases_1 (SNoLev (SNoCut 0 0)) H2 (fun u => u = 0).
  prove 0 = 0.
  reflexivity.
}
apply SNo_eq (SNoCut 0 0) 0 H1 SNo_0.
- prove SNoLev (SNoCut 0 0) = SNoLev 0.
  transitivity 0.
  + exact L1.
  + symmetry. exact SNoLev_0.
- prove SNoEq_ (SNoLev (SNoCut 0 0)) (SNoCut 0 0) 0.
  rewrite L1.
  prove SNoEq_ 0 (SNoCut 0 0) 0.
  apply SNoEq_I.
  let beta. assume Hb: beta :e 0.
  prove False. exact EmptyE beta Hb.
Qed.

Theorem SNoL_0 : SNoL 0 = 0.
apply Empty_Subq_eq.
prove SNoL 0 c= Empty.
let z. assume Hz: z :e SNoL 0.
claim Lz: z :e SNoS_ 0.
{ rewrite <- SNoLev_0.
  prove z :e SNoS_ (SNoLev 0).
  exact SNoL_SNoS_ 0 z Hz.
}
apply SNoS_E2 0 ordinal_Empty z Lz.
assume Hz1: SNoLev z :e 0.
prove False.
exact EmptyE (SNoLev z) Hz1.
Qed.

Theorem SNoR_0 : SNoR 0 = 0.
apply Empty_Subq_eq.
prove SNoR 0 c= Empty.
let z. assume Hz: z :e SNoR 0.
claim Lz: z :e SNoS_ 0.
{ rewrite <- SNoLev_0.
  prove z :e SNoS_ (SNoLev 0).
  exact SNoR_SNoS_ 0 z Hz.
}
apply SNoS_E2 0 ordinal_Empty z Lz.
assume Hz1: SNoLev z :e 0.
prove False.
exact EmptyE (SNoLev z) Hz1.
Qed.

Theorem SNoL_1 : SNoL 1 = 1.
apply set_ext.
- let x. assume Hx: x :e SNoL 1.
  prove x :e 1.
  apply SNoL_E 1 SNo_1 x Hx.
  assume Hxa: SNo x.
  rewrite ordinal_SNoLev 1 (nat_p_ordinal 1 nat_1).
  assume Hxb: SNoLev x :e 1.
  assume _.
  claim L1: 0 = x.
  { apply SNo_eq 0 x SNo_0 Hxa.
    - prove SNoLev 0 = SNoLev x.
      rewrite SNoLev_0.
      prove 0 = SNoLev x.
      apply cases_1 (SNoLev x) Hxb (fun u => 0 = u).
      prove 0 = 0.
      reflexivity.
    - prove SNoEq_ (SNoLev 0) 0 x.
      rewrite SNoLev_0.
      prove SNoEq_ 0 0 x.
      apply SNoEq_I. let beta. assume Hb: beta :e 0.
      prove False. exact EmptyE beta Hb.
  }
  rewrite <- L1. exact In_0_1.
- let x. assume Hx: x :e 1.
  prove x :e SNoL 1.
  apply cases_1 x Hx (fun x => x :e SNoL 1).
  prove 0 :e SNoL 1.
  apply SNoL_I 1 SNo_1 0 SNo_0.
  + prove SNoLev 0 :e SNoLev 1. rewrite SNoLev_0.
    rewrite ordinal_SNoLev 1 (nat_p_ordinal 1 nat_1).
    exact In_0_1.
  + prove 0 < 1.
    exact ordinal_In_SNoLt 1 (nat_p_ordinal 1 nat_1) 0 In_0_1.
Qed.

Theorem SNoR_1 : SNoR 1 = 0.
exact ordinal_SNoR 1 (nat_p_ordinal 1 nat_1).
Qed.

Theorem SNo_max_SNoLev : forall x, SNo x -> (forall y :e SNoS_ (SNoLev x), y < x) -> SNoLev x = x.
let x. assume Hx: SNo x.
assume H2: forall y :e SNoS_ (SNoLev x), y < x.
claim LLx1: ordinal (SNoLev x).
{ exact SNoLev_ordinal x Hx. }
claim LLx2: SNo (SNoLev x).
{ exact ordinal_SNo (SNoLev x) LLx1. }
claim L3: x <= SNoLev x.
{ apply ordinal_SNoLev_max_2 (SNoLev x) LLx1 x Hx.
  prove SNoLev x :e ordsucc (SNoLev x).
  apply ordsuccI2.
}
apply SNoLeE x (SNoLev x) Hx LLx2 L3.
- assume H3: x < SNoLev x.
  prove False.
  apply SNoLtE x (SNoLev x) Hx LLx2 H3.
  + let z. assume Hz: SNo z. 
    assume Hz1: SNoLev z :e SNoLev x :/\: SNoLev (SNoLev x).
    assume Hz2: SNoEq_ (SNoLev z) z x.
    assume Hz3: SNoEq_ (SNoLev z) z (SNoLev x).
    assume Hz4: x < z.
    assume Hz5: z < SNoLev x.
    assume Hz6: SNoLev z /:e x.
    assume Hz7: SNoLev z :e SNoLev x.
    apply SNoLt_irref z.
    apply SNoLt_tra z x z Hz Hx Hz.
    * { prove z < x.
        apply H2.
        prove z :e SNoS_ (SNoLev x).
        apply SNoS_I (SNoLev x) LLx1 z (SNoLev z).
        - prove SNoLev z :e SNoLev x. exact Hz7.
        - prove SNo_ (SNoLev z) z. apply SNoLev_. exact Hz.
      }
    * prove x < z. exact Hz4.
  + assume H4: SNoLev x :e SNoLev (SNoLev x).
    prove False.
    apply In_irref (SNoLev x).
    rewrite <- ordinal_SNoLev (SNoLev x) LLx1 at 2.
    exact H4.
  + assume H4: SNoLev (SNoLev x) :e SNoLev x.
    prove False.
    apply In_irref (SNoLev x).
    rewrite <- ordinal_SNoLev (SNoLev x) LLx1 at 1.
    exact H4.
- assume H3: x = SNoLev x. symmetry. exact H3.
Qed.

Theorem SNo_max_ordinal : forall x, SNo x -> (forall y :e SNoS_ (SNoLev x), y < x) -> ordinal x.
let x. assume Hx: SNo x.
assume H2: forall y :e SNoS_ (SNoLev x), y < x.
prove ordinal x.
rewrite <- SNo_max_SNoLev x Hx H2.
prove ordinal (SNoLev x).
exact SNoLev_ordinal x Hx.
Qed.

Theorem pos_low_eq_one : forall x, SNo x -> 0 < x -> SNoLev x c= 1 -> x = 1.
let x. assume Hx Hxpos Hxlow.
apply SNoLtE 0 x SNo_0 Hx Hxpos.
- let y.
  assume Hy1: SNo y.
  assume Hy2: SNoLev y :e SNoLev 0 :/\: SNoLev x.
  prove False.
  apply EmptyE (SNoLev y).
  prove SNoLev y :e 0.
  rewrite <- ordinal_SNoLev 0 ordinal_Empty.
  prove SNoLev y :e SNoLev 0.
  exact binintersectE1 (SNoLev 0) (SNoLev x) (SNoLev y) Hy2.
- rewrite ordinal_SNoLev 0 ordinal_Empty.
  assume H1: 0 :e SNoLev x.
  assume _.
  assume H2: 0 :e x.
  claim L1: SNoLev x = 1.
  { apply set_ext.
    - exact Hxlow.
    - let n. assume Hn: n :e 1.
      apply cases_1 n Hn.
      prove 0 :e SNoLev x.
      exact H1.
  }
  apply SNo_eq x 1 Hx SNo_1.
  + prove SNoLev x = SNoLev 1.
    rewrite ordinal_SNoLev 1 (nat_p_ordinal 1 nat_1).
    prove SNoLev x = 1.
    exact L1.
  + prove SNoEq_ (SNoLev x) x 1. rewrite L1.
    prove SNoEq_ 1 x 1.
    let n. assume Hn: n :e 1.
    prove n :e x <-> n :e 1.
    apply cases_1 n Hn (fun n => n :e x <-> n :e 1).
    prove 0 :e x <-> 0 :e 1.
    apply iffI.
    * assume _. exact In_0_1.
    * assume _. exact H2.
- assume H1: SNoLev x :e SNoLev 0.
  prove False.
  apply EmptyE (SNoLev x).
  prove SNoLev x :e 0.
  rewrite <- ordinal_SNoLev 0 ordinal_Empty.
  prove SNoLev x :e SNoLev 0.
  exact H1.
Qed.

Definition SNo_extend0 : set -> set := fun x => PSNo (ordsucc (SNoLev x)) (fun delta => delta :e x /\ delta <> SNoLev x).
Definition SNo_extend1 : set -> set := fun x => PSNo (ordsucc (SNoLev x)) (fun delta => delta :e x \/ delta = SNoLev x).

Theorem SNo_extend0_SNo_ : forall x, SNo x -> SNo_ (ordsucc (SNoLev x)) (SNo_extend0 x).
let x. assume Hx: SNo x.
set alpha := SNoLev x.
claim La: ordinal alpha.
{ exact SNoLev_ordinal x Hx. }
exact SNo_PSNo (ordsucc alpha) (ordinal_ordsucc alpha La) (fun delta => delta :e x /\ delta <> alpha).
Qed.

Theorem SNo_extend1_SNo_ : forall x, SNo x -> SNo_ (ordsucc (SNoLev x)) (SNo_extend1 x).
let x. assume Hx: SNo x.
set alpha := SNoLev x.
claim La: ordinal alpha.
{ exact SNoLev_ordinal x Hx. }
exact SNo_PSNo (ordsucc alpha) (ordinal_ordsucc alpha La) (fun delta => delta :e x \/ delta = alpha).
Qed.

Theorem SNo_extend0_SNo : forall x, SNo x -> SNo (SNo_extend0 x).
let x. assume Hx.
exact SNo_SNo (ordsucc (SNoLev x))
              (ordinal_ordsucc (SNoLev x) (SNoLev_ordinal x Hx))
              (SNo_extend0 x) (SNo_extend0_SNo_ x Hx).
Qed.

Theorem SNo_extend1_SNo : forall x, SNo x -> SNo (SNo_extend1 x).
let x. assume Hx.
exact SNo_SNo (ordsucc (SNoLev x))
              (ordinal_ordsucc (SNoLev x) (SNoLev_ordinal x Hx))
              (SNo_extend1 x) (SNo_extend1_SNo_ x Hx).
Qed.

Theorem SNo_extend0_SNoLev : forall x, SNo x -> SNoLev (SNo_extend0 x) = ordsucc (SNoLev x).
let x. assume Hx.
exact SNoLev_uniq2 (ordsucc (SNoLev x))
                   (ordinal_ordsucc (SNoLev x) (SNoLev_ordinal x Hx))
                   (SNo_extend0 x) (SNo_extend0_SNo_ x Hx).
Qed.

Theorem SNo_extend1_SNoLev : forall x, SNo x -> SNoLev (SNo_extend1 x) = ordsucc (SNoLev x).
let x. assume Hx.
exact SNoLev_uniq2 (ordsucc (SNoLev x))
                   (ordinal_ordsucc (SNoLev x) (SNoLev_ordinal x Hx))
                   (SNo_extend1 x) (SNo_extend1_SNo_ x Hx).
Qed.

Theorem SNo_extend0_nIn : forall x, SNo x -> SNoLev x /:e SNo_extend0 x.
let x.
assume Hx: SNo x.
set alpha := SNoLev x.
assume H2: alpha :e PSNo (ordsucc alpha) (fun delta => delta :e x /\ delta <> alpha).
set p : set -> prop := fun delta => delta :e x /\ delta <> alpha.
apply binunionE {beta :e ordsucc alpha|p beta} {beta '|beta :e ordsucc alpha, ~p beta} alpha H2.
- assume H3: alpha :e {beta :e ordsucc alpha|p beta}.
  apply SepE2 (ordsucc alpha) p alpha H3.
  assume _.
  assume H4: alpha <> alpha. apply H4. reflexivity.
- assume H3: alpha :e {beta '|beta :e ordsucc alpha, ~p beta}.
  apply ReplSepE_impred (ordsucc alpha) (fun beta => ~p beta) (fun x => x ') alpha H3.
  let beta. assume Hb: beta :e ordsucc alpha.
  assume H4: ~p beta.
  assume H5: alpha = beta '.
  apply tagged_not_ordinal beta.
  prove ordinal (beta ').
  rewrite <- H5.
  prove ordinal alpha.
  exact SNoLev_ordinal x Hx.
Qed.

Theorem SNo_extend1_In : forall x, SNo x -> SNoLev x :e SNo_extend1 x.
let x.
assume Hx: SNo x.
set alpha := SNoLev x.
set p : set -> prop := fun delta => delta :e x \/ delta = alpha.
prove alpha :e {beta :e ordsucc alpha|p beta} :\/: {beta '|beta :e ordsucc alpha, ~p beta}.
apply binunionI1.
apply SepI.
- prove alpha :e ordsucc alpha. apply ordsuccI2.
- prove alpha :e x \/ alpha = alpha. apply orIR. reflexivity.
Qed.

Theorem SNo_extend0_SNoEq : forall x, SNo x -> SNoEq_ (SNoLev x) (SNo_extend0 x) x.
let x.
assume Hx: SNo x.
set alpha := SNoLev x.
claim La: ordinal alpha.
{ exact SNoLev_ordinal x Hx. }
prove SNoEq_ alpha (SNo_extend0 x) x.
set p : set -> prop := fun beta => beta :e x.
set q : set -> prop := fun beta => beta :e x /\ beta <> alpha.
prove PNoEq_ alpha (fun beta => beta :e PSNo (ordsucc alpha) q) p.
apply PNoEq_tra_ alpha
    (fun beta => beta :e PSNo (ordsucc alpha) q)
    q p.
- prove PNoEq_ alpha (fun beta => beta :e PSNo (ordsucc alpha) q) q.
  apply PNoEq_antimon_ (fun beta => beta :e PSNo (ordsucc alpha) q) q
                       (ordsucc alpha) (ordinal_ordsucc alpha La)
                       alpha (ordsuccI2 alpha).
  prove PNoEq_ (ordsucc alpha) (fun beta => beta :e PSNo (ordsucc alpha) q) q.
  exact PNoEq_PSNo (ordsucc alpha) (ordinal_ordsucc alpha La) q.
- prove PNoEq_ alpha q p.
  apply PNoEq_sym_.
  exact PNo_extend0_eq alpha p.
Qed.

Theorem SNo_extend1_SNoEq : forall x, SNo x -> SNoEq_ (SNoLev x) (SNo_extend1 x) x.
let x.
assume Hx: SNo x.
set alpha := SNoLev x.
claim La: ordinal alpha.
{ exact SNoLev_ordinal x Hx. }
prove SNoEq_ alpha (SNo_extend1 x) x.
set p : set -> prop := fun beta => beta :e x.
set q : set -> prop := fun beta => beta :e x \/ beta = alpha.
prove PNoEq_ alpha (fun beta => beta :e PSNo (ordsucc alpha) q) p.
apply PNoEq_tra_ alpha
    (fun beta => beta :e PSNo (ordsucc alpha) q)
    q p.
- prove PNoEq_ alpha (fun beta => beta :e PSNo (ordsucc alpha) q) q.
  apply PNoEq_antimon_ (fun beta => beta :e PSNo (ordsucc alpha) q) q
                       (ordsucc alpha) (ordinal_ordsucc alpha La)
                       alpha (ordsuccI2 alpha).
  prove PNoEq_ (ordsucc alpha) (fun beta => beta :e PSNo (ordsucc alpha) q) q.
  exact PNoEq_PSNo (ordsucc alpha) (ordinal_ordsucc alpha La) q.
- prove PNoEq_ alpha q p.
  apply PNoEq_sym_.
  exact PNo_extend1_eq alpha p.
Qed.

Theorem SNoLev_0_eq_0 : forall x, SNo x -> SNoLev x = 0 -> x = 0.
let x. assume Hx Hx0.
apply SNo_eq x 0 Hx SNo_0.
- prove SNoLev x = SNoLev 0. rewrite SNoLev_0. exact Hx0.
- prove SNoEq_ (SNoLev x) x 0.
  rewrite Hx0.
  let alpha. assume Ha: alpha :e 0.
  prove False. exact EmptyE alpha Ha.
Qed.

(** eps_ n is the Surreal Number 1/2^n, without needing to define division or exponents first **)
Definition eps_ : set -> set := fun n => {0} :\/: {(ordsucc m) ' | m :e n}.

Theorem eps_ordinal_In_eq_0 : forall n alpha, ordinal alpha -> alpha :e eps_ n -> alpha = 0.
let n alpha. assume Ha.
assume H1: alpha :e {0} :\/: {(ordsucc m) ' | m :e n}.
apply binunionE {0} {(ordsucc m) ' | m :e n} alpha H1.
- assume H2: alpha :e {0}. exact SingE 0 alpha H2.
- assume H2: alpha :e {(ordsucc m) ' | m :e n}. prove False.
  apply ReplE_impred n (fun m => (ordsucc m) ') alpha H2.
  let m. assume Hm: m :e n.
  assume H3: alpha = (ordsucc m) '.
  apply tagged_not_ordinal (ordsucc m).
  prove ordinal ((ordsucc m) ').
  rewrite <- H3.
  exact Ha.
Qed.

Theorem eps_0_1 : eps_ 0 = 1.
apply set_ext.
- let x. assume Hx: x :e {0} :\/: {(ordsucc m) ' | m :e 0}.
  apply binunionE {0} {(ordsucc m) ' | m :e 0} x Hx.
  + assume Hx: x :e {0}. rewrite SingE 0 x Hx.
    prove 0 :e 1. exact In_0_1.
  + assume Hx: x :e {(ordsucc m) ' | m :e 0}.
    apply ReplE_impred 0 (fun m => (ordsucc m) ') x Hx.
    let m. assume Hm: m :e 0. prove False. exact EmptyE m Hm.
- let x. assume Hx: x :e 1.
  apply cases_1 x Hx (fun x => x :e eps_ 0).
  prove 0 :e {0} :\/: {(ordsucc m) ' | m :e 0}.
  apply binunionI1. apply SingI.
Qed.

Theorem SNo__eps_ : forall n :e omega, SNo_ (ordsucc n) (eps_ n).
let n. assume Hn.
claim Ln: nat_p n.
{ exact omega_nat_p n Hn. }
prove eps_ n c= SNoElts_ (ordsucc n)
   /\ forall m :e ordsucc n, exactly1of2 (m ' :e eps_ n) (m :e eps_ n).
apply andI.
- let x. assume Hx: x :e {0} :\/: {(ordsucc m) ' | m :e n}.
  apply binunionE {0} {(ordsucc m) ' | m :e n} x Hx.
  + assume Hx: x :e {0}. rewrite SingE 0 x Hx.
    prove 0 :e SNoElts_ (ordsucc n).
    prove 0 :e ordsucc n :\/: {beta '|beta :e ordsucc n}.
    apply binunionI1.
    prove 0 :e ordsucc n.
    exact nat_0_in_ordsucc n Ln.
  + assume Hx: x :e {(ordsucc m) ' | m :e n}.
    apply ReplE_impred n (fun m => (ordsucc m) ') x Hx.
    let m. assume Hm: m :e n.
    assume Hxm: x = (ordsucc m) '.
    prove x :e SNoElts_ (ordsucc n).
    prove x :e ordsucc n :\/: {beta '|beta :e ordsucc n}.
    apply binunionI2.
    prove x :e {beta '|beta :e ordsucc n}.
    rewrite Hxm.
    prove (ordsucc m) ' :e {beta '|beta :e ordsucc n}.
    exact ReplI (ordsucc n) (fun beta => beta ') (ordsucc m) (nat_ordsucc_in_ordsucc n Ln m Hm).
- let m. assume Hm: m :e ordsucc n.
  claim Lm: nat_p m.
  { exact nat_p_trans (ordsucc n) (nat_ordsucc n Ln) m Hm. }
  apply nat_inv m Lm.
  + assume Hm: m = 0. rewrite Hm.
    apply exactly1of2_I2.
    * { prove 0 ' /:e eps_ n.
        assume H1: 0 ' :e {0} :\/: {(ordsucc m) ' | m :e n}.
        apply binunionE {0} {(ordsucc m) ' | m :e n} (0 ') H1.
        - assume H2: 0 ' :e {0}. apply EmptyE {1}.
          prove {1} :e 0.
          rewrite <- SingE 0 (0 ') H2 at 2.
          prove {1} :e 0 '.
          prove {1} :e 0 :\/: {{1}}.
          apply binunionI2.
          prove {1} :e {{1}}.
          apply SingI.
        - assume H2: 0 ' :e {(ordsucc m) ' | m :e n}.
          apply ReplE_impred n (fun m => (ordsucc m) ') (0 ') H2.
          let m. assume Hm: m :e n.
          assume H3: 0 ' = (ordsucc m) '.
          apply neq_0_ordsucc m.
          prove 0 = ordsucc m.
          apply tagged_eqE_eq.
          + prove ordinal 0. exact ordinal_Empty.
          + prove ordinal (ordsucc m).
            exact (nat_p_ordinal (ordsucc m) (nat_ordsucc m (nat_p_trans n Ln m Hm))).
          + prove 0 ' = (ordsucc m) '. exact H3.
      }
    * prove 0 :e eps_ n.
      prove 0 :e {0} :\/: {(ordsucc m) '|m :e n}.
      apply binunionI1. exact SingI 0.
  + assume H1. apply H1. let k. assume H1. apply H1.
    assume Hk: nat_p k.
    assume Hmk: m = ordsucc k.
    claim Lm: nat_p m.
    { rewrite Hmk. exact nat_ordsucc k Hk. }
    claim LSk: ordsucc k :e ordsucc n.
    { rewrite <- Hmk. exact Hm. }
    claim Lk: k :e n.
    { apply ordsuccE n (ordsucc k) LSk.
      - assume H2: ordsucc k :e n. apply nat_trans n Ln (ordsucc k) H2.
        prove k :e ordsucc k. apply ordsuccI2.
      - assume H2: ordsucc k = n. rewrite <- H2. apply ordsuccI2.
    }
    apply exactly1of2_I1.
    * prove m ' :e eps_ n.
      prove m ' :e {0} :\/: {(ordsucc m) ' | m :e n}.
      apply binunionI2.
      rewrite Hmk.
      prove (ordsucc k) ' :e {(ordsucc m) ' | m :e n}.
      exact ReplI n (fun k => (ordsucc k) ') k Lk.
    * { prove m /:e eps_ n.
        assume H1: m :e {0} :\/: {(ordsucc m) ' | m :e n}.
        apply binunionE {0} {(ordsucc m) ' | m :e n} m H1.
        - assume H2: m :e {0}. apply EmptyE 0.
          prove 0 :e 0. rewrite <- SingE 0 m H2 at 2.
          prove 0 :e m.
          rewrite Hmk.
          exact nat_0_in_ordsucc k Hk.
        - assume H2: m :e {(ordsucc j) ' | j :e n}.
          apply ReplE_impred n (fun j => (ordsucc j) ') m H2.
          let j. assume Hj: j :e n.
          assume Hmj: m = (ordsucc j) '.
          apply tagged_not_ordinal (ordsucc j).
          prove ordinal ((ordsucc j) ').
          rewrite <- Hmj.
          prove ordinal m.
          exact nat_p_ordinal m Lm.
      }
Qed.

Theorem SNo_eps_ : forall n :e omega, SNo (eps_ n).
let n. assume Hn.
claim Ln: nat_p n.
{ exact omega_nat_p n Hn. }
exact SNo_SNo (ordsucc n) (ordinal_ordsucc n (nat_p_ordinal n Ln)) (eps_ n) (SNo__eps_ n Hn).
Qed.

Theorem SNo_eps_1 : SNo (eps_ 1).
exact SNo_eps_ 1 (nat_p_omega 1 nat_1).
Qed.

Theorem SNoLev_eps_ : forall n :e omega, SNoLev (eps_ n) = ordsucc n.
let n. assume Hn.
claim Ln: nat_p n.
{ exact omega_nat_p n Hn. }
apply SNoLev_uniq2 (ordsucc n) (ordinal_ordsucc n (nat_p_ordinal n Ln)) (eps_ n) (SNo__eps_ n Hn).
Qed.

Theorem SNo_eps_SNoS_omega : forall n :e omega, eps_ n :e SNoS_ omega.
let n. assume Hn.
apply SNoS_I omega omega_ordinal (eps_ n) (ordsucc n).
- prove ordsucc n :e omega. exact omega_ordsucc n Hn.
- prove SNo_ (ordsucc n) (eps_ n). exact SNo__eps_ n Hn.
Qed.

Theorem SNo_eps_decr : forall n :e omega, forall m :e n, eps_ n < eps_ m.
let n. assume Hn. let m. assume Hm.
claim Lnn: nat_p n.
{ exact omega_nat_p n Hn. }
claim Lmn: nat_p m.
{ exact nat_p_trans n Lnn m Hm. }
claim Lm: m :e omega.
{ exact nat_p_omega m Lmn. }
apply SNoLtI3.
- prove SNoLev (eps_ m) :e SNoLev (eps_ n).
  rewrite SNoLev_eps_ m Lm.
  rewrite SNoLev_eps_ n Hn.
  prove ordsucc m :e ordsucc n.
  exact nat_ordsucc_in_ordsucc n Lnn m Hm.
- prove SNoEq_ (SNoLev (eps_ m)) (eps_ n) (eps_ m).
  rewrite SNoLev_eps_ m Lm.
  prove SNoEq_ (ordsucc m) (eps_ n) (eps_ m).
  let k. assume Hk: k :e ordsucc m.
  prove k :e eps_ n <-> k :e eps_ m.
  claim Lk: ordinal k.
  { exact nat_p_ordinal k (nat_p_trans (ordsucc m) (nat_ordsucc m Lmn) k Hk). }
  apply iffI.
  + assume H1: k :e eps_ n. rewrite eps_ordinal_In_eq_0 n k Lk H1.
    prove 0 :e eps_ m.
    prove 0 :e {0} :\/: {(ordsucc j) ' | j :e m}.
    apply binunionI1. apply SingI.
  + assume H1: k :e eps_ m. rewrite eps_ordinal_In_eq_0 m k Lk H1.
    prove 0 :e eps_ n.
    prove 0 :e {0} :\/: {(ordsucc j) ' | j :e n}.
    apply binunionI1. apply SingI.
- prove SNoLev (eps_ m) /:e eps_ n.
  rewrite SNoLev_eps_ m Lm.
  assume H1: ordsucc m :e eps_ n.
  apply neq_ordsucc_0 m.
  prove ordsucc m = 0.
  exact eps_ordinal_In_eq_0 n (ordsucc m) (ordinal_ordsucc m (nat_p_ordinal m Lmn)) H1.
Qed.

Theorem SNo_eps_pos : forall n :e omega, 0 < eps_ n.
let n. assume Hn.
apply SNoLtI2 0 (eps_ n).
- prove SNoLev 0 :e SNoLev (eps_ n).
  rewrite SNoLev_0. rewrite SNoLev_eps_ n Hn.
  prove 0 :e ordsucc n. exact nat_0_in_ordsucc n (omega_nat_p n Hn).
- prove SNoEq_ (SNoLev 0) 0 (eps_ n).
  rewrite SNoLev_0.
  let alpha. assume Ha: alpha :e 0.
  prove False. exact EmptyE alpha Ha.
- prove SNoLev 0 :e eps_ n.
  rewrite SNoLev_0.
  prove 0 :e eps_ n.
  prove 0 :e {0} :\/: {(ordsucc m) ' | m :e n}.
  apply binunionI1. apply SingI.
Qed.

Theorem SNo_pos_eps_Lt : forall n, nat_p n -> forall x :e SNoS_ (ordsucc n), 0 < x -> eps_ n < x.
let n. assume Hn: nat_p n.
let x. assume Hx: x :e SNoS_ (ordsucc n).
assume Hxpos: 0 < x.
claim Ln: n :e omega.
{ exact nat_p_omega n Hn. }
apply SNoS_E2 (ordsucc n) (nat_p_ordinal (ordsucc n) (nat_ordsucc n Hn)) x Hx.
assume Hx1: SNoLev x :e ordsucc n.
assume Hx2: ordinal (SNoLev x).
assume Hx3: SNo x.
assume Hx4: SNo_ (SNoLev x) x.
prove eps_ n < x.
apply SNoLt_trichotomy_or_impred (eps_ n) x (SNo_eps_ n Ln) Hx3.
- assume H2: eps_ n < x. exact H2.
- assume H2: eps_ n = x. prove False.
  apply In_irref (ordsucc n).
  rewrite <- SNoLev_eps_ n Ln at 1.
  prove SNoLev (eps_ n) :e ordsucc n.
  rewrite H2. exact Hx1.
- assume H2: x < eps_ n. prove False.
  apply SNoLtE x (eps_ n) Hx3 (SNo_eps_ n Ln) H2.
  + let z.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev x :/\: SNoLev (eps_ n).
    assume Hz3: SNoEq_ (SNoLev z) z x.
    assume Hz4: SNoEq_ (SNoLev z) z (eps_ n).
    assume Hz5: x < z.
    assume Hz6: z < eps_ n.
    assume Hz7: SNoLev z /:e x.
    assume Hz8: SNoLev z :e eps_ n.
    claim Lz0: z = 0.
    { apply SNoLev_0_eq_0 z Hz1. exact eps_ordinal_In_eq_0 n (SNoLev z) (SNoLev_ordinal z Hz1) Hz8. }
    apply SNoLt_irref x.
    prove x < x.
    apply SNoLt_tra x z x Hx3 Hz1 Hx3 Hz5.
    prove z < x. rewrite Lz0. exact Hxpos.
  + assume H1: SNoLev x :e SNoLev (eps_ n).
    assume H2: SNoEq_ (SNoLev x) x (eps_ n).
    assume H3: SNoLev x :e (eps_ n).
    claim Lx0: x = 0.
    { apply SNoLev_0_eq_0 x Hx3. exact eps_ordinal_In_eq_0 n (SNoLev x) Hx2 H3. }
    apply SNoLt_irref x. rewrite Lx0 at 1. exact Hxpos.
  + rewrite SNoLev_eps_ n Ln.
    assume H1: ordsucc n :e SNoLev x. prove False.
    exact In_no2cycle (SNoLev x) (ordsucc n) Hx1 H1.
Qed.

Theorem SNo_pos_eps_Le : forall n, nat_p n -> forall x :e SNoS_ (ordsucc (ordsucc n)), 0 < x -> eps_ n <= x.
let n. assume Hn.
let x. assume Hx: x :e SNoS_ (ordsucc (ordsucc n)).
assume Hxpos: 0 < x.
claim Ln: n :e omega.
{ exact nat_p_omega n Hn. }
apply SNoS_E2 (ordsucc (ordsucc n)) (nat_p_ordinal (ordsucc (ordsucc n)) (nat_ordsucc (ordsucc n) (nat_ordsucc n Hn))) x Hx.
assume Hx1: SNoLev x :e ordsucc (ordsucc n).
assume Hx2: ordinal (SNoLev x).
assume Hx3: SNo x.
assume Hx4: SNo_ (SNoLev x) x.
prove eps_ n <= x.
apply SNoLtLe_or x (eps_ n) Hx3 (SNo_eps_ n Ln).
- assume H2: x < eps_ n. prove False.
  apply SNoLtE x (eps_ n) Hx3 (SNo_eps_ n Ln) H2.
  + let z.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev x :/\: SNoLev (eps_ n).
    assume Hz3: SNoEq_ (SNoLev z) z x.
    assume Hz4: SNoEq_ (SNoLev z) z (eps_ n).
    assume Hz5: x < z.
    assume Hz6: z < eps_ n.
    assume Hz7: SNoLev z /:e x.
    assume Hz8: SNoLev z :e eps_ n.
    claim Lz0: z = 0.
    { apply SNoLev_0_eq_0 z Hz1. exact eps_ordinal_In_eq_0 n (SNoLev z) (SNoLev_ordinal z Hz1) Hz8. }
    apply SNoLt_irref x.
    prove x < x.
    apply SNoLt_tra x z x Hx3 Hz1 Hx3 Hz5.
    prove z < x. rewrite Lz0. exact Hxpos.
  + assume H1: SNoLev x :e SNoLev (eps_ n).
    assume H2: SNoEq_ (SNoLev x) x (eps_ n).
    assume H3: SNoLev x :e (eps_ n).
    claim Lx0: x = 0.
    { apply SNoLev_0_eq_0 x Hx3. exact eps_ordinal_In_eq_0 n (SNoLev x) Hx2 H3. }
    apply SNoLt_irref x. rewrite Lx0 at 1. exact Hxpos.
  + rewrite SNoLev_eps_ n Ln.
    assume H3: ordsucc n :e SNoLev x. prove False.
    apply ordsuccE (ordsucc n) (SNoLev x) Hx1.
    * assume H4: SNoLev x :e ordsucc n.
      exact In_no2cycle (SNoLev x) (ordsucc n) H4 H3.
    * assume H4: SNoLev x = ordsucc n.
      apply In_irref (SNoLev x). rewrite H4 at 1. exact H3.
- assume H2: eps_ n <= x. exact H2.
Qed.

Theorem eps_SNo_eq : forall n, nat_p n -> forall x :e SNoS_ (ordsucc n), 0 < x -> SNoEq_ (SNoLev x) (eps_ n) x -> exists m :e n, x = eps_ m.
let n. assume Hn.
let x.
assume Hx1: x :e SNoS_ (ordsucc n).
assume Hx2: 0 < x.
assume Hx3: SNoEq_ (SNoLev x) (eps_ n) x.
apply SNoS_E2 (ordsucc n) (nat_p_ordinal (ordsucc n) (nat_ordsucc n Hn)) x Hx1.
assume Hx1a: SNoLev x :e ordsucc n.
assume Hx1b: ordinal (SNoLev x).
assume Hx1c: SNo x.
assume Hx1d: SNo_ (SNoLev x) x.
claim L1: nat_p (SNoLev x).
{ apply nat_p_trans (ordsucc n) (nat_ordsucc n Hn).
  prove SNoLev x :e ordsucc n. exact Hx1a.
}
apply nat_inv (SNoLev x) L1.
- assume H1: SNoLev x = 0. prove False.
  claim L2: x = 0.
  { exact SNoLev_0_eq_0 x Hx1c H1. }
  apply SNoLt_irref x.
  rewrite L2 at 1.
  exact Hx2.
- assume H1. apply H1. let m. assume H1. apply H1.
  assume Hm1: nat_p m.
  assume Hm2: SNoLev x = ordsucc m.
  witness m. apply andI.
  + prove m :e n.
    apply nat_ordsucc_trans n Hn (SNoLev x) Hx1a.
    prove m :e SNoLev x. rewrite Hm2. apply ordsuccI2.
  + prove x = eps_ m.
    apply SNo_eq x (eps_ m) Hx1c (SNo_eps_ m (nat_p_omega m Hm1)).
    * prove SNoLev x = SNoLev (eps_ m).
      rewrite SNoLev_eps_ m (nat_p_omega m Hm1).
      exact Hm2.
    * { prove SNoEq_ (SNoLev x) x (eps_ m).
        apply SNoEq_tra_ (SNoLev x) x (eps_ n) (eps_ m).
        - apply SNoEq_sym_. exact Hx3.
        - prove SNoEq_ (SNoLev x) (eps_ n) (eps_ m).
          rewrite Hm2.
          prove SNoEq_ (ordsucc m) (eps_ n) (eps_ m).
          apply SNoEq_I.
          let k. assume Hk: k :e ordsucc m.
          claim L3: ordinal k.
          { exact nat_p_ordinal k (nat_p_trans (ordsucc m) (nat_ordsucc m Hm1) k Hk). }
          apply iffI.
          + assume H2: k :e eps_ n.
            rewrite eps_ordinal_In_eq_0 n k L3 H2.
            prove 0 :e eps_ m.
            prove 0 :e {0} :\/: {SetAdjoin (ordsucc k) {1}| k :e m}.
            apply binunionI1. apply SingI.
          + assume H2: k :e eps_ m.
            rewrite eps_ordinal_In_eq_0 m k L3 H2.
            prove 0 :e eps_ n.
            prove 0 :e {0} :\/: {SetAdjoin (ordsucc k) {1}| k :e n}.
            apply binunionI1. apply SingI.
      }
Qed.

Theorem eps_SNoCutP : forall n :e omega, SNoCutP {0} {eps_ m|m :e n}.
let n. assume Hn.
set L := {0}.
set R := {eps_ m|m :e n}.
claim Ln: nat_p n.
{ exact omega_nat_p n Hn. }
prove (forall w :e L, SNo w)
   /\ (forall z :e R, SNo z)
   /\ (forall w :e L, forall z :e R, w < z).
apply and3I.
- let w. assume Hw. rewrite SingE 0 w Hw. exact SNo_0.
- let z. assume Hz. apply ReplE_impred n eps_ z Hz.
  let m. assume Hm1: m :e n. assume Hm2: z = eps_ m.
  rewrite Hm2. apply SNo_eps_.
  prove m :e omega. apply nat_p_omega.
  exact nat_p_trans n Ln m Hm1.
- let w. assume Hw.
  let z. assume Hz. apply ReplE_impred n eps_ z Hz.
  let m. assume Hm1: m :e n. assume Hm2: z = eps_ m.
  rewrite SingE 0 w Hw.
  rewrite Hm2.
  prove 0 < eps_ m.
  apply SNo_eps_pos.
  prove m :e omega. apply nat_p_omega.
  exact nat_p_trans n Ln m Hm1.
Qed.

Theorem eps_SNoCut : forall n :e omega, eps_ n = SNoCut {0} {eps_ m|m :e n}.
let n. assume Hn.
set L := {0}.
set R := {eps_ m|m :e n}.
claim Ln: nat_p n.
{ exact omega_nat_p n Hn. }
claim L1: SNoCutP L R.
{ exact eps_SNoCutP n Hn. }
claim LRS: forall z :e R, SNo z.
{ apply L1. assume H _. apply H. assume _ H. exact H. }
claim L2: (\/_ x :e L, ordsucc (SNoLev x)) = 1.
{ apply set_ext.
  - let k. assume Hk. apply famunionE_impred L (fun x => ordsucc (SNoLev x)) k Hk.
    let w. assume Hw: w :e L. rewrite SingE 0 w Hw.
    rewrite SNoLev_0.
    assume H2: k :e 1.
    prove k :e 1.
    exact H2.
  - let i. assume Hi. apply cases_1 i Hi (fun i => i :e \/_ x :e L, ordsucc (SNoLev x)).
    prove 0 :e \/_ x :e L, ordsucc (SNoLev x).
    apply famunionI L (fun x => ordsucc (SNoLev x)) 0 0 (SingI 0).
    prove 0 :e ordsucc (SNoLev 0).
    rewrite SNoLev_0.
    exact In_0_1.
}
claim L3: n <> 0 -> (\/_ y :e R, ordsucc (SNoLev y)) = ordsucc n.
{ assume Hn0: n <> 0.
  apply set_ext.
  - let k. assume Hk. apply famunionE_impred R (fun y => ordsucc (SNoLev y)) k Hk.
    let z. assume Hz: z :e R. apply ReplE_impred n eps_ z Hz.
    let m. assume Hm1: m :e n. assume Hm2: z = eps_ m.
    rewrite Hm2. rewrite SNoLev_eps_ m (nat_p_omega m (nat_p_trans n Ln m Hm1)).
    assume H2: k :e ordsucc (ordsucc m).
    prove k :e ordsucc n.
    claim L3a: ordsucc m :e ordsucc n.
    { apply ordinal_ordsucc_In.
      - prove ordinal n. apply nat_p_ordinal n. exact Ln.
      - exact Hm1.
    }
    claim L3b: ordsucc m c= ordsucc n.
    { exact nat_trans (ordsucc n) (nat_ordsucc n Ln) (ordsucc m) L3a. }
    apply ordsuccE (ordsucc m) k H2.
    + assume H3: k :e ordsucc m. apply L3b. exact H3.
    + assume H3: k = ordsucc m. rewrite H3. exact L3a.
  - let i. assume Hi: i :e ordsucc n.
    prove i :e \/_ y :e R, ordsucc (SNoLev y).
    apply nat_inv n Ln.
    + assume H2: n = 0. prove False. exact Hn0 H2.
    + assume H2. apply H2.
      let n'.
      assume H2. apply H2.
      assume Hn'1: nat_p n'. assume Hn'2: n = ordsucc n'.
      apply famunionI R (fun y => ordsucc (SNoLev y)) (eps_ n') i.
      * prove eps_ n' :e R. apply ReplI. prove n' :e n. rewrite Hn'2. apply ordsuccI2.
      * prove i :e ordsucc (SNoLev (eps_ n')).
        rewrite SNoLev_eps_ n' (nat_p_omega n' Hn'1).
        prove i :e ordsucc (ordsucc n'). rewrite <- Hn'2. exact Hi.
}
claim L4: (\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y)) = ordsucc n.
{ apply xm (n = 0).
  - assume H2: n = 0.
    claim L4a: R = 0.
    { apply Empty_eq.
      let z. assume Hz. apply ReplE_impred n eps_ z Hz.
      let m. rewrite H2. assume Hm1: m :e 0.
      prove False. exact EmptyE m Hm1.
    }
    rewrite L4a. rewrite famunion_Empty (fun y => ordsucc (SNoLev y)).
    prove (\/_ x :e L, ordsucc (SNoLev x)) :\/: 0 = ordsucc n.
    rewrite binunion_idr.
    prove (\/_ x :e L, ordsucc (SNoLev x)) = ordsucc n.
    rewrite H2. exact L2.
  - assume H2: n <> 0.
    rewrite <- L3 H2.
    rewrite <- Subq_binunion_eq.
    rewrite L2. rewrite L3 H2.
    prove 1 c= ordsucc n.
    let i. assume Hi. apply cases_1 i Hi (fun i => i :e ordsucc n).
    prove 0 :e ordsucc n. apply nat_0_in_ordsucc. exact Ln.
}
apply SNoCutP_SNoCut_impred L R L1.
assume H1: SNo (SNoCut L R).
rewrite L4.
assume H2: SNoLev (SNoCut L R) :e ordsucc (ordsucc n).
assume H3: forall w :e L, w < SNoCut L R.
assume H4: forall z :e R, SNoCut L R < z.
assume H5: forall u, SNo u -> (forall w :e L, w < u) -> (forall z :e R, u < z) -> SNoLev (SNoCut L R) c= SNoLev u /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) u.
claim L5: SNo (eps_ n).
{ exact SNo_eps_ n Hn. }
claim L6: forall w :e L, w < eps_ n.
{ let w. assume Hw. rewrite SingE 0 w Hw.
  prove 0 < eps_ n. exact SNo_eps_pos n Hn.
}
claim L7: forall z :e R, eps_ n < z.
{ let z. assume Hz. apply ReplE_impred n eps_ z Hz.
  let m. assume Hm1: m :e n. assume Hm2: z = eps_ m.
  rewrite Hm2.
  prove eps_ n < eps_ m.
  exact SNo_eps_decr n Hn m Hm1.
}
apply H5 (eps_ n) L5 L6 L7.
assume H6: SNoLev (SNoCut L R) c= SNoLev (eps_ n).
assume H7: SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) (eps_ n).
symmetry.
apply SNo_eq (SNoCut L R) (eps_ n) H1 L5.
- prove SNoLev (SNoCut L R) = SNoLev (eps_ n).
  rewrite SNoLev_eps_ n Hn.
  prove SNoLev (SNoCut L R) = ordsucc n.
  apply ordsuccE (ordsucc n) (SNoLev (SNoCut L R)) H2.
  + assume H8: SNoLev (SNoCut L R) :e ordsucc n.
    prove False.
    claim L8: eps_ n < SNoCut L R.
    { apply SNo_pos_eps_Lt n (omega_nat_p n Hn) (SNoCut L R).
      - prove SNoCut L R :e SNoS_ (ordsucc n).
        apply SNoS_I (ordsucc n) (nat_p_ordinal (ordsucc n) (nat_ordsucc n (omega_nat_p n Hn))) (SNoCut L R) (SNoLev (SNoCut L R)) H8.
        prove SNo_ (SNoLev (SNoCut L R)) (SNoCut L R).
        exact SNoLev_ (SNoCut L R) H1.
      - prove 0 < SNoCut L R. apply H3. apply SingI.
    }
    apply SNoLtE (eps_ n) (SNoCut L R) (SNo_eps_ n Hn) H1 L8.
    * let z.
      assume Hz1: SNo z.
      assume Hz2: SNoLev z :e SNoLev (eps_ n) :/\: SNoLev (SNoCut L R).
      assume Hz3: SNoEq_ (SNoLev z) z (eps_ n).
      assume Hz4: SNoEq_ (SNoLev z) z (SNoCut L R).
      assume Hz5: eps_ n < z.
      assume Hz6: z < SNoCut L R.
      assume Hz7: SNoLev z /:e eps_ n.
      assume Hz8: SNoLev z :e SNoCut L R.
      claim L9: forall w :e L, w < z.
      { let w. assume Hw. rewrite SingE 0 w Hw.
        prove 0 < z.
        apply SNoLt_tra 0 (eps_ n) z SNo_0 (SNo_eps_ n Hn) Hz1.
        - exact SNo_eps_pos n Hn.
        - exact Hz5.
      }
      claim L10: forall v :e R, z < v.
      { let v. assume Hv.
        apply SNoLt_tra z (SNoCut L R) v Hz1 H1 (LRS v Hv) Hz6.
        prove SNoCut L R < v. apply H4. exact Hv.
      }
      apply H5 z Hz1 L9 L10.
      assume H9: SNoLev (SNoCut L R) c= SNoLev z.
      prove False.
      apply In_irref (SNoLev z). apply H9.
      exact binintersectE2 (SNoLev (eps_ n)) (SNoLev (SNoCut L R)) (SNoLev z) Hz2.
    * rewrite SNoLev_eps_ n Hn. 
      assume H9: ordsucc n :e SNoLev (SNoCut L R).
      prove False.
      exact In_no2cycle (SNoLev (SNoCut L R)) (ordsucc n) H8 H9.
    * rewrite SNoLev_eps_ n Hn.
      assume H9: SNoLev (SNoCut L R) :e ordsucc n.
      assume H10: SNoEq_ (SNoLev (SNoCut L R)) (eps_ n) (SNoCut L R).
      assume H11: SNoLev (SNoCut L R) /:e eps_ n.
      claim L11: exists m :e n, SNoCut L R = eps_ m.
      { apply eps_SNo_eq n (omega_nat_p n Hn) (SNoCut L R).
        - prove SNoCut L R :e SNoS_ (ordsucc n).
          apply SNoS_I (ordsucc n) (nat_p_ordinal (ordsucc n) (nat_ordsucc n (omega_nat_p n Hn))) (SNoCut L R) (SNoLev (SNoCut L R)).
          + prove SNoLev (SNoCut L R) :e ordsucc n. exact H9.
          + prove SNo_ (SNoLev (SNoCut L R)) (SNoCut L R).
            apply SNoLev_. exact H1.
        - prove 0 < SNoCut L R. apply H3. apply SingI.
        - prove SNoEq_ (SNoLev (SNoCut L R)) (eps_ n) (SNoCut L R). exact H10.
      }
      apply L11. let m. assume H12. apply H12.
      assume Hm1: m :e n.
      assume Hm2: SNoCut L R = eps_ m.
      apply SNoLt_irref (eps_ m).
      prove eps_ m < eps_ m.
      rewrite <- Hm2 at 1.
      prove SNoCut L R < eps_ m.
      apply H4.
      prove eps_ m :e {eps_ m|m :e n}.
      apply ReplI. exact Hm1.
  + assume H8: SNoLev (SNoCut L R) = ordsucc n. exact H8.
- exact H7.
Qed.

End TaggedSets2.

Theorem SNo_etaE : forall z, SNo z ->
  forall p:prop,
     (forall L R, SNoCutP L R
       -> (forall x :e L, SNoLev x :e SNoLev z)
       -> (forall y :e R, SNoLev y :e SNoLev z)
       -> z = SNoCut L R
       -> p)
   -> p.
let z. assume Hz: SNo z.
let p. assume H1.
claim LLz: ordinal (SNoLev z).
{ exact SNoLev_ordinal z Hz. }
set L := {x :e SNoS_ (SNoLev z) | x < z}.
set R := {y :e SNoS_ (SNoLev z) | z < y}.
claim L1: z = SNoCut L R.
{ exact SNo_eta z Hz. }
claim LL: forall x, x :e L -> SNo x /\ SNoLev x :e SNoLev z /\ x < z.
{ let x. assume Hx: x :e L.
  apply SepE (SNoS_ (SNoLev z)) (fun x => x < z) x Hx.
  assume Hx1: x :e SNoS_ (SNoLev z).
  assume Hx2: x < z.
  apply SNoS_E (SNoLev z) LLz x Hx1.
  let beta. assume Hx3. apply Hx3.
  assume Hb: beta :e SNoLev z.
  assume Hx3: SNo_ beta x.
  claim Lb: ordinal beta.
  { exact ordinal_Hered (SNoLev z) LLz beta Hb. }
  claim Lx1: SNo x.
  { prove exists alpha, ordinal alpha /\ SNo_ alpha x.
    witness beta.
    apply andI.
    - exact Lb.
    - exact Hx3.
  }
  claim Lx2: SNoLev x = beta.
  { apply SNoLev_prop x Lx1.
    assume Hx4: ordinal (SNoLev x).
    assume Hx5: SNo_ (SNoLev x) x.
    apply SNoLev_uniq x.
    - exact Hx4.
    - exact Lb.
    - apply Hx5.
    - exact Hx3.
  }
  claim Lx3: SNoLev x :e SNoLev z.
  { rewrite Lx2. exact Hb. }
  apply and3I.
  - prove SNo x. exact Lx1.
  - prove SNoLev x :e SNoLev z. exact Lx3.
  - prove x < z. exact Hx2.
}
claim LR: forall y, y :e R -> SNo y /\ SNoLev y :e SNoLev z /\ z < y.
{ let y.
  assume Hy: y :e R.
  apply SepE (SNoS_ (SNoLev z)) (fun y => z < y) y Hy.
  assume Hy1: y :e SNoS_ (SNoLev z).
  assume Hy2: z < y.
  apply SNoS_E (SNoLev z) LLz y Hy1.
  let beta. assume Hy3. apply Hy3.
  assume Hb: beta :e SNoLev z.
  assume Hy3: SNo_ beta y.
  claim Lb: ordinal beta.
  { exact ordinal_Hered (SNoLev z) LLz beta Hb. }
  claim Ly1: SNo y.
  { prove exists alpha, ordinal alpha /\ SNo_ alpha y.
    witness beta. apply andI.
    - exact Lb.
    - exact Hy3.
  }
  claim Ly2: SNoLev y = beta.
  { apply SNoLev_prop y Ly1.
    assume Hy4: ordinal (SNoLev y).
    assume Hy5: SNo_ (SNoLev y) y.
    apply SNoLev_uniq y.
    - exact Hy4.
    - exact Lb.
    - apply Hy5.
    - exact Hy3.
  }
  claim Ly3: SNoLev y :e SNoLev z.
  { rewrite Ly2. exact Hb. }
  apply and3I.
  - prove SNo y. exact Ly1.
  - prove SNoLev y :e SNoLev z. exact Ly3.
  - prove z < y. exact Hy2.
}
apply H1 L R.
- prove SNoCutP L R.
  prove (forall x :e L, SNo x)
     /\ (forall y :e R, SNo y)
     /\ (forall x :e L, forall y :e R, x < y).
  apply and3I.
  + let x. assume Hx. apply LL x Hx. assume H _. apply H. assume H _. exact H.
  + let y. assume Hy. apply LR y Hy. assume H _. apply H. assume H _. exact H.
  + let x. assume Hx. let y. assume Hy.
    apply LL x Hx. assume H2. apply H2.
    assume H2: SNo x.
    assume H3: SNoLev x :e SNoLev z.
    assume H4: x < z.
    apply LR y Hy. assume H5. apply H5.
    assume H5: SNo y.
    assume H6: SNoLev y :e SNoLev z.
    assume H7: z < y.
    exact SNoLt_tra x z y H2 Hz H5 H4 H7.
- prove forall x :e L, SNoLev x :e SNoLev z.
  let x. assume Hx. apply LL x Hx. assume H _. apply H. assume _ H. exact H.
- prove forall y :e R, SNoLev y :e SNoLev z.
  let y. assume Hy. apply LR y Hy. assume H _. apply H. assume _ H. exact H.
- prove z = SNoCut L R. exact L1.
Qed.

(*** surreal induction ***)
Theorem SNo_ind : forall P:set -> prop,
  (forall L R, SNoCutP L R
   -> (forall x :e L, P x)
   -> (forall y :e R, P y)
   -> P (SNoCut L R))
 -> forall z, SNo z -> P z.
let P.
assume H1.
claim L1: forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e alpha -> P z.
{ apply ordinal_ind.
  let alpha. assume Ha: ordinal alpha.
  assume IH: forall beta :e alpha, forall z, SNo z -> SNoLev z :e beta -> P z.
  let z. assume Hz: SNo z.
  assume Hz2: SNoLev z :e alpha.
  prove P z.
  claim LLz: ordinal (SNoLev z).
  { exact SNoLev_ordinal z Hz. }
  apply SNo_etaE z Hz.
  let L R.
  assume H2: SNoCutP L R.
  assume H3: forall x :e L, SNoLev x :e SNoLev z.
  assume H4: forall y :e R, SNoLev y :e SNoLev z.
  assume H5: z = SNoCut L R.
  apply H2. assume H6. apply H6.
  assume H6: forall x :e L, SNo x.
  assume H7: forall y :e R, SNo y.
  assume H8: forall x :e L, forall y :e R, x < y.
  rewrite H5.
  prove P (SNoCut L R).
  apply H1.
  - prove SNoCutP L R. exact H2.
  - prove forall x, x :e L -> P x.
    let x. assume Hx: x :e L.
    apply IH (SNoLev z) Hz2 x.
    + prove SNo x. exact H6 x Hx.
    + prove SNoLev x :e SNoLev z. exact H3 x Hx.
  - prove forall y, y :e R -> P y.
    let y. assume Hy: y :e R.
    apply IH (SNoLev z) Hz2 y.
    + prove SNo y. exact H7 y Hy.
    + prove SNoLev y :e SNoLev z. exact H4 y Hy.
}
let z. assume Hz: SNo z.
claim L2: ordinal (ordsucc (SNoLev z)).
{ apply ordinal_ordsucc. apply SNoLev_ordinal. exact Hz. }
apply L1 (ordsucc (SNoLev z)) L2 z Hz.
apply ordsuccI2.
Qed.

(*** surreal recursion ***)
Section SurrealRecI.
Variable F:set -> (set -> set) -> set.
Let default : set := Eps_i (fun _ => True).
Let G : set -> (set -> set -> set) -> set -> set
  := fun alpha g =>
       If_ii
          (ordinal alpha)
          (fun z:set => if z :e SNoS_ (ordsucc alpha) then
                           F z (fun w => g (SNoLev w) w)
                        else
                           default)
          (fun z:set => default).
(* Parameter SNo_rec_i "352082c509ab97c1757375f37a2ac62ed806c7b39944c98161720a584364bfaf" "be45dfaed6c479503a967f3834400c4fd18a8a567c8887787251ed89579f7be3" *)
Definition SNo_rec_i : set -> set
 := fun z => In_rec_ii G (SNoLev z) z.
Hypothesis Fr: forall z, SNo z ->
   forall g h:set -> set, (forall w :e SNoS_ (SNoLev z), g w = h w)
     -> F z g = F z h.

Theorem SNo_rec_i_eq : forall z, SNo z -> SNo_rec_i z = F z SNo_rec_i.
let z. assume Hz: SNo z.
prove SNo_rec_i z = F z SNo_rec_i.
prove In_rec_ii G (SNoLev z) z = F z (fun z => In_rec_ii G (SNoLev z) z).
claim L1: forall alpha, forall g h:set -> set -> set, (forall x :e alpha, g x = h x) -> G alpha g = G alpha h.
{ let alpha g h.
  assume Hgh: forall x :e alpha, g x = h x.
  prove G alpha g = G alpha h.
  prove (If_ii (ordinal alpha) (fun z:set => if z :e SNoS_ (ordsucc alpha) then F z (fun w => g (SNoLev w) w) else default) (fun z:set => default))
      = (If_ii (ordinal alpha) (fun z:set => if z :e SNoS_ (ordsucc alpha) then F z (fun w => h (SNoLev w) w) else default) (fun z:set => default)).
  apply xm (ordinal alpha).
  - assume H1: ordinal alpha.
    rewrite If_ii_1 (ordinal alpha) (fun z => if z :e SNoS_ (ordsucc alpha) then F z (fun w => h (SNoLev w) w) else default) (fun z:set => default) H1.
    rewrite If_ii_1 (ordinal alpha) (fun z => if z :e SNoS_ (ordsucc alpha) then F z (fun w => g (SNoLev w) w) else default) (fun z:set => default) H1.
    prove (fun z:set => if z :e SNoS_ (ordsucc alpha) then F z (fun w => g (SNoLev w) w) else default)
        = (fun z:set => if z :e SNoS_ (ordsucc alpha) then F z (fun w => h (SNoLev w) w) else default).
    apply func_ext set set.
    let z.
    prove (if z :e SNoS_ (ordsucc alpha) then F z (fun w => g (SNoLev w) w) else default)
        = (if z :e SNoS_ (ordsucc alpha) then F z (fun w => h (SNoLev w) w) else default).
    apply xm (z :e SNoS_ (ordsucc alpha)).
    + assume Hz: z :e SNoS_ (ordsucc alpha).
      rewrite If_i_1 (z :e SNoS_ (ordsucc alpha)) (F z (fun w => g (SNoLev w) w)) default Hz.
      rewrite If_i_1 (z :e SNoS_ (ordsucc alpha)) (F z (fun w => h (SNoLev w) w)) default Hz.
      prove F z (fun w => g (SNoLev w) w) = F z (fun w => h (SNoLev w) w).
      claim Lsa: ordinal (ordsucc alpha).
      { exact ordinal_ordsucc alpha H1. }
      apply SNoS_E2 (ordsucc alpha) Lsa z Hz.
      assume Hz1: SNoLev z :e ordsucc alpha.
      assume Hz2: ordinal (SNoLev z).
      assume Hz3: SNo z.
      assume Hz4: SNo_ (SNoLev z) z.
      prove F z (fun w => g (SNoLev w) w)
          = F z (fun w => h (SNoLev w) w).
      apply Fr.
      * prove SNo z. exact Hz3.
      * prove forall w :e SNoS_ (SNoLev z), g (SNoLev w) w = h (SNoLev w) w.
        let w. assume Hw: w :e SNoS_ (SNoLev z).
        apply SNoS_E2 (SNoLev z) Hz2 w Hw.
        assume Hw1: SNoLev w :e SNoLev z.
        assume Hw2: ordinal (SNoLev w).
        assume Hw3: SNo w.
        assume Hw4: SNo_ (SNoLev w) w.
        claim LLw: SNoLev w :e alpha.
        { apply ordsuccE alpha (SNoLev z) Hz1.
          - assume H2: SNoLev z :e alpha.
            apply H1. assume Ha1 _. exact Ha1 (SNoLev z) H2 (SNoLev w) Hw1.
          - assume H2: SNoLev z = alpha.
            rewrite <- H2. exact Hw1.
        }
        rewrite Hgh (SNoLev w) LLw.
        reflexivity.
    + assume Hz: z /:e SNoS_ (ordsucc alpha).
      rewrite If_i_0 (z :e SNoS_ (ordsucc alpha)) (F z (fun w => h (SNoLev w) w)) default Hz.
      exact If_i_0 (z :e SNoS_ (ordsucc alpha)) (F z (fun w => g (SNoLev w) w)) default Hz.
  - assume H1: ~ordinal alpha.
    rewrite If_ii_0 (ordinal alpha) (fun z => if z :e SNoS_ (ordsucc alpha) then F z (fun w => h (SNoLev w) w) else default) (fun z:set => default) H1.
    exact If_ii_0 (ordinal alpha) (fun z => if z :e SNoS_ (ordsucc alpha) then F z (fun w => g (SNoLev w) w) else default) (fun z:set => default) H1.
}
rewrite In_rec_ii_eq G L1.
prove G (SNoLev z) (In_rec_ii G) z = F z (fun z => In_rec_ii G (SNoLev z) z).
prove (If_ii (ordinal (SNoLev z)) (fun u:set => if u :e SNoS_ (ordsucc (SNoLev z)) then F u (fun w:set => In_rec_ii G (SNoLev w) w) else default) (fun _:set => default)) z = F z (fun z => In_rec_ii G (SNoLev z) z).
claim L2: ordinal (SNoLev z).
{ exact SNoLev_ordinal z Hz. }
rewrite If_ii_1 (ordinal (SNoLev z))
                (fun u:set => if u :e SNoS_ (ordsucc (SNoLev z)) then F u (fun w:set => In_rec_ii G (SNoLev w) w) else default)
                        (fun _:set => default)
                        L2.
prove (if z :e SNoS_ (ordsucc (SNoLev z)) then F z (fun w:set => In_rec_ii G (SNoLev w) w) else default) = F z (fun z => In_rec_ii G (SNoLev z) z).
claim L3: z :e SNoS_ (ordsucc (SNoLev z)).
{ exact SNoS_SNoLev z Hz. }
exact If_i_1 (z :e SNoS_ (ordsucc (SNoLev z))) (F z (fun w:set => In_rec_ii G (SNoLev w) w)) default L3.
Qed.

End SurrealRecI.
Section SurrealRecII.
Variable F:set -> (set -> (set -> set)) -> (set -> set).
Let default : (set -> set) := Descr_ii (fun _ => True).
Let G : set -> (set -> set -> (set -> set)) -> set -> (set -> set)
  := fun alpha g =>
       If_iii
          (ordinal alpha)
          (fun z:set => If_ii (z :e SNoS_ (ordsucc alpha))
                              (F z (fun w => g (SNoLev w) w))
                              default)
          (fun z:set => default).
(* Parameter SNo_rec_ii "030b1b3db48f720b8db18b1192717cad8f204fff5fff81201b9a2414f5036417" "e148e62186e718374accb69cda703e3440725cca8832aed55c0b32731f7401ab" *)
Definition SNo_rec_ii : set -> (set -> set)
 := fun z => In_rec_iii G (SNoLev z) z.
Hypothesis Fr: forall z, SNo z ->
   forall g h:set -> (set -> set), (forall w :e SNoS_ (SNoLev z), g w = h w)
     -> F z g = F z h.

Theorem SNo_rec_ii_eq : forall z, SNo z -> SNo_rec_ii z = F z SNo_rec_ii.
let z. assume Hz: SNo z.
prove SNo_rec_ii z = F z SNo_rec_ii.
prove In_rec_iii G (SNoLev z) z = F z (fun z => In_rec_iii G (SNoLev z) z).
claim L1: forall alpha, forall g h:set -> set -> (set -> set), (forall x :e alpha, g x = h x) -> G alpha g = G alpha h.
{ let alpha g h.
  assume Hgh: forall x :e alpha, g x = h x.
  prove G alpha g = G alpha h.
  prove (If_iii (ordinal alpha) (fun z:set => If_ii (z :e SNoS_ (ordsucc alpha)) (F z (fun w => g (SNoLev w) w)) default) (fun z:set => default))
      = (If_iii (ordinal alpha) (fun z:set => If_ii (z :e SNoS_ (ordsucc alpha)) (F z (fun w => h (SNoLev w) w)) default) (fun z:set => default)).
  apply xm (ordinal alpha).
  - assume H1: ordinal alpha.
    rewrite If_iii_1 (ordinal alpha) (fun z => If_ii (z :e SNoS_ (ordsucc alpha)) (F z (fun w => h (SNoLev w) w)) default) (fun z:set => default) H1.
    rewrite If_iii_1 (ordinal alpha) (fun z => If_ii (z :e SNoS_ (ordsucc alpha)) (F z (fun w => g (SNoLev w) w)) default) (fun z:set => default) H1.
    prove (fun z:set => If_ii (z :e SNoS_ (ordsucc alpha)) (F z (fun w => g (SNoLev w) w)) default)
        = (fun z:set => If_ii (z :e SNoS_ (ordsucc alpha)) (F z (fun w => h (SNoLev w) w)) default).
    apply func_ext set (set -> set).
    let z.
    prove (If_ii (z :e SNoS_ (ordsucc alpha)) (F z (fun w => g (SNoLev w) w)) default)
        = (If_ii (z :e SNoS_ (ordsucc alpha)) (F z (fun w => h (SNoLev w) w)) default).
    apply xm (z :e SNoS_ (ordsucc alpha)).
    + assume Hz: z :e SNoS_ (ordsucc alpha).
      rewrite If_ii_1 (z :e SNoS_ (ordsucc alpha)) (F z (fun w => g (SNoLev w) w)) default Hz.
      rewrite If_ii_1 (z :e SNoS_ (ordsucc alpha)) (F z (fun w => h (SNoLev w) w)) default Hz.
      prove F z (fun w => g (SNoLev w) w) = F z (fun w => h (SNoLev w) w).
      claim Lsa: ordinal (ordsucc alpha).
      { exact ordinal_ordsucc alpha H1. }
      apply SNoS_E2 (ordsucc alpha) Lsa z Hz.
      assume Hz1: SNoLev z :e ordsucc alpha.
      assume Hz2: ordinal (SNoLev z).
      assume Hz3: SNo z.
      assume Hz4: SNo_ (SNoLev z) z.
      prove F z (fun w => g (SNoLev w) w)
          = F z (fun w => h (SNoLev w) w).
      apply Fr.
      * prove SNo z. exact Hz3.
      * prove forall w :e SNoS_ (SNoLev z), g (SNoLev w) w = h (SNoLev w) w.
        let w. assume Hw: w :e SNoS_ (SNoLev z).
        apply SNoS_E2 (SNoLev z) Hz2 w Hw.
        assume Hw1: SNoLev w :e SNoLev z.
        assume Hw2: ordinal (SNoLev w).
        assume Hw3: SNo w.
        assume Hw4: SNo_ (SNoLev w) w.
        claim LLw: SNoLev w :e alpha.
        { apply ordsuccE alpha (SNoLev z) Hz1.
          - assume H2: SNoLev z :e alpha.
            apply H1. assume Ha1 _. exact Ha1 (SNoLev z) H2 (SNoLev w) Hw1.
          - assume H2: SNoLev z = alpha.
            rewrite <- H2. exact Hw1.
        }
        rewrite Hgh (SNoLev w) LLw.
        reflexivity.
    + assume Hz: z /:e SNoS_ (ordsucc alpha).
      rewrite If_ii_0 (z :e SNoS_ (ordsucc alpha)) (F z (fun w => h (SNoLev w) w)) default Hz.
      exact If_ii_0 (z :e SNoS_ (ordsucc alpha)) (F z (fun w => g (SNoLev w) w)) default Hz.
  - assume H1: ~ordinal alpha.
    rewrite If_iii_0 (ordinal alpha) (fun z => If_ii (z :e SNoS_ (ordsucc alpha)) (F z (fun w => h (SNoLev w) w)) default) (fun z:set => default) H1.
    exact If_iii_0 (ordinal alpha) (fun z => If_ii (z :e SNoS_ (ordsucc alpha)) (F z (fun w => g (SNoLev w) w)) default) (fun z:set => default) H1.
}
rewrite In_rec_iii_eq G L1.
prove G (SNoLev z) (In_rec_iii G) z = F z (fun z => In_rec_iii G (SNoLev z) z).
prove (If_iii (ordinal (SNoLev z)) (fun u:set => If_ii (u :e SNoS_ (ordsucc (SNoLev z))) (F u (fun w:set => In_rec_iii G (SNoLev w) w)) default) (fun _:set => default)) z = F z (fun z => In_rec_iii G (SNoLev z) z).
claim L2: ordinal (SNoLev z).
{ exact SNoLev_ordinal z Hz. }
rewrite If_iii_1 (ordinal (SNoLev z))
                        (fun u:set => If_ii (u :e SNoS_ (ordsucc (SNoLev z))) (F u (fun w:set => In_rec_iii G (SNoLev w) w)) default)
                        (fun _:set => default)
                        L2.
prove (If_ii (z :e SNoS_ (ordsucc (SNoLev z))) (F z (fun w:set => In_rec_iii G (SNoLev w) w)) default) = F z (fun z => In_rec_iii G (SNoLev z) z).
claim L3: z :e SNoS_ (ordsucc (SNoLev z)).
{ exact SNoS_SNoLev z Hz. }
exact If_ii_1 (z :e SNoS_ (ordsucc (SNoLev z))) (F z (fun w:set => In_rec_iii G (SNoLev w) w)) default L3.
Qed.

End SurrealRecII.
Section SurrealRec2.
Variable F:set -> set -> (set -> set -> set) -> set.
Let G:set -> (set -> set -> set) -> set -> (set -> set) -> set
  := fun w f z g => F w z (fun x y => if x = w then g y else f x y).
Let H:set -> (set -> set -> set) -> set -> set
  := fun w f z => if SNo z then SNo_rec_i (G w f) z else Empty.
(* Parameter SNo_rec2 "9c6267051fa817eed39b404ea37e7913b3571fe071763da2ebc1baa56b4b77f5" "7d10ab58310ebefb7f8bf63883310aa10fc2535f53bb48db513a868bc02ec028" *)
Definition SNo_rec2 : set -> set -> set
  := SNo_rec_ii H.
Hypothesis Fr: forall w, SNo w -> forall z, SNo z ->
   forall g h:set -> set -> set,
        (forall x :e SNoS_ (SNoLev w), forall y, SNo y -> g x y = h x y)
     -> (forall y :e SNoS_ (SNoLev z), g w y = h w y)
     -> F w z g = F w z h.

Theorem SNo_rec2_G_prop : forall w, SNo w -> forall f k:set -> set -> set,
    (forall x :e SNoS_ (SNoLev w), f x = k x)
 -> forall z, SNo z ->
    forall g h:set -> set, (forall u :e SNoS_ (SNoLev z), g u = h u)
 -> G w f z g = G w k z h.
let w. assume Hw: SNo w.
let f k.
assume Hfk: forall x :e SNoS_ (SNoLev w), f x = k x.
let z. assume Hz: SNo z.
let g h.
assume Hgh: forall u :e SNoS_ (SNoLev z), g u = h u.
prove G w f z g = G w k z h.
prove F w z (fun x y => if x = w then g y else f x y)
    = F w z (fun x y => if x = w then h y else k x y).
apply Fr.
- prove SNo w. exact Hw.
- prove SNo z. exact Hz.
- let x. assume Hx: x :e SNoS_ (SNoLev w).
  let y. assume Hy: SNo y.
  prove (if x = w then g y else f x y)
      = (if x = w then h y else k x y).
  claim Lxw: x <> w.
  { exact SNoS_In_neq w Hw x Hx. }
  rewrite If_i_0 (x = w) (g y) (f x y) Lxw.
  rewrite If_i_0 (x = w) (h y) (k x y) Lxw.
  prove f x y = k x y.
  rewrite Hfk x Hx.
  reflexivity.
- let y. assume Hy: y :e SNoS_ (SNoLev z).
  prove (if w = w then g y else f w y)
      = (if w = w then h y else k w y).
  rewrite If_i_1 (w = w) (g y) (f w y) (fun q H => H).
  rewrite If_i_1 (w = w) (h y) (k w y) (fun q H => H).
  prove g y = h y.
  exact Hgh y Hy.
Qed.

Theorem SNo_rec2_eq_1 : forall w, SNo w -> forall f:set -> set -> set,
  forall z, SNo z ->
   SNo_rec_i (G w f) z = G w f z (SNo_rec_i (G w f)).
let w. assume Hw: SNo w.
let f.
claim L1: forall z, SNo z -> forall g h:set -> set, (forall u :e SNoS_ (SNoLev z), g u = h u) -> G w f z g = G w f z h.
{ let z. assume Hz. let g h. assume Hgh.
  claim L1a: forall x :e SNoS_ (SNoLev w), f x = f x.
  { let x. assume Hx. reflexivity. }
  exact SNo_rec2_G_prop w Hw f f L1a z Hz g h Hgh.
}
exact SNo_rec_i_eq (G w f) L1.
Qed.

Theorem SNo_rec2_eq : forall w, SNo w -> forall z, SNo z ->
   SNo_rec2 w z = F w z SNo_rec2.
let w. assume Hw: SNo w.
let z. assume Hz: SNo z.
prove SNo_rec2 w z = F w z SNo_rec2.
prove SNo_rec_ii H w z = F w z SNo_rec2.
claim L1: forall w, SNo w ->
    forall g h:set -> set -> set, (forall x :e SNoS_ (SNoLev w), g x = h x)
     -> H w g = H w h.
{ let w. assume Hw: SNo w.
  let g h.
  assume Hgh: forall x :e SNoS_ (SNoLev w), g x = h x.
  prove H w g = H w h.
  prove (fun z:set => if SNo z then SNo_rec_i (G w g) z else Empty)
      = (fun z:set => if SNo z then SNo_rec_i (G w h) z else Empty).
  apply func_ext set set.
  let z.
  prove (if SNo z then SNo_rec_i (G w g) z else Empty)
      = (if SNo z then SNo_rec_i (G w h) z else Empty).
  apply xm (SNo z).
  - assume Hz: SNo z.
    rewrite If_i_1 (SNo z) (SNo_rec_i (G w g) z) Empty Hz.
    rewrite If_i_1 (SNo z) (SNo_rec_i (G w h) z) Empty Hz.
    prove SNo_rec_i (G w g) z = SNo_rec_i (G w h) z.
    claim L1a: forall alpha, ordinal alpha -> forall z :e SNoS_ alpha, SNo_rec_i (G w g) z = SNo_rec_i (G w h) z.
    { apply ordinal_ind.
      let alpha. assume Ha: ordinal alpha.
      assume IH: forall beta :e alpha, forall z :e SNoS_ beta, SNo_rec_i (G w g) z = SNo_rec_i (G w h) z.
      let z. assume Hz: z :e SNoS_ alpha.
      apply SNoS_E2 alpha Ha z Hz.
      assume Hz1: SNoLev z :e alpha.
      assume Hz2: ordinal (SNoLev z).
      assume Hz3: SNo z.
      assume Hz4: SNo_ (SNoLev z) z.
      prove SNo_rec_i (G w g) z = SNo_rec_i (G w h) z.
      rewrite SNo_rec2_eq_1 w Hw g z Hz3.
      rewrite SNo_rec2_eq_1 w Hw h z Hz3.
      prove G w g z (SNo_rec_i (G w g)) = G w h z (SNo_rec_i (G w h)).
      apply SNo_rec2_G_prop w Hw g h Hgh z Hz3 (SNo_rec_i (G w g)) (SNo_rec_i (G w h)).
      prove forall y :e SNoS_ (SNoLev z), SNo_rec_i (G w g) y = SNo_rec_i (G w h) y.
      let y.
      assume Hy : y :e SNoS_ (SNoLev z).
      exact IH (SNoLev z) Hz1 y Hy.
    }
    exact L1a (ordsucc (SNoLev z)) (ordinal_ordsucc (SNoLev z) (SNoLev_ordinal z Hz))
              z (SNoS_SNoLev z Hz).
  - assume Hz: ~SNo z.
    rewrite If_i_0 (SNo z) (SNo_rec_i (G w h) z) Empty Hz.
    exact If_i_0 (SNo z) (SNo_rec_i (G w g) z) Empty Hz.
}
claim L2: H w (SNo_rec_ii H) z = F w z SNo_rec2.
{ prove (if SNo z then SNo_rec_i (G w (SNo_rec_ii H)) z else Empty) = F w z SNo_rec2.
  rewrite If_i_1 (SNo z) (SNo_rec_i (G w (SNo_rec_ii H)) z) Empty Hz.
  prove SNo_rec_i (G w (SNo_rec_ii H)) z = F w z SNo_rec2.
  prove SNo_rec_i (G w (SNo_rec_ii H)) z = F w z (SNo_rec_ii H).
  rewrite SNo_rec2_eq_1 w Hw (SNo_rec_ii H) z Hz.
  prove G w (SNo_rec_ii H) z (SNo_rec_i (G w (SNo_rec_ii H))) = F w z (SNo_rec_ii H).
  prove F w z (fun x y => if x = w then SNo_rec_i (G w (SNo_rec_ii H)) y else SNo_rec_ii H x y) = F w z (SNo_rec_ii H).
  claim L2a: forall x :e SNoS_ (SNoLev w), forall y, SNo y -> (if x = w then SNo_rec_i (G w (SNo_rec_ii H)) y else SNo_rec_ii H x y) = SNo_rec_ii H x y.
  { let x. assume Hx: x :e SNoS_ (SNoLev w).
    let y. assume Hy: SNo y.
    claim Lxw: x <> w.
    { exact SNoS_In_neq w Hw x Hx. }
    exact If_i_0 (x = w) (SNo_rec_i (G w (SNo_rec_ii H)) y) (SNo_rec_ii H x y) Lxw.
  }
  claim L2b: forall y :e SNoS_ (SNoLev z), (if w = w then SNo_rec_i (G w (SNo_rec_ii H)) y else SNo_rec_ii H w y) = SNo_rec_ii H w y.
  { let y. assume Hy: y :e SNoS_ (SNoLev z).
    rewrite If_i_1 (w = w) (SNo_rec_i (G w (SNo_rec_ii H)) y) (SNo_rec_ii H w y) (fun q H => H).
    claim Ly: SNo y.
    { apply SNoS_E2 (SNoLev z) (SNoLev_ordinal z Hz) y Hy.
      assume Hy1: SNoLev y :e SNoLev z.
      assume Hy2: ordinal (SNoLev y).
      assume Hy3: SNo y.
      assume Hy4: SNo_ (SNoLev y) y.
      exact Hy3.
    }
    prove SNo_rec_i (G w (SNo_rec_ii H)) y = SNo_rec_ii H w y.
    apply eq_i_tra (SNo_rec_i (G w (SNo_rec_ii H)) y) (H w (SNo_rec_ii H) y) (SNo_rec_ii H w y).
    - prove SNo_rec_i (G w (SNo_rec_ii H)) y = H w (SNo_rec_ii H) y.
      prove SNo_rec_i (G w (SNo_rec_ii H)) y = if SNo y then (SNo_rec_i (G w (SNo_rec_ii H)) y) else Empty.
      symmetry.
      exact If_i_1 (SNo y) (SNo_rec_i (G w (SNo_rec_ii H)) y) Empty Ly.
    - prove H w (SNo_rec_ii H) y = SNo_rec_ii H w y.
      rewrite SNo_rec_ii_eq H L1 w Hw.
      prove H w (SNo_rec_ii H) y = H w (SNo_rec_ii H) y.
      exact (fun q H => H).
  }
  exact Fr w Hw z Hz (fun x y => if x = w then SNo_rec_i (G w (SNo_rec_ii H)) y else SNo_rec_ii H x y) (SNo_rec_ii H) L2a L2b.
}
prove SNo_rec_ii H w z = F w z SNo_rec2.
rewrite SNo_rec_ii_eq H L1 w Hw.
prove H w (SNo_rec_ii H) z = F w z SNo_rec2.
exact L2.
Qed.

End SurrealRec2.

Theorem SNo_ordinal_ind : forall P:set -> prop,
  (forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, P x)
  ->
  (forall x, SNo x -> P x).
let P.
assume H1.
let x. assume Hx: SNo x.
claim LLx: ordinal (SNoLev x).
{ exact SNoLev_ordinal x Hx. }
claim LsLx: ordinal (ordsucc (SNoLev x)).
{ exact ordinal_ordsucc (SNoLev x) LLx. }
claim LxsLx: x :e SNoS_ (ordsucc (SNoLev x)).
{ exact SNoS_SNoLev x Hx. }
exact H1 (ordsucc (SNoLev x)) LsLx x LxsLx.
Qed.

Theorem SNo_ordinal_ind2 : forall P:set -> set -> prop,
  (forall alpha, ordinal alpha ->
   forall beta, ordinal beta ->
   forall x :e SNoS_ alpha, forall y :e SNoS_ beta, P x y)
  ->
  (forall x y, SNo x -> SNo y -> P x y).
let P.
assume H1.
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
claim LLx: ordinal (SNoLev x).
{ exact SNoLev_ordinal x Hx. }
claim LsLx: ordinal (ordsucc (SNoLev x)).
{ exact ordinal_ordsucc (SNoLev x) LLx. }
claim LxsLx: x :e SNoS_ (ordsucc (SNoLev x)).
{ exact SNoS_SNoLev x Hx. }
claim LLy: ordinal (SNoLev y).
{ exact SNoLev_ordinal y Hy. }
claim LsLy: ordinal (ordsucc (SNoLev y)).
{ exact ordinal_ordsucc (SNoLev y) LLy. }
claim LysLy: y :e SNoS_ (ordsucc (SNoLev y)).
{ exact SNoS_SNoLev y Hy. }
exact H1 (ordsucc (SNoLev x)) LsLx
         (ordsucc (SNoLev y)) LsLy
         x LxsLx y LysLy.
Qed.

Theorem SNo_ordinal_ind3 : forall P:set -> set -> set -> prop,
  (forall alpha, ordinal alpha ->
   forall beta, ordinal beta ->
   forall gamma, ordinal gamma ->
   forall x :e SNoS_ alpha, forall y :e SNoS_ beta, forall z :e SNoS_ gamma, P x y z)
  ->
  (forall x y z, SNo x -> SNo y -> SNo z -> P x y z).
let P.
assume H1.
let x y z.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
claim LLx: ordinal (SNoLev x).
{ exact SNoLev_ordinal x Hx. }
claim LsLx: ordinal (ordsucc (SNoLev x)).
{ exact ordinal_ordsucc (SNoLev x) LLx. }
claim LxsLx: x :e SNoS_ (ordsucc (SNoLev x)).
{ exact SNoS_SNoLev x Hx. }
claim LLy: ordinal (SNoLev y).
{ exact SNoLev_ordinal y Hy. }
claim LsLy: ordinal (ordsucc (SNoLev y)).
{ exact ordinal_ordsucc (SNoLev y) LLy. }
claim LysLy: y :e SNoS_ (ordsucc (SNoLev y)).
{ exact SNoS_SNoLev y Hy. }
claim LLz: ordinal (SNoLev z).
{ exact SNoLev_ordinal z Hz. }
claim LsLz: ordinal (ordsucc (SNoLev z)).
{ exact ordinal_ordsucc (SNoLev z) LLz. }
claim LzsLz: z :e SNoS_ (ordsucc (SNoLev z)).
{ exact SNoS_SNoLev z Hz. }
exact H1 (ordsucc (SNoLev x)) LsLx
         (ordsucc (SNoLev y)) LsLy
         (ordsucc (SNoLev z)) LsLz
         x LxsLx y LysLy z LzsLz.
Qed.

Theorem SNoLev_ind : forall P:set -> prop,
  (forall x, SNo x -> (forall w :e SNoS_ (SNoLev x), P w) -> P x)
  ->
  (forall x, SNo x -> P x).
let P.
assume H1: forall x, SNo x -> (forall w :e SNoS_ (SNoLev x), P w) -> P x.
claim L1: forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, P x.
{ apply ordinal_ind.
  let alpha. assume Ha: ordinal alpha.
  assume IH: forall beta :e alpha, forall x :e SNoS_ beta, P x.
  let x. assume Hx: x :e SNoS_ alpha.
  apply SNoS_E2 alpha Ha x Hx.
  assume Hx1: SNoLev x :e alpha.
  assume Hx2: ordinal (SNoLev x).
  assume Hx3: SNo x.
  assume Hx4: SNo_ (SNoLev x) x.
  apply H1 x Hx3.
  prove forall w :e SNoS_ (SNoLev x), P w.
  exact IH (SNoLev x) Hx1.
}
exact SNo_ordinal_ind P L1.
Qed.

Theorem SNoLev_ind2 : forall P:set -> set -> prop,
  (forall x y, SNo x -> SNo y
    -> (forall w :e SNoS_ (SNoLev x), P w y)
    -> (forall z :e SNoS_ (SNoLev y), P x z)
    -> (forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), P w z)
    -> P x y)
-> forall x y, SNo x -> SNo y -> P x y.
let P.
assume H1: forall x y, SNo x -> SNo y
    -> (forall w :e SNoS_ (SNoLev x), P w y)
    -> (forall z :e SNoS_ (SNoLev y), P x z)
    -> (forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), P w z)
    -> P x y.
claim L1: forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall x :e SNoS_ alpha, forall y :e SNoS_ beta, P x y.
{ apply ordinal_ind.
  let alpha. assume Ha: ordinal alpha.
  assume IHa: forall gamma :e alpha, forall beta, ordinal beta -> forall x :e SNoS_ gamma, forall y :e SNoS_ beta, P x y.
  apply ordinal_ind.
  let beta. assume Hb: ordinal beta.
  assume IHb: forall delta :e beta, forall x :e SNoS_ alpha, forall y :e SNoS_ delta, P x y.
  let x. assume Hx: x :e SNoS_ alpha.
  let y. assume Hy: y :e SNoS_ beta.
  apply SNoS_E2 alpha Ha x Hx.
  assume Hx1: SNoLev x :e alpha.
  assume Hx2: ordinal (SNoLev x).
  assume Hx3: SNo x.
  assume Hx4: SNo_ (SNoLev x) x.
  apply SNoS_E2 beta Hb y Hy.
  assume Hy1: SNoLev y :e beta.
  assume Hy2: ordinal (SNoLev y).
  assume Hy3: SNo y.
  assume Hy4: SNo_ (SNoLev y) y.
  apply H1 x y Hx3 Hy3.
  - prove forall w :e SNoS_ (SNoLev x), P w y.
    let w. assume Hw: w :e SNoS_ (SNoLev x).
    exact IHa (SNoLev x) Hx1 beta Hb w Hw y Hy.
  - prove forall z :e SNoS_ (SNoLev y), P x z.
    exact IHb (SNoLev y) Hy1 x Hx.
  - prove forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), P w z.
    let w. assume Hw: w :e SNoS_ (SNoLev x).
    let z. assume Hz: z :e SNoS_ (SNoLev y).
    exact IHa (SNoLev x) Hx1 (SNoLev y) Hy2 w Hw z Hz.
}
exact SNo_ordinal_ind2 P L1.
Qed.

Theorem SNoLev_ind3 : forall P:set -> set -> set -> prop,
  (forall x y z, SNo x -> SNo y -> SNo z
    -> (forall u :e SNoS_ (SNoLev x), P u y z)
    -> (forall v :e SNoS_ (SNoLev y), P x v z)
    -> (forall w :e SNoS_ (SNoLev z), P x y w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), P u v z)
    -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), P u y w)
    -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P x v w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P u v w)
    -> P x y z)
 -> forall x y z, SNo x -> SNo y -> SNo z -> P x y z.
let P.
assume H1: forall x y z, SNo x -> SNo y -> SNo z
    -> (forall u :e SNoS_ (SNoLev x), P u y z)
    -> (forall v :e SNoS_ (SNoLev y), P x v z)
    -> (forall w :e SNoS_ (SNoLev z), P x y w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), P u v z)
    -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), P u y w)
    -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P x v w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P u v w)
    -> P x y z.
claim L1: forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall gamma, ordinal gamma -> forall x :e SNoS_ alpha, forall y :e SNoS_ beta, forall z :e SNoS_ gamma, P x y z.
{ apply ordinal_ind.
  let alpha. assume Ha: ordinal alpha.
  assume IHa: forall delta :e alpha, forall beta, ordinal beta -> forall gamma, ordinal gamma -> forall x :e SNoS_ delta, forall y :e SNoS_ beta, forall z :e SNoS_ gamma, P x y z.
  apply ordinal_ind.
  let beta. assume Hb: ordinal beta.
  assume IHb: forall delta :e beta, forall gamma, ordinal gamma -> forall x :e SNoS_ alpha, forall y :e SNoS_ delta, forall z :e SNoS_ gamma, P x y z.
  apply ordinal_ind.
  let gamma. assume Hc: ordinal gamma.
  assume IHc: forall delta :e gamma, forall x :e SNoS_ alpha, forall y :e SNoS_ beta, forall z :e SNoS_ delta, P x y z.
  let x. assume Hx: x :e SNoS_ alpha.
  let y. assume Hy: y :e SNoS_ beta.
  let z. assume Hz: z :e SNoS_ gamma.
  apply SNoS_E2 alpha Ha x Hx.
  assume Hx1: SNoLev x :e alpha.
  assume Hx2: ordinal (SNoLev x).
  assume Hx3: SNo x.
  assume Hx4: SNo_ (SNoLev x) x.
  apply SNoS_E2 beta Hb y Hy.
  assume Hy1: SNoLev y :e beta.
  assume Hy2: ordinal (SNoLev y).
  assume Hy3: SNo y.
  assume Hy4: SNo_ (SNoLev y) y.
  apply SNoS_E2 gamma Hc z Hz.
  assume Hz1: SNoLev z :e gamma.
  assume Hz2: ordinal (SNoLev z).
  assume Hz3: SNo z.
  assume Hz4: SNo_ (SNoLev z) z.
  apply H1 x y z Hx3 Hy3 Hz3.
  - prove forall u :e SNoS_ (SNoLev x), P u y z.
    let u. assume Hu: u :e SNoS_ (SNoLev x).
    exact IHa (SNoLev x) Hx1 beta Hb gamma Hc u Hu y Hy z Hz.
  - prove forall v :e SNoS_ (SNoLev y), P x v z.
    let v. assume Hv: v :e SNoS_ (SNoLev y).
    exact IHb (SNoLev y) Hy1 gamma Hc x Hx v Hv z Hz.
  - prove forall w :e SNoS_ (SNoLev z), P x y w.
    exact IHc (SNoLev z) Hz1 x Hx y Hy.
  - prove forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), P u v z.
    let u. assume Hu: u :e SNoS_ (SNoLev x).
    let v. assume Hv: v :e SNoS_ (SNoLev y).
    exact IHa (SNoLev x) Hx1 (SNoLev y) Hy2 gamma Hc u Hu v Hv z Hz.
  - prove forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), P u y w.
    let u. assume Hu: u :e SNoS_ (SNoLev x).
    let w. assume Hw: w :e SNoS_ (SNoLev z).
    exact IHa (SNoLev x) Hx1 beta Hb (SNoLev z) Hz2 u Hu y Hy w Hw.
  - prove forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P x v w.
    let v. assume Hv: v :e SNoS_ (SNoLev y).
    let w. assume Hw: w :e SNoS_ (SNoLev z).
    exact IHb (SNoLev y) Hy1 (SNoLev z) Hz2 x Hx v Hv w Hw.
  - prove forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P u v w.
    let u. assume Hu: u :e SNoS_ (SNoLev x).
    let v. assume Hv: v :e SNoS_ (SNoLev y).
    let w. assume Hw: w :e SNoS_ (SNoLev z).
    exact IHa (SNoLev x) Hx1 (SNoLev y) Hy2 (SNoLev z) Hz2 u Hu v Hv w Hw.
}
exact SNo_ordinal_ind3 P L1.
Qed.

Theorem SNo_omega : SNo omega.
exact ordinal_SNo omega omega_ordinal.
Qed.

Theorem SNoLt_0_1 : 0 < 1.
apply ordinal_In_SNoLt 1 ordinal_1 0.
prove 0 :e 1.
exact In_0_1.
Qed.

Theorem SNoLt_0_2 : 0 < 2.
apply ordinal_In_SNoLt 2 ordinal_2 0.
prove 0 :e 2.
exact In_0_2.
Qed.

Theorem SNoLt_1_2 : 1 < 2.
apply ordinal_In_SNoLt 2 ordinal_2 1.
prove 1 :e 2.
exact In_1_2.
Qed.

Theorem restr_SNo_ : forall x, SNo x -> forall alpha :e SNoLev x, SNo_ alpha (x :/\: SNoElts_ alpha).
let x. assume Hx. let alpha. assume Ha.
claim Lx1: SNo_ (SNoLev x) x.
{ exact SNoLev_ x Hx. }
apply Lx1.
assume Hx1: x c= SNoElts_ (SNoLev x).
assume Hx2: forall beta :e SNoLev x, exactly1of2 (SetAdjoin beta {1} :e x) (beta :e x).
prove x :/\: SNoElts_ alpha c= SNoElts_ alpha
   /\ forall beta :e alpha, exactly1of2 (SetAdjoin beta {1} :e x :/\: SNoElts_ alpha) (beta :e x :/\: SNoElts_ alpha).
apply andI.
- exact binintersect_Subq_2 x (SNoElts_ alpha).
- let beta. assume Hb: beta :e alpha.
  claim Lb: beta :e SNoLev x.
  { exact ordinal_TransSet (SNoLev x) (SNoLev_ordinal x Hx) alpha Ha beta Hb. }
  apply exactly1of2_E (SetAdjoin beta {1} :e x) (beta :e x) (Hx2 beta Lb).
  + assume H1: SetAdjoin beta {1} :e x.
    assume H2: beta /:e x.
    apply exactly1of2_I1.
    * { apply binintersectI.
        - exact H1.
        - prove SetAdjoin beta {1} :e SNoElts_ alpha.
          prove SetAdjoin beta {1} :e alpha :\/: {SetAdjoin beta {1}|beta :e alpha}.
          apply binunionI2.
          exact ReplI alpha (fun beta => SetAdjoin beta {1}) beta Hb.
      }
    * prove beta /:e x :/\: SNoElts_ alpha.
      assume H3. exact H2 (binintersectE1 x (SNoElts_ alpha) beta H3).
  + assume H1: SetAdjoin beta {1} /:e x.
    assume H2: beta :e x.
    apply exactly1of2_I2.
    * assume H3: SetAdjoin beta {1} :e x :/\: SNoElts_ alpha.
      exact H1 (binintersectE1 x (SNoElts_ alpha) (SetAdjoin beta {1}) H3).
    * { apply binintersectI.
        - exact H2.
        - prove beta :e SNoElts_ alpha.
          prove beta :e alpha :\/: {SetAdjoin beta {1}|beta :e alpha}.
          apply binunionI1. exact Hb.
      }
Qed.

Theorem restr_SNo : forall x, SNo x -> forall alpha :e SNoLev x, SNo (x :/\: SNoElts_ alpha).
let x. assume Hx. let alpha. assume Ha.
claim La: ordinal alpha.
{ exact ordinal_Hered (SNoLev x) (SNoLev_ordinal x Hx) alpha Ha. }
claim L1: SNo_ alpha (x :/\: SNoElts_ alpha).
{ exact restr_SNo_ x Hx alpha Ha. }
exact SNo_SNo alpha La (x :/\: SNoElts_ alpha) L1.
Qed.

Theorem restr_SNoLev : forall x, SNo x -> forall alpha :e SNoLev x, SNoLev (x :/\: SNoElts_ alpha) = alpha.
let x. assume Hx. let alpha. assume Ha.
claim La: ordinal alpha.
{ exact ordinal_Hered (SNoLev x) (SNoLev_ordinal x Hx) alpha Ha. }
claim L1: SNo_ alpha (x :/\: SNoElts_ alpha).
{ exact restr_SNo_ x Hx alpha Ha. }
exact SNoLev_uniq2 alpha La (x :/\: SNoElts_ alpha) L1.
Qed.

Theorem restr_SNoEq : forall x, SNo x -> forall alpha :e SNoLev x, SNoEq_ alpha (x :/\: SNoElts_ alpha) x.
let x. assume Hx.
let alpha. assume Ha.
apply SNoEq_I.
let beta. assume Hb: beta :e alpha.
prove beta :e x :/\: SNoElts_ alpha <-> beta :e x.
apply iffI.
- assume H1: beta :e x :/\: SNoElts_ alpha.
  exact binintersectE1 x (SNoElts_ alpha) beta H1.
- assume H1: beta :e x.
  apply binintersectI.
  + exact H1.
  + prove beta :e alpha :\/: {SetAdjoin beta {1}|beta :e alpha}.
    apply binunionI1. exact Hb.
Qed.

Theorem SNo_extend0_restr_eq : forall x, SNo x -> x = SNo_extend0 x :/\: SNoElts_ (SNoLev x).
let x. assume Hx.
claim L1: SNo (SNo_extend0 x).
{ exact SNo_extend0_SNo x Hx. }
claim L2: SNoLev x :e SNoLev (SNo_extend0 x).
{ rewrite SNo_extend0_SNoLev x Hx. apply ordsuccI2. }
apply SNo_eq.
- exact Hx.
- apply restr_SNo.
  + exact L1.
  + exact L2.
- prove SNoLev x = SNoLev (SNo_extend0 x :/\: SNoElts_ (SNoLev x)).
  symmetry.
  apply restr_SNoLev.
  + exact L1.
  + exact L2.
- prove SNoEq_ (SNoLev x) x (SNo_extend0 x :/\: SNoElts_ (SNoLev x)).
  apply SNoEq_sym_.
  apply SNoEq_tra_ (SNoLev x) (SNo_extend0 x :/\: SNoElts_ (SNoLev x)) (SNo_extend0 x) x.
  + prove SNoEq_ (SNoLev x) (SNo_extend0 x :/\: SNoElts_ (SNoLev x)) (SNo_extend0 x).
    exact restr_SNoEq (SNo_extend0 x) L1 (SNoLev x) L2.
  + prove SNoEq_ (SNoLev x) (SNo_extend0 x) x.
    exact SNo_extend0_SNoEq x Hx.
Qed.

Theorem SNo_extend1_restr_eq : forall x, SNo x -> x = SNo_extend1 x :/\: SNoElts_ (SNoLev x).
let x. assume Hx.
claim L1: SNo (SNo_extend1 x).
{ exact SNo_extend1_SNo x Hx. }
claim L2: SNoLev x :e SNoLev (SNo_extend1 x).
{ rewrite SNo_extend1_SNoLev x Hx. apply ordsuccI2. }
apply SNo_eq.
- exact Hx.
- apply restr_SNo.
  + exact L1.
  + exact L2.
- prove SNoLev x = SNoLev (SNo_extend1 x :/\: SNoElts_ (SNoLev x)).
  symmetry.
  apply restr_SNoLev.
  + exact L1.
  + exact L2.
- prove SNoEq_ (SNoLev x) x (SNo_extend1 x :/\: SNoElts_ (SNoLev x)).
  apply SNoEq_sym_.
  apply SNoEq_tra_ (SNoLev x) (SNo_extend1 x :/\: SNoElts_ (SNoLev x)) (SNo_extend1 x) x.
  + prove SNoEq_ (SNoLev x) (SNo_extend1 x :/\: SNoElts_ (SNoLev x)) (SNo_extend1 x).
    exact restr_SNoEq (SNo_extend1 x) L1 (SNoLev x) L2.
  + prove SNoEq_ (SNoLev x) (SNo_extend1 x) x.
    exact SNo_extend1_SNoEq x Hx.
Qed.

Opaque eps_ SNo_rec2 SNo_rec_ii SNo_rec_i SNoLev SNo.

Section SurrealMinus.
(* Parameter minus_SNo "6d39c64862ac40c95c6f5e4ed5f02bb019279bfb0cda8c9bbe0e1b813b1e876c" "268a6c1da15b8fe97d37be85147bc7767b27098cdae193faac127195e8824808" *)
Definition minus_SNo : set -> set
  := SNo_rec_i (fun x m => SNoCut {m z|z :e SNoR x} {m w|w :e SNoL x}).
Prefix - 358 := minus_SNo.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem minus_SNo_eq : forall x, SNo x -> - x = SNoCut {- z|z :e SNoR x} {- w|w :e SNoL x}.
claim L1: forall x, SNo x ->
  forall g h:set -> set, (forall w :e SNoS_ (SNoLev x), g w = h w)
   -> SNoCut {g z|z :e SNoR x} {g w|w :e SNoL x}
    = SNoCut {h z|z :e SNoR x} {h w|w :e SNoL x}.
{ let x. assume Hx: SNo x.
  let g h.
  assume Hgh: forall w :e SNoS_ (SNoLev x), g w = h w.
  prove SNoCut {g z|z :e SNoR x} {g w|w :e SNoL x}
      = SNoCut {h z|z :e SNoR x} {h w|w :e SNoL x}.
  claim L1a: {g z|z :e SNoR x} = {h z|z :e SNoR x}.
  { apply ReplEq_ext.
    let z. assume Hz: z :e SNoR x.
    prove g z = h z.
    apply Hgh.
    prove z :e SNoS_ (SNoLev x).
    exact SNoR_SNoS x Hx z Hz.
  }
  claim L1b: {g w|w :e SNoL x} = {h w|w :e SNoL x}.
  { apply ReplEq_ext.
    let w. assume Hw: w :e SNoL x.
    prove g w = h w.
    apply Hgh.
    prove w :e SNoS_ (SNoLev x).
    exact SNoL_SNoS x Hx w Hw.
  }
  rewrite L1a. rewrite L1b. reflexivity.
}
exact SNo_rec_i_eq (fun x m => SNoCut {m z|z :e SNoR x} {m w|w :e SNoL x}) L1.
Qed.

Theorem minus_SNo_prop1 : forall x, SNo x -> SNo (- x) /\ (forall u :e SNoL x, - x < - u) /\ (forall u :e SNoR x, - u < - x) /\ SNoCutP {- z|z :e SNoR x} {- w|w :e SNoL x}.
apply SNoLev_ind.
let x. assume Hx: SNo x.
assume IH: forall w :e SNoS_ (SNoLev x), SNo (- w) /\ (forall u :e SNoL w, - w < - u) /\ (forall u :e SNoR w, - u < - w) /\ SNoCutP {- z|z :e SNoR w} {- v|v :e SNoL w}.
claim IHLx : forall w :e SNoL x, SNo (- w) /\ (forall u :e SNoL w, - w < - u) /\ (forall u :e SNoR w, - u < - w).
{ let w. assume Hw: w :e SNoL x.
  apply SNoL_E x Hx w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev x.
  assume Hw3: w < x.
  claim Lw: w :e SNoS_ (SNoLev x).
  { exact SNoS_I2 w x Hw1 Hx Hw2. }
  apply IH w Lw. assume H _. exact H.
}
claim IHRx : forall z :e SNoR x, SNo (- z) /\ (forall u :e SNoL z, - z < - u) /\ (forall u :e SNoR z, - u < - z).
{ let w. assume Hw: w :e SNoR x.
  apply SNoR_E x Hx w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev x.
  assume Hw3: x < w.
  claim Lw: w :e SNoS_ (SNoLev x).
  { exact SNoS_I2 w x Hw1 Hx Hw2. }
  apply IH w Lw. assume H _. exact H.
}
set L := {- z|z :e SNoR x}.
set R := {- w|w :e SNoL x}.
claim LLR: SNoCutP L R.
{ prove (forall w :e L, SNo w)
     /\ (forall z :e R, SNo z)
     /\ (forall w :e L, forall z :e R, w < z).
  apply and3I.
  - let w. assume Hw: w :e L.
    prove SNo w.
    apply ReplE_impred (SNoR x) (fun z => - z) w Hw.
    let z.
    assume Hz: z :e SNoR x.
    assume Hwz: w = - z.
    apply IHRx z Hz. assume H2. apply H2.
    assume H2: SNo (- z).
    assume _ _.
    prove SNo w.
    rewrite Hwz. exact H2.
  - let z. assume Hz: z :e R.
    prove SNo z.
    apply ReplE_impred (SNoL x) (fun w => - w) z Hz.
    let w.
    assume Hw: w :e SNoL x.
    assume Hzw: z = - w.
    apply IHLx w Hw. assume H2. apply H2.
    assume H2: SNo (- w).
    assume _ _.
    prove SNo z.
    rewrite Hzw. exact H2.
  - let w. assume Hw: w :e L.
    let z. assume Hz: z :e R.
    apply ReplE_impred (SNoR x) (fun z => - z) w Hw.
    let u.
    assume Hu: u :e SNoR x.
    assume Hwu: w = - u.
    apply SNoR_E x Hx u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev x.
    assume Hu3: x < u.
    apply SNoLev_prop u Hu1.
    assume Hu1a: ordinal (SNoLev u).
    assume Hu1b: SNo_ (SNoLev u) u.
    apply ReplE_impred (SNoL x) (fun w => - w) z Hz.
    let v.
    assume Hv: v :e SNoL x.
    assume Hzv: z = - v.
    apply SNoL_E x Hx v Hv.
    assume Hv1: SNo v.
    assume Hv2: SNoLev v :e SNoLev x.
    assume Hv3: v < x.
    apply SNoLev_prop v Hv1.
    assume Hv1a: ordinal (SNoLev v).
    assume Hv1b: SNo_ (SNoLev v) v.
    apply IHLx v Hv. assume H2. apply H2.
    assume H2: SNo (- v).
    assume H3: forall u :e SNoL v, - v < - u.
    assume H4: forall u :e SNoR v, - u < - v.
    apply IHRx u Hu. assume H5. apply H5.
    assume H5: SNo (- u).
    assume H6: forall v :e SNoL u, - u < - v.
    assume H7: forall v :e SNoR u, - v < - u.
    prove w < z.
    rewrite Hwu. rewrite Hzv.
    prove - u < - v.
    claim Lvu: v < u.
    { exact SNoLt_tra v x u Hv1 Hx Hu1 Hv3 Hu3. }
    apply SNoLtE v u Hv1 Hu1 Lvu.
    + let z. assume Hz: SNo z.
      assume Hz1: SNoLev z :e SNoLev v :/\: SNoLev u.
      assume Hz2: SNoEq_ (SNoLev z) z v.
      assume Hz3: SNoEq_ (SNoLev z) z u.
      assume Hz4: v < z.
      assume Hz5: z < u.
      assume Hz6: SNoLev z /:e v.
      assume Hz7: SNoLev z :e u.
      apply SNoLev_prop z Hz.
      assume Hza: ordinal (SNoLev z).
      assume Hzb: SNo_ (SNoLev z) z.
      apply binintersectE (SNoLev v) (SNoLev u) (SNoLev z) Hz1.
      assume Hz1a: SNoLev z :e SNoLev v.
      assume Hz1b: SNoLev z :e SNoLev u.
      claim LzLx: z :e SNoS_ (SNoLev x).
      { apply SNoS_I2 z x Hz Hx.
        prove SNoLev z :e SNoLev x.
        apply SNoLev_ordinal x Hx.
        assume Hx2: TransSet (SNoLev x).
        assume _.
        exact Hx2 (SNoLev u) Hu2 (SNoLev z) Hz1b.
      }
      claim Lmz: SNo (- z).
      { apply IH z LzLx.
        assume H. apply H. assume H. apply H. assume H _ _ _. exact H.
      }
      prove - u < - v.
      apply SNoLt_tra (- u) (- z) (- v) H5 Lmz H2.
      * { prove - u < - z.
          apply H6.
          prove z :e SNoL u.
          prove z :e {x :e SNoS_ (SNoLev u) | x < u}.
          apply SepI.
          - prove z :e SNoS_ (SNoLev u).
            apply SNoS_I2 z u Hz Hu1 Hz1b.
          - prove z < u. exact Hz5.
        }
      * { prove - z < - v.
          apply H4.
          prove z :e SNoR v.
          prove z :e {x :e SNoS_ (SNoLev v) | v < x}.
          apply SepI.
          - prove z :e SNoS_ (SNoLev v).
            exact SNoS_I2 z v Hz Hv1 Hz1a.
          - prove v < z. exact Hz4.
        }
    + assume H8: SNoLev v :e SNoLev u.
      assume H9: SNoEq_ (SNoLev v) v u.
      assume H10: SNoLev v :e u.
      prove - u < - v.
      apply H6.
      prove v :e SNoL u.
      prove v :e {x :e SNoS_ (SNoLev u) | x < u}.
      apply SepI.
      * prove v :e SNoS_ (SNoLev u).
        exact SNoS_I2 v u Hv1 Hu1 H8.
      * prove v < u. exact Lvu.
    + assume H8: SNoLev u :e SNoLev v.
      assume H9: SNoEq_ (SNoLev u) v u.
      assume H10: SNoLev u /:e v.
      prove - u < - v.
      apply H4.
      prove u :e SNoR v.
      prove u :e {x :e SNoS_ (SNoLev v) | v < x}.
      apply SepI.
      * prove u :e SNoS_ (SNoLev v).
        exact SNoS_I2 u v Hu1 Hv1 H8.
      * prove v < u. exact Lvu.
}
claim LNLR: SNo (SNoCut L R).
{ exact SNoCutP_SNo_SNoCut L R LLR. }
apply andI.
- rewrite minus_SNo_eq x Hx. 
  apply and3I.
  + prove SNo (SNoCut L R). exact LNLR.
  + prove forall u :e SNoL x, SNoCut L R < - u.
    let u. assume Hu: u :e SNoL x.
    prove SNoCut L R < - u.
    apply SNoL_E x Hx u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev x.
    assume Hu3: u < x.
    claim LmuR: - u :e R.
    { apply ReplI. prove u :e SNoL x. exact Hu. }
    prove SNoCut L R < - u.
    exact SNoCutP_SNoCut_R L R LLR (- u) LmuR. (** Using LLR here which was proven using IH **)
  + prove forall u :e SNoR x, - u < SNoCut L R.
    let u. assume Hu: u :e SNoR x.
    prove - u < SNoCut L R.
    apply SNoR_E x Hx u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev x.
    assume Hu3: x < u.
    claim LmuL: - u :e L.
    { apply ReplI. prove u :e SNoR x. exact Hu. }
    prove - u < SNoCut L R.
    exact SNoCutP_SNoCut_L L R LLR (- u) LmuL. (** Using LLR here which was proven using IH **)
- prove SNoCutP L R. exact LLR.
Qed.

Theorem SNo_minus_SNo : forall x, SNo x -> SNo (- x).
let x. assume Hx.
apply minus_SNo_prop1 x Hx.
assume H. apply H. assume H. apply H.
assume H _ _ _. exact H.
Qed.

Theorem minus_SNo_Lt_contra : forall x y, SNo x -> SNo y -> x < y -> - y < - x.
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hxy: x < y.
apply minus_SNo_prop1 x Hx.
assume H1. apply H1. assume H1. apply H1.
assume H1: SNo (- x).
assume H2: forall u :e SNoL x, - x < - u.
assume H3: forall u :e SNoR x, - u < - x.
assume _.
apply minus_SNo_prop1 y Hy.
assume H4. apply H4. assume H4. apply H4.
assume H4: SNo (- y).
assume H5: forall u :e SNoL y, - y < - u.
assume H6: forall u :e SNoR y, - u < - y.
assume _.
apply SNoLtE x y Hx Hy Hxy.
- let z. assume Hz: SNo z.
  assume Hz1: SNoLev z :e SNoLev x :/\: SNoLev y.
  assume Hz2: SNoEq_ (SNoLev z) z x.
  assume Hz3: SNoEq_ (SNoLev z) z y.
  assume Hz4: x < z.
  assume Hz5: z < y.
  assume Hz6: SNoLev z /:e x.
  assume Hz7: SNoLev z :e y.
  apply binintersectE (SNoLev x) (SNoLev y) (SNoLev z) Hz1.
  assume Hz1x Hz1y.
  prove - y < - x.
  apply SNoLt_tra (- y) (- z) (- x) H4 (SNo_minus_SNo z Hz) H1.
  + prove - y < - z.
    apply H5 z.
    prove z :e SNoL y.
    prove z :e {x :e SNoS_ (SNoLev y) | x < y}.
    apply SepI.
    * prove z :e SNoS_ (SNoLev y).
      exact SNoS_I2 z y Hz Hy Hz1y.
    * prove z < y. exact Hz5.
  + prove - z < - x.
    apply H3 z.
    prove z :e SNoR x.
    prove z :e {z :e SNoS_ (SNoLev x) | x < z}.
    apply SepI.
    * prove z :e SNoS_ (SNoLev x).
      exact SNoS_I2 z x Hz Hx Hz1x.
    * prove x < z. exact Hz4.
- assume H7: SNoLev x :e SNoLev y.
  assume H8: SNoEq_ (SNoLev x) x y.
  assume H9: SNoLev x :e y.
  apply H5 x.
  prove x :e SNoL y.
  prove x :e {x :e SNoS_ (SNoLev y) | x < y}.
  apply SepI.
  + prove x :e SNoS_ (SNoLev y).
    exact SNoS_I2 x y Hx Hy H7.
  + prove x < y. exact Hxy.
- assume H7: SNoLev y :e SNoLev x.
  assume H8: SNoEq_ (SNoLev y) x y.
  assume H9: SNoLev y /:e x.
  prove - y < - x.
  apply H3 y.
  prove y :e SNoR x.
  prove y :e {y :e SNoS_ (SNoLev x) | x < y}.
  apply SepI.
  + prove y :e SNoS_ (SNoLev x).
    exact SNoS_I2 y x Hy Hx H7.
  + prove x < y. exact Hxy.
Qed.

Theorem minus_SNo_Le_contra : forall x y, SNo x -> SNo y -> x <= y -> - y <= - x.
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hxy: x <= y.
apply SNoLeE x y Hx Hy Hxy.
- assume H1: x < y.
  prove -y <= -x.
  apply SNoLtLe.
  prove -y < -x.
  exact minus_SNo_Lt_contra x y Hx Hy H1.
- assume H1: x = y.
  prove -y <= -x.
  rewrite H1.
  prove -y <= -y.
  apply SNoLe_ref.
Qed.

Theorem minus_SNo_SNoCutP : forall x, SNo x -> SNoCutP {- z|z :e SNoR x} {- w|w :e SNoL x}.
let x. assume Hx: SNo x.
apply minus_SNo_prop1 x Hx.
assume H1. apply H1. assume H1. apply H1.
assume _ _ _ H1.
exact H1.
Qed.

Theorem minus_SNo_SNoCutP_gen : forall L R, SNoCutP L R -> SNoCutP {- z|z :e R} {- w|w :e L}.
let L R.
assume HLR: SNoCutP L R.
apply HLR. assume H. apply H.
assume HLR1: forall x :e L, SNo x.
assume HLR2: forall y :e R, SNo y.
assume HLR3: forall x :e L, forall y :e R, x < y.
set Lm := {- z|z :e R}.
set Rm := {- w|w :e L}.
prove (forall w :e Lm, SNo w)
   /\ (forall z :e Rm, SNo z)
   /\ (forall w :e Lm, forall z :e Rm, w < z).
apply and3I.
- let w. assume Hw: w :e Lm.
  prove SNo w.
  apply ReplE_impred R (fun z => - z) w Hw.
  let z.
  assume Hz: z :e R.
  assume Hwz: w = - z.
  rewrite Hwz.
  prove SNo (- z).
  apply SNo_minus_SNo.
  apply HLR2. exact Hz.
- let z. assume Hz: z :e Rm.
  prove SNo z.
  apply ReplE_impred L (fun w => - w) z Hz.
  let w.
  assume Hw: w :e L.
  assume Hzw: z = -w.
  rewrite Hzw.
  prove SNo (-w).
  apply SNo_minus_SNo.
  exact HLR1 w Hw.
- let w. assume Hw: w :e Lm.
  let z. assume Hz: z :e Rm.
  apply ReplE_impred R (fun z => - z) w Hw.
  let u.
  assume Hu: u :e R.
  assume Hwu: w = -u.
  apply ReplE_impred L (fun w => - w) z Hz.
  let v.
  assume Hv: v :e L.
  assume Hzv: z = -v.
  prove w < z.
  rewrite Hwu. rewrite Hzv.
  prove -u < -v.
  apply minus_SNo_Lt_contra v u (HLR1 v Hv) (HLR2 u Hu).
  prove v < u.
  exact HLR3 v Hv u Hu.
Qed.

Theorem minus_SNo_Lev_lem1 : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, SNoLev (- x) c= SNoLev x.
apply ordinal_ind.
let alpha. assume Ha: ordinal alpha.
apply Ha. assume Ha1 Ha2.
assume IH: forall beta :e alpha, forall x :e SNoS_ beta, SNoLev (- x) c= SNoLev x.
let x. assume Hx: x :e SNoS_ alpha.
apply SNoS_E2 alpha Ha x Hx.
assume Hx1: SNoLev x :e alpha.
assume Hx2: ordinal (SNoLev x).
assume Hx3: SNo x.
assume Hx4: SNo_ (SNoLev x) x.
set L := {- z|z :e SNoR x}.
set R := {- w|w :e SNoL x}.
claim LLR: SNoCutP L R.
{ exact minus_SNo_SNoCutP x Hx3. }
prove SNoLev (- x) c= SNoLev x.
rewrite minus_SNo_eq x Hx3.
prove SNoLev (SNoCut L R) c= SNoLev x.
apply SNoCutP_SNoCut_impred L R LLR.
assume H2: SNo (SNoCut L R).
assume H3: SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume _ _ _.
claim L3: ordinal ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
{ apply ordinal_binunion.
  - apply ordinal_famunion.
    let w. assume Hw: w :e L.
    prove ordinal (ordsucc (SNoLev w)).
    apply ReplE_impred (SNoR x) (fun z => - z) w Hw.
    let u.
    assume Hu: u :e SNoR x.
    assume Hwu: w = - u.
    apply SNoR_E x Hx3 u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev x.
    assume Hu3: x < u.
    apply ordinal_ordsucc.
    prove ordinal (SNoLev w).
    apply SNoLev_ordinal.
    prove SNo w.
    rewrite Hwu.
    exact SNo_minus_SNo u Hu1.
  - apply ordinal_famunion.
    let w. assume Hw: w :e R.
    prove ordinal (ordsucc (SNoLev w)).
    apply ReplE_impred (SNoL x) (fun z => - z) w Hw.
    let u.
    assume Hu: u :e SNoL x.
    assume Hwu: w = - u.
    apply SNoL_E x Hx3 u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev x.
    assume Hu3: u < x.
    apply ordinal_ordsucc.
    prove ordinal (SNoLev w).
    apply SNoLev_ordinal.
    prove SNo w.
    rewrite Hwu.
    exact SNo_minus_SNo u Hu1.
}
claim L3a: TransSet ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
{ apply L3. assume H _. exact H. }
let beta. assume Hb: beta :e SNoLev (SNoCut L R).
claim Lb: beta :e ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
{ apply ordsuccE ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))) (SNoLev (SNoCut L R)) H3.
  - assume H4. exact L3a (SNoLev (SNoCut L R)) H4 beta Hb.
  - assume H4. rewrite <- H4. exact Hb.
}
prove beta :e SNoLev x.
apply binunionE (\/_ x :e L, ordsucc (SNoLev x)) (\/_ y :e R, ordsucc (SNoLev y)) beta Lb.
- assume H4: beta :e \/_ x :e L, ordsucc (SNoLev x).
  apply famunionE L (fun x => ordsucc (SNoLev x)) beta H4.
  let w. assume Hw. apply Hw.
  assume Hw1: w :e L.
  assume Hw2: beta :e ordsucc (SNoLev w).
  prove beta :e SNoLev x.
  apply ReplE_impred (SNoR x) (fun z => - z) w Hw1.
  let u.
  assume Hu: u :e SNoR x.
  assume Hwu: w = - u.
  apply SNoR_E x Hx3 u Hu.
  assume Hu1: SNo u.
  assume Hu2: SNoLev u :e SNoLev x.
  assume Hu3: x < u.
  claim Lu: u :e SNoS_ (ordsucc (SNoLev u)).
  { exact SNoS_SNoLev u Hu1. }
  claim LsLu: ordsucc (SNoLev u) :e alpha.
  { apply ordinal_ordsucc_In_eq (SNoLev x) (SNoLev u) Hx2 Hu2.
    - assume H2: ordsucc (SNoLev u) :e SNoLev x.
      exact Ha1 (SNoLev x) Hx1 (ordsucc (SNoLev u)) H2.
    - assume H2: SNoLev x = ordsucc (SNoLev u).
      rewrite <- H2. exact Hx1.
  }
  claim IHu: SNoLev (- u) c= SNoLev u.
  { exact IH (ordsucc (SNoLev u)) LsLu u Lu. }
  claim LLu: ordinal (SNoLev u).
  { exact SNoLev_ordinal u Hu1. }
  claim Lmu: SNo (- u).
  { exact SNo_minus_SNo u Hu1. }
  claim LLmu: ordinal (SNoLev (- u)).
  { exact SNoLev_ordinal (- u) Lmu. }
  claim LsLw: ordinal (ordsucc (SNoLev w)).
  { apply ordinal_ordsucc. rewrite Hwu. exact LLmu. }
  claim Lb: ordinal beta.
  { exact ordinal_Hered (ordsucc (SNoLev w)) LsLw beta Hw2. }
  apply ordinal_In_Or_Subq beta (SNoLev x) Lb Hx2.
  + assume H5: beta :e SNoLev x. exact H5.
  + assume H5: SNoLev x c= beta.
    prove False.
    claim LLub: SNoLev u :e beta.
    { exact H5 (SNoLev u) Hu2. }
    apply ordsuccE (SNoLev w) beta Hw2.
    * rewrite Hwu. assume H5: beta :e SNoLev (- u).
      apply In_no2cycle (SNoLev u) beta LLub.
      prove beta :e SNoLev u.
      exact IHu beta H5.
    * rewrite Hwu. assume H5: beta = SNoLev (- u).
      apply In_irref (SNoLev u).
      apply IHu (SNoLev u).
      prove SNoLev u :e SNoLev (- u). rewrite <- H5. exact LLub.
- assume H4: beta :e \/_ y :e R, ordsucc (SNoLev y).
  apply famunionE R (fun x => ordsucc (SNoLev x)) beta H4.
  let w. assume Hw. apply Hw.
  assume Hw1: w :e R.
  assume Hw2: beta :e ordsucc (SNoLev w).
  prove beta :e SNoLev x.
  apply ReplE_impred (SNoL x) (fun z => - z) w Hw1.
  let u.
  assume Hu: u :e SNoL x.
  assume Hwu: w = - u.
  apply SNoL_E x Hx3 u Hu.
  assume Hu1: SNo u.
  assume Hu2: SNoLev u :e SNoLev x.
  assume Hu3: u < x.
  claim Lu: u :e SNoS_ (ordsucc (SNoLev u)).
  { exact SNoS_SNoLev u Hu1. }
  claim LsLu: ordsucc (SNoLev u) :e alpha.
  { apply ordinal_ordsucc_In_eq (SNoLev x) (SNoLev u) Hx2 Hu2.
    - assume H2: ordsucc (SNoLev u) :e SNoLev x.
      exact Ha1 (SNoLev x) Hx1 (ordsucc (SNoLev u)) H2.
    - assume H2: SNoLev x = ordsucc (SNoLev u).
      rewrite <- H2. exact Hx1.
  }
  claim IHu: SNoLev (- u) c= SNoLev u.
  { exact IH (ordsucc (SNoLev u)) LsLu u Lu. }
  claim LLu: ordinal (SNoLev u).
  { exact SNoLev_ordinal u Hu1. }
  claim Lmu: SNo (- u).
  { exact SNo_minus_SNo u Hu1. }
  claim LLmu: ordinal (SNoLev (- u)).
  { exact SNoLev_ordinal (- u) Lmu. }
  claim LsLw: ordinal (ordsucc (SNoLev w)).
  { apply ordinal_ordsucc. rewrite Hwu. exact LLmu. }
  claim Lb: ordinal beta.
  { exact ordinal_Hered (ordsucc (SNoLev w)) LsLw beta Hw2. }
  apply ordinal_In_Or_Subq beta (SNoLev x) Lb Hx2.
  + assume H5: beta :e SNoLev x. exact H5.
  + assume H5: SNoLev x c= beta.
    prove False.
    claim LLub: SNoLev u :e beta.
    { exact H5 (SNoLev u) Hu2. }
    apply ordsuccE (SNoLev w) beta Hw2.
    * rewrite Hwu. assume H5: beta :e SNoLev (- u).
      apply In_no2cycle (SNoLev u) beta LLub.
      prove beta :e SNoLev u.
      exact IHu beta H5.
    * rewrite Hwu. assume H5: beta = SNoLev (- u).
      apply In_irref (SNoLev u).
      apply IHu (SNoLev u).
      prove SNoLev u :e SNoLev (- u). rewrite <- H5. exact LLub.
Qed.

Theorem minus_SNo_Lev_lem2 : forall x, SNo x -> SNoLev (- x) c= SNoLev x.
let x. assume Hx: SNo x.
claim LLx: ordinal (SNoLev x).
{ exact SNoLev_ordinal x Hx. }
claim LsLx: ordinal (ordsucc (SNoLev x)).
{ exact ordinal_ordsucc (SNoLev x) LLx. }
claim LxsLx: x :e SNoS_ (ordsucc (SNoLev x)).
{ exact SNoS_SNoLev x Hx. }
exact minus_SNo_Lev_lem1 (ordsucc (SNoLev x)) LsLx x LxsLx.
Qed.

Theorem minus_SNo_invol : forall x, SNo x -> - - x = x.
apply SNo_ind.
let L R.
assume HLR: SNoCutP L R.
assume IHL: forall x :e L, - - x = x.
assume IHR: forall y :e R, - - y = y.
apply HLR. assume H. apply H.
assume HLR1: forall x :e L, SNo x.
assume HLR2: forall y :e R, SNo y.
assume HLR3: forall x :e L, forall y :e R, x < y.
claim LCLR: SNo (SNoCut L R).
{ exact SNoCutP_SNo_SNoCut L R HLR. }
claim LmCLR: SNo (- SNoCut L R).
{ apply SNo_minus_SNo. exact LCLR. }
claim LmmCLR: SNo (- - SNoCut L R).
{ apply SNo_minus_SNo. exact LmCLR. }
claim L1: SNoLev (SNoCut L R) c= SNoLev (- - SNoCut L R)
       /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) (- - SNoCut L R).
{ apply SNoCutP_SNoCut_fst.
  - exact HLR.
  - prove SNo (- - SNoCut L R). exact LmmCLR.
  - prove forall x :e L, x < - - SNoCut L R.
    let x. assume Hx. rewrite <- IHL x Hx.
    claim Lx: SNo x.
    { exact HLR1 x Hx. }
    claim Lmx: SNo (- x).
    { exact SNo_minus_SNo x Lx. }
    prove - - x < - - SNoCut L R.
    apply minus_SNo_Lt_contra (- SNoCut L R) (- x) LmCLR Lmx.
    prove - SNoCut L R < - x.
    apply minus_SNo_Lt_contra x (SNoCut L R) Lx LCLR.
    prove x < SNoCut L R.
    exact SNoCutP_SNoCut_L L R HLR x Hx.
  - prove forall y :e R, - - SNoCut L R < y.
    let y. assume Hy. rewrite <- IHR y Hy.
    claim Ly: SNo y.
    { exact HLR2 y Hy. }
    claim Lmy: SNo (- y).
    { exact SNo_minus_SNo y Ly. }
    prove - - SNoCut L R < - - y.
    apply minus_SNo_Lt_contra (- y) (- SNoCut L R) Lmy LmCLR.
    prove - y < - SNoCut L R.
    apply minus_SNo_Lt_contra (SNoCut L R) y LCLR Ly.
    prove SNoCut L R < y.
    exact SNoCutP_SNoCut_R L R HLR y Hy.
}
apply L1.
assume L1a: SNoLev (SNoCut L R) c= SNoLev (- - SNoCut L R).
assume L1b: SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) (- - SNoCut L R).
prove - - SNoCut L R = SNoCut L R.
symmetry.
apply SNo_eq.
- exact LCLR.
- exact LmmCLR.
- prove SNoLev (SNoCut L R) = SNoLev (- - SNoCut L R).
  apply set_ext.
  + prove SNoLev (SNoCut L R) c= SNoLev (- - SNoCut L R).
    exact L1a.
  + prove SNoLev (- - SNoCut L R) c= SNoLev (SNoCut L R).
    apply Subq_tra (SNoLev (- - SNoCut L R)) (SNoLev (- SNoCut L R)) (SNoLev (SNoCut L R)).
    * prove SNoLev (- - SNoCut L R) c= SNoLev (- SNoCut L R).
      apply minus_SNo_Lev_lem2 (- SNoCut L R) LmCLR.
    * prove SNoLev (- SNoCut L R) c= SNoLev (SNoCut L R).
      apply minus_SNo_Lev_lem2 (SNoCut L R) LCLR.
- prove SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) (- - SNoCut L R).
  exact L1b.
Qed.

Theorem minus_SNo_Lev : forall x, SNo x -> SNoLev (- x) = SNoLev x.
let x. assume Hx.
apply set_ext.
- prove SNoLev (- x) c= SNoLev x.
  exact minus_SNo_Lev_lem2 x Hx.
- prove SNoLev x c= SNoLev (- x).
  rewrite <- minus_SNo_invol x Hx at 1.
  prove SNoLev (- - x) c= SNoLev (- x).
  exact minus_SNo_Lev_lem2 (- x) (SNo_minus_SNo x Hx).
Qed.

Theorem minus_SNo_SNo_ : forall alpha, ordinal alpha -> forall x, SNo_ alpha x -> SNo_ alpha (- x).
let alpha. assume Ha.
let x. assume Hx: SNo_ alpha x.
claim Lx: SNo x.
{ exact SNo_SNo alpha Ha x Hx. }
claim Lxa: SNoLev x = alpha.
{ exact SNoLev_uniq2 alpha Ha x Hx. }
claim Lmxa: SNoLev (- x) = alpha.
{ rewrite minus_SNo_Lev x Lx. exact Lxa. }
prove SNo_ alpha (- x).
rewrite <- Lmxa.
prove SNo_ (SNoLev (- x)) (- x).
apply SNoLev_.
prove SNo (- x).
exact SNo_minus_SNo x Lx.
Qed.

Theorem minus_SNo_SNoS_ : forall alpha, ordinal alpha -> forall x, x :e SNoS_ alpha -> - x :e SNoS_ alpha.
let alpha. assume Ha.
let x. assume Hx: x :e SNoS_ alpha.
apply SNoS_E2 alpha Ha x Hx.
assume Hx1: SNoLev x :e alpha.
assume Hx2: ordinal (SNoLev x).
assume Hx3: SNo x.
assume Hx4: SNo_ (SNoLev x) x.
claim Lbmx: SNo_ (SNoLev x) (- x).
{ exact minus_SNo_SNo_ (SNoLev x) Hx2 x Hx4. }
exact SNoS_I alpha Ha (- x) (SNoLev x) Hx1 Lbmx.
Qed.

Theorem minus_SNoCut_eq_lem : forall v, SNo v -> forall L R, SNoCutP L R -> v = SNoCut L R -> - v = SNoCut {- z|z :e R} {- w|w :e L}.
apply SNoLev_ind.
let v.
assume Hv: SNo v.
assume IHv: forall u :e SNoS_ (SNoLev v), forall L R, SNoCutP L R -> u = SNoCut L R -> - u = SNoCut {- z|z :e R} {- w|w :e L}.
let L R.
assume HLR: SNoCutP L R.
apply HLR. assume HLR1. apply HLR1.
assume HLR1: forall x :e L, SNo x.
assume HLR2: forall y :e R, SNo y.
assume HLR3: forall x :e L, forall y :e R, x < y.
assume HvLR: v = SNoCut L R.
set mL := {- w|w :e L}.
set mR := {- z|z :e R}.
set mLv := {- w|w :e SNoL v}.
set mRv := {- z|z :e SNoR v}.
claim L1: SNo (SNoCut L R).
{ exact SNoCutP_SNo_SNoCut L R HLR. }
claim L2: SNoCutP mR mL.
{ exact minus_SNo_SNoCutP_gen L R HLR. }
apply SNoCutP_SNoCut_impred mR mL L2.
assume H1: SNo (SNoCut mR mL).
assume H2: SNoLev (SNoCut mR mL) :e ordsucc ((\/_ x :e mR, ordsucc (SNoLev x)) :\/: (\/_ y :e mL, ordsucc (SNoLev y))).
assume H3: forall x :e mR, x < SNoCut mR mL.
assume H4: forall y :e mL, SNoCut mR mL < y.
assume H5: forall z, SNo z -> (forall x :e mR, x < z) -> (forall y :e mL, z < y) -> SNoLev (SNoCut mR mL) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut mR mL)) (SNoCut mR mL) z.
claim L3: forall x :e mR, x < - v.
{ let x. assume Hx: x :e mR.
  apply ReplE_impred R minus_SNo x Hx.
  let z.
  assume Hz: z :e R.
  assume Hxz: x = - z.
  prove x < - v.
  rewrite Hxz.
  prove - z < - v.
  apply minus_SNo_Lt_contra v z Hv (HLR2 z Hz).
  prove v < z.
  rewrite HvLR.
  prove SNoCut L R < z.
  exact SNoCutP_SNoCut_R L R HLR z Hz.
}
claim L4: forall y :e mL, - v < y.
{ let y. assume Hy: y :e mL.
  apply ReplE_impred L minus_SNo y Hy.
  let w.
  assume Hw: w :e L.
  assume Hyw: y = - w.
  prove - v < y.
  rewrite Hyw.
  prove - v < - w.
  apply minus_SNo_Lt_contra w v (HLR1 w Hw) Hv.
  prove w < v.
  rewrite HvLR.
  prove w < SNoCut L R.
  exact SNoCutP_SNoCut_L L R HLR w Hw.
}
apply H5 (- v) (SNo_minus_SNo v Hv) L3 L4.
assume H6: SNoLev (SNoCut mR mL) c= SNoLev (- v).
assume H7: SNoEq_ (SNoLev (SNoCut mR mL)) (SNoCut mR mL) (- v).
claim L5: ordinal (SNoLev (SNoCut mR mL)).
{ apply SNoLev_ordinal. exact H1. }
claim L6: ordinal (SNoLev (- v)).
{ apply SNoLev_ordinal. apply SNo_minus_SNo. exact Hv. }
apply ordinal_In_Or_Subq (SNoLev (SNoCut mR mL)) (SNoLev (- v)) L5 L6.
- assume H8: SNoLev (SNoCut mR mL) :e SNoLev (- v).
  prove False.
  claim L7: SNoCut mR mL :e SNoS_ (SNoLev v).
  { apply SNoS_I2.
    - prove SNo (SNoCut mR mL). exact H1.
    - prove SNo v. exact Hv.
    - prove SNoLev (SNoCut mR mL) :e SNoLev v.
      rewrite <- minus_SNo_Lev v Hv. exact H8.
  }
  claim LIH: - SNoCut mR mL = SNoCut {- z|z :e mL} {- w|w :e mR}.
  { exact IHv (SNoCut mR mL) L7 mR mL L2 (fun q H => H). }
  claim L8: {- z|z :e mL} = L.
  { apply Repl_invol_eq (fun x => x :e L) minus_SNo.
    - let x. assume Hx: x :e L.
      prove - - x = x.
      exact minus_SNo_invol x (HLR1 x Hx).
    - let x. assume Hx: x :e L. exact Hx.
  }
  claim L9: {- z|z :e mR} = R.
  { apply Repl_invol_eq (fun y => y :e R) minus_SNo.
    - let y. assume Hy: y :e R.
      prove - - y = y.
      exact minus_SNo_invol y (HLR2 y Hy).
    - let y. assume Hy: y :e R. exact Hy.
  }
  claim L10: - SNoCut mR mL = v.
  { rewrite LIH. rewrite L8. rewrite L9. symmetry. exact HvLR. }
  apply In_irref (SNoLev v).
  prove SNoLev v :e SNoLev v.
  rewrite <- L10 at 1.
  prove SNoLev (- SNoCut mR mL) :e SNoLev v.
  rewrite minus_SNo_Lev (SNoCut mR mL) H1.
  rewrite <- minus_SNo_Lev v Hv.
  exact H8.
- assume H8: SNoLev (- v) c= SNoLev (SNoCut mR mL).
  prove - v = SNoCut mR mL.
  symmetry.
  apply SNo_eq (SNoCut mR mL) (- v) H1 (SNo_minus_SNo v Hv).
  + prove SNoLev (SNoCut mR mL) = SNoLev (- v).
    apply set_ext.
    * exact H6.
    * exact H8.
  + prove SNoEq_ (SNoLev (SNoCut mR mL)) (SNoCut mR mL) (- v).
    exact H7.
Qed.

Theorem minus_SNoCut_eq : forall L R, SNoCutP L R -> - SNoCut L R = SNoCut {- z|z :e R} {- w|w :e L}.
let L R. assume HLR.
exact minus_SNoCut_eq_lem (SNoCut L R) (SNoCutP_SNo_SNoCut L R HLR) L R HLR (fun q H => H).
Qed.

Theorem minus_SNo_Lt_contra1 : forall x y, SNo x -> SNo y -> -x < y -> - y < x.
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hxy: -x < y.
prove -y < x.
rewrite <- minus_SNo_invol x Hx.
prove -y < --x.
apply minus_SNo_Lt_contra (-x) y (SNo_minus_SNo x Hx) Hy.
prove -x < y.
exact Hxy.
Qed.

Theorem minus_SNo_Lt_contra2 : forall x y, SNo x -> SNo y -> x < -y -> y < - x.
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hxy: x < -y.
prove y < -x.
rewrite <- minus_SNo_invol y Hy.
prove --y < -x.
apply minus_SNo_Lt_contra x (-y) Hx (SNo_minus_SNo y Hy).
prove x < -y.
exact Hxy.
Qed.

Theorem mordinal_SNoLev_min_2 : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e ordsucc alpha -> - alpha <= z.
let alpha. assume Ha.
let z. assume Hz: SNo z.
assume H1: SNoLev z :e ordsucc alpha.
claim Lz1: SNo (-z).
{ exact SNo_minus_SNo z Hz. }
claim Lz2: SNoLev (-z) :e ordsucc alpha.
{ rewrite minus_SNo_Lev z Hz. exact H1. }
prove -alpha <= z.
rewrite <- minus_SNo_invol z Hz.
prove -alpha <= --z.
apply minus_SNo_Le_contra (-z) alpha Lz1 (ordinal_SNo alpha Ha).
prove -z <= alpha.
exact ordinal_SNoLev_max_2 alpha Ha (-z) Lz1 Lz2.
Qed.

Theorem minus_SNo_SNoS_omega : forall x :e SNoS_ omega, - x :e SNoS_ omega.
let x. assume Hx.
apply SNoS_E2 omega omega_ordinal x Hx.
assume Hx1: SNoLev x :e omega.
assume Hx2: ordinal (SNoLev x).
assume Hx3: SNo x.
assume Hx4: SNo_ (SNoLev x) x.
apply SNoS_I omega omega_ordinal (- x) (SNoLev (- x)).
- prove SNoLev (- x) :e omega.
  rewrite minus_SNo_Lev x Hx3.
  prove SNoLev x :e omega.
  exact Hx1.
- prove SNo_ (SNoLev (- x)) (- x).
  apply SNoLev_. exact SNo_minus_SNo x Hx3.
Qed.

Theorem SNoL_minus_SNoR: forall x, SNo x -> SNoL (- x) = {- w|w :e SNoR x}.
let x. assume Hx.
claim Lmx: SNo (- x).
{ exact SNo_minus_SNo x Hx. }
apply set_ext.
- let z. assume Hz: z :e SNoL (- x).
  apply SNoL_E (- x) Lmx z Hz.
  assume Hz1: SNo z.
  rewrite minus_SNo_Lev x Hx.
  assume Hz2: SNoLev z :e SNoLev x.
  assume Hz3: z < - x.
  prove z :e {- w|w :e SNoR x}.
  rewrite <- minus_SNo_invol z Hz1.
  apply ReplI.
  prove - z :e SNoR x.
  apply SNoR_I x Hx (- z) (SNo_minus_SNo z Hz1).
  + prove SNoLev (-z) :e SNoLev x.
    rewrite minus_SNo_Lev z Hz1. exact Hz2.
  + prove x < - z.
    apply minus_SNo_Lt_contra2 z x Hz1 Hx.
    exact Hz3.
- let z. assume Hz: z :e {- w|w :e SNoR x}.
  apply ReplE_impred (SNoR x) minus_SNo z Hz.
  let w. assume Hw: w :e SNoR x.
  assume Hzw: z = - w.
  prove z :e SNoL (- x).
  rewrite Hzw.
  prove - w :e SNoL (- x).
  apply SNoR_E x Hx w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev x.
  assume Hw3: x < w.
  apply SNoL_I (- x) Lmx (- w) (SNo_minus_SNo w Hw1).
  + prove SNoLev (- w) :e SNoLev (- x).
    rewrite minus_SNo_Lev w Hw1.
    rewrite minus_SNo_Lev x Hx.
    exact Hw2.
  + prove - w < - x.
    apply minus_SNo_Lt_contra x w Hx Hw1.
    exact Hw3.
Qed.

End SurrealMinus.
Opaque minus_SNo.
Section SurrealAdd.
Prefix - 358 := minus_SNo.
(* Parameter add_SNo "29b9b279a7a5b776b777d842e678a4acaf3b85b17a0223605e4cc68025e9b2a7" "127d043261bd13d57aaeb99e7d2c02cae2bd0698c0d689b03e69f1ac89b3c2c6" *)
Definition add_SNo : set -> set -> set
  := SNo_rec2 (fun x y a => SNoCut ({a w y|w :e SNoL x} :\/: {a x w|w :e SNoL y}) ({a z y|z :e SNoR x} :\/: {a x z|z :e SNoR y})).
Infix + 360 right := add_SNo.

Theorem add_SNo_eq : forall x, SNo x -> forall y, SNo y ->
    x + y = SNoCut ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
set F : set -> set -> (set -> set -> set) -> set
  := fun x y a => SNoCut ({a w y|w :e SNoL x} :\/: {a x w|w :e SNoL y}) ({a z y|z :e SNoR x} :\/: {a x z|z :e SNoR y}).
claim L1: forall x, SNo x -> forall y, SNo y ->
  forall g h:set -> set -> set,
      (forall w :e SNoS_ (SNoLev x), forall z, SNo z -> g w z = h w z)
   -> (forall z :e SNoS_ (SNoLev y), g x z = h x z)
   -> F x y g = F x y h.
{ let x. assume Hx: SNo x.
  let y. assume Hy: SNo y.
  let g h.
  assume Hgh1: forall w :e SNoS_ (SNoLev x), forall z, SNo z -> g w z = h w z.
  assume Hgh2: forall z :e SNoS_ (SNoLev y), g x z = h x z.
  prove F x y g = F x y h.
  claim L1a: {g w y|w :e SNoL x} = {h w y|w :e SNoL x}.
  { apply ReplEq_ext.
    let w. assume Hw: w :e SNoL x.
    prove g w y = h w y.
    apply Hgh1.
    - prove w :e SNoS_ (SNoLev x). exact SNoL_SNoS x Hx w Hw.
    - prove SNo y. exact Hy.
  }
  claim L1b: {g x w|w :e SNoL y} = {h x w|w :e SNoL y}.
  { apply ReplEq_ext.
    let w. assume Hw: w :e SNoL y.
    prove g x w = h x w.
    apply Hgh2.
    prove w :e SNoS_ (SNoLev y). exact SNoL_SNoS y Hy w Hw.
  }
  claim L1c: {g z y|z :e SNoR x} = {h z y|z :e SNoR x}.
  { apply ReplEq_ext.
    let z. assume Hz: z :e SNoR x.
    prove g z y = h z y.
    apply Hgh1.
    - prove z :e SNoS_ (SNoLev x). exact SNoR_SNoS x Hx z Hz.
    - prove SNo y. exact Hy.
  }
  claim L1d: {g x z|z :e SNoR y} = {h x z|z :e SNoR y}.
  { apply ReplEq_ext.
    let z. assume Hz: z :e SNoR y.
    prove g x z = h x z.
    apply Hgh2.
    prove z :e SNoS_ (SNoLev y). exact SNoR_SNoS y Hy z Hz.
  }
  prove SNoCut ({g w y|w :e SNoL x} :\/: {g x w|w :e SNoL y}) ({g z y|z :e SNoR x} :\/: {g x z|z :e SNoR y})
      = SNoCut ({h w y|w :e SNoL x} :\/: {h x w|w :e SNoL y}) ({h z y|z :e SNoR x} :\/: {h x z|z :e SNoR y}).
  rewrite L1a.
  rewrite L1b.
  rewrite L1c.
  rewrite L1d.
  reflexivity.
}
exact SNo_rec2_eq F L1.
Qed.

Theorem add_SNo_prop1 : forall x y, SNo x -> SNo y ->
    SNo (x + y)
 /\ (forall u :e SNoL x, u + y < x + y)
 /\ (forall u :e SNoR x, x + y < u + y)
 /\ (forall u :e SNoL y, x + u < x + y)
 /\ (forall u :e SNoR y, x + y < x + u)
 /\ SNoCutP ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
set P : set -> set -> prop
 := fun x y =>
     SNo (x + y)
 /\ (forall u :e SNoL x, u + y < x + y)
 /\ (forall u :e SNoR x, x + y < u + y)
 /\ (forall u :e SNoL y, x + u < x + y)
 /\ (forall u :e SNoR y, x + y < x + u)
 /\ SNoCutP ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
claim LPE: forall x y, P x y -> (** drop the SNoCut part here **)
  forall p:prop,
       (SNo (x + y)
         -> (forall u :e SNoL x, u + y < x + y)
         -> (forall u :e SNoR x, x + y < u + y)
         -> (forall u :e SNoL y, x + u < x + y)
         -> (forall u :e SNoR y, x + y < x + u)
         -> p)
    -> p.
{ let x y. assume Hxy.
  let p. assume Hp.
  apply Hxy.
  assume H. apply H. assume H. apply H.
  assume H. apply H. assume H. apply H.
  assume H1 H2 H3 H4 H5 _.
  exact Hp H1 H2 H3 H4 H5.
}
prove forall x y, SNo x -> SNo y -> P x y.
apply SNoLev_ind2.
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
assume IHx: forall w :e SNoS_ (SNoLev x), P w y.
assume IHy: forall z :e SNoS_ (SNoLev y), P x z.
assume IHxy: forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), P w z.
claim LLx: ordinal (SNoLev x).
{ exact SNoLev_ordinal x Hx. }
claim LLxa: TransSet (SNoLev x).
{ exact ordinal_TransSet (SNoLev x) LLx. }
claim LLy: ordinal (SNoLev y).
{ exact SNoLev_ordinal y Hy. }
claim LLya: TransSet (SNoLev y).
{ exact ordinal_TransSet (SNoLev y) LLy. }
set L1 := {w + y|w :e SNoL x}.
set L2 := {x + w|w :e SNoL y}.
set L := L1 :\/: L2.
set R1 := {z + y|z :e SNoR x}.
set R2 := {x + z|z :e SNoR y}.
set R := R1 :\/: R2.
claim IHLx : forall w :e SNoL x, P w y.
{ let w. assume Hw: w :e SNoL x.
  apply SNoL_E x Hx w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev x.
  assume Hw3: w < x.
  claim Lw: w :e SNoS_ (SNoLev x).
  { exact SNoS_I2 w x Hw1 Hx Hw2. }
  exact IHx w Lw.
}
claim IHRx : forall w :e SNoR x, P w y.
{ let w. assume Hw: w :e SNoR x.
  apply SNoR_E x Hx w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev x.
  assume Hw3: x < w.
  claim Lw: w :e SNoS_ (SNoLev x).
  { exact SNoS_I2 w x Hw1 Hx Hw2. }
  exact IHx w Lw.
}
claim IHLy : forall w :e SNoL y, P x w.
{ let w. assume Hw: w :e SNoL y.
  apply SNoL_E y Hy w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev y.
  assume Hw3: w < y.
  claim Lw: w :e SNoS_ (SNoLev y).
  { exact SNoS_I2 w y Hw1 Hy Hw2. }
  exact IHy w Lw.
}
claim IHRy : forall w :e SNoR y, P x w.
{ let w. assume Hw: w :e SNoR y.
  apply SNoR_E y Hy w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev y.
  assume Hw3: y < w.
  claim Lw: w :e SNoS_ (SNoLev y).
  { exact SNoS_I2 w y Hw1 Hy Hw2. }
  exact IHy w Lw.
}
claim LLR: SNoCutP L R.
{ prove (forall w :e L, SNo w)
     /\ (forall z :e R, SNo z)
     /\ (forall w :e L, forall z :e R, w < z).
  apply and3I.
  - let w. assume Hw: w :e L1 :\/: L2.
    prove SNo w.
    apply binunionE L1 L2 w Hw.
    + assume Hw: w :e {w + y|w :e SNoL x}.
      apply ReplE_impred (SNoL x) (fun z => z + y) w Hw.
      let z.
      assume Hz: z :e SNoL x.
      assume Hwz: w = z + y.
      apply LPE z y (IHLx z Hz).
      assume H2: SNo (z + y).
      assume _ _ _ _.
      prove SNo w.
      rewrite Hwz. exact H2.
    + assume Hw: w :e {x + w|w :e SNoL y}.
      apply ReplE_impred (SNoL y) (fun z => x + z) w Hw.
      let z.
      assume Hz: z :e SNoL y.
      assume Hwz: w = x + z.
      apply LPE x z (IHLy z Hz).
      assume H2: SNo (x + z).
      assume _ _ _ _.
      prove SNo w.
      rewrite Hwz. exact H2.
  - let w. assume Hw: w :e R1 :\/: R2.
    prove SNo w.
    apply binunionE R1 R2 w Hw.
    + assume Hw: w :e {z + y|z :e SNoR x}.
      apply ReplE_impred (SNoR x) (fun z => z + y) w Hw.
      let z.
      assume Hz: z :e SNoR x.
      assume Hwz: w = z + y.
      apply LPE z y (IHRx z Hz).
      assume H2: SNo (z + y).
      assume _ _ _ _.
      prove SNo w.
      rewrite Hwz. exact H2.
    + assume Hw: w :e {x + z|z :e SNoR y}.
      apply ReplE_impred (SNoR y) (fun z => x + z) w Hw.
      let z.
      assume Hz: z :e SNoR y.
      assume Hwz: w = x + z.
      apply LPE x z (IHRy z Hz).
      assume H2: SNo (x + z).
      assume _ _ _ _.
      prove SNo w.
      rewrite Hwz. exact H2.
  - let w. assume Hw: w :e L.
    let z. assume Hz: z :e R.
    prove w < z.
    apply binunionE L1 L2 w Hw.
    + assume Hw: w :e {w + y|w :e SNoL x}.
      apply ReplE_impred (SNoL x) (fun z => z + y) w Hw.
      let u.
      assume Hu: u :e SNoL x.
      assume Hwu: w = u + y.
      apply SNoL_E x Hx u Hu.
      assume Hu1: SNo u.
      assume Hu2: SNoLev u :e SNoLev x.
      assume Hu3: u < x.
      claim Lux: u :e SNoS_ (SNoLev x).
      { exact SNoS_I2 u x Hu1 Hx Hu2. }
      apply LPE u y (IHLx u Hu).
      assume IHu1: SNo (u + y).
      assume IHu2: forall z :e SNoL u, z + y < u + y.
      assume IHu3: forall z :e SNoR u, u + y < z + y.
      assume IHu4: forall z :e SNoL y, u + z < u + y.
      assume IHu5: forall z :e SNoR y, u + y < u + z.
      prove w < z.
      rewrite Hwu.
      prove u + y < z.
      apply binunionE R1 R2 z Hz.
      * { assume Hz: z :e {z + y|z :e SNoR x}.
          apply ReplE_impred (SNoR x) (fun z => z + y) z Hz.
          let v.
          assume Hv: v :e SNoR x.
          assume Hzv: z = v + y.
          apply SNoR_E x Hx v Hv.
          assume Hv1: SNo v.
          assume Hv2: SNoLev v :e SNoLev x.
          assume Hv3: x < v.
          apply LPE v y (IHRx v Hv).
          assume IHv1: SNo (v + y).
          assume IHv2: forall u :e SNoL v, u + y < v + y.
          assume IHv3: forall u :e SNoR v, v + y < u + y.
          assume IHv4: forall u :e SNoL y, v + u < v + y.
          assume IHv5: forall u :e SNoR y, v + y < v + u.
          rewrite Hzv.
          prove u + y < v + y.
          claim Luv: u < v.
          { exact SNoLt_tra u x v Hu1 Hx Hv1 Hu3 Hv3. }
          apply SNoLtE u v Hu1 Hv1 Luv.
          - let q.
            assume Hq1: SNo q.
            assume Hq2: SNoLev q :e SNoLev u :/\: SNoLev v.
            assume _ _.
            assume Hq5: u < q.
            assume Hq6: q < v.
            assume _ _.
            apply binintersectE (SNoLev u) (SNoLev v) (SNoLev q) Hq2.
            assume Hq2u Hq2v.
            claim Lqx: SNoLev q :e SNoLev x.
            { exact LLxa (SNoLev u) Hu2 (SNoLev q) Hq2u. }
            claim Lqx2: q :e SNoS_ (SNoLev x).
            { exact SNoS_I2 q x Hq1 Hx Lqx. }
            claim Lqy: SNo (q + y).
            { apply LPE q y (IHx q Lqx2).
              assume IHq1 _ _ _ _. exact IHq1.
            }
            apply SNoLt_tra (u + y) (q + y) (v + y) IHu1 Lqy IHv1.
            + prove u + y < q + y.
              apply IHu3.
              prove q :e SNoR u.
              exact SNoR_I u Hu1 q Hq1 Hq2u Hq5.
            + prove q + y < v + y.
              apply IHv2.
              prove q :e SNoL v.
              exact SNoL_I v Hv1 q Hq1 Hq2v Hq6.
          - assume Huv: SNoLev u :e SNoLev v.
            assume _ _.
            prove u + y < v + y.
            apply IHv2.
            prove u :e SNoL v.
            exact SNoL_I v Hv1 u Hu1 Huv Luv.
          - assume Hvu: SNoLev v :e SNoLev u.
            assume _ _.
            prove u + y < v + y.
            apply IHu3.
            prove v :e SNoR u.
            exact SNoR_I u Hu1 v Hv1 Hvu Luv.
        }
      * { assume Hz: z :e {x + z|z :e SNoR y}.
          apply ReplE_impred (SNoR y) (fun z => x + z) z Hz.
          let v.
          assume Hv: v :e SNoR y.
          assume Hzv: z = x + v.
          apply SNoR_E y Hy v Hv.
          assume Hv1: SNo v.
          assume Hv2: SNoLev v :e SNoLev y.
          assume Hv3: y < v.
          claim Lvy: v :e SNoS_ (SNoLev y).
          { exact SNoS_I2 v y Hv1 Hy Hv2. }
          apply LPE x v (IHRy v Hv).
          assume IHv1: SNo (x + v).
          assume IHv2: forall u :e SNoL x, u + v < x + v.
          assume IHv3: forall u :e SNoR x, x + v < u + v.
          assume IHv4: forall u :e SNoL v, x + u < x + v.
          assume IHv5: forall u :e SNoR v, x + v < x + u.
          rewrite Hzv.
          prove u + y < x + v.
          apply LPE u v (IHxy u Lux v Lvy).
          assume IHuv1: SNo (u + v).
          assume _ _ _ _.
          prove u + y < x + v.
          apply SNoLt_tra (u + y) (u + v) (x + v) IHu1 IHuv1 IHv1.
          - prove u + y < u + v.
            apply IHu5.
            prove v :e SNoR y.
            exact SNoR_I y Hy v Hv1 Hv2 Hv3.
          - prove u + v < x + v.
            apply IHv2.
            prove u :e SNoL x.
            exact SNoL_I x Hx u Hu1 Hu2 Hu3.
        }
    + assume Hw: w :e {x + w|w :e SNoL y}.
      apply ReplE_impred (SNoL y) (fun z => x + z) w Hw.
      let u.
      assume Hu: u :e SNoL y.
      assume Hwu: w = x + u.
      apply SNoL_E y Hy u Hu.
      assume Hu1: SNo u.
      assume Hu2: SNoLev u :e SNoLev y.
      assume Hu3: u < y.
      claim Luy: u :e SNoS_ (SNoLev y).
      { exact SNoS_I2 u y Hu1 Hy Hu2. }
      apply LPE x u (IHLy u Hu).
      assume IHu1: SNo (x + u).
      assume IHu2: forall z :e SNoL x, z + u < x + u.
      assume IHu3: forall z :e SNoR x, x + u < z + u.
      assume IHu4: forall z :e SNoL u, x + z < x + u.
      assume IHu5: forall z :e SNoR u, x + u < x + z.
      prove w < z.
      rewrite Hwu.
      prove x + u < z.
      apply binunionE R1 R2 z Hz.
      * { assume Hz: z :e {z + y|z :e SNoR x}.
          apply ReplE_impred (SNoR x) (fun z => z + y) z Hz.
          let v.
          assume Hv: v :e SNoR x.
          assume Hzv: z = v + y.
          apply SNoR_E x Hx v Hv.
          assume Hv1: SNo v.
          assume Hv2: SNoLev v :e SNoLev x.
          assume Hv3: x < v.
          claim Lvx: v :e SNoS_ (SNoLev x).
          { exact SNoS_I2 v x Hv1 Hx Hv2. }
          apply LPE v y (IHRx v Hv).
          assume IHv1: SNo (v + y).
          assume IHv2: forall u :e SNoL v, u + y < v + y.
          assume IHv3: forall u :e SNoR v, v + y < u + y.
          assume IHv4: forall u :e SNoL y, v + u < v + y.
          assume IHv5: forall u :e SNoR y, v + y < v + u.
          rewrite Hzv.
          prove x + u < v + y.
          apply LPE v u (IHxy v Lvx u Luy).
          assume IHvu1: SNo (v + u).
          assume _ _ _ _.
          prove x + u < v + y.
          apply SNoLt_tra (x + u) (v + u) (v + y) IHu1 IHvu1 IHv1.
          - prove x + u < v + u.
            apply IHu3.
            prove v :e SNoR x.
            exact SNoR_I x Hx v Hv1 Hv2 Hv3.
          - prove v + u < v + y.
            apply IHv4.
            prove u :e SNoL y.
            exact SNoL_I y Hy u Hu1 Hu2 Hu3.
        }
      * { assume Hz: z :e {x + z|z :e SNoR y}.
          apply ReplE_impred (SNoR y) (fun z => x + z) z Hz.
          let v.
          assume Hv: v :e SNoR y.
          assume Hzv: z = x + v.
          apply SNoR_E y Hy v Hv.
          assume Hv1: SNo v.
          assume Hv2: SNoLev v :e SNoLev y.
          assume Hv3: y < v.
          apply LPE x v (IHRy v Hv).
          assume IHv1: SNo (x + v).
          assume IHv2: forall u :e SNoL x, u + v < x + v.
          assume IHv3: forall u :e SNoR x, x + v < u + v.
          assume IHv4: forall u :e SNoL v, x + u < x + v.
          assume IHv5: forall u :e SNoR v, x + v < x + u.
          rewrite Hzv.
          prove x + u < x + v.
          claim Luv: u < v.
          { exact SNoLt_tra u y v Hu1 Hy Hv1 Hu3 Hv3. }
          apply SNoLtE u v Hu1 Hv1 Luv.
          - let q.
            assume Hq1: SNo q.
            assume Hq2: SNoLev q :e SNoLev u :/\: SNoLev v.
            assume _ _.
            assume Hq5: u < q.
            assume Hq6: q < v.
            assume _ _.
            apply binintersectE (SNoLev u) (SNoLev v) (SNoLev q) Hq2.
            assume Hq2u Hq2v.
            claim Lqy: SNoLev q :e SNoLev y.
            { exact LLya (SNoLev v) Hv2 (SNoLev q) Hq2v. }
            claim Lqy2: q :e SNoS_ (SNoLev y).
            { exact SNoS_I2 q y Hq1 Hy Lqy. }
            claim Lxq: SNo (x + q).
            { apply LPE x q (IHy q Lqy2).
              assume IHq1 _ _ _ _. exact IHq1.
            }
            prove x + u < x + v.
            apply SNoLt_tra (x + u) (x + q) (x + v) IHu1 Lxq IHv1.
            + prove x + u < x + q.
              apply IHu5.
              prove q :e SNoR u.
              exact SNoR_I u Hu1 q Hq1 Hq2u Hq5.
            + prove x + q < x + v.
              apply IHv4.
              prove q :e SNoL v.
              exact SNoL_I v Hv1 q Hq1 Hq2v Hq6.
          - assume Huv: SNoLev u :e SNoLev v.
            assume _ _.
            prove x + u < x + v.
            apply IHv4.
            prove u :e SNoL v.
            exact SNoL_I v Hv1 u Hu1 Huv Luv.
          - assume Hvu: SNoLev v :e SNoLev u.
            assume _ _.
            prove x + u < x + v.
            apply IHu5.
            prove v :e SNoR u.
            exact SNoR_I u Hu1 v Hv1 Hvu Luv.
        }
}
prove P x y.
prove SNo (x + y)
 /\ (forall u :e SNoL x, u + y < x + y)
 /\ (forall u :e SNoR x, x + y < u + y)
 /\ (forall u :e SNoL y, x + u < x + y)
 /\ (forall u :e SNoR y, x + y < x + u)
 /\ SNoCutP L R.
claim LNLR: SNo (SNoCut L R).
{ exact SNoCutP_SNo_SNoCut L R LLR. }
apply andI.
- rewrite add_SNo_eq x Hx y Hy.
  apply and5I.
  + prove SNo (SNoCut L R). exact LNLR.
  + prove forall u :e SNoL x, u + y < SNoCut L R.
    let u. assume Hu: u :e SNoL x.
    prove u + y < SNoCut L R.
    apply SNoL_E x Hx u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev x.
    assume Hu3: u < x.
    claim LuyL: u + y :e L.
    { prove u + y :e L1 :\/: L2.
      apply binunionI1.
      prove u + y :e {w + y|w :e SNoL x}.
      apply ReplI (SNoL x) (fun w => w + y) u.
      prove u :e SNoL x.
      exact Hu.
    }
    prove u + y < SNoCut L R.
    exact SNoCutP_SNoCut_L L R LLR (u + y) LuyL.
  + prove forall u :e SNoR x, SNoCut L R < u + y.
    let u. assume Hu: u :e SNoR x.
    prove SNoCut L R < u + y.
    apply SNoR_E x Hx u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev x.
    assume Hu3: x < u.
    claim LuyR: u + y :e R.
    { prove u + y :e R1 :\/: R2.
      apply binunionI1.
      prove u + y :e {z + y|z :e SNoR x}.
      apply ReplI (SNoR x) (fun w => w + y) u.
      prove u :e SNoR x.
      exact Hu.
    }
    prove SNoCut L R < u + y.
    exact SNoCutP_SNoCut_R L R LLR (u + y) LuyR.
  + prove forall u :e SNoL y, x + u < SNoCut L R.
    let u. assume Hu: u :e SNoL y.
    prove x + u < SNoCut L R.
    apply SNoL_E y Hy u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev y.
    assume Hu3: u < y.
    claim LxuL: x + u :e L.
    { prove x + u :e L1 :\/: L2.
      apply binunionI2.
      prove x + u :e {x + w|w :e SNoL y}.
      apply ReplI (SNoL y) (fun w => x + w) u.
      prove u :e SNoL y.
      exact Hu.
    }
    prove x + u < SNoCut L R.
    exact SNoCutP_SNoCut_L L R LLR (x + u) LxuL.
  + prove forall u :e SNoR y, SNoCut L R < x + u.
    let u. assume Hu: u :e SNoR y.
    prove SNoCut L R < x + u.
    apply SNoR_E y Hy u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev y.
    assume Hu3: y < u.
    claim LxuR: x + u :e R.
    { prove x + u :e R1 :\/: R2.
      apply binunionI2.
      prove x + u :e {x + z|z :e SNoR y}.
      apply ReplI (SNoR y) (fun z => x + z) u.
      prove u :e SNoR y.
      exact Hu.
    }
    prove SNoCut L R < x + u.
    exact SNoCutP_SNoCut_R L R LLR (x + u) LxuR.
- exact LLR.
Qed.

Theorem SNo_add_SNo : forall x y, SNo x -> SNo y -> SNo (x + y).
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
apply add_SNo_prop1 x y Hx Hy.
assume H. apply H. assume H. apply H.
assume H. apply H. assume H. apply H.
assume H _ _ _ _ _. exact H.
Qed.

Theorem SNo_add_SNo_3 : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x + y + z).
let x y z. assume Hx Hy Hz.
apply SNo_add_SNo.
- exact Hx.
- apply SNo_add_SNo.
  + exact Hy.
  + exact Hz.
Qed.

Theorem SNo_add_SNo_3c : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x + y + - z).
let x y z. assume Hx Hy Hz.
apply SNo_add_SNo_3.
- exact Hx.
- exact Hy.
- apply SNo_minus_SNo. exact Hz.
Qed.

Theorem SNo_add_SNo_4 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> SNo (x + y + z + w).
let x y z w. assume Hx Hy Hz Hw.
exact SNo_add_SNo_3 x y (z + w) Hx Hy (SNo_add_SNo z w Hz Hw).
Qed.

Theorem add_SNo_Lt1 : forall x y z, SNo x -> SNo y -> SNo z -> x < z -> x + y < z + y.
let x y z.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
assume Hxz: x < z.
apply add_SNo_prop1 x y Hx Hy.
assume H. apply H. assume H. apply H.
assume H. apply H. assume H. apply H.
assume H1: SNo (x + y).
assume _.
assume H2: forall u :e SNoR x, x + y < u + y.
assume _ _ _.
apply add_SNo_prop1 z y Hz Hy.
assume H. apply H. assume H. apply H.
assume H. apply H. assume H. apply H.
assume H3: SNo (z + y).
assume H4: forall u :e SNoL z, u + y < z + y.
assume _ _ _ _.
apply SNoLtE x z Hx Hz Hxz.
- let w.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev x :/\: SNoLev z.
  assume _ _.
  assume Hw5: x < w.
  assume Hw6: w < z.
  assume _ _.
  apply binintersectE (SNoLev x) (SNoLev z) (SNoLev w) Hw2.
  assume Hw2x Hw2z.
  prove x + y < z + y.
  apply SNoLt_tra (x + y) (w + y) (z + y) H1 (SNo_add_SNo w y Hw1 Hy) H3.
  + prove x + y < w + y.
    apply H2.
    prove w :e SNoR x.
    apply SNoR_I x Hx w Hw1.
    * prove SNoLev w :e SNoLev x.
      exact Hw2x.
    * prove x < w. exact Hw5.
  + prove w + y < z + y.
    apply H4.
    prove w :e SNoL z.
    apply SNoL_I z Hz w Hw1.
    * prove SNoLev w :e SNoLev z.
      exact Hw2z.
    * prove w < z. exact Hw6.
- assume Hxz1: SNoLev x :e SNoLev z.
  assume _ _.
  prove x + y < z + y.
  apply H4.
  prove x :e SNoL z.
  apply SNoL_I z Hz x Hx.
  + prove SNoLev x :e SNoLev z.
    exact Hxz1.
  + prove x < z. exact Hxz.
- assume Hzx: SNoLev z :e SNoLev x.
  assume _ _.
  prove x + y < z + y.
  apply H2.
  prove z :e SNoR x.
  apply SNoR_I x Hx z Hz.
  + prove SNoLev z :e SNoLev x.
    exact Hzx.
  + prove x < z. exact Hxz.
Qed.

Theorem add_SNo_Le1 : forall x y z, SNo x -> SNo y -> SNo z -> x <= z -> x + y <= z + y.
let x y z.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
assume Hxz: x <= z.
prove x + y <= z + y.
apply SNoLeE x z Hx Hz Hxz.
- assume H1: x < z. apply SNoLtLe. exact add_SNo_Lt1 x y z Hx Hy Hz H1.
- assume H1: x = z. rewrite H1. apply SNoLe_ref.
Qed.

Theorem add_SNo_Lt2 : forall x y z, SNo x -> SNo y -> SNo z -> y < z -> x + y < x + z.
let x y z.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
assume Hyz: y < z.
apply add_SNo_prop1 x y Hx Hy.
assume H. apply H. assume H. apply H.
assume H. apply H. assume H. apply H.
assume H1: SNo (x + y).
assume _ _ _.
assume H2: forall u :e SNoR y, x + y < x + u.
assume _.
apply add_SNo_prop1 x z Hx Hz.
assume H. apply H. assume H. apply H.
assume H. apply H. assume H. apply H.
assume H3: SNo (x + z).
assume _ _.
assume H4: forall u :e SNoL z, x + u < x + z.
assume _ _.
apply SNoLtE y z Hy Hz Hyz.
- let w.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev y :/\: SNoLev z.
  assume _ _.
  assume Hw5: y < w.
  assume Hw6: w < z.
  assume _ _.
  apply binintersectE (SNoLev y) (SNoLev z) (SNoLev w) Hw2.
  assume Hw2y Hw2z.
  prove x + y < x + z.
  apply SNoLt_tra (x + y) (x + w) (x + z) H1 (SNo_add_SNo x w Hx Hw1) H3.
  + prove x + y < x + w.
    apply H2.
    prove w :e SNoR y.
    apply SNoR_I y Hy w Hw1.
    * prove SNoLev w :e SNoLev y.
      exact Hw2y.
    * prove y < w. exact Hw5.
  + prove x + w < x + z.
    apply H4.
    prove w :e SNoL z.
    apply SNoL_I z Hz w Hw1.
    * prove SNoLev w :e SNoLev z.
      exact Hw2z.
    * prove w < z. exact Hw6.
- assume Hyz1: SNoLev y :e SNoLev z.
  assume _ _.
  prove x + y < x + z.
  apply H4.
  prove y :e SNoL z.
  apply SNoL_I z Hz y Hy.
  + prove SNoLev y :e SNoLev z.
    exact Hyz1.
  + prove y < z. exact Hyz.
- assume Hzy: SNoLev z :e SNoLev y.
  assume _ _.
  prove x + y < x + z.
  apply H2.
  prove z :e SNoR y.
  apply SNoR_I y Hy z Hz.
  + prove SNoLev z :e SNoLev y.
    exact Hzy.
  + prove y < z. exact Hyz.
Qed.

Theorem add_SNo_Le2 : forall x y z, SNo x -> SNo y -> SNo z -> y <= z -> x + y <= x + z.
let x y z.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
assume Hyz: y <= z.
prove x + y <= x + z.
apply SNoLeE y z Hy Hz Hyz.
- assume H1: y < z. apply SNoLtLe. exact add_SNo_Lt2 x y z Hx Hy Hz H1.
- assume H1: y = z. rewrite H1. apply SNoLe_ref.
Qed.

Theorem add_SNo_Lt3a : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x < z -> y <= w -> x + y < z + w.
let x y z w.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
assume Hw: SNo w.
assume Hxz: x < z.
assume Hyw: y <= w.
apply SNoLtLe_tra (x+y) (z+y) (z+w) (SNo_add_SNo x y Hx Hy) (SNo_add_SNo z y Hz Hy) (SNo_add_SNo z w Hz Hw).
- prove x+y < z+y. exact add_SNo_Lt1 x y z Hx Hy Hz Hxz.
- prove z+y <= z+w. exact add_SNo_Le2 z y w Hz Hy Hw Hyw.
Qed.

Theorem add_SNo_Lt3b : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x <= z -> y < w -> x + y < z + w.
let x y z w.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
assume Hw: SNo w.
assume Hxz: x <= z.
assume Hyw: y < w.
apply SNoLeLt_tra (x+y) (z+y) (z+w) (SNo_add_SNo x y Hx Hy) (SNo_add_SNo z y Hz Hy) (SNo_add_SNo z w Hz Hw).
- prove x+y <= z+y. exact add_SNo_Le1 x y z Hx Hy Hz Hxz.
- prove z+y < z+w. exact add_SNo_Lt2 z y w Hz Hy Hw Hyw.
Qed.

Theorem add_SNo_Lt3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x < z -> y < w -> x + y < z + w.
let x y z w.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
assume Hw: SNo w.
assume Hxz: x < z.
assume Hyw: y < w.
apply add_SNo_Lt3a x y z w Hx Hy Hz Hw Hxz.
prove y <= w.
apply SNoLtLe.
prove y < w.
exact Hyw.
Qed.

Theorem add_SNo_Le3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x <= z -> y <= w -> x + y <= z + w.
let x y z w.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
assume Hw: SNo w.
assume Hxz: x <= z.
assume Hyw: y <= w.
apply SNoLe_tra (x+y) (z+y) (z+w) (SNo_add_SNo x y Hx Hy) (SNo_add_SNo z y Hz Hy) (SNo_add_SNo z w Hz Hw).
- prove x+y <= z+y. exact add_SNo_Le1 x y z Hx Hy Hz Hxz.
- prove z+y <= z+w. exact add_SNo_Le2 z y w Hz Hy Hw Hyw.
Qed.

Theorem add_SNo_SNoCutP : forall x y, SNo x -> SNo y -> SNoCutP ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
apply add_SNo_prop1 x y Hx Hy.
assume _ H. exact H.
Qed.

Theorem add_SNo_com : forall x y, SNo x -> SNo y -> x + y = y + x.
apply SNoLev_ind2.
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
assume IHx: forall w :e SNoS_ (SNoLev x), w + y = y + w.
assume IHy: forall z :e SNoS_ (SNoLev y), x + z = z + x.
assume IHxy: forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), w + z = z + w.
claim IHLx : forall w :e SNoL x, w + y = y + w.
{ let w. assume Hw: w :e SNoL x.
  apply SNoL_E x Hx w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev x.
  assume Hw3: w < x.
  claim Lw: w :e SNoS_ (SNoLev x).
  { exact SNoS_I2 w x Hw1 Hx Hw2. }
  exact IHx w Lw.
}
claim IHRx : forall w :e SNoR x, w + y = y + w.
{ let w. assume Hw: w :e SNoR x.
  apply SNoR_E x Hx w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev x.
  assume Hw3: x < w.
  claim Lw: w :e SNoS_ (SNoLev x).
  { exact SNoS_I2 w x Hw1 Hx Hw2. }
  exact IHx w Lw.
}
claim IHLy : forall w :e SNoL y, x + w = w + x.
{ let w. assume Hw: w :e SNoL y.
  apply SNoL_E y Hy w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev y.
  assume Hw3: w < y.
  claim Lw: w :e SNoS_ (SNoLev y).
  { exact SNoS_I2 w y Hw1 Hy Hw2. }
  exact IHy w Lw.
}
claim IHRy : forall w :e SNoR y, x + w = w + x.
{ let w. assume Hw: w :e SNoR y.
  apply SNoR_E y Hy w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev y.
  assume Hw3: y < w.
  claim Lw: w :e SNoS_ (SNoLev y).
  { exact SNoS_I2 w y Hw1 Hy Hw2. }
  exact IHy w Lw.
}
prove x + y = y + x.
set Lxy1 := {w + y|w :e SNoL x}.
set Lxy2 := {x + w|w :e SNoL y}.
set Rxy1 := {z + y|z :e SNoR x}.
set Rxy2 := {x + z|z :e SNoR y}.
rewrite add_SNo_eq x Hx y Hy.
prove (SNoCut (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2)) = y + x.
set Lyx1 := {w + x|w :e SNoL y}.
set Lyx2 := {y + w|w :e SNoL x}.
set Ryx1 := {z + x|z :e SNoR y}.
set Ryx2 := {y + z|z :e SNoR x}.
rewrite add_SNo_eq y Hy x Hx.
prove (SNoCut (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2))
    = (SNoCut (Lyx1 :\/: Lyx2) (Ryx1 :\/: Ryx2)).
claim Lxy1yx2: Lxy1 = Lyx2.
{ prove {w + y|w :e SNoL x} = {y + w|w :e SNoL x}.
  apply ReplEq_ext (SNoL x) (fun w => w + y) (fun w => y + w).
  let w. assume Hw: w :e SNoL x.
  prove w + y = y + w.
  exact IHLx w Hw.
}
claim Lxy2yx1: Lxy2 = Lyx1.
{ prove {x + w|w :e SNoL y} = {w + x|w :e SNoL y}.
  apply ReplEq_ext (SNoL y) (fun w => x + w) (fun w => w + x).
  let w. assume Hw: w :e SNoL y.
  prove x + w = w + x.
  exact IHLy w Hw.
}
claim Rxy1yx2: Rxy1 = Ryx2.
{ prove {w + y|w :e SNoR x} = {y + w|w :e SNoR x}.
  apply ReplEq_ext (SNoR x) (fun w => w + y) (fun w => y + w).
  let w. assume Hw: w :e SNoR x.
  prove w + y = y + w.
  exact IHRx w Hw.
}
claim Rxy2yx1: Rxy2 = Ryx1.
{ prove {x + w|w :e SNoR y} = {w + x|w :e SNoR y}.
  apply ReplEq_ext (SNoR y) (fun w => x + w) (fun w => w + x).
  let w. assume Hw: w :e SNoR y.
  prove x + w = w + x.
  exact IHRy w Hw.
}
rewrite Lxy1yx2.
rewrite Lxy2yx1.
rewrite Rxy1yx2.
rewrite Rxy2yx1.
prove (SNoCut (Lyx2 :\/: Lyx1) (Ryx2 :\/: Ryx1))
    = (SNoCut (Lyx1 :\/: Lyx2) (Ryx1 :\/: Ryx2)).
rewrite binunion_com Lyx2 Lyx1.
rewrite binunion_com Ryx2 Ryx1.
reflexivity.
Qed.

Theorem add_SNo_0L : forall x, SNo x -> 0 + x = x.
apply SNoLev_ind.
let x.
assume Hx: SNo x.
assume IH: forall w :e SNoS_ (SNoLev x), 0 + w = w.
prove 0 + x = x.
rewrite add_SNo_eq 0 SNo_0 x Hx.
prove SNoCut ({w + x|w :e SNoL 0} :\/: {0 + w|w :e SNoL x}) ({w + x|w :e SNoR 0} :\/: {0 + w|w :e SNoR x}) = x.
claim L1: {w + x|w :e SNoL 0} :\/: {0 + w|w :e SNoL x} = SNoL x.
{ rewrite SNoL_0.
  prove {w + x|w :e Empty} :\/: {0 + w|w :e SNoL x} = SNoL x.
  rewrite Repl_Empty (fun w => w + x).
  prove Empty :\/: {0 + w|w :e SNoL x} = SNoL x.
  rewrite binunion_idl.
  prove {0 + w|w :e SNoL x} = SNoL x.
  apply set_ext.
  - let u. assume Hu: u :e {0 + w|w :e SNoL x}.
    apply ReplE_impred (SNoL x) (fun w => 0 + w) u Hu.
    let w. assume Hw: w :e SNoL x.
    assume H1: u = 0 + w.
    prove u :e SNoL x.
    rewrite H1.
    prove 0 + w :e SNoL x.
    rewrite IH w (SNoL_SNoS_ x w Hw).
    prove w :e SNoL x.
    exact Hw.
  - let u. assume Hu: u :e SNoL x.
    prove u :e {0 + w|w :e SNoL x}.
    rewrite <- IH u (SNoL_SNoS_ x u Hu).
    prove 0 + u :e {0 + w|w :e SNoL x}.
    exact ReplI (SNoL x) (fun w => 0 + w) u Hu.
}
claim L2: {w + x|w :e SNoR 0} :\/: {0 + w|w :e SNoR x} = SNoR x.
{ rewrite SNoR_0.
  prove {w + x|w :e Empty} :\/: {0 + w|w :e SNoR x} = SNoR x.
  rewrite Repl_Empty (fun w => w + x).
  prove Empty :\/: {0 + w|w :e SNoR x} = SNoR x.
  rewrite binunion_idl.
  prove {0 + w|w :e SNoR x} = SNoR x.
  apply set_ext.
  - let u. assume Hu: u :e {0 + w|w :e SNoR x}.
    apply ReplE_impred (SNoR x) (fun w => 0 + w) u Hu.
    let w. assume Hw: w :e SNoR x.
    assume H1: u = 0 + w.
    prove u :e SNoR x.
    rewrite H1.
    prove 0 + w :e SNoR x.
    rewrite IH w (SNoR_SNoS_ x w Hw).
    prove w :e SNoR x.
    exact Hw.
  - let u. assume Hu: u :e SNoR x.
    prove u :e {0 + w|w :e SNoR x}.
    rewrite <- IH u (SNoR_SNoS_ x u Hu).
    prove 0 + u :e {0 + w|w :e SNoR x}.
    exact ReplI (SNoR x) (fun w => 0 + w) u Hu.
}
rewrite L1.
rewrite L2.
prove SNoCut (SNoL x) (SNoR x) = x.
symmetry.
exact SNo_eta x Hx.
Qed.

Theorem add_SNo_0R : forall x, SNo x -> x + 0 = x.
let x. assume Hx: SNo x.
rewrite add_SNo_com x 0 Hx SNo_0.
exact add_SNo_0L x Hx.
Qed.

Theorem add_SNo_minus_SNo_linv : forall x, SNo x -> -x+x = 0.
apply SNoLev_ind.
let x. assume Hx: SNo x.
assume IH: forall w :e SNoS_ (SNoLev x), -w+w = 0.
prove -x+x = 0.
claim Lmx: SNo (-x).
{ exact SNo_minus_SNo x Hx. }
set L1 := {w + x|w :e SNoL (- x)}.
set L2 := {- x + w|w :e SNoL x}.
set R1 := {z + x|z :e SNoR (- x)}.
set R2 := {- x + z|z :e SNoR x}.
set L := L1 :\/: L2.
set R := R1 :\/: R2.
rewrite add_SNo_eq (- x) Lmx x Hx.
prove SNoCut L R = 0.
claim LLR: SNoCutP L R.
{ exact add_SNo_SNoCutP (- x) x Lmx Hx. }
claim LNLR: SNo (SNoCut L R).
{ exact SNoCutP_SNo_SNoCut L R LLR. }
claim Lfst: SNoLev (SNoCut L R) c= SNoLev 0
         /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) 0.
{ apply SNoCutP_SNoCut_fst L R LLR 0 SNo_0.
  - prove forall w :e L, w < 0.
    let w. assume Hw: w :e L.
    apply binunionE L1 L2 w Hw.
    + assume Hw: w :e {w + x|w :e SNoL (- x)}.
      apply ReplE_impred (SNoL (- x)) (fun z => z + x) w Hw.
      let u.
      assume Hu: u :e SNoL (- x).
      assume Hwu: w = u + x.
      apply SNoL_E (- x) Lmx u Hu.
      assume Hu1: SNo u.
      assume Hu2: SNoLev u :e SNoLev (- x).
      assume Hu3: u < - x.
      claim Lmu: SNo (-u).
      { apply SNo_minus_SNo. exact Hu1. }
      claim Lmuu: -u + u = 0.
      { apply IH. prove u :e SNoS_ (SNoLev x).
        apply SNoS_I2 u x Hu1 Hx.
        prove SNoLev u :e SNoLev x.
        rewrite <- minus_SNo_Lev x Hx.
        prove SNoLev u :e SNoLev (-x).
        exact Hu2.
      }
      claim Lxmu: x < -u.
      { rewrite <- minus_SNo_invol x Hx.
        prove - - x < -u.
        apply minus_SNo_Lt_contra u (- x) Hu1 Lmx.
        prove u < - x.
        exact Hu3.
      }
      prove w < 0.
      rewrite Hwu.
      prove u + x < 0.
      rewrite add_SNo_com u x Hu1 Hx.
      prove x + u < 0.
      rewrite <- Lmuu.
      prove x + u < -u + u.
      apply add_SNo_Lt1 x u (-u) Hx Hu1 Lmu.
      prove x < -u.
      exact Lxmu.
    + assume Hw: w :e {- x + w|w :e SNoL x}.
      apply ReplE_impred (SNoL x) (fun z => - x + z) w Hw.
      let u.
      assume Hu: u :e SNoL x.
      assume Hwu: w = - x + u.
      apply SNoL_E x Hx u Hu.
      assume Hu1: SNo u.
      assume Hu2: SNoLev u :e SNoLev x.
      assume Hu3: u < x.
      claim Lmu: SNo (-u).
      { apply SNo_minus_SNo. exact Hu1. }
      claim Lmuu: -u + u = 0.
      { apply IH. prove u :e SNoS_ (SNoLev x).
        apply SNoS_I2 u x Hu1 Hx.
        prove SNoLev u :e SNoLev x.
        exact Hu2.
      }
      claim Lmxmu: -x < -u.
      { apply minus_SNo_Lt_contra u x Hu1 Hx.
        prove u < x.
        exact Hu3.
      }
      prove w < 0.
      rewrite Hwu.
      prove -x + u < 0.
      rewrite <- Lmuu.
      prove -x+u < -u+u.
      apply add_SNo_Lt1 (-x) u (-u) Lmx Hu1 Lmu.
      prove -x < -u.
      exact Lmxmu.
  - prove forall z :e R, 0 < z.
    let z. assume Hz: z :e R.
    apply binunionE R1 R2 z Hz.
    + assume Hz: z :e {z + x|z :e SNoR (- x)}.
      apply ReplE_impred (SNoR (- x)) (fun z => z + x) z Hz.
      let v.
      assume Hv: v :e SNoR (- x).
      assume Hzv: z = v + x.
      apply SNoR_E (- x) Lmx v Hv.
      assume Hv1: SNo v.
      assume Hv2: SNoLev v :e SNoLev (- x).
      assume Hv3: - x < v.
      claim Lmv: SNo (-v).
      { apply SNo_minus_SNo. exact Hv1. }
      claim Lmvv: -v + v = 0.
      { apply IH. prove v :e SNoS_ (SNoLev x).
        apply SNoS_I2 v x Hv1 Hx.
        prove SNoLev v :e SNoLev x.
        rewrite <- minus_SNo_Lev x Hx.
        prove SNoLev v :e SNoLev (-x).
        exact Hv2.
      }
      claim Lmvx: -v < x.
      { rewrite <- minus_SNo_invol x Hx.
        prove -v < --x.
        apply minus_SNo_Lt_contra (-x) v Lmx Hv1.
        prove -x < v.
        exact Hv3.
      }
      prove 0 < z.
      rewrite Hzv.
      prove 0 < v + x.
      rewrite add_SNo_com v x Hv1 Hx.
      prove 0 < x+v.
      rewrite <- Lmvv.
      prove -v+v < x+v.
      apply add_SNo_Lt1 (-v) v x Lmv Hv1 Hx.
      prove -v < x.
      exact Lmvx.
    + assume Hz: z :e {- x + z|z :e SNoR x}.
      apply ReplE_impred (SNoR x) (fun z => - x + z) z Hz.
      let v.
      assume Hv: v :e SNoR x.
      assume Hzv: z = - x + v.
      apply SNoR_E x Hx v Hv.
      assume Hv1: SNo v.
      assume Hv2: SNoLev v :e SNoLev x.
      assume Hv3: x < v.
      claim Lmv: SNo (-v).
      { apply SNo_minus_SNo. exact Hv1. }
      claim Lmvv: -v + v = 0.
      { apply IH. prove v :e SNoS_ (SNoLev x).
        apply SNoS_I2 v x Hv1 Hx.
        prove SNoLev v :e SNoLev x.
        exact Hv2.
      }
      claim Lmvmx: -v < -x.
      { apply minus_SNo_Lt_contra x v Hx Hv1.
        prove x < v.
        exact Hv3.
      }
      prove 0 < z.
      rewrite Hzv.
      prove 0 < -x + v.
      rewrite <- Lmvv.
      prove -v+v < -x+v.
      apply add_SNo_Lt1 (-v) v (-x) Lmv Hv1 Lmx.
      prove -v < -x.
      exact Lmvmx.
}
apply Lfst.
assume H1: SNoLev (SNoCut L R) c= SNoLev 0.
assume H2: SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) 0.
apply SNo_eq (SNoCut L R) 0 LNLR SNo_0.
- prove SNoLev (SNoCut L R) = SNoLev 0.
  apply set_ext.
  + exact H1.
  + rewrite ordinal_SNoLev 0 ordinal_Empty.
    prove 0 c= SNoLev (SNoCut L R).
    apply Subq_Empty.
- prove SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) 0.
  exact H2.
Qed.

Theorem add_SNo_minus_SNo_rinv : forall x, SNo x -> x + -x = 0.
let x. assume Hx: SNo x.
claim Lmx: SNo (-x).
{ exact SNo_minus_SNo x Hx. }
prove x + -x = 0.
rewrite add_SNo_com x (-x) Hx Lmx.
prove -x + x = 0.
exact add_SNo_minus_SNo_linv x Hx.
Qed.

Theorem add_SNo_ordinal_SNoCutP : forall alpha, ordinal alpha -> forall beta, ordinal beta -> SNoCutP ({x + beta | x :e SNoS_ alpha} :\/: {alpha + x | x :e SNoS_ beta}) Empty.
let alpha. assume Ha: ordinal alpha.
let beta. assume Hb: ordinal beta.
set Lo1 := {x + beta | x :e SNoS_ alpha}.
set Lo2 := {alpha + x | x :e SNoS_ beta}.
prove (forall x :e Lo1 :\/: Lo2, SNo x)
   /\ (forall y :e Empty, SNo y)
   /\ (forall x :e Lo1 :\/: Lo2, forall y :e Empty, x < y).
apply and3I.
- let w. assume Hw: w :e Lo1 :\/: Lo2.
  apply binunionE Lo1 Lo2 w Hw.
  + assume H1: w :e Lo1.
    apply ReplE_impred (SNoS_ alpha) (fun x => x + beta) w H1.
    let x. assume Hx: x :e SNoS_ alpha.
    assume H2: w = x + beta.
    apply SNoS_E2 alpha Ha x Hx.
    assume _ _.
    assume Hx2: SNo x.
    assume _.
    prove SNo w.
    rewrite H2.
    prove SNo (x + beta).
    exact SNo_add_SNo x beta Hx2 (ordinal_SNo beta Hb).
  + assume H1: w :e Lo2.
    apply ReplE_impred (SNoS_ beta) (fun x => alpha + x) w H1.
    let x. assume Hx: x :e SNoS_ beta.
    assume H2: w = alpha + x.
    apply SNoS_E2 beta Hb x Hx.
    assume _ _.
    assume Hx2: SNo x.
    assume _.
    prove SNo w.
    rewrite H2.
    prove SNo (alpha + x).
    exact SNo_add_SNo alpha x (ordinal_SNo alpha Ha) Hx2.
- let y. assume Hy: y :e Empty. prove False. exact EmptyE y Hy.
- let x. assume _.
  let y. assume Hy: y :e Empty. prove False. exact EmptyE y Hy.
Qed.

Theorem add_SNo_ordinal_eq : forall alpha, ordinal alpha -> forall beta, ordinal beta -> alpha + beta = SNoCut ({x + beta | x :e SNoS_ alpha} :\/: {alpha + x | x :e SNoS_ beta}) Empty.
let alpha. assume Ha: ordinal alpha.
let beta. assume Hb: ordinal beta.
set Lo1 := {x + beta | x :e SNoS_ alpha}.
set Lo2 := {alpha + x | x :e SNoS_ beta}.
prove alpha + beta = SNoCut (Lo1 :\/: Lo2) Empty.
claim La: SNo alpha.
{ exact ordinal_SNo alpha Ha. }
claim Lb: SNo beta.
{ exact ordinal_SNo beta Hb. }
rewrite add_SNo_eq alpha La beta Lb.
prove SNoCut ({x + beta|x :e SNoL alpha} :\/: {alpha + x|x :e SNoL beta})
             ({x + beta|x :e SNoR alpha} :\/: {alpha + x|x :e SNoR beta})
    = SNoCut (Lo1 :\/: Lo2) Empty.
rewrite ordinal_SNoL alpha Ha.
rewrite ordinal_SNoL beta Hb.
prove SNoCut (Lo1 :\/: Lo2)
             ({x + beta|x :e SNoR alpha} :\/: {alpha + x|x :e SNoR beta})
    = SNoCut (Lo1 :\/: Lo2) Empty.
rewrite ordinal_SNoR alpha Ha.
rewrite ordinal_SNoR beta Hb.
prove SNoCut (Lo1 :\/: Lo2)
             ({x + beta|x :e Empty} :\/: {alpha + x|x :e Empty})
    = SNoCut (Lo1 :\/: Lo2) Empty.
rewrite Repl_Empty.
rewrite Repl_Empty.
prove SNoCut (Lo1 :\/: Lo2) (Empty :\/: Empty)
    = SNoCut (Lo1 :\/: Lo2) Empty.
rewrite binunion_idl.
reflexivity.
Qed.

Theorem add_SNo_ordinal_ordinal : forall alpha, ordinal alpha -> forall beta, ordinal beta -> ordinal (alpha + beta).
let alpha. assume Ha: ordinal alpha.
let beta. assume Hb: ordinal beta.
claim La: SNo alpha.
{ exact ordinal_SNo alpha Ha. }
claim Lb: SNo beta.
{ exact ordinal_SNo beta Hb. }
claim Lab1: SNo (alpha + beta).
{ exact SNo_add_SNo alpha beta La Lb. }
claim Lab2: ordinal (SNoLev (alpha + beta)).
{ exact SNoLev_ordinal (alpha + beta) Lab1. }
prove ordinal (alpha + beta).
apply SNo_max_ordinal (alpha + beta) Lab1.
prove forall y :e SNoS_ (SNoLev (alpha + beta)), y < alpha + beta.
let y. assume Hy: y :e SNoS_ (SNoLev (alpha + beta)).
apply SNoS_E2 (SNoLev (alpha + beta)) Lab2 y Hy.
assume Hy1: SNoLev y :e SNoLev (alpha + beta).
assume Hy2: ordinal (SNoLev y).
assume Hy3: SNo y.
assume Hy4: SNo_ (SNoLev y) y.
set Lo1 := {x + beta | x :e SNoS_ alpha}.
set Lo2 := {alpha + x | x :e SNoS_ beta}.
apply SNoLt_trichotomy_or y (alpha + beta) Hy3 Lab1. assume H1. apply H1.
- assume H1: y < alpha + beta. exact H1.
- assume H1: y = alpha + beta.
  prove False.
  apply In_irref (SNoLev y).
  rewrite H1 at 2. exact Hy1.
- assume H1: alpha + beta < y.
  prove False.
  apply add_SNo_ordinal_SNoCutP alpha Ha beta Hb.
  assume H2. apply H2.
  assume H2: forall x :e Lo1 :\/: Lo2, SNo x.
  assume _ _.
  apply SNoCutP_SNoCut (Lo1 :\/: Lo2) Empty
               (add_SNo_ordinal_SNoCutP alpha Ha beta Hb).
  assume H3. apply H3. assume H3. apply H3.
  assume _.
  assume H3: forall x :e Lo1 :\/: Lo2, x < SNoCut (Lo1 :\/: Lo2) Empty.
  assume _.
  assume H4: forall z, SNo z
            -> (forall x :e Lo1 :\/: Lo2, x < z)
            -> (forall y :e Empty, z < y)
            -> SNoLev (SNoCut (Lo1 :\/: Lo2) Empty) c= SNoLev z
            /\ SNoEq_ (SNoLev (SNoCut (Lo1 :\/: Lo2) Empty)) (SNoCut (Lo1 :\/: Lo2) Empty) z.
  claim L1: SNoLev (alpha + beta) c= SNoLev y
         /\ SNoEq_ (SNoLev (alpha + beta)) (alpha + beta) y.
  { rewrite add_SNo_ordinal_eq alpha Ha beta Hb.
    apply H4 y Hy3.
    - let w. assume Hw: w :e Lo1 :\/: Lo2.
      prove w < y.
      apply SNoLt_tra w (alpha + beta) y (H2 w Hw) Lab1 Hy3.
      + prove w < alpha + beta.
        rewrite add_SNo_ordinal_eq alpha Ha beta Hb.
        exact H3 w Hw.
      + prove alpha + beta < y. exact H1.
    - let w. assume Hw: w :e Empty. prove False. exact EmptyE w Hw.
  }
  apply L1.
  assume H5: SNoLev (alpha + beta) c= SNoLev y.
  assume _.
  apply In_irref (SNoLev y).
  apply H5. exact Hy1.
Qed.

Theorem add_SNo_ordinal_SL : forall alpha, ordinal alpha -> forall beta, ordinal beta -> ordsucc alpha + beta = ordsucc (alpha + beta).
let alpha. assume Ha: ordinal alpha.
apply ordinal_ind.
let beta. assume Hb: ordinal beta.
assume IH: forall delta :e beta, ordsucc alpha + delta = ordsucc (alpha + delta).
claim La: SNo alpha.
{ exact ordinal_SNo alpha Ha. }
claim Lb: SNo beta.
{ exact ordinal_SNo beta Hb. }
claim Lab: ordinal (alpha + beta).
{ exact add_SNo_ordinal_ordinal alpha Ha beta Hb. }
claim LSa: ordinal (ordsucc alpha).
{ apply ordinal_ordsucc. exact Ha. }
claim LSa2: SNo (ordsucc alpha).
{ apply ordinal_SNo. exact LSa. }
claim LSab: ordinal (ordsucc alpha + beta).
{ exact add_SNo_ordinal_ordinal (ordsucc alpha) LSa beta Hb. }
set Lo1 := {x + beta | x :e SNoS_ (ordsucc alpha)}.
set Lo2 := {ordsucc alpha + x | x :e SNoS_ beta}.
apply SNoCutP_SNoCut (Lo1 :\/: Lo2) Empty (add_SNo_ordinal_SNoCutP (ordsucc alpha) LSa beta Hb).
assume H1. apply H1. assume H1. apply H1.
assume _.
rewrite <- add_SNo_ordinal_eq (ordsucc alpha) LSa beta Hb.
assume H1: forall x :e Lo1 :\/: Lo2 , x < ordsucc alpha + beta.
assume _.
assume H2: forall z, SNo z -> (forall x :e Lo1 :\/: Lo2, x < z) -> (forall y :e Empty, z < y) -> SNoLev (ordsucc alpha + beta) c= SNoLev z /\ SNoEq_ (SNoLev (ordsucc alpha + beta)) (ordsucc alpha + beta) z.
claim L1: alpha + beta :e ordsucc alpha + beta.
{ apply ordinal_SNoLt_In (alpha + beta) (ordsucc alpha + beta) Lab LSab.
  prove alpha + beta < ordsucc alpha + beta.
  apply H1.
  prove alpha + beta :e Lo1 :\/: Lo2.
  apply binunionI1.
  prove alpha + beta :e {x + beta | x :e SNoS_ (ordsucc alpha)}.
  apply ReplI (SNoS_ (ordsucc alpha)) (fun x => x + beta) alpha.
  prove alpha :e SNoS_ (ordsucc alpha).
  apply SNoS_I (ordsucc alpha) LSa alpha alpha (ordsuccI2 alpha).
  prove SNo_ alpha alpha.
  exact ordinal_SNo_ alpha Ha.
}
apply ordinal_ordsucc_In_eq (ordsucc alpha + beta) (alpha + beta) LSab L1.
- assume H3: ordsucc (alpha + beta) :e ordsucc alpha + beta.
  prove False.
  set z := ordsucc (alpha + beta).
  claim Lz: ordinal z.
  { exact ordinal_ordsucc (alpha + beta) Lab. }
  claim Lz1: TransSet z.
  { exact ordinal_TransSet z Lz. }
  claim Lz2: SNo z.
  { apply ordinal_SNo. exact Lz. }
  claim L2: SNoLev (ordsucc alpha + beta) c= SNoLev z
         /\ SNoEq_ (SNoLev (ordsucc alpha + beta)) (ordsucc alpha + beta) z.
  { apply H2 z (ordinal_SNo z Lz).
    - let w. assume Hw: w :e Lo1 :\/: Lo2.
      prove w < z.
      apply binunionE Lo1 Lo2 w Hw.
      + assume H4: w :e Lo1.
        apply ReplE_impred (SNoS_ (ordsucc alpha)) (fun x => x + beta) w H4.
        let x.
        assume Hx: x :e SNoS_ (ordsucc alpha).
        assume Hwx: w = x + beta.
        apply SNoS_E2 (ordsucc alpha) LSa x Hx.
        assume Hx1: SNoLev x :e ordsucc alpha.
        assume Hx2: ordinal (SNoLev x).
        assume Hx3: SNo x.
        assume Hx4: SNo_ (SNoLev x) x.
        prove w < z.
        rewrite Hwx.
        prove x + beta < z.
        claim LLxb: ordinal (SNoLev x + beta).
        { exact add_SNo_ordinal_ordinal (SNoLev x) Hx2 beta Hb. }
        claim LLxb2: SNo (SNoLev x + beta).
        { apply ordinal_SNo. exact LLxb. }
        apply SNoLeLt_tra (x + beta) (SNoLev x + beta) z
                          (SNo_add_SNo x beta Hx3 Lb)
                          LLxb2 Lz2.
        * prove x + beta <= SNoLev x + beta.
          apply add_SNo_Le1 x beta (SNoLev x) Hx3 Lb (ordinal_SNo (SNoLev x) Hx2).
          prove x <= SNoLev x.
          exact ordinal_SNoLev_max_2 (SNoLev x) Hx2 x Hx3 (ordsuccI2 (SNoLev x)).
        * { prove SNoLev x + beta < z.
            apply SNoLeLt_tra (SNoLev x + beta) (alpha + beta) z
                              LLxb2 (ordinal_SNo (alpha + beta) Lab) Lz2.
            - prove SNoLev x + beta <= alpha + beta.
              apply add_SNo_Le1 (SNoLev x) beta alpha (ordinal_SNo (SNoLev x) Hx2) Lb La.
              prove SNoLev x <= alpha.
              apply ordinal_Subq_SNoLe (SNoLev x) alpha Hx2 Ha.
              prove SNoLev x c= alpha.
              apply ordsuccE alpha (SNoLev x) Hx1.
              + assume H5: SNoLev x :e alpha. apply Ha. assume Ha1 _. exact Ha1 (SNoLev x) H5.
              + assume H5: SNoLev x = alpha. rewrite H5. apply Subq_ref.
            - prove alpha + beta < z.
              exact ordinal_In_SNoLt z Lz (alpha + beta) (ordsuccI2 (alpha + beta)).
          }
      + assume H4: w :e Lo2.
        apply ReplE_impred (SNoS_ beta) (fun x => ordsucc alpha + x) w H4.
        let x.
        assume Hx: x :e SNoS_ beta.
        assume Hwx: w = ordsucc alpha + x.
        apply SNoS_E2 beta Hb x Hx.
        assume Hx1: SNoLev x :e beta.
        assume Hx2: ordinal (SNoLev x).
        assume Hx3: SNo x.
        assume Hx4: SNo_ (SNoLev x) x.
        prove w < z.
        rewrite Hwx.
        prove ordsucc alpha + x < z.
        claim IHLx: ordsucc alpha + SNoLev x = ordsucc (alpha + SNoLev x).
        { exact IH (SNoLev x) Hx1. }
        claim LSax: SNo (ordsucc alpha + x).
        { exact SNo_add_SNo (ordsucc alpha) x LSa2 Hx3. }
        claim LaLx: ordinal (alpha + SNoLev x).
        { exact add_SNo_ordinal_ordinal alpha Ha (SNoLev x) Hx2. }
        claim LSaLx: ordinal (ordsucc alpha + SNoLev x).
        { exact add_SNo_ordinal_ordinal (ordsucc alpha) LSa (SNoLev x) Hx2. }
        claim LSaLx2: SNo (ordsucc alpha + SNoLev x).
        { apply ordinal_SNo. exact LSaLx. }
        apply SNoLeLt_tra (ordsucc alpha + x) (ordsucc alpha + SNoLev x) z
                          LSax LSaLx2 Lz2.
        * prove ordsucc alpha + x <= ordsucc alpha + SNoLev x.
          apply add_SNo_Le2 (ordsucc alpha) x (SNoLev x)
                            LSa2 Hx3 (ordinal_SNo (SNoLev x) Hx2).
          prove x <= SNoLev x.
          exact ordinal_SNoLev_max_2 (SNoLev x) Hx2 x Hx3 (ordsuccI2 (SNoLev x)).
        * prove ordsucc alpha + SNoLev x < z.
          rewrite IHLx.
          prove ordsucc (alpha + SNoLev x) < ordsucc (alpha + beta).
          apply ordinal_In_SNoLt z Lz (ordsucc (alpha + SNoLev x)).
          prove ordsucc (alpha + SNoLev x) :e ordsucc (alpha + beta).
          apply ordinal_ordsucc_In (alpha + beta) Lab.
          prove alpha + SNoLev x :e alpha + beta.
          apply ordinal_SNoLt_In (alpha + SNoLev x) (alpha + beta) LaLx Lab.
          prove alpha + SNoLev x < alpha + beta.
          apply add_SNo_Lt2 alpha (SNoLev x) beta La (ordinal_SNo (SNoLev x) Hx2) Lb.
          prove SNoLev x < beta.
          apply ordinal_In_SNoLt beta Hb (SNoLev x).
          prove SNoLev x :e beta.
          exact Hx1.
    - let w. assume Hw: w :e Empty. prove False. exact EmptyE w Hw.
  }
  apply L2.
  rewrite ordinal_SNoLev (ordsucc alpha + beta) LSab.
  rewrite ordinal_SNoLev z Lz.
  assume H4: ordsucc alpha + beta c= z.
  assume _.
  apply In_irref z.
  apply H4.
  prove z :e ordsucc alpha + beta.
  exact H3.
- assume H3: ordsucc alpha + beta = ordsucc (alpha + beta).
  exact H3.
Qed.

Theorem add_SNo_ordinal_SR : forall alpha, ordinal alpha -> forall beta, ordinal beta -> alpha + ordsucc beta = ordsucc (alpha + beta).
let alpha. assume Ha: ordinal alpha.
let beta. assume Hb: ordinal beta.
claim La: SNo alpha.
{ exact ordinal_SNo alpha Ha. }
claim Lb: SNo beta.
{ exact ordinal_SNo beta Hb. }
claim La: SNo alpha.
{ exact ordinal_SNo alpha Ha. }
claim LSb: ordinal (ordsucc beta).
{ apply ordinal_ordsucc. exact Hb. }
claim LSb2: SNo (ordsucc beta).
{ exact ordinal_SNo (ordsucc beta) LSb. }
rewrite add_SNo_com alpha (ordsucc beta) La LSb2.
prove ordsucc beta + alpha = ordsucc (alpha + beta).
rewrite add_SNo_ordinal_SL beta Hb alpha Ha.
prove ordsucc (beta + alpha) = ordsucc (alpha + beta).
rewrite add_SNo_com beta alpha Lb La.
reflexivity.
Qed.

Theorem add_SNo_ordinal_InL : forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall gamma :e alpha, gamma + beta :e alpha + beta.
let alpha. assume Ha. let beta. assume Hb. let gamma. assume Hc.
claim Lc: ordinal gamma.
{ exact ordinal_Hered alpha Ha gamma Hc. }
claim Lab: ordinal (alpha + beta).
{ apply add_SNo_ordinal_ordinal.
  - exact Ha.
  - exact Hb.
}
claim Lcb: ordinal (gamma + beta).
{ apply add_SNo_ordinal_ordinal.
  - exact Lc.
  - exact Hb.
}
prove gamma + beta :e alpha + beta.
apply ordinal_SNoLt_In (gamma + beta) (alpha + beta) Lcb Lab.
prove gamma + beta < alpha + beta.
apply add_SNo_Lt1.
- apply ordinal_SNo. exact Lc.
- apply ordinal_SNo. exact Hb.
- apply ordinal_SNo. exact Ha.
- exact ordinal_In_SNoLt alpha Ha gamma Hc.
Qed.

Theorem add_SNo_ordinal_InR : forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall gamma :e beta, alpha + gamma :e alpha + beta.
let alpha. assume Ha: ordinal alpha.
let beta. assume Hb: ordinal beta.
let gamma. assume Hc: gamma :e beta.
claim La: SNo alpha.
{ exact ordinal_SNo alpha Ha. }
claim Lb: SNo beta.
{ exact ordinal_SNo beta Hb. }
claim Lc: ordinal gamma.
{ exact ordinal_Hered beta Hb gamma Hc. }
claim Lc2: SNo gamma.
{ exact ordinal_SNo gamma Lc. }
rewrite add_SNo_com alpha gamma La Lc2.
rewrite add_SNo_com alpha beta La Lb.
exact add_SNo_ordinal_InL beta Hb alpha Ha gamma Hc.
Qed.

Theorem add_nat_add_SNo : forall n m :e omega, add_nat n m = n + m.
let n. assume Hn: n :e omega.
claim Ln1: nat_p n.
{ exact omega_nat_p n Hn. }
claim Ln2: ordinal n.
{ exact nat_p_ordinal n Ln1. }
claim Ln3: SNo n.
{ exact ordinal_SNo n Ln2. }
claim L1: forall m, nat_p m -> add_nat n m = n + m.
{ apply nat_ind.
  - prove add_nat n 0 = n + 0.
    rewrite add_SNo_0R n Ln3.
    prove add_nat n 0 = n.
    exact add_nat_0R n.
  - let m.
    assume Hm: nat_p m.
    assume IH: add_nat n m = n + m.
    prove add_nat n (ordsucc m) = n + (ordsucc m).
    rewrite add_SNo_ordinal_SR n Ln2 m (nat_p_ordinal m Hm).
    prove add_nat n (ordsucc m) = ordsucc (n + m).
    rewrite <- IH.
    prove add_nat n (ordsucc m) = ordsucc (add_nat n m).
    exact add_nat_SR n m Hm.
}
let m. assume Hm: m :e omega.
prove add_nat n m = n + m.
exact L1 m (omega_nat_p m Hm).
Qed.

Theorem add_SNo_In_omega : forall n m :e omega, n + m :e omega.
let n. assume Hn. let m. assume Hm.
rewrite <- add_nat_add_SNo n Hn m Hm.
apply nat_p_omega.
apply add_nat_p.
- apply omega_nat_p. exact Hn.
- apply omega_nat_p. exact Hm.
Qed.

Theorem add_SNo_1_1_2 : 1 + 1 = 2.
rewrite <- add_nat_add_SNo 1 (nat_p_omega 1 nat_1) 1 (nat_p_omega 1 nat_1).
exact add_nat_1_1_2.
Qed.

Theorem add_SNo_SNoL_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoL (x + y), (exists v :e SNoL x, u <= v + y) \/ (exists v :e SNoL y, u <= x + v).
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
claim Lxy: SNo (x + y).
{ exact SNo_add_SNo x y Hx Hy. }
claim LI: forall u, SNo u -> SNoLev u :e SNoLev (x + y) -> u < x + y -> (exists v :e SNoL x, u <= v + y) \/ (exists v :e SNoL y, u <= x + v).
{ apply SNoLev_ind.
  let u.
  assume Hu1: SNo u.
  assume IH: forall z :e SNoS_ (SNoLev u), SNoLev z :e SNoLev (x + y) -> z < x + y -> (exists v :e SNoL x, z <= v + y) \/ (exists v :e SNoL y, z <= x + v).
  assume Hu2: SNoLev u :e SNoLev (x + y).
  assume Hu3: u < x + y.
  apply dneg.
  assume HNC: ~((exists v :e SNoL x, u <= v + y) \/ (exists v :e SNoL y, u <= x + v)).
  apply SNoLt_irref u.
  prove u < u.
  apply SNoLtLe_tra u (x + y) u Hu1 Lxy Hu1 Hu3.
  prove x + y <= u.
  set Lxy1 := {w + y|w :e SNoL x}.
  set Lxy2 := {x + w|w :e SNoL y}.
  set Rxy1 := {z + y|z :e SNoR x}.
  set Rxy2 := {x + z|z :e SNoR y}.
  rewrite add_SNo_eq x Hx y Hy.
  prove SNoCut (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2) <= u.
  rewrite SNo_eta u Hu1.
  prove SNoCut (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2) <= SNoCut (SNoL u) (SNoR u).
  apply SNoCut_Le (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2) (SNoL u) (SNoR u).
  - exact add_SNo_SNoCutP x y Hx Hy.
  - exact SNoCutP_SNoL_SNoR u Hu1.
  - rewrite <- SNo_eta u Hu1.
    prove forall w :e Lxy1 :\/: Lxy2, w < u.
    let w. assume Hw: w :e Lxy1 :\/: Lxy2.
    apply binunionE Lxy1 Lxy2 w Hw.
    + assume Hw2: w :e Lxy1.
      prove w < u.
      apply ReplE_impred (SNoL x) (fun w => w + y) w Hw2.
      let v.
      assume Hv: v :e SNoL x.
      assume Hwv: w = v + y.
      apply SNoL_E x Hx v Hv.
      assume Hv1: SNo v.
      assume Hv2: SNoLev v :e SNoLev x.
      assume Hv3: v < x.
      rewrite Hwv.
      prove v + y < u.
      claim Lvy: SNo (v + y).
      { exact SNo_add_SNo v y Hv1 Hy. }
      apply SNoLtLe_or (v+y) u Lvy Hu1.
      * assume H1: v + y < u. exact H1.
      * { assume H1: u <= v+y.
          prove False.
          apply HNC.
          apply orIL.
          witness v.
          apply andI.
          - prove v :e SNoL x. exact Hv.
          - prove u <= v + y. exact H1.
        }
    + assume Hw2: w :e Lxy2.
      prove w < u.
      apply ReplE_impred (SNoL y) (fun w => x + w) w Hw2.
      let v.
      assume Hv: v :e SNoL y.
      assume Hwv: w = x + v.
      apply SNoL_E y Hy v Hv.
      assume Hv1: SNo v.
      assume Hv2: SNoLev v :e SNoLev y.
      assume Hv3: v < y.
      rewrite Hwv.
      prove x + v < u.
      claim Lxv: SNo (x + v).
      { exact SNo_add_SNo x v Hx Hv1. }
      apply SNoLtLe_or (x+v) u Lxv Hu1.
      * assume H1: x + v < u. exact H1.
      * { assume H1: u <= x+v.
          prove False.
          apply HNC.
          apply orIR.
          witness v.
          apply andI.
          - prove v :e SNoL y. exact Hv.
          - prove u <= x + v. exact H1.
        }
  - rewrite <- add_SNo_eq x Hx y Hy.
    prove forall z :e SNoR u, x + y < z.
    let z. assume Hz: z :e SNoR u.
    apply SNoR_E u Hu1 z Hz.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev u.
    assume Hz3: u < z.
    apply SNoLt_trichotomy_or (x + y) z Lxy Hz1.
    assume H1. apply H1.
    + assume H1: x + y < z. exact H1.
    + assume H1: x + y = z.
      prove False.
      apply In_no2cycle (SNoLev z) (SNoLev u) Hz2.
      prove SNoLev u :e SNoLev z.
      rewrite <- H1.
      exact Hu2.
    + assume H1: z < x + y.
      prove False.
      claim Lz1: z :e SNoS_ (SNoLev u).
      { exact SNoR_SNoS_ u z Hz. }
      claim Lz2: SNoLev z :e SNoLev (x + y).
      { apply SNoLev_ordinal (x+y) Lxy. assume Hxy1 _.
        exact Hxy1 (SNoLev u) Hu2 (SNoLev z) Hz2.
      }
      apply IH z Lz1 Lz2 H1.
      * { assume H2: exists v :e SNoL x, z <= v + y.
          apply H2.
          let v. assume H3. apply H3.
          assume Hv: v :e SNoL x.
          assume H3: z <= v + y.
          apply SNoL_E x Hx v Hv.
          assume Hv1: SNo v.
          assume Hv2: SNoLev v :e SNoLev x.
          assume Hv3: v < x.
          apply HNC.
          apply orIL.
          witness v.
          apply andI.
          - exact Hv.
          - prove u <= v + y.
            apply SNoLe_tra u z (v + y) Hu1 Hz1 (SNo_add_SNo v y Hv1 Hy).
            + prove u <= z. apply SNoLtLe. exact Hz3.
            + prove z <= v + y. exact H3.
        }
      * { assume H2: exists v :e SNoL y, z <= x + v.
          apply H2.
          let v. assume H3. apply H3.
          assume Hv: v :e SNoL y.
          assume H3: z <= x + v.
          apply SNoL_E y Hy v Hv.
          assume Hv1: SNo v.
          assume Hv2: SNoLev v :e SNoLev y.
          assume Hv3: v < y.
          apply HNC.
          apply orIR.
          witness v.
          apply andI.
          - exact Hv.
          - prove u <= x + v.
            apply SNoLe_tra u z (x + v) Hu1 Hz1 (SNo_add_SNo x v Hx Hv1).
            + prove u <= z. apply SNoLtLe. exact Hz3.
            + prove z <= x + v. exact H3.
        }
}
let u.
assume Hu: u :e SNoL (x+y).
apply SNoL_E (x+y) Lxy u Hu.
assume Hu1: SNo u.
assume Hu2: SNoLev u :e SNoLev (x + y).
assume Hu3: u < x + y.
exact LI u Hu1 Hu2 Hu3.
Qed.

Theorem add_SNo_SNoR_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoR (x + y), (exists v :e SNoR x, v + y <= u) \/ (exists v :e SNoR y, x + v <= u).
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
claim Lxy: SNo (x + y).
{ exact SNo_add_SNo x y Hx Hy. }
claim LI: forall u, SNo u -> SNoLev u :e SNoLev (x + y) -> x + y < u -> (exists v :e SNoR x, v + y <= u) \/ (exists v :e SNoR y, x + v <= u).
{ apply SNoLev_ind.
  let u.
  assume Hu1: SNo u.
  assume IH: forall z :e SNoS_ (SNoLev u), SNoLev z :e SNoLev (x + y) -> x + y < z -> (exists v :e SNoR x, v + y <= z) \/ (exists v :e SNoR y, x + v <= z).
  assume Hu2: SNoLev u :e SNoLev (x + y).
  assume Hu3: x + y < u.
  apply dneg.
  assume HNC: ~((exists v :e SNoR x, v + y <= u) \/ (exists v :e SNoR y, x + v <= u)).
  apply SNoLt_irref u.
  prove u < u.
  apply (fun H: u <= x+y => SNoLeLt_tra u (x + y) u Hu1 Lxy Hu1 H Hu3).
  prove u <= x + y.
  set Lxy1 := {w + y|w :e SNoL x}.
  set Lxy2 := {x + w|w :e SNoL y}.
  set Rxy1 := {z + y|z :e SNoR x}.
  set Rxy2 := {x + z|z :e SNoR y}.
  rewrite add_SNo_eq x Hx y Hy.
  prove u <= SNoCut (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2).
  rewrite SNo_eta u Hu1.
  prove SNoCut (SNoL u) (SNoR u) <= SNoCut (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2).
  apply SNoCut_Le (SNoL u) (SNoR u) (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2).
  - exact SNoCutP_SNoL_SNoR u Hu1.
  - exact add_SNo_SNoCutP x y Hx Hy.
  - rewrite <- add_SNo_eq x Hx y Hy.
    prove forall z :e SNoL u, z < x + y.
    let z. assume Hz: z :e SNoL u.
    apply SNoL_E u Hu1 z Hz.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev u.
    assume Hz3: z < u.
    apply SNoLt_trichotomy_or z (x + y) Hz1 Lxy.
    assume H1. apply H1.
    + assume H1: z < x + y. exact H1.
    + assume H1: z = x + y.
      prove False.
      apply In_no2cycle (SNoLev z) (SNoLev u) Hz2.
      prove SNoLev u :e SNoLev z.
      rewrite H1.
      exact Hu2.
    + assume H1: x + y < z.
      prove False.
      claim Lz1: z :e SNoS_ (SNoLev u).
      { exact SNoL_SNoS_ u z Hz. }
      claim Lz2: SNoLev z :e SNoLev (x + y).
      { apply SNoLev_ordinal (x+y) Lxy. assume Hxy1 _.
        exact Hxy1 (SNoLev u) Hu2 (SNoLev z) Hz2.
      }
      apply IH z Lz1 Lz2 H1.
      * { assume H2: exists v :e SNoR x, v + y <= z.
          apply H2.
          let v. assume H3. apply H3.
          assume Hv: v :e SNoR x.
          assume H3: v + y <= z.
          apply SNoR_E x Hx v Hv.
          assume Hv1: SNo v.
          assume Hv2: SNoLev v :e SNoLev x.
          assume Hv3: x < v.
          apply HNC.
          apply orIL.
          witness v.
          apply andI.
          - exact Hv.
          - prove v + y <= u.
            apply SNoLe_tra (v + y) z u (SNo_add_SNo v y Hv1 Hy) Hz1 Hu1.
            + prove v + y <= z. exact H3.
            + prove z <= u. apply SNoLtLe. exact Hz3.
        }
      * { assume H2: exists v :e SNoR y, x + v <= z.
          apply H2.
          let v. assume H3. apply H3.
          assume Hv: v :e SNoR y.
          assume H3: x + v <= z.
          apply SNoR_E y Hy v Hv.
          assume Hv1: SNo v.
          assume Hv2: SNoLev v :e SNoLev y.
          assume Hv3: y < v.
          apply HNC.
          apply orIR.
          witness v.
          apply andI.
          - exact Hv.
          - prove x + v <= u.
            apply SNoLe_tra (x + v) z u (SNo_add_SNo x v Hx Hv1) Hz1 Hu1.
            + prove x + v <= z. exact H3.
            + prove z <= u. apply SNoLtLe. exact Hz3.
        }
  - rewrite <- SNo_eta u Hu1.
    prove forall w :e Rxy1 :\/: Rxy2, u < w.
    let w. assume Hw: w :e Rxy1 :\/: Rxy2.
    apply binunionE Rxy1 Rxy2 w Hw.
    + assume Hw2: w :e Rxy1.
      prove u < w.
      apply ReplE_impred (SNoR x) (fun w => w + y) w Hw2.
      let v.
      assume Hv: v :e SNoR x.
      assume Hwv: w = v + y.
      apply SNoR_E x Hx v Hv.
      assume Hv1: SNo v.
      assume Hv2: SNoLev v :e SNoLev x.
      assume Hv3: x < v.
      rewrite Hwv.
      prove u < v + y.
      claim Lvy: SNo (v + y).
      { exact SNo_add_SNo v y Hv1 Hy. }
      apply SNoLtLe_or u (v+y) Hu1 Lvy.
      * assume H1: u < v + y. exact H1.
      * { assume H1: v+y <= u.
          prove False.
          apply HNC.
          apply orIL.
          witness v.
          apply andI.
          - prove v :e SNoR x. exact Hv.
          - prove v + y <= u. exact H1.
        }
    + assume Hw2: w :e Rxy2.
      prove u < w.
      apply ReplE_impred (SNoR y) (fun w => x + w) w Hw2.
      let v.
      assume Hv: v :e SNoR y.
      assume Hwv: w = x + v.
      apply SNoR_E y Hy v Hv.
      assume Hv1: SNo v.
      assume Hv2: SNoLev v :e SNoLev y.
      assume Hv3: y < v.
      rewrite Hwv.
      prove u < x + v.
      claim Lxv: SNo (x + v).
      { exact SNo_add_SNo x v Hx Hv1. }
      apply SNoLtLe_or u (x+v) Hu1 Lxv.
      * assume H1: u < x + v. exact H1.
      * { assume H1: x+v <= u.
          prove False.
          apply HNC.
          apply orIR.
          witness v.
          apply andI.
          - prove v :e SNoR y. exact Hv.
          - prove x + v <= u. exact H1.
        }
}
let u.
assume Hu: u :e SNoR (x+y).
apply SNoR_E (x+y) Lxy u Hu.
assume Hu1: SNo u.
assume Hu2: SNoLev u :e SNoLev (x + y).
assume Hu3: x + y < u.
exact LI u Hu1 Hu2 Hu3.
Qed.

Theorem add_SNo_assoc : forall x y z, SNo x -> SNo y -> SNo z -> x + (y + z) = (x + y) + z.
set P : set -> set -> set -> prop := fun x y z => x + (y + z) = (x + y) + z.
apply SNoLev_ind3.
let x y z.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
assume IH1: forall u :e SNoS_ (SNoLev x), P u y z.
assume IH2: forall v :e SNoS_ (SNoLev y), P x v z.
assume IH3: forall w :e SNoS_ (SNoLev z), P x y w.
assume IH4: forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), P u v z.
assume IH5: forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), P u y w.
assume IH6: forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P x v w.
assume IH7: forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P u v w.
prove x + (y + z) = (x + y) + z.
claim Lxy: SNo (x + y).
{ exact SNo_add_SNo x y Hx Hy. }
claim Lyz: SNo (y + z).
{ exact SNo_add_SNo y z Hy Hz. }
set Lxyz1 := {w + (y + z)|w :e SNoL x}.
set Lxyz2 := {x + w|w :e SNoL (y + z)}.
set Rxyz1 := {w + (y + z)|w :e SNoR x}.
set Rxyz2 := {x + w|w :e SNoR (y + z)}.
set Lxyz3 := {w + z|w :e SNoL (x + y)}.
set Lxyz4 := {(x + y) + w|w :e SNoL z}.
set Rxyz3 := {w + z|w :e SNoR (x + y)}.
set Rxyz4 := {(x + y) + w|w :e SNoR z}.
rewrite add_SNo_eq x Hx (y+z) Lyz.
rewrite add_SNo_eq (x+y) Lxy z Hz.
prove (SNoCut (Lxyz1 :\/: Lxyz2) (Rxyz1 :\/: Rxyz2))
    = (SNoCut (Lxyz3 :\/: Lxyz4) (Rxyz3 :\/: Rxyz4)).
claim Lxyz12: SNoCutP (Lxyz1 :\/: Lxyz2) (Rxyz1 :\/: Rxyz2).
{ exact add_SNo_SNoCutP x (y+z) Hx Lyz. }
claim Lxyz34: SNoCutP (Lxyz3 :\/: Lxyz4) (Rxyz3 :\/: Rxyz4).
{ exact add_SNo_SNoCutP (x+y) z Lxy Hz. }
apply SNoCut_ext.
- exact Lxyz12.
- exact Lxyz34.
- prove forall w :e Lxyz1 :\/: Lxyz2, w < SNoCut (Lxyz3 :\/: Lxyz4) (Rxyz3 :\/: Rxyz4).
  rewrite <- add_SNo_eq (x+y) Lxy z Hz.
  prove forall w :e Lxyz1 :\/: Lxyz2, w < (x + y) + z.
  let w. assume Hw: w :e Lxyz1 :\/: Lxyz2.
  apply binunionE Lxyz1 Lxyz2 w Hw.
  + assume Hw: w :e Lxyz1.
    apply ReplE_impred (SNoL x) (fun w => w+(y+z)) w Hw.
    let u.
    assume Hu: u :e SNoL x.
    assume Hwu: w = u+(y+z).
    apply SNoL_E x Hx u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev x.
    assume Hu3: u < x.
    prove w < (x + y) + z.
    rewrite Hwu.
    prove u + (y + z) < (x + y) + z.
    claim IH1u: u+(y+z) = (u+y)+z.
    { exact IH1 u (SNoL_SNoS_ x u Hu). }
    rewrite IH1u.
    prove (u + y) + z < (x + y) + z.
    apply add_SNo_Lt1 (u + y) z (x + y) (SNo_add_SNo u y Hu1 Hy) Hz Lxy.
    prove u + y < x + y.
    apply add_SNo_Lt1 u y x Hu1 Hy Hx.
    prove u < x.
    exact Hu3.
  + assume Hw: w :e Lxyz2.
    apply ReplE_impred (SNoL (y+z)) (fun w => x+w) w Hw.
    let u.
    assume Hu: u :e SNoL (y+z).
    assume Hwu: w = x+u.
    apply SNoL_E (y+z) Lyz u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev (y+z).
    assume Hu3: u < y+z.
    rewrite Hwu.
    prove x + u < (x + y) + z.
    apply add_SNo_SNoL_interpolate y z Hy Hz u Hu.
    * { assume H1: exists v :e SNoL y, u <= v + z.
        apply H1.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoL y.
        assume H2: u <= v + z.
        apply SNoL_E y Hy v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev y.
        assume Hv3: v < y.
        claim IH2v: x + (v + z) = (x + v) + z.
        { exact IH2 v (SNoL_SNoS_ y v Hv). }
        prove x + u < (x + y) + z.
        apply SNoLeLt_tra (x + u) (x + (v + z)) ((x + y) + z)
                          (SNo_add_SNo x u Hx Hu1)
                          (SNo_add_SNo x (v+z) Hx (SNo_add_SNo v z Hv1 Hz))
                          (SNo_add_SNo (x+y) z Lxy Hz).
        - prove x + u <= x + (v + z).
          apply add_SNo_Le2 x u (v + z) Hx Hu1 (SNo_add_SNo v z Hv1 Hz).
          prove u <= v + z.
          exact H2.
        - prove x + (v + z) < (x + y) + z.
          rewrite IH2v.
          prove (x + v) + z < (x + y) + z.
          apply add_SNo_Lt1 (x+v) z (x+y) (SNo_add_SNo x v Hx Hv1) Hz Lxy.
          prove x + v < x + y.
          apply add_SNo_Lt2 x v y Hx Hv1 Hy.
          prove v < y.
          exact Hv3.
      }
    * { assume H1: exists v :e SNoL z, u <= y + v.
        apply H1.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoL z.
        assume H2: u <= y + v.
        apply SNoL_E z Hz v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev z.
        assume Hv3: v < z.
        claim IH3v: x + (y + v) = (x + y) + v.
        { exact IH3 v (SNoL_SNoS_ z v Hv). }
        prove x + u < (x + y) + z.
        apply SNoLeLt_tra (x + u) (x + (y + v)) ((x + y) + z)
                          (SNo_add_SNo x u Hx Hu1)
                          (SNo_add_SNo x (y+v) Hx (SNo_add_SNo y v Hy Hv1))
                          (SNo_add_SNo (x+y) z Lxy Hz).
        - prove x + u <= x + (y + v).
          apply add_SNo_Le2 x u (y + v) Hx Hu1 (SNo_add_SNo y v Hy Hv1).
          prove u <= y + v.
          exact H2.
        - prove x + (y + v) < (x + y) + z.
          rewrite IH3v.
          prove (x + y) + v < (x + y) + z.
          apply add_SNo_Lt2 (x+y) v z Lxy Hv1 Hz.
          prove v < z.
          exact Hv3.
      }
- prove forall v :e Rxyz1 :\/: Rxyz2, SNoCut (Lxyz3 :\/: Lxyz4) (Rxyz3 :\/: Rxyz4) < v.
  rewrite <- add_SNo_eq (x+y) Lxy z Hz.
  prove forall v :e Rxyz1 :\/: Rxyz2, (x + y) + z < v.
  let v. assume Hv: v :e Rxyz1 :\/: Rxyz2.
  apply binunionE Rxyz1 Rxyz2 v Hv.
  + assume Hv: v :e Rxyz1.
    apply ReplE_impred (SNoR x) (fun w => w+(y+z)) v Hv.
    let u.
    assume Hu: u :e SNoR x.
    assume Hvu: v = u+(y+z).
    apply SNoR_E x Hx u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev x.
    assume Hu3: x < u.
    prove (x + y) + z < v.
    rewrite Hvu.
    prove (x + y) + z < u + (y + z).
    claim IH1u: u+(y+z) = (u+y)+z.
    { exact IH1 u (SNoR_SNoS_ x u Hu). }
    rewrite IH1u.
    prove (x + y) + z < (u + y) + z.
    apply add_SNo_Lt1 (x + y) z (u + y) Lxy Hz (SNo_add_SNo u y Hu1 Hy).
    prove x + y < u + y.
    apply add_SNo_Lt1 x y u Hx Hy Hu1.
    prove x < u.
    exact Hu3.
  + assume Hv: v :e Rxyz2.
    apply ReplE_impred (SNoR (y+z)) (fun w => x+w) v Hv.
    let u.
    assume Hu: u :e SNoR (y+z).
    assume Hvu: v = x+u.
    apply SNoR_E (y+z) Lyz u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev (y+z).
    assume Hu3: y+z < u.
    rewrite Hvu.
    prove (x + y) + z < x + u.
    apply add_SNo_SNoR_interpolate y z Hy Hz u Hu.
    * { assume H1: exists v :e SNoR y, v + z <= u.
        apply H1.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoR y.
        assume H2: v + z <= u.
        apply SNoR_E y Hy v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev y.
        assume Hv3: y < v.
        claim IH2v: x + (v + z) = (x + v) + z.
        { exact IH2 v (SNoR_SNoS_ y v Hv). }
        prove (x + y) + z < x + u.
        apply SNoLtLe_tra ((x + y) + z) (x + (v + z)) (x + u)
                          (SNo_add_SNo (x+y) z Lxy Hz)
                          (SNo_add_SNo x (v+z) Hx (SNo_add_SNo v z Hv1 Hz))
                          (SNo_add_SNo x u Hx Hu1).
        - prove (x + y) + z < x + (v + z).
          rewrite IH2v.
          prove (x + y) + z < (x + v) + z.
          apply add_SNo_Lt1 (x+y) z (x+v) Lxy Hz (SNo_add_SNo x v Hx Hv1).
          prove x + y < x + v.
          apply add_SNo_Lt2 x y v Hx Hy Hv1.
          prove y < v.
          exact Hv3.
        - prove x + (v + z) <= x + u.
          apply add_SNo_Le2 x (v + z) u Hx (SNo_add_SNo v z Hv1 Hz) Hu1.
          prove v + z <= u.
          exact H2.
      }
    * { assume H1: exists v :e SNoR z, y + v <= u.
        apply H1.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoR z.
        assume H2: y + v <= u.
        apply SNoR_E z Hz v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev z.
        assume Hv3: z < v.
        claim IH3v: x + (y + v) = (x + y) + v.
        { exact IH3 v (SNoR_SNoS_ z v Hv). }
        prove (x + y) + z < x + u.
        apply SNoLtLe_tra ((x + y) + z) (x + (y + v)) (x + u)
                          (SNo_add_SNo (x+y) z Lxy Hz)
                          (SNo_add_SNo x (y+v) Hx (SNo_add_SNo y v Hy Hv1))
                          (SNo_add_SNo x u Hx Hu1).
        - prove (x + y) + z < x + (y + v).
          rewrite IH3v.
          prove (x + y) + z < (x + y) + v.
          apply add_SNo_Lt2 (x+y) z v Lxy Hz Hv1.
          prove z < v.
          exact Hv3.
        - prove x + (y + v) <= x + u.
          apply add_SNo_Le2 x (y + v) u Hx (SNo_add_SNo y v Hy Hv1) Hu1.
          prove y + v <= u.
          exact H2.
      }
- prove forall w :e Lxyz3 :\/: Lxyz4, w < SNoCut (Lxyz1 :\/: Lxyz2) (Rxyz1 :\/: Rxyz2).
  rewrite <- add_SNo_eq x Hx (y+z) Lyz.
  prove forall w :e Lxyz3 :\/: Lxyz4, w < x + (y + z).
  let w. assume Hw: w :e Lxyz3 :\/: Lxyz4.
  apply binunionE Lxyz3 Lxyz4 w Hw.
  + assume Hw: w :e Lxyz3.
    apply ReplE_impred (SNoL (x+y)) (fun w => w+z) w Hw.
    let u.
    assume Hu: u :e SNoL (x+y).
    assume Hwu: w = u+z.
    apply SNoL_E (x+y) Lxy u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev (x+y).
    assume Hu3: u < x+y.
    rewrite Hwu.
    prove u + z < x + (y + z).
    apply add_SNo_SNoL_interpolate x y Hx Hy u Hu.
    * { assume H1: exists v :e SNoL x, u <= v + y.
        apply H1.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoL x.
        assume H2: u <= v + y.
        apply SNoL_E x Hx v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev x.
        assume Hv3: v < x.
        claim IH1v: v + (y + z) = (v + y) + z.
        { exact IH1 v (SNoL_SNoS_ x v Hv). }
        prove u + z < x + (y + z).
        apply SNoLeLt_tra (u + z) ((v + y) + z) (x + (y + z))
                          (SNo_add_SNo u z Hu1 Hz)
                          (SNo_add_SNo (v+y) z (SNo_add_SNo v y Hv1 Hy) Hz)
                          (SNo_add_SNo x (y+z) Hx Lyz).
        - prove u + z <= (v + y) + z.
          apply add_SNo_Le1 u z (v + y) Hu1 Hz (SNo_add_SNo v y Hv1 Hy).
          prove u <= v + y.
          exact H2.
        - prove (v + y) + z < x + (y + z).
          rewrite <- IH1v.
          prove v + (y + z) < x + (y + z).
          apply add_SNo_Lt1 v (y+z) x Hv1 Lyz Hx.
          prove v < x.
          exact Hv3.
      }
    * { assume H1: exists v :e SNoL y, u <= x + v.
        apply H1.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoL y.
        assume H2: u <= x + v.
        apply SNoL_E y Hy v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev y.
        assume Hv3: v < y.
        claim IH2v: x + (v + z) = (x + v) + z.
        { exact IH2 v (SNoL_SNoS_ y v Hv). }
        prove u + z < x + (y + z).
        apply SNoLeLt_tra (u + z) ((x + v) + z) (x + (y + z))
                          (SNo_add_SNo u z Hu1 Hz)
                          (SNo_add_SNo (x+v) z (SNo_add_SNo x v Hx Hv1) Hz)
                          (SNo_add_SNo x (y+z) Hx Lyz).
        - prove u + z <= (x + v) + z.
          apply add_SNo_Le1 u z (x + v) Hu1 Hz (SNo_add_SNo x v Hx Hv1).
          prove u <= x + v.
          exact H2.
        - prove (x + v) + z < x + (y + z).
          rewrite <- IH2v.
          prove x + (v + z) < x + (y + z).
          apply add_SNo_Lt2 x (v+z) (y+z) Hx (SNo_add_SNo v z Hv1 Hz) Lyz.
          prove v + z < y + z.
          apply add_SNo_Lt1 v z y Hv1 Hz Hy.
          prove v < y.
          exact Hv3.
      }
  + assume Hw: w :e Lxyz4.
    apply ReplE_impred (SNoL z) (fun w => (x+y)+w) w Hw.
    let u.
    assume Hu: u :e SNoL z.
    assume Hwu: w = (x+y)+u.
    apply SNoL_E z Hz u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev z.
    assume Hu3: u < z.
    prove w < x + (y + z).
    rewrite Hwu.
    prove (x + y) + u < x + (y + z).
    claim IH3u: x + (y + u) = (x + y) + u.
    { exact IH3 u (SNoL_SNoS_ z u Hu). }
    rewrite <- IH3u.
    prove x + (y + u) < x + (y + z).
    apply add_SNo_Lt2 x (y + u) (y + z) Hx (SNo_add_SNo y u Hy Hu1) Lyz.
    prove y + u < y + z.
    apply add_SNo_Lt2 y u z Hy Hu1 Hz.
    prove u < z.
    exact Hu3.
- prove forall v :e Rxyz3 :\/: Rxyz4, SNoCut (Lxyz1 :\/: Lxyz2) (Rxyz1 :\/: Rxyz2) < v.
  rewrite <- add_SNo_eq x Hx (y+z) Lyz.
  prove forall v :e Rxyz3 :\/: Rxyz4, x + (y + z) < v.
  let v. assume Hv: v :e Rxyz3 :\/: Rxyz4.
  apply binunionE Rxyz3 Rxyz4 v Hv.
  + assume Hv: v :e Rxyz3.
    apply ReplE_impred (SNoR (x+y)) (fun w => w+z) v Hv.
    let u.
    assume Hu: u :e SNoR (x+y).
    assume Hvu: v = u+z.
    apply SNoR_E (x+y) Lxy u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev (x+y).
    assume Hu3: x+y < u.
    rewrite Hvu.
    prove x + (y + z) < u + z.
    apply add_SNo_SNoR_interpolate x y Hx Hy u Hu.
    * { assume H1: exists v :e SNoR x, v + y <= u.
        apply H1.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoR x.
        assume H2: v + y <= u.
        apply SNoR_E x Hx v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev x.
        assume Hv3: x < v.
        claim IH1v: v + (y + z) = (v + y) + z.
        { exact IH1 v (SNoR_SNoS_ x v Hv). }
        prove x + (y + z) < u + z.
        apply SNoLtLe_tra (x + (y + z)) ((v + y) + z) (u + z)
                          (SNo_add_SNo x (y+z) Hx Lyz)
                          (SNo_add_SNo (v+y) z (SNo_add_SNo v y Hv1 Hy) Hz)
                          (SNo_add_SNo u z Hu1 Hz).
        - prove x + (y + z) < (v + y) + z.
          rewrite <- IH1v.
          prove x + (y + z) < v + (y + z).
          apply add_SNo_Lt1 x (y+z) v Hx Lyz Hv1.
          prove x < v.
          exact Hv3.
        - prove (v + y) + z <= u + z.
          apply add_SNo_Le1 (v + y) z u (SNo_add_SNo v y Hv1 Hy) Hz Hu1.
          prove v + y <= u.
          exact H2.
      }
    * { assume H1: exists v :e SNoR y, x + v <= u.
        apply H1.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoR y.
        assume H2: x + v <= u.
        apply SNoR_E y Hy v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev y.
        assume Hv3: y < v.
        claim IH2v: x + (v + z) = (x + v) + z.
        { exact IH2 v (SNoR_SNoS_ y v Hv). }
        prove x + (y + z) < u + z.
        apply SNoLtLe_tra (x + (y + z)) ((x + v) + z) (u + z)
                          (SNo_add_SNo x (y+z) Hx Lyz)
                          (SNo_add_SNo (x+v) z (SNo_add_SNo x v Hx Hv1) Hz)
                          (SNo_add_SNo u z Hu1 Hz).
        - prove x + (y + z) < (x + v) + z.
          rewrite <- IH2v.
          prove x + (y + z) < x + (v + z).
          apply add_SNo_Lt2 x (y+z) (v+z) Hx Lyz (SNo_add_SNo v z Hv1 Hz).
          prove y + z < v + z.
          apply add_SNo_Lt1 y z v Hy Hz Hv1.
          prove y < v.
          exact Hv3.
        - prove (x + v) + z <= u + z.
          apply add_SNo_Le1 (x + v) z u (SNo_add_SNo x v Hx Hv1) Hz Hu1.
          prove x + v <= u.
          exact H2.
      }
  + assume Hv: v :e Rxyz4.
    apply ReplE_impred (SNoR z) (fun w => (x+y)+w) v Hv.
    let u.
    assume Hu: u :e SNoR z.
    assume Hvu: v = (x+y)+u.
    apply SNoR_E z Hz u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e SNoLev z.
    assume Hu3: z < u.
    prove x + (y + z) < v.
    rewrite Hvu.
    prove x + (y + z) < (x + y) + u.
    claim IH3u: x+(y+u) = (x+y)+u.
    { exact IH3 u (SNoR_SNoS_ z u Hu). }
    rewrite <- IH3u.
    prove x + (y + z) < x + (y + u).
    apply add_SNo_Lt2 x (y + z) (y + u) Hx Lyz (SNo_add_SNo y u Hy Hu1).
    prove y + z < y + u.
    apply add_SNo_Lt2 y z u Hy Hz Hu1.
    prove z < u.
    exact Hu3.
Qed.

Theorem add_SNo_minus_R2 : forall x y, SNo x -> SNo y -> (x + y) + - y = x.
let x y. assume Hx Hy.
transitivity x + (y + - y),
             x + 0.
- symmetry. exact add_SNo_assoc x y (- y) Hx Hy (SNo_minus_SNo y Hy).
- f_equal. exact add_SNo_minus_SNo_rinv y Hy.
- exact add_SNo_0R x Hx.
Qed.

Theorem add_SNo_minus_R2' : forall x y, SNo x -> SNo y -> (x + - y) + y = x.
let x y. assume Hx Hy.
rewrite <- minus_SNo_invol y Hy at 2.
exact add_SNo_minus_R2 x (- y) Hx (SNo_minus_SNo y Hy).
Qed.

Theorem add_SNo_minus_L2 : forall x y, SNo x -> SNo y -> - x + (x + y) = y.
let x y. assume Hx Hy.
rewrite add_SNo_com (- x) (x + y) (SNo_minus_SNo x Hx) (SNo_add_SNo x y Hx Hy).
prove (x + y) + - x = y.
rewrite add_SNo_com x y Hx Hy.
prove (y + x) + - x = y.
exact add_SNo_minus_R2 y x Hy Hx.
Qed.

Theorem add_SNo_minus_L2' : forall x y, SNo x -> SNo y -> x + (- x + y) = y.
let x y. assume Hx Hy.
rewrite <- minus_SNo_invol x Hx at 1.
exact add_SNo_minus_L2 (- x) y (SNo_minus_SNo x Hx) Hy.
Qed.

Theorem add_SNo_cancel_L : forall x y z, SNo x -> SNo y -> SNo z -> x + y = x + z -> y = z.
let x y z.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
assume Hxyz: x + y = x + z.
claim Lmx: SNo (-x).
{ exact SNo_minus_SNo x Hx. }
rewrite <- add_SNo_minus_L2 x y Hx Hy.
rewrite Hxyz.
exact add_SNo_minus_L2 x z Hx Hz.
Qed.

Theorem add_SNo_cancel_R : forall x y z, SNo x -> SNo y -> SNo z -> x + y = z + y -> x = z.
let x y z.
assume Hx: SNo x.
assume Hy: SNo y.
assume Hz: SNo z.
assume Hxyz: x + y = z + y.
claim L1: y + x = y + z.
{ rewrite add_SNo_com y x Hy Hx.
  rewrite add_SNo_com y z Hy Hz.
  exact Hxyz.
}
exact add_SNo_cancel_L y x z Hy Hx Hz L1.
Qed.

Theorem minus_SNo_0 : - 0 = 0.
apply add_SNo_cancel_L 0 (- 0) 0 SNo_0 (SNo_minus_SNo 0 SNo_0) SNo_0.
prove 0 + - 0 = 0 + 0.
transitivity 0.
- exact add_SNo_minus_SNo_rinv 0 SNo_0.
- symmetry. exact add_SNo_0L 0 SNo_0.
Qed.

Theorem minus_add_SNo_distr : forall x y, SNo x -> SNo y -> -(x+y) = (-x) + (-y).
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
claim Lmx: SNo (-x).
{ exact SNo_minus_SNo x Hx. }
claim Lmy: SNo (-y).
{ exact SNo_minus_SNo y Hy. }
claim Lxy: SNo (x+y).
{ exact SNo_add_SNo x y Hx Hy. }
claim L1: (x+y) + -(x+y) = (x+y) + ((-x) + (-y)).
{ rewrite add_SNo_minus_SNo_rinv (x+y) Lxy.
  prove 0 = (x+y) + ((-x) + (-y)).
  rewrite add_SNo_assoc (x+y) (-x) (-y) Lxy Lmx Lmy.
  prove 0 = ((x+y) + (-x)) + (-y).
  rewrite add_SNo_com x y Hx Hy.
  prove 0 = ((y+x) + -x) + -y.
  rewrite <- add_SNo_assoc y x (-x) Hy Hx Lmx.
  prove 0 = (y + (x + -x)) + -y.
  rewrite add_SNo_minus_SNo_rinv x Hx.
  prove 0 = (y + 0) + -y.
  rewrite add_SNo_0R y Hy.
  prove 0 = y + -y.
  rewrite add_SNo_minus_SNo_rinv y Hy.
  prove 0 = 0.
  reflexivity.
}
exact add_SNo_cancel_L (x+y) (-(x+y)) ((-x) + (-y)) Lxy (SNo_minus_SNo (x+y) Lxy) (SNo_add_SNo (-x) (-y) Lmx Lmy) L1.
Qed.

Theorem minus_add_SNo_distr_3 : forall x y z, SNo x -> SNo y -> SNo z -> -(x + y + z) = -x + - y + -z.
let x y z. assume Hx Hy Hz.
transitivity -x + -(y + z).
- exact minus_add_SNo_distr x (y + z) Hx (SNo_add_SNo y z Hy Hz).
- f_equal. prove -(y + z) = -y + -z.
  exact minus_add_SNo_distr y z Hy Hz.
Qed.

Theorem add_SNo_Lev_bd : forall x y, SNo x -> SNo y -> SNoLev (x + y) c= SNoLev x + SNoLev y.
set P : set -> set -> prop := fun x y => SNoLev (x + y) c= SNoLev x + SNoLev y.
apply SNoLev_ind2.
let x y.
assume Hx: SNo x.
assume Hy: SNo y.
claim Lxy: SNo (x + y).
{ exact SNo_add_SNo x y Hx Hy. }
claim LLxLy: ordinal (SNoLev x + SNoLev y).
{ apply add_SNo_ordinal_ordinal.
  - apply SNoLev_ordinal. exact Hx.
  - apply SNoLev_ordinal. exact Hy.
}
assume IH1: forall w :e SNoS_ (SNoLev x), P w y.
assume IH2: forall z :e SNoS_ (SNoLev y), P x z.
assume IH3: forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), P w z.
prove SNoLev (x + y) c= SNoLev x + SNoLev y.
set Lxy1 := {w + y|w :e SNoL x}.
set Lxy2 := {x + w|w :e SNoL y}.
set Rxy1 := {z + y|z :e SNoR x}.
set Rxy2 := {x + z|z :e SNoR y}.
rewrite add_SNo_eq x Hx y Hy.
prove SNoLev (SNoCut (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2)) c= SNoLev x + SNoLev y.
claim L1: SNoCutP (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2).
{ exact add_SNo_SNoCutP x y Hx Hy. }
apply SNoCutP_SNoCut_impred (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2) L1.
assume H1: SNo (SNoCut (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2)).
assume H2: SNoLev (SNoCut (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2)) :e ordsucc ((\/_ x :e (Lxy1 :\/: Lxy2), ordsucc (SNoLev x)) :\/: (\/_ y :e (Rxy1 :\/: Rxy2), ordsucc (SNoLev y))).
assume _ _ _.
claim Lxy1E: forall u :e Lxy1, forall p:set -> prop, (forall w :e SNoS_ (SNoLev x), u = w + y -> SNo w -> SNoLev w :e SNoLev x -> w < x -> p (w + y)) -> p u.
{ let u. assume Hu. let p. assume Hp.
  apply ReplE_impred (SNoL x) (fun w => w + y) u Hu.
  let w.
  assume Hw: w :e SNoL x.
  assume Huw: u = w + y.
  rewrite Huw.
  apply SNoL_E x Hx w Hw.
  claim Lw: w :e SNoS_ (SNoLev x).
  { exact SNoL_SNoS_ x w Hw. }
  exact Hp w Lw Huw.
}
claim Lxy2E: forall u :e Lxy2, forall p:set -> prop, (forall w :e SNoS_ (SNoLev y), u = x + w -> SNo w -> SNoLev w :e SNoLev y -> w < y -> p (x + w)) -> p u.
{ let u. assume Hu. let p. assume Hp.
  apply ReplE_impred (SNoL y) (fun w => x + w) u Hu.
  let w.
  assume Hw: w :e SNoL y.
  assume Huw: u = x + w.
  rewrite Huw.
  apply SNoL_E y Hy w Hw.
  claim Lw: w :e SNoS_ (SNoLev y).
  { exact SNoL_SNoS_ y w Hw. }
  exact Hp w Lw Huw.
}
claim Rxy1E: forall u :e Rxy1, forall p:set -> prop, (forall w :e SNoS_ (SNoLev x), u = w + y -> SNo w -> SNoLev w :e SNoLev x -> x < w -> p (w + y)) -> p u.
{ let u. assume Hu. let p. assume Hp.
  apply ReplE_impred (SNoR x) (fun w => w + y) u Hu.
  let w.
  assume Hw: w :e SNoR x.
  assume Huw: u = w + y.
  rewrite Huw.
  apply SNoR_E x Hx w Hw.
  claim Lw: w :e SNoS_ (SNoLev x).
  { exact SNoR_SNoS_ x w Hw. }
  exact Hp w Lw Huw.
}
claim Rxy2E: forall u :e Rxy2, forall p:set -> prop, (forall w :e SNoS_ (SNoLev y), u = x + w -> SNo w -> SNoLev w :e SNoLev y -> y < w -> p (x + w)) -> p u.
{ let u. assume Hu. let p. assume Hp.
  apply ReplE_impred (SNoR y) (fun w => x + w) u Hu.
  let w.
  assume Hw: w :e SNoR y.
  assume Huw: u = x + w.
  rewrite Huw.
  apply SNoR_E y Hy w Hw.
  claim Lw: w :e SNoS_ (SNoLev y).
  { exact SNoR_SNoS_ y w Hw. }
  exact Hp w Lw Huw.
}
claim Lxy1E2: forall u :e Lxy1, SNo u.
{ let u. assume Hu. apply Lxy1E u Hu.
  let w. assume Hw1 Hw2 Hw3 Hw4 Hw5.
  prove SNo (w + y).
  apply SNo_add_SNo.
  - exact Hw3.
  - exact Hy.
}
claim Lxy2E2: forall u :e Lxy2, SNo u.
{ let u. assume Hu. apply Lxy2E u Hu.
  let w. assume Hw1 Hw2 Hw3 Hw4 Hw5.
  prove SNo (x + w).
  apply SNo_add_SNo.
  - exact Hx.
  - exact Hw3.
}
claim Rxy1E2: forall u :e Rxy1, SNo u.
{ let u. assume Hu. apply Rxy1E u Hu.
  let w. assume Hw1 Hw2 Hw3 Hw4 Hw5.
  prove SNo (w + y).
  apply SNo_add_SNo.
  - exact Hw3.
  - exact Hy.
}
claim Rxy2E2: forall u :e Rxy2, SNo u.
{ let u. assume Hu. apply Rxy2E u Hu.
  let w. assume Hw1 Hw2 Hw3 Hw4 Hw5.
  prove SNo (x + w).
  apply SNo_add_SNo.
  - exact Hx.
  - exact Hw3.
}
claim L2: ordinal ((\/_ u :e (Lxy1 :\/: Lxy2), ordsucc (SNoLev u)) :\/: (\/_ u :e (Rxy1 :\/: Rxy2), ordsucc (SNoLev u))).
{ apply ordinal_binunion.
  - apply ordinal_famunion (Lxy1 :\/: Lxy2) (fun u => ordsucc (SNoLev u)).
    let u. assume Hu: u :e Lxy1 :\/: Lxy2.
    prove ordinal (ordsucc (SNoLev u)).
    apply ordinal_ordsucc.
    apply SNoLev_ordinal.
    prove SNo u.
    apply binunionE Lxy1 Lxy2 u Hu.
    + assume Hu. exact Lxy1E2 u Hu.
    + assume Hu. exact Lxy2E2 u Hu.
  - apply ordinal_famunion (Rxy1 :\/: Rxy2) (fun u => ordsucc (SNoLev u)).
    let u. assume Hu: u :e Rxy1 :\/: Rxy2.
    prove ordinal (ordsucc (SNoLev u)).
    apply ordinal_ordsucc.
    apply SNoLev_ordinal.
    prove SNo u.
    apply binunionE Rxy1 Rxy2 u Hu.
    + assume Hu. exact Rxy1E2 u Hu.
    + assume Hu. exact Rxy2E2 u Hu.
}
claim L3: SNoLev (SNoCut (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2)) c= (\/_ u :e (Lxy1 :\/: Lxy2), ordsucc (SNoLev u)) :\/: (\/_ u :e (Rxy1 :\/: Rxy2), ordsucc (SNoLev u)).
{ apply TransSet_In_ordsucc_Subq.
  + prove TransSet ((\/_ u :e (Lxy1 :\/: Lxy2), ordsucc (SNoLev u)) :\/: (\/_ u :e (Rxy1 :\/: Rxy2), ordsucc (SNoLev u))).
    apply L2. assume H _. exact H.
  + exact H2.
}
claim L4: ((\/_ u :e (Lxy1 :\/: Lxy2), ordsucc (SNoLev u)) :\/: (\/_ u :e (Rxy1 :\/: Rxy2), ordsucc (SNoLev u))) c= SNoLev x + SNoLev y.
{ apply binunion_Subq_min.
  - prove (\/_ u :e (Lxy1 :\/: Lxy2), ordsucc (SNoLev u)) c= SNoLev x + SNoLev y.
    let v. assume Hv: v :e (\/_ u :e (Lxy1 :\/: Lxy2), ordsucc (SNoLev u)).
    apply famunionE_impred (Lxy1 :\/: Lxy2) (fun u => ordsucc (SNoLev u)) v Hv.
    let u. assume Hu: u :e Lxy1 :\/: Lxy2.
    apply binunionE Lxy1 Lxy2 u Hu.
    + assume Hu: u :e Lxy1. apply Lxy1E u Hu.
      let w.
      assume Hw1: w :e SNoS_ (SNoLev x).
      assume Hw2: u = w + y.
      assume Hw3: SNo w.
      assume Hw4: SNoLev w :e SNoLev x.
      assume Hw5: w < x.
      assume Hw6: v :e ordsucc (SNoLev (w + y)).
      prove v :e SNoLev x + SNoLev y.
      claim Lv: ordinal v.
      { apply ordinal_Hered (ordsucc (SNoLev (w + y))).
        - prove ordinal (ordsucc (SNoLev (w + y))).
          apply ordinal_ordsucc. apply SNoLev_ordinal.
          apply SNo_add_SNo.
          + exact Hw3.
          + exact Hy.
        - exact Hw6.
      }
      apply ordinal_In_Or_Subq v (SNoLev x + SNoLev y) Lv LLxLy.
      * assume H1: v :e SNoLev x + SNoLev y. exact H1.
      * { assume H1: SNoLev x + SNoLev y c= v.
          prove False.
          claim LIHw: SNoLev (w + y) c= SNoLev w + SNoLev y.
          { apply IH1. prove w :e SNoS_ (SNoLev x). exact Hw1. }
          claim L4a: SNoLev w + SNoLev y :e SNoLev x + SNoLev y.
          { apply add_SNo_ordinal_InL.
            - apply SNoLev_ordinal. exact Hx.
            - apply SNoLev_ordinal. exact Hy.
            - exact Hw4.
          }
          claim L4b: SNoLev w + SNoLev y c= SNoLev x + SNoLev y.
          { apply LLxLy. assume H _. exact H (SNoLev w + SNoLev y) L4a. }
          claim L4c: v c= SNoLev (w + y).
          { apply ordinal_In_Or_Subq (SNoLev (w + y)) v (SNoLev_ordinal (w + y) (SNo_add_SNo w y Hw3 Hy)) Lv.
            - assume H2: SNoLev (w + y) :e v.
              prove False.
              apply ordsuccE (SNoLev (w + y)) v Hw6.
              + assume H3: v :e SNoLev (w + y).
                exact In_no2cycle (SNoLev (w + y)) v H2 H3.
              + assume H3: v = SNoLev (w + y).
                apply In_irref v. rewrite H3 at 1. exact H2.
            - assume H2: v c= SNoLev (w + y). exact H2.
          }
          apply In_irref (SNoLev w + SNoLev y).
          prove (SNoLev w + SNoLev y) :e (SNoLev w + SNoLev y).
          apply LIHw.
          prove (SNoLev w + SNoLev y) :e SNoLev (w + y).
          apply L4c.
          prove (SNoLev w + SNoLev y) :e v.
          apply H1.
          prove (SNoLev w + SNoLev y) :e SNoLev x + SNoLev y.
          exact L4a.
        }
    + assume Hu: u :e Lxy2. apply Lxy2E u Hu.
      let w.
      assume Hw1: w :e SNoS_ (SNoLev y).
      assume Hw2: u = x + w.
      assume Hw3: SNo w.
      assume Hw4: SNoLev w :e SNoLev y.
      assume Hw5: w < y.
      assume Hw6: v :e ordsucc (SNoLev (x + w)).
      prove v :e SNoLev x + SNoLev y.
      claim Lv: ordinal v.
      { apply ordinal_Hered (ordsucc (SNoLev (x + w))).
        - prove ordinal (ordsucc (SNoLev (x + w))).
          apply ordinal_ordsucc. apply SNoLev_ordinal.
          apply SNo_add_SNo.
          + exact Hx.
          + exact Hw3.
        - exact Hw6.
      }
      apply ordinal_In_Or_Subq v (SNoLev x + SNoLev y) Lv LLxLy.
      * assume H1: v :e SNoLev x + SNoLev y. exact H1.
      * { assume H1: SNoLev x + SNoLev y c= v.
          prove False.
          claim LIHw: SNoLev (x + w) c= SNoLev x + SNoLev w.
          { apply IH2. prove w :e SNoS_ (SNoLev y). exact Hw1. }
          claim L4a: SNoLev x + SNoLev w :e SNoLev x + SNoLev y.
          { apply add_SNo_ordinal_InR.
            - apply SNoLev_ordinal. exact Hx.
            - apply SNoLev_ordinal. exact Hy.
            - exact Hw4.
          }
          claim L4b: SNoLev x + SNoLev w c= SNoLev x + SNoLev y.
          { apply LLxLy. assume H _. exact H (SNoLev x + SNoLev w) L4a. }
          claim L4c: v c= SNoLev (x + w).
          { apply ordinal_In_Or_Subq (SNoLev (x + w)) v (SNoLev_ordinal (x + w) (SNo_add_SNo x w Hx Hw3)) Lv.
            - assume H2: SNoLev (x + w) :e v.
              prove False.
              apply ordsuccE (SNoLev (x + w)) v Hw6.
              + assume H3: v :e SNoLev (x + w).
                exact In_no2cycle (SNoLev (x + w)) v H2 H3.
              + assume H3: v = SNoLev (x + w).
                apply In_irref v. rewrite H3 at 1. exact H2.
            - assume H2: v c= SNoLev (x + w). exact H2.
          }
          apply In_irref (SNoLev x + SNoLev w).
          prove (SNoLev x + SNoLev w) :e (SNoLev x + SNoLev w).
          apply LIHw.
          prove (SNoLev x + SNoLev w) :e SNoLev (x + w).
          apply L4c.
          prove (SNoLev x + SNoLev w) :e v.
          apply H1.
          prove (SNoLev x + SNoLev w) :e SNoLev x + SNoLev y.
          exact L4a.
        }
  - prove (\/_ u :e (Rxy1 :\/: Rxy2), ordsucc (SNoLev u)) c= SNoLev x + SNoLev y.
    let v. assume Hv: v :e (\/_ u :e (Rxy1 :\/: Rxy2), ordsucc (SNoLev u)).
    apply famunionE_impred (Rxy1 :\/: Rxy2) (fun u => ordsucc (SNoLev u)) v Hv.
    let u. assume Hu: u :e Rxy1 :\/: Rxy2.
    apply binunionE Rxy1 Rxy2 u Hu.
    + assume Hu: u :e Rxy1. apply Rxy1E u Hu.
      let w.
      assume Hw1: w :e SNoS_ (SNoLev x).
      assume Hw2: u = w + y.
      assume Hw3: SNo w.
      assume Hw4: SNoLev w :e SNoLev x.
      assume Hw5: x < w.
      assume Hw6: v :e ordsucc (SNoLev (w + y)).
      prove v :e SNoLev x + SNoLev y.
      claim Lv: ordinal v.
      { apply ordinal_Hered (ordsucc (SNoLev (w + y))).
        - prove ordinal (ordsucc (SNoLev (w + y))).
          apply ordinal_ordsucc. apply SNoLev_ordinal.
          apply SNo_add_SNo.
          + exact Hw3.
          + exact Hy.
        - exact Hw6.
      }
      apply ordinal_In_Or_Subq v (SNoLev x + SNoLev y) Lv LLxLy.
      * assume H1: v :e SNoLev x + SNoLev y. exact H1.
      * { assume H1: SNoLev x + SNoLev y c= v.
          prove False.
          claim LIHw: SNoLev (w + y) c= SNoLev w + SNoLev y.
          { apply IH1. prove w :e SNoS_ (SNoLev x). exact Hw1. }
          claim L4a: SNoLev w + SNoLev y :e SNoLev x + SNoLev y.
          { apply add_SNo_ordinal_InL.
            - apply SNoLev_ordinal. exact Hx.
            - apply SNoLev_ordinal. exact Hy.
            - exact Hw4.
          }
          claim L4b: SNoLev w + SNoLev y c= SNoLev x + SNoLev y.
          { apply LLxLy. assume H _. exact H (SNoLev w + SNoLev y) L4a. }
          claim L4c: v c= SNoLev (w + y).
          { apply ordinal_In_Or_Subq (SNoLev (w + y)) v (SNoLev_ordinal (w + y) (SNo_add_SNo w y Hw3 Hy)) Lv.
            - assume H2: SNoLev (w + y) :e v.
              prove False.
              apply ordsuccE (SNoLev (w + y)) v Hw6.
              + assume H3: v :e SNoLev (w + y).
                exact In_no2cycle (SNoLev (w + y)) v H2 H3.
              + assume H3: v = SNoLev (w + y).
                apply In_irref v. rewrite H3 at 1. exact H2.
            - assume H2: v c= SNoLev (w + y). exact H2.
          }
          apply In_irref (SNoLev w + SNoLev y).
          prove (SNoLev w + SNoLev y) :e (SNoLev w + SNoLev y).
          apply LIHw.
          prove (SNoLev w + SNoLev y) :e SNoLev (w + y).
          apply L4c.
          prove (SNoLev w + SNoLev y) :e v.
          apply H1.
          prove (SNoLev w + SNoLev y) :e SNoLev x + SNoLev y.
          exact L4a.
        }
    + assume Hu: u :e Rxy2. apply Rxy2E u Hu.
      let w.
      assume Hw1: w :e SNoS_ (SNoLev y).
      assume Hw2: u = x + w.
      assume Hw3: SNo w.
      assume Hw4: SNoLev w :e SNoLev y.
      assume Hw5: y < w.
      assume Hw6: v :e ordsucc (SNoLev (x + w)).
      prove v :e SNoLev x + SNoLev y.
      claim Lv: ordinal v.
      { apply ordinal_Hered (ordsucc (SNoLev (x + w))).
        - prove ordinal (ordsucc (SNoLev (x + w))).
          apply ordinal_ordsucc. apply SNoLev_ordinal.
          apply SNo_add_SNo.
          + exact Hx.
          + exact Hw3.
        - exact Hw6.
      }
      apply ordinal_In_Or_Subq v (SNoLev x + SNoLev y) Lv LLxLy.
      * assume H1: v :e SNoLev x + SNoLev y. exact H1.
      * { assume H1: SNoLev x + SNoLev y c= v.
          prove False.
          claim LIHw: SNoLev (x + w) c= SNoLev x + SNoLev w.
          { apply IH2. prove w :e SNoS_ (SNoLev y). exact Hw1. }
          claim L4a: SNoLev x + SNoLev w :e SNoLev x + SNoLev y.
          { apply add_SNo_ordinal_InR.
            - apply SNoLev_ordinal. exact Hx.
            - apply SNoLev_ordinal. exact Hy.
            - exact Hw4.
          }
          claim L4b: SNoLev x + SNoLev w c= SNoLev x + SNoLev y.
          { apply LLxLy. assume H _. exact H (SNoLev x + SNoLev w) L4a. }
          claim L4c: v c= SNoLev (x + w).
          { apply ordinal_In_Or_Subq (SNoLev (x + w)) v (SNoLev_ordinal (x + w) (SNo_add_SNo x w Hx Hw3)) Lv.
            - assume H2: SNoLev (x + w) :e v.
              prove False.
              apply ordsuccE (SNoLev (x + w)) v Hw6.
              + assume H3: v :e SNoLev (x + w).
                exact In_no2cycle (SNoLev (x + w)) v H2 H3.
              + assume H3: v = SNoLev (x + w).
                apply In_irref v. rewrite H3 at 1. exact H2.
            - assume H2: v c= SNoLev (x + w). exact H2.
          }
          apply In_irref (SNoLev x + SNoLev w).
          prove (SNoLev x + SNoLev w) :e (SNoLev x + SNoLev w).
          apply LIHw.
          prove (SNoLev x + SNoLev w) :e SNoLev (x + w).
          apply L4c.
          prove (SNoLev x + SNoLev w) :e v.
          apply H1.
          prove (SNoLev x + SNoLev w) :e SNoLev x + SNoLev y.
          exact L4a.
        }
}
exact Subq_tra (SNoLev (SNoCut (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2))) ((\/_ u :e (Lxy1 :\/: Lxy2), ordsucc (SNoLev u)) :\/: (\/_ u :e (Rxy1 :\/: Rxy2), ordsucc (SNoLev u))) (SNoLev x + SNoLev y) L3 L4.
Qed.

Theorem add_SNo_SNoS_omega : forall x y :e SNoS_ omega, x + y :e SNoS_ omega.
let x. assume Hx. let y. assume Hy.
apply SNoS_E2 omega omega_ordinal x Hx.
assume Hx1: SNoLev x :e omega.
assume Hx2: ordinal (SNoLev x).
assume Hx3: SNo x.
assume Hx4: SNo_ (SNoLev x) x.
apply SNoS_E2 omega omega_ordinal y Hy.
assume Hy1: SNoLev y :e omega.
assume Hy2: ordinal (SNoLev y).
assume Hy3: SNo y.
assume Hy4: SNo_ (SNoLev y) y.
apply SNoS_I omega omega_ordinal (x + y) (SNoLev (x + y)).
- prove SNoLev (x + y) :e omega.
  claim LLxy: ordinal (SNoLev (x + y)).
  { apply SNoLev_ordinal. exact SNo_add_SNo x y Hx3 Hy3. }
  apply ordinal_In_Or_Subq (SNoLev (x + y)) omega LLxy omega_ordinal.
  + assume H1. exact H1.
  + assume H1: omega c= SNoLev (x + y).
    apply In_irref (SNoLev x + SNoLev y).
    prove (SNoLev x + SNoLev y) :e (SNoLev x + SNoLev y).
    apply add_SNo_Lev_bd x y Hx3 Hy3.
    prove (SNoLev x + SNoLev y) :e SNoLev (x + y).
    apply H1.
    prove (SNoLev x + SNoLev y) :e omega.
    exact add_SNo_In_omega (SNoLev x) Hx1 (SNoLev y) Hy1.
- prove SNo_ (SNoLev (x + y)) (x + y).
  apply SNoLev_. exact SNo_add_SNo x y Hx3 Hy3.
Qed.

Theorem add_SNo_Lt1_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y < z + y -> x < z.
let x y z. assume Hx Hy Hz H1.
prove x < z.
claim L1: (x + y) + - y = x.
{ exact add_SNo_minus_R2 x y Hx Hy. }
claim L2: (z + y) + - y = z.
{ exact add_SNo_minus_R2 z y Hz Hy. }
rewrite <- L1. rewrite <- L2.
prove (x + y) + - y < (z + y) + - y.
exact add_SNo_Lt1 (x + y) (- y) (z + y)
                  (SNo_add_SNo x y Hx Hy)
                  (SNo_minus_SNo y Hy)
                  (SNo_add_SNo z y Hz Hy)
                  H1.
Qed.

Theorem add_SNo_Lt2_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y < x + z -> y < z.
let x y z. assume Hx Hy Hz.
rewrite add_SNo_com x y Hx Hy.
rewrite add_SNo_com x z Hx Hz.
exact add_SNo_Lt1_cancel y x z Hy Hx Hz.
Qed.

Theorem add_SNo_Le1_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y <= z + y -> x <= z.
let x y z. assume Hx Hy Hz H1.
prove x <= z.
claim L1: (x + y) + - y = x.
{ exact add_SNo_minus_R2 x y Hx Hy. }
claim L2: (z + y) + - y = z.
{ exact add_SNo_minus_R2 z y Hz Hy. }
rewrite <- L1. rewrite <- L2.
prove (x + y) + - y <= (z + y) + - y.
exact add_SNo_Le1 (x + y) (- y) (z + y)
                  (SNo_add_SNo x y Hx Hy)
                  (SNo_minus_SNo y Hy)
                  (SNo_add_SNo z y Hz Hy)
                  H1.
Qed.

Theorem add_SNo_assoc_4 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> x + y + z + w = (x + y + z) + w.
let x y z w. assume Hx Hy Hz Hw.
transitivity (x + y) + z + w,
             ((x + y) + z) + w.
- exact add_SNo_assoc x y (z + w) Hx Hy (SNo_add_SNo z w Hz Hw).
- exact add_SNo_assoc (x + y) z w (SNo_add_SNo x y Hx Hy) Hz Hw.
- f_equal. symmetry. exact add_SNo_assoc x y z Hx Hy Hz.
Qed.

Theorem add_SNo_com_3_0_1 : forall x y z, SNo x -> SNo y -> SNo z
  -> x + y + z = y + x + z.
let x y z.
assume Hx Hy Hz.
rewrite add_SNo_assoc x y z Hx Hy Hz.
rewrite add_SNo_assoc y x z Hy Hx Hz.
f_equal.
exact add_SNo_com x y Hx Hy.
Qed.

Theorem add_SNo_com_3b_1_2 : forall x y z, SNo x -> SNo y -> SNo z
  -> (x + y) + z = (x + z) + y.
let x y z.
assume Hx Hy Hz.
rewrite <- add_SNo_assoc x y z Hx Hy Hz.
rewrite <- add_SNo_assoc x z y Hx Hz Hy.
f_equal.
exact add_SNo_com y z Hy Hz.
Qed.

Theorem add_SNo_com_4_inner_mid : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> (x + y) + (z + w) = (x + z) + (y + w).
let x y z w.
assume Hx Hy Hz Hw.
rewrite add_SNo_assoc (x + y) z w (SNo_add_SNo x y Hx Hy) Hz Hw.
prove ((x + y) + z) + w = (x + z) + (y + w).
rewrite add_SNo_com_3b_1_2 x y z Hx Hy Hz.
prove ((x + z) + y) + w = (x + z) + (y + w).
symmetry.
exact add_SNo_assoc (x + z) y w (SNo_add_SNo x z Hx Hz) Hy Hw.
Qed.

Theorem add_SNo_rotate_3_1 : forall x y z, SNo x -> SNo y -> SNo z ->
  x + y + z = z + x + y.
let x y z.
assume Hx Hy Hz.
prove x + (y + z) = z + (x + y).
transitivity x + (z + y),
             (x + z) + y,
             (z + x) + y.
- f_equal. exact add_SNo_com y z Hy Hz.
- exact add_SNo_assoc x z y Hx Hz Hy.
- f_equal. exact add_SNo_com x z Hx Hz.
- symmetry. exact add_SNo_assoc z x y Hz Hx Hy.
Qed.

Theorem add_SNo_rotate_4_1 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w ->
  x + y + z + w = w + x + y + z.
let x y z w. assume Hx Hy Hz Hw.
rewrite add_SNo_rotate_3_1 y z w Hy Hz Hw.
prove x + w + y + z = w + x + y + z.
exact add_SNo_com_3_0_1 x w (y + z) Hx Hw (SNo_add_SNo y z Hy Hz).
Qed.

Theorem add_SNo_rotate_5_1 : forall x y z w v, SNo x -> SNo y -> SNo z -> SNo w -> SNo v ->
  x + y + z + w + v = v + x + y + z + w.
let x y z w v. assume Hx Hy Hz Hw Hv.
rewrite add_SNo_rotate_4_1 y z w v Hy Hz Hw Hv.
prove x + v + y + z + w = v + x + y + z + w.
exact add_SNo_com_3_0_1 x v (y + z + w) Hx Hv (SNo_add_SNo_3 y z w Hy Hz Hw).
Qed.

Theorem add_SNo_rotate_5_2 : forall x y z w v, SNo x -> SNo y -> SNo z -> SNo w -> SNo v ->
  x + y + z + w + v = w + v + x + y + z.
let x y z w v. assume Hx Hy Hz Hw Hv.
transitivity (v + x + y + z + w).
- exact add_SNo_rotate_5_1 x y z w v Hx Hy Hz Hw Hv.
- exact add_SNo_rotate_5_1 v x y z w Hv Hx Hy Hz Hw.
Qed.

Theorem add_SNo_minus_SNo_prop2 : forall x y, SNo x -> SNo y -> x + - x + y = y.
let x y. assume Hx Hy.
rewrite add_SNo_assoc x (- x) y Hx (SNo_minus_SNo x Hx) Hy.
prove (x + - x) + y = y.
rewrite add_SNo_minus_SNo_rinv x Hx.
prove 0 + y = y.
exact add_SNo_0L y Hy.
Qed.

Theorem add_SNo_minus_SNo_prop3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y + z) + (- z + w) = x + y + w.
let x y z w. assume Hx Hy Hz Hw.
rewrite add_SNo_assoc x y z Hx Hy Hz.
prove ((x + y) + z) + (- z + w) = x + y + w.
rewrite <- add_SNo_assoc (x + y) z (- z + w) (SNo_add_SNo x y Hx Hy) Hz (SNo_add_SNo (- z) w (SNo_minus_SNo z Hz) Hw).
prove (x + y) + (z + - z + w) = x + y + w.
rewrite add_SNo_minus_L2' z w Hz Hw.
prove (x + y) + w = x + y + w.
symmetry. exact add_SNo_assoc x y w Hx Hy Hw.
Qed.

Theorem add_SNo_minus_SNo_prop5 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y + - z) + (z + w) = x + y + w.
let x y z w. assume Hx Hy Hz Hw.
prove (x + y + - z) + (z + w) = x + y + w.
rewrite <- minus_SNo_invol z Hz at 2.
prove (x + y + - z) + (- - z + w) = x + y + w.
exact add_SNo_minus_SNo_prop3 x y (- z) w Hx Hy (SNo_minus_SNo z Hz) Hw.
Qed.

Theorem add_SNo_minus_Lt1 : forall x y z, SNo x -> SNo y -> SNo z -> x + - y < z -> x < z + y.
let x y z. assume Hx Hy Hz H1.
apply add_SNo_Lt1_cancel x (- y) (z + y) Hx (SNo_minus_SNo y Hy) (SNo_add_SNo z y Hz Hy).
prove x + - y < (z + y) + - y.
rewrite <- add_SNo_assoc z y (- y) Hz Hy (SNo_minus_SNo y Hy).
rewrite add_SNo_minus_SNo_rinv y Hy.
rewrite add_SNo_0R z Hz.
exact H1.
Qed.

Theorem add_SNo_minus_Lt2 : forall x y z, SNo x -> SNo y -> SNo z -> z < x + - y -> z + y < x.
let x y z. assume Hx Hy Hz H1.
apply add_SNo_Lt1_cancel (z + y) (- y) x (SNo_add_SNo z y Hz Hy) (SNo_minus_SNo y Hy) Hx.
prove (z + y) + - y < x + - y.
rewrite <- add_SNo_assoc z y (- y) Hz Hy (SNo_minus_SNo y Hy).
prove z + y + - y < x + - y.
rewrite add_SNo_minus_SNo_rinv y Hy.
rewrite add_SNo_0R z Hz.
exact H1.
Qed.

Theorem add_SNo_minus_Lt1b : forall x y z, SNo x -> SNo y -> SNo z -> x < z + y -> x + - y < z.
let x y z. assume Hx Hy Hz H1.
apply add_SNo_Lt1_cancel (x + - y) y z (SNo_add_SNo x (- y) Hx (SNo_minus_SNo y Hy)) Hy Hz.
prove (x + - y) + y < z + y.
rewrite <- add_SNo_assoc x (- y) y Hx (SNo_minus_SNo y Hy) Hy.
rewrite add_SNo_minus_SNo_linv y Hy.
rewrite add_SNo_0R x Hx.
exact H1.
Qed.

Theorem add_SNo_minus_Lt2b : forall x y z, SNo x -> SNo y -> SNo z -> z + y < x -> z < x + - y.
let x y z. assume Hx Hy Hz H1.
apply add_SNo_Lt1_cancel z y (x + - y) Hz Hy (SNo_add_SNo x (- y) Hx (SNo_minus_SNo y Hy)).
prove z + y < (x + - y) + y.
rewrite <- add_SNo_assoc x (- y) y Hx (SNo_minus_SNo y Hy) Hy.
rewrite add_SNo_minus_SNo_linv y Hy.
rewrite add_SNo_0R x Hx.
exact H1.
Qed.

Theorem add_SNo_minus_Lt1b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x + y < w + z -> x + y + - z < w.
let x y z w. assume Hx Hy Hz Hw H1.
prove x + y + - z < w.
rewrite add_SNo_assoc x y (- z) Hx Hy (SNo_minus_SNo z Hz).
prove (x + y) + - z < w.
apply add_SNo_minus_Lt1b (x + y) z w (SNo_add_SNo x y Hx Hy) Hz Hw.
exact H1.
Qed.

Theorem add_SNo_minus_Lt2b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> w + z < x + y -> w < x + y + - z.
let x y z w. assume Hx Hy Hz Hw H1.
prove w < x + y + - z.
rewrite add_SNo_assoc x y (- z) Hx Hy (SNo_minus_SNo z Hz).
prove w < (x + y) + - z.
apply add_SNo_minus_Lt2b (x + y) z w (SNo_add_SNo x y Hx Hy) Hz Hw.
exact H1.
Qed.

Theorem add_SNo_minus_Lt_lem : forall x y z u v w, SNo x -> SNo y -> SNo z -> SNo u -> SNo v -> SNo w ->
  x + y + w < u + v + z ->
  x + y + - z < u + v + - w.
let x y z u v w. assume Hx Hy Hz Hu Hv Hw H1.
claim Lmz: SNo (- z).
{ exact SNo_minus_SNo z Hz. }
claim Lmw: SNo (- w).
{ exact SNo_minus_SNo w Hw. }
claim Lxy: SNo (x + y).
{ exact SNo_add_SNo x y Hx Hy. }
claim Luv: SNo (u + v).
{ exact SNo_add_SNo u v Hu Hv. }
rewrite add_SNo_assoc x y (- z) Hx Hy Lmz.
rewrite add_SNo_assoc u v (- w) Hu Hv Lmw.
prove (x + y) + - z < (u + v) + - w.
apply add_SNo_minus_Lt2b (u + v) w ((x + y) + - z) Luv Hw (SNo_add_SNo (x + y) (- z) Lxy Lmz).
prove ((x + y) + - z) + w < u + v.
rewrite <- add_SNo_assoc (x + y) (- z) w Lxy Lmz Hw.
prove (x + y) + - z + w < u + v.
rewrite add_SNo_com (- z) w Lmz Hw.
prove (x + y) + w + - z < u + v.
rewrite add_SNo_assoc (x + y) w (- z) Lxy Hw Lmz.
prove ((x + y) + w) + - z < u + v.
apply add_SNo_minus_Lt1b ((x + y) + w) z (u + v) (SNo_add_SNo (x + y) w Lxy Hw) Hz Luv.
prove (x + y) + w < (u + v) + z.
rewrite <- add_SNo_assoc x y w Hx Hy Hw.
rewrite <- add_SNo_assoc u v z Hu Hv Hz.
exact H1.
Qed.

Theorem add_SNo_minus_Le2 : forall x y z, SNo x -> SNo y -> SNo z -> z <= x + - y -> z + y <= x.
let x y z. assume Hx Hy Hz H1.
apply SNoLeE z (x + - y) Hz (SNo_add_SNo x (- y) Hx (SNo_minus_SNo y Hy)) H1.
- assume H2. apply SNoLtLe.
  exact add_SNo_minus_Lt2 x y z Hx Hy Hz H2.
- assume H2: z = x + - y.
  prove z + y <= x.
  rewrite H2.
  prove (x + - y) + y <= x.
  rewrite add_SNo_minus_R2' x y Hx Hy.
  apply SNoLe_ref.
Qed.

Theorem add_SNo_minus_Le2b : forall x y z, SNo x -> SNo y -> SNo z -> z + y <= x -> z <= x + - y.
let x y z. assume Hx Hy Hz H1.
apply SNoLeE (z + y) x (SNo_add_SNo z y Hz Hy) Hx H1.
- assume H2. apply SNoLtLe.
  exact add_SNo_minus_Lt2b x y z Hx Hy Hz H2.
- assume H2: z + y = x.
  prove z <= x + - y.
  rewrite <- H2.
  prove z <= (z + y) + - y.
  rewrite add_SNo_minus_R2 z y Hz Hy.
  apply SNoLe_ref.
Qed.

Theorem add_SNo_Lt_subprop2 : forall x y z w u v, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
  -> x + u < z + v
  -> y + v < w + u
  -> x + y < z + w.
let x y z w u v.
assume Hx Hy Hz Hw Hu Hv H1 H2.
apply add_SNo_Lt1_cancel (x + y) (u + v) (z + w)
           (SNo_add_SNo x y Hx Hy)
           (SNo_add_SNo u v Hu Hv)
           (SNo_add_SNo z w Hz Hw).
prove (x + y) + (u + v) < (z + w) + (u + v).
rewrite add_SNo_com_4_inner_mid x y u v Hx Hy Hu Hv.
prove (x + u) + (y + v) < (z + w) + (u + v).
claim L1: (z + w) + (u + v) = (z + v) + (w + u).
{ rewrite <- add_SNo_assoc z w (u + v) Hz Hw (SNo_add_SNo u v Hu Hv).
  rewrite <- add_SNo_assoc z v (w + u) Hz Hv (SNo_add_SNo w u Hw Hu).
  prove z + (w + (u + v)) = z + (v + (w + u)).
  f_equal.
  prove w + u + v = v + w + u.
  exact add_SNo_rotate_3_1 w u v Hw Hu Hv.
}
rewrite L1.
prove (x + u) + (y + v) < (z + v) + (w + u).
exact add_SNo_Lt3 (x + u) (y + v) (z + v) (w + u)
                       (SNo_add_SNo x u Hx Hu)
                       (SNo_add_SNo y v Hy Hv)
                       (SNo_add_SNo z v Hz Hv)
                       (SNo_add_SNo w u Hw Hu)
                       H1 H2.
Qed.

Theorem add_SNo_Lt_subprop3a : forall x y z w u a, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo a
  -> x + z < w + a
  -> y + a < u
  -> x + y + z < w + u.
let x y z w u a.
assume Hx Hy Hz Hw Hu Ha H1 H2.
apply SNoLt_tra (x + y + z) (y + w + a) (w + u)
                (SNo_add_SNo x (y + z) Hx (SNo_add_SNo y z Hy Hz))
                (SNo_add_SNo y (w + a) Hy (SNo_add_SNo w a Hw Ha))
                (SNo_add_SNo w u Hw Hu).
- prove x + y + z < y + w + a.
  rewrite add_SNo_com_3_0_1 x y z Hx Hy Hz.
  prove y + x + z < y + w + a.
  apply add_SNo_Lt2 y (x + z) (w + a) Hy (SNo_add_SNo x z Hx Hz) (SNo_add_SNo w a Hw Ha).
  exact H1.
- prove y + w + a < w + u.
  rewrite <- add_SNo_rotate_3_1 w a y Hw Ha Hy.
  prove w + a + y < w + u.
  apply add_SNo_Lt2 w (a + y) u Hw (SNo_add_SNo a y Ha Hy) Hu.
  prove a + y < u.
  rewrite add_SNo_com a y Ha Hy. exact H2.
Qed.

Theorem add_SNo_Lt_subprop3b : forall x y w u v a, SNo x -> SNo y -> SNo w -> SNo u -> SNo v -> SNo a
  -> x + a < w + v
  -> y < a + u
  -> x + y < w + u + v.
let x y w u v a.
assume Hx Hy Hw Hu Hv Ha H1 H2.
rewrite add_SNo_com x y Hx Hy.
prove y + x < w + u + v.
rewrite <- add_SNo_rotate_3_1 u v w Hu Hv Hw.
prove y + x < u + v + w.
rewrite <- add_SNo_0R x Hx.
prove y + x + 0 < u + v + w.
apply add_SNo_Lt_subprop3a y x 0 u (v + w) a Hy Hx SNo_0 Hu (SNo_add_SNo v w Hv Hw) Ha.
- prove y + 0 < u + a. rewrite add_SNo_0R y Hy. rewrite add_SNo_com u a Hu Ha. exact H2.
- prove x + a < v + w. rewrite add_SNo_com v w Hv Hw. exact H1.
Qed.

Theorem add_SNo_Lt_subprop3c : forall x y z w u a b c, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo a -> SNo b -> SNo c
 -> x + a < b + c
 -> y + c < u
 -> b + z < w + a
 -> x + y + z < w + u.
let x y z w u a b c.
assume Hx Hy Hz Hw Hu Ha Hb Hc H1 H2 H3.
claim L1: x + z < c + w.
{ apply add_SNo_Lt_subprop2 x z c w a b Hx Hz Hc Hw Ha Hb.
  - prove x + a < c + b. rewrite add_SNo_com c b Hc Hb. exact H1.
  - prove z + b < w + a. rewrite add_SNo_com z b Hz Hb. exact H3.
}
claim Lxz: SNo (x + z).
{ exact SNo_add_SNo x z Hx Hz. }
claim Lcw: SNo (c + w).
{ exact SNo_add_SNo c w Hc Hw. }
apply SNoLt_tra (x + y + z) (c + w + y) (w + u).
- exact SNo_add_SNo x (y + z) Hx (SNo_add_SNo y z Hy Hz).
- exact SNo_add_SNo c (w + y) Hc (SNo_add_SNo w y Hw Hy).
- exact SNo_add_SNo w u Hw Hu.
- prove x + y + z < c + w + y.
  rewrite add_SNo_com y z Hy Hz.
  prove x + z + y < c + w + y.
  rewrite add_SNo_assoc x z y Hx Hz Hy.
  rewrite add_SNo_assoc c w y Hc Hw Hy.
  exact add_SNo_Lt1 (x + z) y (c + w) Lxz Hy Lcw L1.
- prove c + w + y < w + u.
  rewrite <- add_SNo_rotate_3_1 w y c Hw Hy Hc.
  prove w + y + c < w + u.
  apply add_SNo_Lt2 w (y + c) u Hw (SNo_add_SNo y c Hy Hc) Hu.
  prove y + c < u.
  exact H2.
Qed.

Theorem add_SNo_Lt_subprop3d : forall x y w u v a b c, SNo x -> SNo y -> SNo w -> SNo u -> SNo v -> SNo a -> SNo b -> SNo c
 -> x + a < b + v
 -> y < c + u
 -> b + c < w + a
 -> x + y < w + u + v.
let x y w u v a b c.
assume Hx Hy Hw Hu Hv Ha Hb Hc H1 H2 H3.
claim L1: b + y < w + u + a.
{ exact add_SNo_Lt_subprop3b b y w u a c Hb Hy Hw Hu Ha Hc H3 H2. }
claim Lxy: SNo (x + y).
{ exact SNo_add_SNo x y Hx Hy. }
claim Lwuv: SNo (w + u + v).
{ exact SNo_add_SNo w (u + v) Hw (SNo_add_SNo u v Hu Hv). }
claim Lwua: SNo (w + u + a).
{ exact SNo_add_SNo w (u + a) Hw (SNo_add_SNo u a Hu Ha). }
claim Lby: SNo (b + y).
{ exact SNo_add_SNo b y Hb Hy. }
apply add_SNo_Lt1_cancel (x + y) b (w + u + v) Lxy Hb Lwuv.
prove (x + y) + b < (w + u + v) + b.
apply SNoLt_tra ((x + y) + b)
                (x + w + u + a)
                ((w + u + v) + b)
                (SNo_add_SNo (x + y) b Lxy Hb)
                (SNo_add_SNo x (w + u + a) Hx Lwua)
                (SNo_add_SNo (w + u + v) b Lwuv Hb).
- prove (x + y) + b < x + w + u + a.
  rewrite <- add_SNo_assoc x y b Hx Hy Hb.
  prove x + y + b < x + w + u + a.
  rewrite add_SNo_com y b Hy Hb.
  prove x + b + y < x + w + u + a.
  apply add_SNo_Lt2 x (b + y) (w + u + a) Hx Lby Lwua.
  prove b + y < w + u + a.
  exact L1.
- prove x + w + u + a < (w + u + v) + b.
  claim L2: x + w + u + a = (w + u) + (x + a).
  { transitivity (x + w + u) + a,
                 (w + u + x) + a,
                 w + u + x + a.
    - exact add_SNo_assoc_4 x w u a Hx Hw Hu Ha.
    - f_equal. symmetry. exact add_SNo_rotate_3_1 w u x Hw Hu Hx.
    - symmetry. exact add_SNo_assoc_4 w u x a Hw Hu Hx Ha.
    - prove w + u + x + a = (w + u) + (x + a).
      exact add_SNo_assoc w u (x + a) Hw Hu (SNo_add_SNo x a Hx Ha).
  }
  claim L3: (w + u + v) + b = (w + u) + b + v.
  { transitivity ((w + u) + v) + b,
                 (w + u) + (v + b).
    - f_equal. exact add_SNo_assoc w u v Hw Hu Hv.
    - symmetry. exact add_SNo_assoc (w + u) v b (SNo_add_SNo w u Hw Hu) Hv Hb.
    - f_equal. exact add_SNo_com v b Hv Hb.
  }
  rewrite L2. rewrite L3.
  prove (w + u) + (x + a) < (w + u) + (b + v).
  apply add_SNo_Lt2 (w + u) (x + a) (b + v)
                    (SNo_add_SNo w u Hw Hu)
                    (SNo_add_SNo x a Hx Ha)
                    (SNo_add_SNo b v Hb Hv).
  exact H1.
Qed.

Theorem ordinal_ordsucc_SNo_eq : forall alpha, ordinal alpha -> ordsucc alpha = 1 + alpha.
let alpha. assume Ha.
rewrite <- add_SNo_0L alpha (ordinal_SNo alpha Ha) at 1.
prove ordsucc (0 + alpha) = 1 + alpha.
symmetry.
exact add_SNo_ordinal_SL 0 ordinal_Empty alpha Ha.
Qed.

Theorem add_SNo_3a_2b: forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u
 -> (x + y + z) + (w + u) = (u + y + z) + (w + x).
let x y z w u. assume Hx Hy Hz Hw Hu.
rewrite add_SNo_com (x + y + z) (w + u)
                    (SNo_add_SNo_3 x y z Hx Hy Hz) (SNo_add_SNo w u Hw Hu).
prove (w + u) + (x + y + z) = (u + y + z) + (w + x).
rewrite add_SNo_com_4_inner_mid w u x (y + z) Hw Hu Hx (SNo_add_SNo y z Hy Hz).
prove (w + x) + (u + y + z) = (u + y + z) + (w + x).
exact add_SNo_com (w + x) (u + y + z)
                  (SNo_add_SNo w x Hw Hx)
                  (SNo_add_SNo_3 u y z Hu Hy Hz).
Qed.

Theorem add_SNo_1_ordsucc : forall n :e omega, n + 1 = ordsucc n.
let n. assume Hn.
rewrite <- add_nat_add_SNo n Hn 1 (nat_p_omega 1 nat_1).
prove add_nat n 1 = ordsucc n.
rewrite add_nat_SR n 0 nat_0.
prove ordsucc (add_nat n 0) = ordsucc n.
rewrite add_nat_0R.
reflexivity.
Qed.

Theorem add_SNo_eps_Lt : forall x, SNo x -> forall n :e omega, x < x + eps_ n.
let x. assume Hx. let n. assume Hn.
rewrite <- add_SNo_0R x Hx at 1.
prove x + 0 < x + eps_ n.
apply add_SNo_Lt2 x 0 (eps_ n) Hx SNo_0 (SNo_eps_ n Hn).
exact SNo_eps_pos n Hn.
Qed.

Theorem add_SNo_eps_Lt' : forall x y, SNo x -> SNo y -> forall n :e omega, x < y -> x < y + eps_ n.
let x y. assume Hx Hy. let n. assume Hn.
assume Hxy.
apply SNoLt_tra x y (y + eps_ n) Hx Hy (SNo_add_SNo y (eps_ n) Hy (SNo_eps_ n Hn)) Hxy.
prove y < y + eps_ n.
exact add_SNo_eps_Lt y Hy n Hn.
Qed.

Theorem SNoLt_minus_pos : forall x y, SNo x -> SNo y -> x < y -> 0 < y + - x.
let x y. assume Hx Hy Hxy.
apply add_SNo_minus_Lt2b y x 0 Hy Hx SNo_0.
prove 0 + x < y.
rewrite add_SNo_0L x Hx. exact Hxy.
Qed.

Theorem add_SNo_omega_In_cases: forall m, forall n :e omega, forall k, nat_p k -> m :e n + k -> m :e n \/ m + - n :e k.
let m n. assume Hn.
claim Ln: SNo n.
{ apply omega_SNo. exact Hn. }
apply nat_ind.
- prove m :e n + 0 -> m :e n \/ m + - n :e 0.
  rewrite add_SNo_0R n Ln.
  assume H1. apply orIL. exact H1.
- let k. assume Hk.
  assume IHk: m :e n + k -> m :e n \/ m + - n :e k.
  rewrite <- add_SNo_1_ordsucc k (nat_p_omega k Hk) at 1.
  rewrite add_SNo_assoc n k 1 Ln (nat_p_SNo k Hk) SNo_1.
  rewrite add_SNo_1_ordsucc (n + k) (add_SNo_In_omega n Hn k (nat_p_omega k Hk)).
  assume H1: m :e ordsucc (n + k).
  apply ordsuccE (n + k) m H1.
  + assume H2: m :e n + k. apply IHk H2.
    * assume H3: m :e n. apply orIL. exact H3.
    * assume H3: m + - n :e k. apply orIR.
      apply ordsuccI1. exact H3.
  + assume H2: m = n + k. apply orIR. rewrite H2.
    prove (n + k) + - n :e ordsucc k.
    rewrite add_SNo_com (n + k) (- n) (SNo_add_SNo n k Ln (nat_p_SNo k Hk)) (SNo_minus_SNo n Ln).
    rewrite add_SNo_minus_L2 n k Ln (nat_p_SNo k Hk).
    apply ordsuccI2.
Qed.

Theorem add_SNo_Lt4 : forall x y z w u v, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v -> x < w -> y < u -> z < v -> x + y + z < w + u + v.
let x y z w u v.
assume Hx Hy Hz Hw Hu Hv Hxw Hyu Hzv.
prove x + y + z < w + u + v.
apply add_SNo_Lt3 x (y + z) w (u + v) Hx (SNo_add_SNo y z Hy Hz) Hw (SNo_add_SNo u v Hu Hv) Hxw.
prove y + z < u + v.
exact add_SNo_Lt3 y z u v Hy Hz Hu Hv Hyu Hzv.
Qed.

Theorem add_SNo_3_3_3_Lt1 : forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u ->
  x + y < z + w -> x + y + u < z + w + u.
let x y z w u. assume Hx Hy Hz Hw Hu H1.
rewrite add_SNo_assoc x y u Hx Hy Hu.
rewrite add_SNo_assoc z w u Hz Hw Hu.
prove (x + y) + u < (z + w) + u.
exact add_SNo_Lt1 (x + y) u (z + w) (SNo_add_SNo x y Hx Hy) Hu (SNo_add_SNo z w Hz Hw) H1.
Qed.

Theorem add_SNo_3_2_3_Lt1 : forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u ->
  y + x < z + w -> x + u + y < z + w + u.
let x y z w u. assume Hx Hy Hz Hw Hu H1.
rewrite add_SNo_rotate_3_1 x u y Hx Hu Hy.
prove y + x + u < z + w + u.
exact add_SNo_3_3_3_Lt1 y x z w u Hy Hx Hz Hw Hu H1. 
Qed.

Theorem add_SNo_minus_Lt12b3: forall x y z w u v,
    SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
 -> x + y + v < w + u + z
 -> x + y + - z < w + u + - v.
let x y z w u v.
assume Hx Hy Hz Hw Hu Hv.
assume H1: x + y + v < w + u + z.
prove x + y + - z < w + u + - v.
claim Lmv: SNo (- v).
{ exact SNo_minus_SNo v Hv. }
apply add_SNo_minus_Lt1b3 x y z (w + u + - v) Hx Hy Hz (SNo_add_SNo_3 w u (- v) Hw Hu Lmv).
prove x + y < (w + u + - v) + z.
rewrite add_SNo_assoc w u (- v) Hw Hu Lmv.
prove x + y < ((w + u) + - v) + z.
rewrite add_SNo_com_3b_1_2 (w + u) (- v) z (SNo_add_SNo w u Hw Hu) Lmv Hz.
prove x + y < ((w + u) + z) + - v.
apply add_SNo_minus_Lt2b ((w + u) + z) v (x + y) (SNo_add_SNo (w + u) z (SNo_add_SNo w u Hw Hu) Hz) Hv (SNo_add_SNo x y Hx Hy).
prove (x + y) + v < (w + u) + z.
rewrite <- add_SNo_assoc x y v Hx Hy Hv.
rewrite <- add_SNo_assoc w u z Hw Hu Hz.
exact H1.
Qed.

Theorem add_SNo_minus_Le1b : forall x y z, SNo x -> SNo y -> SNo z -> x <= z + y -> x + - y <= z.
let x y z. assume Hx Hy Hz H1.
apply add_SNo_Le1_cancel (x + - y) y z (SNo_add_SNo x (- y) Hx (SNo_minus_SNo y Hy)) Hy Hz.
prove (x + - y) + y <= z + y.
rewrite <- add_SNo_assoc x (- y) y Hx (SNo_minus_SNo y Hy) Hy.
rewrite add_SNo_minus_SNo_linv y Hy.
rewrite add_SNo_0R x Hx.
exact H1.
Qed.

Theorem add_SNo_minus_Le1b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x + y <= w + z -> x + y + - z <= w.
let x y z w. assume Hx Hy Hz Hw H1.
prove x + y + - z <= w.
rewrite add_SNo_assoc x y (- z) Hx Hy (SNo_minus_SNo z Hz).
prove (x + y) + - z <= w.
apply add_SNo_minus_Le1b (x + y) z w (SNo_add_SNo x y Hx Hy) Hz Hw.
exact H1.
Qed.

Theorem add_SNo_minus_Le12b3: forall x y z w u v,
    SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
 -> x + y + v <= w + u + z
 -> x + y + - z <= w + u + - v.
let x y z w u v.
assume Hx Hy Hz Hw Hu Hv.
assume H1: x + y + v <= w + u + z.
prove x + y + - z <= w + u + - v.
claim Lmv: SNo (- v).
{ exact SNo_minus_SNo v Hv. }
apply add_SNo_minus_Le1b3 x y z (w + u + - v) Hx Hy Hz (SNo_add_SNo_3 w u (- v) Hw Hu Lmv).
prove x + y <= (w + u + - v) + z.
rewrite add_SNo_assoc w u (- v) Hw Hu Lmv.
prove x + y <= ((w + u) + - v) + z.
rewrite add_SNo_com_3b_1_2 (w + u) (- v) z (SNo_add_SNo w u Hw Hu) Lmv Hz.
prove x + y <= ((w + u) + z) + - v.
apply add_SNo_minus_Le2b ((w + u) + z) v (x + y) (SNo_add_SNo (w + u) z (SNo_add_SNo w u Hw Hu) Hz) Hv (SNo_add_SNo x y Hx Hy).
prove (x + y) + v <= (w + u) + z.
rewrite <- add_SNo_assoc x y v Hx Hy Hv.
rewrite <- add_SNo_assoc w u z Hw Hu Hz.
exact H1.
Qed.

End SurrealAdd.

Opaque add_SNo.

Section SurrealAbs.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
(* Parameter abs_SNo "9f9389c36823b2e0124a7fe367eb786d080772b5171a5d059b10c47361cef0ef" "34f6dccfd6f62ca020248cdfbd473fcb15d8d9c5c55d1ec7c5ab6284006ff40f" *)
Definition abs_SNo : set -> set := fun x => if 0 <= x then x else - x.

Theorem nonneg_abs_SNo : forall x, 0 <= x -> abs_SNo x = x.
let x. assume Hx.
exact If_i_1 (0 <= x) x (- x) Hx.
Qed.

Theorem not_nonneg_abs_SNo : forall x, ~(0 <= x) -> abs_SNo x = - x.
let x. assume Hx.
exact If_i_0 (0 <= x) x (- x) Hx.
Qed.

Theorem pos_abs_SNo : forall x, 0 < x -> abs_SNo x = x.
let x. assume Hx.
apply nonneg_abs_SNo. prove 0 <= x.
apply SNoLtLe. exact Hx.
Qed.

Theorem neg_abs_SNo : forall x, SNo x -> x < 0 -> abs_SNo x = - x.
let x. assume Hx1 Hx2.
apply not_nonneg_abs_SNo.
assume H1: 0 <= x.
prove False.
apply SNoLt_irref x.
prove x < x.
exact SNoLtLe_tra x 0 x Hx1 SNo_0 Hx1 Hx2 H1.
Qed.

Theorem SNo_abs_SNo : forall x, SNo x -> SNo (abs_SNo x).
let x. assume Hx.
apply xm (0 <= x).
- assume H1. rewrite nonneg_abs_SNo x H1. exact Hx.
- assume H1. rewrite not_nonneg_abs_SNo x H1.
  apply SNo_minus_SNo. exact Hx.
Qed.

Theorem abs_SNo_minus: forall x, SNo x -> abs_SNo (- x) = abs_SNo x.
let x. assume Hx.
apply SNoLtLe_or x 0 Hx SNo_0.
- assume H1: x < 0. rewrite neg_abs_SNo x Hx H1.
  prove abs_SNo (- x) = - x.
  claim L1: 0 <= - x.
  { apply SNoLtLe. prove 0 < - x.
    apply minus_SNo_Lt_contra2 x 0 Hx SNo_0.
    prove x < - 0. rewrite minus_SNo_0. exact H1.
  }
  exact nonneg_abs_SNo (- x) L1.
- assume H1: 0 <= x.
  apply SNoLtLe_or (- x) 0 (SNo_minus_SNo x Hx) SNo_0.
  + assume H2: - x < 0.
    rewrite nonneg_abs_SNo x H1.
    rewrite neg_abs_SNo (- x) (SNo_minus_SNo x Hx) H2.
    prove - - x = x.
    exact minus_SNo_invol x Hx.
  + assume H2: 0 <= - x.
    claim L2: x = 0.
    { apply SNoLe_antisym x 0 Hx SNo_0.
      - prove x <= 0.
        rewrite <- minus_SNo_0.
        rewrite <- minus_SNo_invol x Hx.
        prove - - x <= - 0.
        apply minus_SNo_Le_contra 0 (- x) SNo_0 (SNo_minus_SNo x Hx).
        prove 0 <= - x. exact H2.
      - prove 0 <= x. exact H1.
    }
    rewrite L2. f_equal. exact minus_SNo_0.
Qed.

Theorem abs_SNo_dist_swap: forall x y, SNo x -> SNo y -> abs_SNo (x + - y) = abs_SNo (y + - x).
let x y. assume Hx Hy.
claim Lmx: SNo (- x).
{ apply SNo_minus_SNo. exact Hx. }
claim Lmy: SNo (- y).
{ apply SNo_minus_SNo. exact Hy. }
claim Lymx: SNo (y + - x).
{ exact SNo_add_SNo y (- x) Hy Lmx. }
transitivity abs_SNo (- (y + - x)).
- f_equal. prove x + - y = - (y + - x).
  rewrite minus_add_SNo_distr y (- x) Hy Lmx.
  prove x + - y = - y + - - x.
  rewrite minus_SNo_invol x Hx.
  prove x + - y = - y + x.
  exact add_SNo_com x (- y) Hx Lmy.
- exact abs_SNo_minus (y + - x) Lymx.
Qed.

End SurrealAbs.

Opaque abs_SNo.

Section SurrealMul.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
(* Parameter mul_SNo "f56bf39b8eea93d7f63da529dedb477ae1ab1255c645c47d8915623f364f2d6b" "48d05483e628cb37379dd5d279684d471d85c642fe63533c3ad520b84b18df9d" *)
Definition mul_SNo : set -> set -> set
  := SNo_rec2
      (fun x y m =>
        SNoCut ({m (w 0) y + m x (w 1) + - m (w 0) (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {m (z 0) y + m x (z 1) + - m (z 0) (z 1)|z :e SNoR x :*: SNoR y})
               ({m (w 0) y + m x (w 1) + - m (w 0) (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {m (z 0) y + m x (z 1) + - m (z 0) (z 1)|z :e SNoR x :*: SNoL y})).

Infix * 355 right := mul_SNo.

Theorem mul_SNo_eq : forall x, SNo x -> forall y, SNo y ->
   x * y
      = SNoCut ({(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoR y})
               ({(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoL y}).
set F : set -> set -> (set -> set -> set) -> set
  := fun x y m => 
        SNoCut ({m (w 0) y + m x (w 1) + - m (w 0) (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {m (z 0) y + m x (z 1) + - m (z 0) (z 1)|z :e SNoR x :*: SNoR y})
               ({m (w 0) y + m x (w 1) + - m (w 0) (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {m (z 0) y + m x (z 1) + - m (z 0) (z 1)|z :e SNoR x :*: SNoL y}).
claim L1: forall x, SNo x -> forall y, SNo y ->
  forall g h:set -> set -> set,
      (forall w :e SNoS_ (SNoLev x), forall z, SNo z -> g w z = h w z)
   -> (forall z :e SNoS_ (SNoLev y), g x z = h x z)
   -> F x y g = F x y h.
{ let x. assume Hx: SNo x.
  let y. assume Hy: SNo y.
  let g h.
  assume Hgh1: forall w :e SNoS_ (SNoLev x), forall z, SNo z -> g w z = h w z.
  assume Hgh2: forall z :e SNoS_ (SNoLev y), g x z = h x z.
  prove F x y g = F x y h.
  claim L1a: {g (w 0) y + g x (w 1) + - g (w 0) (w 1)|w :e SNoL x :*: SNoL y}
           = {h (w 0) y + h x (w 1) + - h (w 0) (w 1)|w :e SNoL x :*: SNoL y}.
  { apply ReplEq_setprod_ext (SNoL x) (SNoL y) (fun w0 w1 => g w0 y + g x w1 + - g w0 w1) (fun w0 w1 => h w0 y + h x w1 + - h w0 w1).
    prove forall w0 :e SNoL x, forall w1 :e SNoL y,
              g w0 y + g x w1 + - g w0 w1
            = h w0 y + h x w1 + - h w0 w1.
    let w0. assume Hw0: w0 :e SNoL x.
    let w1. assume Hw1: w1 :e SNoL y.
    claim Lw0: w0 :e SNoS_ (SNoLev x).
    { exact SNoL_SNoS x Hx w0 Hw0. }
    claim Lw1: w1 :e SNoS_ (SNoLev y).
    { exact SNoL_SNoS y Hy w1 Hw1. }
    claim Lw1b: SNo w1.
    { apply SNoL_E y Hy w1 Hw1. assume H _ _. exact H. }
    claim L1aa: g w0 y = h w0 y.
    { apply Hgh1.
      - exact Lw0.
      - exact Hy.
    }
    claim L1ab: g x w1 = h x w1.
    { apply Hgh2. exact Lw1. }
    claim L1ac: g w0 w1 = h w0 w1.
    { apply Hgh1.
      - exact Lw0.
      - exact Lw1b.
    }
    rewrite L1aa. rewrite L1ab. rewrite L1ac. reflexivity.
  }
  claim L1b: {g (z 0) y + g x (z 1) + - g (z 0) (z 1)|z :e SNoR x :*: SNoR y}
           = {h (z 0) y + h x (z 1) + - h (z 0) (z 1)|z :e SNoR x :*: SNoR y}.
  { apply ReplEq_setprod_ext (SNoR x) (SNoR y) (fun z0 z1 => g z0 y + g x z1 + - g z0 z1) (fun z0 z1 => h z0 y + h x z1 + - h z0 z1).
    prove forall z0 :e SNoR x, forall z1 :e SNoR y,
              g z0 y + g x z1 + - g z0 z1
            = h z0 y + h x z1 + - h z0 z1.
    let z0. assume Hz0: z0 :e SNoR x.
    let z1. assume Hz1: z1 :e SNoR y.
    claim Lz0: z0 :e SNoS_ (SNoLev x).
    { exact SNoR_SNoS x Hx z0 Hz0. }
    claim Lz1: z1 :e SNoS_ (SNoLev y).
    { exact SNoR_SNoS y Hy z1 Hz1. }
    claim Lz1b: SNo z1.
    { apply SNoR_E y Hy z1 Hz1. assume H _ _. exact H. }
    claim L1ba: g z0 y = h z0 y.
    { apply Hgh1.
      - exact Lz0.
      - exact Hy.
    }
    claim L1bb: g x z1 = h x z1.
    { apply Hgh2. exact Lz1. }
    claim L1bc: g z0 z1 = h z0 z1.
    { apply Hgh1.
      - exact Lz0.
      - exact Lz1b.
    }
    rewrite L1ba. rewrite L1bb. rewrite L1bc. reflexivity.
  }
  claim L1c: {g (w 0) y + g x (w 1) + - g (w 0) (w 1)|w :e SNoL x :*: SNoR y}
           = {h (w 0) y + h x (w 1) + - h (w 0) (w 1)|w :e SNoL x :*: SNoR y}.
  { apply ReplEq_setprod_ext (SNoL x) (SNoR y) (fun w0 w1 => g w0 y + g x w1 + - g w0 w1) (fun w0 w1 => h w0 y + h x w1 + - h w0 w1).
    prove forall w0 :e SNoL x, forall w1 :e SNoR y,
              g w0 y + g x w1 + - g w0 w1
            = h w0 y + h x w1 + - h w0 w1.
    let w0. assume Hw0: w0 :e SNoL x.
    let w1. assume Hw1: w1 :e SNoR y.
    claim Lw0: w0 :e SNoS_ (SNoLev x).
    { exact SNoL_SNoS x Hx w0 Hw0. }
    claim Lw1: w1 :e SNoS_ (SNoLev y).
    { exact SNoR_SNoS y Hy w1 Hw1. }
    claim Lw1b: SNo w1.
    { apply SNoR_E y Hy w1 Hw1. assume H _ _. exact H. }
    claim L1ca: g w0 y = h w0 y.
    { apply Hgh1.
      - exact Lw0.
      - exact Hy.
    }
    claim L1cb: g x w1 = h x w1.
    { apply Hgh2. exact Lw1. }
    claim L1cc: g w0 w1 = h w0 w1.
    { apply Hgh1.
      - exact Lw0.
      - exact Lw1b.
    }
    rewrite L1ca. rewrite L1cb. rewrite L1cc. reflexivity.
  }
  claim L1d: {g (z 0) y + g x (z 1) + - g (z 0) (z 1)|z :e SNoR x :*: SNoL y}
           = {h (z 0) y + h x (z 1) + - h (z 0) (z 1)|z :e SNoR x :*: SNoL y}.
  { apply ReplEq_setprod_ext (SNoR x) (SNoL y) (fun z0 z1 => g z0 y + g x z1 + - g z0 z1) (fun z0 z1 => h z0 y + h x z1 + - h z0 z1).
    prove forall z0 :e SNoR x, forall z1 :e SNoL y,
              g z0 y + g x z1 + - g z0 z1
            = h z0 y + h x z1 + - h z0 z1.
    let z0. assume Hz0: z0 :e SNoR x.
    let z1. assume Hz1: z1 :e SNoL y.
    claim Lz0: z0 :e SNoS_ (SNoLev x).
    { exact SNoR_SNoS x Hx z0 Hz0. }
    claim Lz1: z1 :e SNoS_ (SNoLev y).
    { exact SNoL_SNoS y Hy z1 Hz1. }
    claim Lz1b: SNo z1.
    { apply SNoL_E y Hy z1 Hz1. assume H _ _. exact H. }
    claim L1da: g z0 y = h z0 y.
    { apply Hgh1.
      - exact Lz0.
      - exact Hy.
    }
    claim L1db: g x z1 = h x z1.
    { apply Hgh2. exact Lz1. }
    claim L1dc: g z0 z1 = h z0 z1.
    { apply Hgh1.
      - exact Lz0.
      - exact Lz1b.
    }
    rewrite L1da. rewrite L1db. rewrite L1dc. reflexivity.
  }
  prove SNoCut ({g (w 0) y + g x (w 1) + - g (w 0) (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {g (z 0) y + g x (z 1) + - g (z 0) (z 1)|z :e SNoR x :*: SNoR y})
               ({g (w 0) y + g x (w 1) + - g (w 0) (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {g (z 0) y + g x (z 1) + - g (z 0) (z 1)|z :e SNoR x :*: SNoL y})
      = SNoCut ({h (w 0) y + h x (w 1) + - h (w 0) (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {h (z 0) y + h x (z 1) + - h (z 0) (z 1)|z :e SNoR x :*: SNoR y})
               ({h (w 0) y + h x (w 1) + - h (w 0) (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {h (z 0) y + h x (z 1) + - h (z 0) (z 1)|z :e SNoR x :*: SNoL y}).
  rewrite L1a.
  rewrite L1b.
  rewrite L1c.
  rewrite L1d.
  reflexivity.
}
exact SNo_rec2_eq F L1.
Qed.

Theorem mul_SNo_eq_2 : forall x y, SNo x -> SNo y ->
  forall p:prop,
    (forall L R,
         (forall u, u :e L ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall w1 :e SNoL y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e SNoR x, forall z1 :e SNoR y, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall w1 :e SNoL y, w0 * y + x * w1 + - w0 * w1 :e L)
      -> (forall z0 :e SNoR x, forall z1 :e SNoR y, z0 * y + x * z1 + - z0 * z1 :e L)
      -> (forall u, u :e R ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall z1 :e SNoR y, u = w0 * y + x * z1 + - w0 * z1 -> q)
             -> (forall z0 :e SNoR x, forall w1 :e SNoL y, u = z0 * y + x * w1 + - z0 * w1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall z1 :e SNoR y, w0 * y + x * z1 + - w0 * z1 :e R)
      -> (forall z0 :e SNoR x, forall w1 :e SNoL y, z0 * y + x * w1 + - z0 * w1 :e R)
      -> x * y = SNoCut L R
      -> p)
   -> p.
let x y. assume Hx Hy. let p. assume Hp.
prove p.
set Lxy1 := {(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoL y}.
set Lxy2 := {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoR y}.
set Rxy1 := {(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoR y}.
set Rxy2 := {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoL y}.
apply Hp (Lxy1 :\/: Lxy2) (Rxy1 :\/: Rxy2).
- let u. assume Hu. let q.
  assume Hq1: forall w0 :e SNoL x, forall w1 :e SNoL y, u = w0 * y + x * w1 + - w0 * w1 -> q.
  assume Hq2: forall z0 :e SNoR x, forall z1 :e SNoR y, u = z0 * y + x * z1 + - z0 * z1 -> q.
  apply binunionE Lxy1 Lxy2 u Hu.
  + assume Hu1: u :e Lxy1.
    apply ReplE_impred (SNoL x :*: SNoL y) (fun w => (w 0) * y + x * (w 1) + - (w 0) * (w 1)) u Hu1.
    let w. assume Hw: w :e SNoL x :*: SNoL y.
    assume Hw2: u = (w 0) * y + x * (w 1) + - (w 0) * (w 1).
    exact Hq1 (w 0) (ap0_Sigma (SNoL x) (fun _ => SNoL y) w Hw)
              (w 1) (ap1_Sigma (SNoL x) (fun _ => SNoL y) w Hw)
              Hw2.
  + assume Hu2: u :e Lxy2.
    apply ReplE_impred (SNoR x :*: SNoR y) (fun z => (z 0) * y + x * (z 1) + - (z 0) * (z 1)) u Hu2.
    let z. assume Hz: z :e SNoR x :*: SNoR y.
    assume Hz2: u = (z 0) * y + x * (z 1) + - (z 0) * (z 1).
    exact Hq2 (z 0) (ap0_Sigma (SNoR x) (fun _ => SNoR y) z Hz)
              (z 1) (ap1_Sigma (SNoR x) (fun _ => SNoR y) z Hz)
              Hz2.
- let w0. assume Hw0: w0 :e SNoL x. let w1. assume Hw1: w1 :e SNoL y.
  prove w0 * y + x * w1 + - w0 * w1 :e Lxy1 :\/: Lxy2.
  apply binunionI1.
  prove w0 * y + x * w1 + - w0 * w1 :e Lxy1.
  apply tuple_2_0_eq w0 w1 (fun u v => u * y + x * w1 + - u * w1 :e Lxy1).
  prove (w0,w1) 0 * y + x * w1 + - (w0,w1) 0 * w1 :e Lxy1.
  apply tuple_2_1_eq w0 w1 (fun u v => (w0,w1) 0 * y + x * u + - (w0,w1) 0 * u :e Lxy1).
  prove (w0,w1) 0 * y + x * (w0,w1) 1 + - (w0,w1) 0 * (w0,w1) 1 :e Lxy1.
  apply ReplI (SNoL x :*: SNoL y) (fun w => (w 0) * y + x * (w 1) + - (w 0) * (w 1)) (w0,w1).
  prove (w0,w1) :e SNoL x :*: SNoL y.
  apply tuple_2_setprod.
  + exact Hw0.
  + exact Hw1.
- let z0. assume Hz0: z0 :e SNoR x. let z1. assume Hz1: z1 :e SNoR y.
  prove z0 * y + x * z1 + - z0 * z1 :e Lxy1 :\/: Lxy2.
  apply binunionI2.
  prove z0 * y + x * z1 + - z0 * z1 :e Lxy2.
  apply tuple_2_0_eq z0 z1 (fun u v => u * y + x * z1 + - u * z1 :e Lxy2).
  prove (z0,z1) 0 * y + x * z1 + - (z0,z1) 0 * z1 :e Lxy2.
  apply tuple_2_1_eq z0 z1 (fun u v => (z0,z1) 0 * y + x * u + - (z0,z1) 0 * u :e Lxy2).
  prove (z0,z1) 0 * y + x * (z0,z1) 1 + - (z0,z1) 0 * (z0,z1) 1 :e Lxy2.
  apply ReplI (SNoR x :*: SNoR y) (fun z => (z 0) * y + x * (z 1) + - (z 0) * (z 1)) (z0,z1).
  prove (z0,z1) :e SNoR x :*: SNoR y.
  apply tuple_2_setprod.
  + exact Hz0.
  + exact Hz1.
- let u. assume Hu. let q. assume Hq1 Hq2.
  apply binunionE Rxy1 Rxy2 u Hu.
  + assume Hu1: u :e Rxy1.
    apply ReplE_impred (SNoL x :*: SNoR y) (fun w => (w 0) * y + x * (w 1) + - (w 0) * (w 1)) u Hu1.
    let w. assume Hw: w :e SNoL x :*: SNoR y.
    assume Hw2: u = (w 0) * y + x * (w 1) + - (w 0) * (w 1).
    exact Hq1 (w 0) (ap0_Sigma (SNoL x) (fun _ => SNoR y) w Hw)
              (w 1) (ap1_Sigma (SNoL x) (fun _ => SNoR y) w Hw)
              Hw2.
  + assume Hu2: u :e Rxy2.
    apply ReplE_impred (SNoR x :*: SNoL y) (fun z => (z 0) * y + x * (z 1) + - (z 0) * (z 1)) u Hu2.
    let z. assume Hz: z :e SNoR x :*: SNoL y.
    assume Hz2: u = (z 0) * y + x * (z 1) + - (z 0) * (z 1).
    exact Hq2 (z 0) (ap0_Sigma (SNoR x) (fun _ => SNoL y) z Hz)
              (z 1) (ap1_Sigma (SNoR x) (fun _ => SNoL y) z Hz)
              Hz2.
- let w0. assume Hw0: w0 :e SNoL x. let z1. assume Hz1: z1 :e SNoR y.
  prove w0 * y + x * z1 + - w0 * z1 :e Rxy1 :\/: Rxy2.
  apply binunionI1.
  prove w0 * y + x * z1 + - w0 * z1 :e Rxy1.
  apply tuple_2_0_eq w0 z1 (fun u v => u * y + x * z1 + - u * z1 :e Rxy1).
  prove (w0,z1) 0 * y + x * z1 + - (w0,z1) 0 * z1 :e Rxy1.
  apply tuple_2_1_eq w0 z1 (fun u v => (w0,z1) 0 * y + x * u + - (w0,z1) 0 * u :e Rxy1).
  prove (w0,z1) 0 * y + x * (w0,z1) 1 + - (w0,z1) 0 * (w0,z1) 1 :e Rxy1.
  apply ReplI (SNoL x :*: SNoR y) (fun w => (w 0) * y + x * (w 1) + - (w 0) * (w 1)) (w0,z1).
  prove (w0,z1) :e SNoL x :*: SNoR y.
  apply tuple_2_setprod.
  + exact Hw0.
  + exact Hz1.
- let z0. assume Hz0: z0 :e SNoR x. let w1. assume Hw1: w1 :e SNoL y.
  prove z0 * y + x * w1 + - z0 * w1 :e Rxy1 :\/: Rxy2.
  apply binunionI2.
  prove z0 * y + x * w1 + - z0 * w1 :e Rxy2.
  apply tuple_2_0_eq z0 w1 (fun u v => u * y + x * w1 + - u * w1 :e Rxy2).
  prove (z0,w1) 0 * y + x * w1 + - (z0,w1) 0 * w1 :e Rxy2.
  apply tuple_2_1_eq z0 w1 (fun u v => (z0,w1) 0 * y + x * u + - (z0,w1) 0 * u :e Rxy2).
  prove (z0,w1) 0 * y + x * (z0,w1) 1 + - (z0,w1) 0 * (z0,w1) 1 :e Rxy2.
  apply ReplI (SNoR x :*: SNoL y) (fun w => (w 0) * y + x * (w 1) + - (w 0) * (w 1)) (z0,w1).
  prove (z0,w1) :e SNoR x :*: SNoL y.
  apply tuple_2_setprod.
  + exact Hz0.
  + exact Hw1.
- exact mul_SNo_eq x Hx y Hy.         
Qed.

Theorem mul_SNo_prop_1 : forall x, SNo x -> forall y, SNo y ->
 forall p:prop,
    (SNo (x * y)
  -> (forall u :e SNoL x, forall v :e SNoL y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoR x, forall v :e SNoR y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoL x, forall v :e SNoR y, x * y + u * v < u * y + x * v)
  -> (forall u :e SNoR x, forall v :e SNoL y, x * y + u * v < u * y + x * v)
  -> p)
 -> p.
set P : set -> prop
 := fun x =>
 forall y, SNo y ->
 forall p:prop,
    (SNo (x * y)
  -> (forall u :e SNoL x, forall v :e SNoL y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoR x, forall v :e SNoR y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoL x, forall v :e SNoR y, x * y + u * v < u * y + x * v)
  -> (forall u :e SNoR x, forall v :e SNoL y, x * y + u * v < u * y + x * v)
  -> p)
 -> p.
prove forall x, SNo x -> P x.
apply SNoLev_ind.
let x.
assume Hx: SNo x.
assume IHx: forall w :e SNoS_ (SNoLev x), P w.
set Q : set -> prop
 := fun y =>
 forall p:prop,
    (SNo (x * y)
  -> (forall u :e SNoL x, forall v :e SNoL y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoR x, forall v :e SNoR y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoL x, forall v :e SNoR y, x * y + u * v < u * y + x * v)
  -> (forall u :e SNoR x, forall v :e SNoL y, x * y + u * v < u * y + x * v)
  -> p)
 -> p.
prove forall y, SNo y -> Q y.
apply SNoLev_ind.
let y.
assume Hy: SNo y.
assume IHy: forall z :e SNoS_ (SNoLev y), Q z.
apply mul_SNo_eq_2 x y Hx Hy.
let L R.
assume HLE HLI1 HLI2 HRE HRI1 HRI2 Hxy.
claim LLx: forall u :e SNoL x, forall v, SNo v -> SNo (u * v).
{ let u. assume Hu. let v. assume Hv.
  apply IHx u (SNoL_SNoS x Hx u Hu) v Hv.
  assume H1 _ _ _ _. exact H1.
}
claim LRx: forall u :e SNoR x, forall v, SNo v -> SNo (u * v).
{ let u. assume Hu. let v. assume Hv.
  apply IHx u (SNoR_SNoS x Hx u Hu) v Hv.
  assume H1 _ _ _ _. exact H1.
}
claim LLxy: forall u :e SNoL x, SNo (u * y).
{ let u. assume Hu. exact LLx u Hu y Hy. }
claim LRxy: forall u :e SNoR x, SNo (u * y).
{ let u. assume Hu. exact LRx u Hu y Hy. }
claim LxLy: forall v :e SNoL y, SNo (x * v).
{ let v. assume Hv. apply IHy v (SNoL_SNoS y Hy v Hv).
  assume H1 _ _ _ _. exact H1.
}
claim LxRy: forall v :e SNoR y, SNo (x * v).
{ let v. assume Hv. apply IHy v (SNoR_SNoS y Hy v Hv).
  assume H1 _ _ _ _. exact H1.
}
claim LLR1: SNoCutP L R.
{ prove (forall x :e L, SNo x)
     /\ (forall y :e R, SNo y)
     /\ (forall x :e L, forall y :e R, x < y).
  apply and3I.
  - let u. assume Hu.
    apply HLE u Hu.
    + let w0. assume Hw0. let w1. assume Hw1 Huw.
      apply SNoL_E y Hy w1 Hw1.
      assume Hw1a _ _.
      prove SNo u.
      rewrite Huw.
      prove SNo (w0 * y + x * w1 + - w0 * w1).
      apply SNo_add_SNo.
      * prove SNo (w0 * y). exact LLxy w0 Hw0.
      * { prove SNo (x * w1 + - w0 * w1).
          apply SNo_add_SNo.
          - prove SNo (x * w1). exact LxLy w1 Hw1.
          - prove SNo (- w0 * w1).
            apply SNo_minus_SNo.
            exact LLx w0 Hw0 w1 Hw1a.
        }
    + let z0. assume Hz0. let z1. assume Hz1 Huz.
      apply SNoR_E y Hy z1 Hz1.
      assume Hz1a _ _.
      prove SNo u.
      rewrite Huz.
      prove SNo (z0 * y + x * z1 + - z0 * z1).
      apply SNo_add_SNo.
      * prove SNo (z0 * y). exact LRxy z0 Hz0.
      * { prove SNo (x * z1 + - z0 * z1).
          apply SNo_add_SNo.
          - prove SNo (x * z1). exact LxRy z1 Hz1.
          - prove SNo (- z0 * z1).
            apply SNo_minus_SNo.
            exact LRx z0 Hz0 z1 Hz1a.
        }
  - let u. assume Hu.
    apply HRE u Hu.
    + let w0. assume Hw0. let z1. assume Hz1 Huw.
      apply SNoR_E y Hy z1 Hz1.
      assume Hz1a _ _.
      prove SNo u.
      rewrite Huw.
      prove SNo (w0 * y + x * z1 + - w0 * z1).
      apply SNo_add_SNo.
      * prove SNo (w0 * y). exact LLxy w0 Hw0.
      * { prove SNo (x * z1 + - w0 * z1).
          apply SNo_add_SNo.
          - prove SNo (x * z1). exact LxRy z1 Hz1.
          - prove SNo (- w0 * z1).
            apply SNo_minus_SNo.
            exact LLx w0 Hw0 z1 Hz1a.
        }
    + let z0. assume Hz0. let w1. assume Hw1 Huz.
      apply SNoL_E y Hy w1 Hw1.
      assume Hw1a _ _.
      prove SNo u.
      rewrite Huz.
      prove SNo (z0 * y + x * w1 + - z0 * w1).
      apply SNo_add_SNo.
      * prove SNo (z0 * y). exact LRxy z0 Hz0.
      * { prove SNo (x * w1 + - z0 * w1).
          apply SNo_add_SNo.
          - prove SNo (x * w1). exact LxLy w1 Hw1.
          - prove SNo (- z0 * w1).
            apply SNo_minus_SNo.
            exact LRx z0 Hz0 w1 Hw1a.
        }
  - let u. assume Hu. let v. assume Hv.
    claim Luvimp: forall u0 v0 :e SNoS_ (SNoLev x), forall u1 v1 :e SNoS_ (SNoLev y),
           forall p:prop,
            (SNo (u0 * y) -> SNo (x * u1) -> SNo (u0 * u1) ->
             SNo (v0 * y) -> SNo (x * v1) -> SNo (v0 * v1) ->
             SNo (u0 * v1) -> SNo (v0 * u1) ->
                 (u = u0 * y + x * u1 + - u0 * u1
               -> v = v0 * y + x * v1 + - v0 * v1
               -> u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1
               -> u < v)
              -> p)
            -> p.
    { let u0. assume Hu0. let v0. assume Hv0.
      let u1. assume Hu1. let v1. assume Hv1.
      apply SNoS_E2 (SNoLev y) (SNoLev_ordinal y Hy) u1 Hu1.
      assume Hu1a: SNoLev u1 :e SNoLev y.
      assume Hu1b: ordinal (SNoLev u1).
      assume Hu1c: SNo u1.
      assume _.
      apply SNoS_E2 (SNoLev y) (SNoLev_ordinal y Hy) v1 Hv1.
      assume Hv1a: SNoLev v1 :e SNoLev y.
      assume Hv1b: ordinal (SNoLev v1).
      assume Hv1c: SNo v1.
      assume _.
      claim Lu0u1: SNo (u0 * u1).
      { apply IHx u0 Hu0 u1 Hu1c.
        assume IHx0 _ _ _ _. exact IHx0.
      }
      claim Lv0v1: SNo (v0 * v1).
      { apply IHx v0 Hv0 v1 Hv1c.
        assume IHx0 _ _ _ _. exact IHx0.
      }
      claim Lu0y: SNo (u0 * y).
      { apply IHx u0 Hu0 y Hy. assume H _ _ _ _. exact H. }
      claim Lxu1: SNo (x * u1).
      { apply IHy u1 Hu1. assume H _ _ _ _. exact H. }
      claim Lv0y: SNo (v0 * y).
      { apply IHx v0 Hv0 y Hy. assume H _ _ _ _. exact H. }
      claim Lxv1: SNo (x * v1).
      { apply IHy v1 Hv1. assume H _ _ _ _. exact H. }
      claim Lu0v1: SNo (u0 * v1).
      { apply IHx u0 Hu0 v1 Hv1c.
        assume IHx0 _ _ _ _. exact IHx0.
      }
      claim Lv0u1: SNo (v0 * u1).
      { apply IHx v0 Hv0 u1 Hu1c.
        assume IHx0 _ _ _ _. exact IHx0.
      }
      let p. assume Hp.
      apply Hp Lu0y Lxu1 Lu0u1 Lv0y Lxv1 Lv0v1 Lu0v1 Lv0u1.
      assume Hue Hve H1.
      prove u < v.
      rewrite Hue. rewrite Hve.
      apply add_SNo_Lt1_cancel
                   (u0 * y + x * u1 + - u0 * u1)
                   (u0 * u1 + v0 * v1)
                   (v0 * y + x * v1 + - v0 * v1)
                   (SNo_add_SNo (u0 * y) (x * u1 + - u0 * u1) Lu0y (SNo_add_SNo (x * u1) (- u0 * u1) Lxu1 (SNo_minus_SNo (u0 * u1) Lu0u1)))
                   (SNo_add_SNo (u0 * u1) (v0 * v1) Lu0u1 Lv0v1)
                   (SNo_add_SNo (v0 * y) (x * v1 + - v0 * v1) Lv0y (SNo_add_SNo (x * v1) (- v0 * v1) Lxv1 (SNo_minus_SNo (v0 * v1) Lv0v1))).
      claim L1: (u0 * y + x * u1 + - u0 * u1) + (u0 * u1 + v0 * v1)
               = u0 * y + x * u1 + v0 * v1.
      { exact add_SNo_minus_SNo_prop5 (u0 * y) (x * u1) (u0 * u1) (v0 * v1) Lu0y Lxu1 Lu0u1 Lv0v1. }
      claim L2: (v0 * y + x * v1 + - v0 * v1) + (u0 * u1 + v0 * v1)
               = v0 * y + x * v1 + u0 * u1.
      { rewrite add_SNo_com (u0 * u1) (v0 * v1) Lu0u1 Lv0v1.
        exact add_SNo_minus_SNo_prop5 (v0 * y) (x * v1) (v0 * v1) (u0 * u1) Lv0y Lxv1 Lv0v1 Lu0u1.
      }
      rewrite L1. rewrite L2. exact H1.
    }
    apply HLE u Hu.
    + let u0. assume Hu0. let u1. assume Hu1 Hue.
      apply SNoL_E x Hx u0 Hu0.
      assume Hu0a: SNo u0.
      assume Hu0b: SNoLev u0 :e SNoLev x.
      assume Hu0c: u0 < x.
      apply SNoL_E y Hy u1 Hu1.
      assume Hu1a: SNo u1.
      assume Hu1b: SNoLev u1 :e SNoLev y.
      assume Hu1c: u1 < y.
      apply HRE v Hv.
      * { let v0. assume Hv0. let v1. assume Hv1 Hve.
          apply SNoL_E x Hx v0 Hv0.
          assume Hv0a: SNo v0.
          assume Hv0b: SNoLev v0 :e SNoLev x.
          assume Hv0c: v0 < x.
          apply SNoR_E y Hy v1 Hv1.
          assume Hv1a: SNo v1.
          assume Hv1b: SNoLev v1 :e SNoLev y.
          assume Hv1c: y < v1.
          apply Luvimp u0 (SNoL_SNoS x Hx u0 Hu0) v0 (SNoL_SNoS x Hx v0 Hv0)
                       u1 (SNoL_SNoS y Hy u1 Hu1) v1 (SNoR_SNoS y Hy v1 Hv1).
          assume Lu0y Lxu1 Lu0u1 Lv0y Lxv1 Lv0v1 Lu0v1 Lv0u1 Luv.
          apply Luv Hue Hve.
          prove u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          claim Lu1v1lt: u1 < v1.
          { exact SNoLt_tra u1 y v1 Hu1a Hy Hv1a Hu1c Hv1c. }
          claim L3: forall z :e SNoL x, x * u1 + z * v1 < z * u1 + x * v1.
          { let z. assume Hz.
            claim Lzu1: SNo (z * u1).
            { exact LLx z Hz u1 Hu1a. }
            claim Lzv1: SNo (z * v1).
            { exact LLx z Hz v1 Hv1a. }
            apply SNoLt_SNoL_or_SNoR_impred u1 v1 Hu1a Hv1a Lu1v1lt.
            - let w.
              assume Hwv1: w :e SNoL v1.
              assume Hwu1: w :e SNoR u1.
              apply SNoR_E u1 Hu1a w Hwu1.
              assume Hwu1a: SNo w.
              assume Hwu1b: SNoLev w :e SNoLev u1.
              assume Hwu1c: u1 < w.
              claim LwSy: w :e SNoS_ (SNoLev y).
              { apply SNoS_I2 w y Hwu1a Hy.
                prove SNoLev w :e SNoLev y.
                exact ordinal_TransSet (SNoLev y) (SNoLev_ordinal y Hy) (SNoLev u1) Hu1b (SNoLev w) Hwu1b.
              }
              claim Lzw: SNo (z * w).
              { exact LLx z Hz w Hwu1a. }
              claim Lxw: SNo (x * w).
              { apply IHy w LwSy. assume H1 _ _ _ _. exact H1. }
              claim L3a: z * v1 + x * w < x * v1 + z * w.
              { apply IHy v1 (SNoR_SNoS y Hy v1 Hv1).
                assume _ IHy1 _ _ _.
                exact IHy1 z Hz w Hwv1.
              }
              claim L3b: x * u1 + z * w < z * u1 + x * w.
              { apply IHy u1 (SNoL_SNoS y Hy u1 Hu1).
                assume _ _ _ IHy3 _.
                exact IHy3 z Hz w Hwu1.
              }
              exact add_SNo_Lt_subprop2 (x * u1) (z * v1) (z * u1) (x * v1) (z * w) (x * w)
                       Lxu1 Lzv1 Lzu1 Lxv1 Lzw Lxw
                       L3b L3a.
            - assume Hu1v1: u1 :e SNoL v1.
              apply IHy v1 (SNoR_SNoS y Hy v1 Hv1).
              assume _ IHy1 _ _ _.
              rewrite add_SNo_com (x * u1) (z * v1) Lxu1 Lzv1.
              rewrite add_SNo_com (z * u1) (x * v1) Lzu1 Lxv1.
              prove z * v1 + x * u1 < x * v1 + z * u1.
              exact IHy1 z Hz u1 Hu1v1.
            - assume Hv1u1: v1 :e SNoR u1.
              apply IHy u1 (SNoL_SNoS y Hy u1 Hu1).
              assume _ _ _ IHy3 _.
              exact IHy3 z Hz v1 Hv1u1.
          }
          claim L3u0: x * u1 + u0 * v1 < u0 * u1 + x * v1.
          { exact L3 u0 Hu0. }
          claim L3v0: x * u1 + v0 * v1 < v0 * u1 + x * v1.
          { exact L3 v0 Hv0. }
          claim L3u0imp: u0 * y + v0 * v1 < v0 * y + u0 * v1 -> u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          { assume H1.
            apply add_SNo_Lt_subprop3a (u0 * y) (x * u1) (v0 * v1) (v0 * y) (x * v1 + u0 * u1) (u0 * v1)
                            Lu0y Lxu1 Lv0v1 Lv0y
                            (SNo_add_SNo (x * v1) (u0 * u1) Lxv1 Lu0u1)
                            Lu0v1 H1.
            prove x * u1 + u0 * v1 < x * v1 + u0 * u1.
            rewrite add_SNo_com (x * v1) (u0 * u1) Lxv1 Lu0u1.
            exact L3u0.
          }
          claim L3v0imp: u0 * y + v0 * u1 < v0 * y + u0 * u1 -> u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          { assume H1.
            apply add_SNo_Lt_subprop3b (u0 * y) (x * u1 + v0 * v1) (v0 * y) (x * v1) (u0 * u1) (v0 * u1)
                            Lu0y
                            (SNo_add_SNo (x * u1) (v0 * v1) Lxu1 Lv0v1)
                            Lv0y Lxv1 Lu0u1 Lv0u1.
            - prove u0 * y + v0 * u1 < v0 * y + u0 * u1. exact H1.
            - prove x * u1 + v0 * v1 < v0 * u1 + x * v1. exact L3v0.
          }
          apply SNoL_or_SNoR_impred v0 u0 Hv0a Hu0a.
          - assume Hv0u0: v0 = u0. rewrite Hv0u0.
            prove u0 * y + (x * u1 + u0 * v1) < u0 * y + (x * v1 + u0 * u1).
            apply add_SNo_Lt2 (u0 * y) (x * u1 + u0 * v1) (x * v1 + u0 * u1)
                              Lu0y
                              (SNo_add_SNo (x * u1) (u0 * v1) Lxu1 Lu0v1)
                              (SNo_add_SNo (x * v1) (u0 * u1) Lxv1 Lu0u1).
            prove x * u1 + u0 * v1 < x * v1 + u0 * u1.
            rewrite add_SNo_com (x * v1) (u0 * u1) Lxv1 Lu0u1.
            exact L3u0.
          - let z.
            assume Hzu0: z :e SNoL u0.
            assume Hzv0: z :e SNoR v0.
            claim L4: u0 * y + z * v1 < z * y + u0 * v1.
            { apply IHx u0 (SNoL_SNoS x Hx u0 Hu0) y Hy.
              assume _ _ _ IHx3 _.
              exact IHx3 z Hzu0 v1 Hv1.
            }
            claim L5: z * y + v0 * v1 < v0 * y + z * v1.
            { apply IHx v0 (SNoL_SNoS x Hx v0 Hv0) y Hy.
              assume _ _ IHx2 _ _.
              exact IHx2 z Hzv0 v1 Hv1.
            }
            claim Lz: z :e SNoL x.
            { apply SNoL_E u0 Hu0a z Hzu0.
              assume Hza: SNo z.
              assume Hzb: SNoLev z :e SNoLev u0.
              assume Hzc: z < u0.
              apply SNoL_I x Hx z Hza.
              - prove SNoLev z :e SNoLev x.
                exact ordinal_TransSet (SNoLev x) (SNoLev_ordinal x Hx) (SNoLev u0) Hu0b (SNoLev z) Hzb.
              - prove z < x. exact SNoLt_tra z u0 x Hza Hu0a Hx Hzc Hu0c.
            }
            apply add_SNo_Lt_subprop3c (u0 * y) (x * u1) (v0 * v1) (v0 * y) (x * v1 + u0 * u1) (z * v1) (z * y) (u0 * v1)
                                       Lu0y Lxu1 Lv0v1 Lv0y
                                       (SNo_add_SNo (x * v1) (u0 * u1) Lxv1 Lu0u1)
                                       (LLx z Lz v1 Hv1a) (LLxy z Lz)
                                       Lu0v1.
            + exact L4.
            + rewrite add_SNo_com (x * v1) (u0 * u1) Lxv1 Lu0u1. exact L3u0.
            + exact L5.
          - assume Hv0u0: v0 :e SNoL u0. apply L3u0imp.
            prove u0 * y + v0 * v1 < v0 * y + u0 * v1.
            apply IHx u0 (SNoL_SNoS x Hx u0 Hu0) y Hy.
            assume _ _ _ IHx3 _.
            exact IHx3 v0 Hv0u0 v1 Hv1.
          - assume Hu0v0: u0 :e SNoR v0. apply L3u0imp.
            prove u0 * y + v0 * v1 < v0 * y + u0 * v1.
            apply IHx v0 (SNoL_SNoS x Hx v0 Hv0) y Hy.
            assume _ _ IHx2 _ _.
            exact IHx2 u0 Hu0v0 v1 Hv1.
          - let z.
            assume Hzu0: z :e SNoR u0.
            assume Hzv0: z :e SNoL v0.
            claim L6: z * y + v0 * u1 < v0 * y + z * u1.
            { apply IHx v0 (SNoL_SNoS x Hx v0 Hv0) y Hy.
              assume _ IHx1 _ _ _.
              exact IHx1 z Hzv0 u1 Hu1.
            }
            claim L7: u0 * y + z * u1 < z * y + u0 * u1.
            { apply IHx u0 (SNoL_SNoS x Hx u0 Hu0) y Hy.
              assume _ _ _ _ IHx4.
              exact IHx4 z Hzu0 u1 Hu1.
            }
            claim Lz: z :e SNoL x.
            { apply SNoL_E v0 Hv0a z Hzv0.
              assume Hza: SNo z.
              assume Hzb: SNoLev z :e SNoLev v0.
              assume Hzc: z < v0.
              apply SNoL_I x Hx z Hza.
              - prove SNoLev z :e SNoLev x.
                exact ordinal_TransSet (SNoLev x) (SNoLev_ordinal x Hx) (SNoLev v0) Hv0b (SNoLev z) Hzb.
              - prove z < x. exact SNoLt_tra z v0 x Hza Hv0a Hx Hzc Hv0c.
            }
            exact add_SNo_Lt_subprop3d (u0 * y) (x * u1 + v0 * v1) (v0 * y) (x * v1) (u0 * u1) (z * u1) (z * y) (v0 * u1)
                       Lu0y (SNo_add_SNo (x * u1) (v0 * v1) Lxu1 Lv0v1) Lv0y Lxv1 Lu0u1
                       (LLx z Lz u1 Hu1a) (LLxy z Lz)
                       Lv0u1
                       L7 L3v0 L6.
          - assume Hv0u0: v0 :e SNoR u0. apply L3v0imp.
            prove u0 * y + v0 * u1 < v0 * y + u0 * u1.
            apply IHx u0 (SNoL_SNoS x Hx u0 Hu0) y Hy.
            assume _ _ _ _ IHx4.
            exact IHx4 v0 Hv0u0 u1 Hu1.
          - assume Hu0v0: u0 :e SNoL v0. apply L3v0imp.
            prove u0 * y + v0 * u1 < v0 * y + u0 * u1.
            apply IHx v0 (SNoL_SNoS x Hx v0 Hv0) y Hy.
            assume _ IHx1 _ _ _.
            exact IHx1 u0 Hu0v0 u1 Hu1.
        }
      * { let v0. assume Hv0. let v1. assume Hv1 Hve.
          apply SNoR_E x Hx v0 Hv0.
          assume Hv0a: SNo v0.
          assume Hv0b: SNoLev v0 :e SNoLev x.
          assume Hv0c: x < v0.
          apply SNoL_E y Hy v1 Hv1.
          assume Hv1a: SNo v1.
          assume Hv1b: SNoLev v1 :e SNoLev y.
          assume Hv1c: v1 < y.
          apply Luvimp u0 (SNoL_SNoS x Hx u0 Hu0) v0 (SNoR_SNoS x Hx v0 Hv0)
                       u1 (SNoL_SNoS y Hy u1 Hu1) v1 (SNoL_SNoS y Hy v1 Hv1).
          assume Lu0y Lxu1 Lu0u1 Lv0y Lxv1 Lv0v1 Lu0v1 Lv0u1 Luv.
          apply Luv Hue Hve.
          prove u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          claim Lu0v0lt: u0 < v0.
          { exact SNoLt_tra u0 x v0 Hu0a Hx Hv0a Hu0c Hv0c. }
          claim L3: forall z :e SNoL y, u0 * y + v0 * z < v0 * y + u0 * z.
          { let z. assume Hz.
            apply SNoL_E y Hy z Hz.
            assume Hza: SNo z.
            assume Hzb: SNoLev z :e SNoLev y.
            assume Hzc: z < y.
            claim Lu0z: SNo (u0 * z).
            { exact LLx u0 Hu0 z Hza. }
            claim Lv0z: SNo (v0 * z).
            { exact LRx v0 Hv0 z Hza. }
            apply SNoLt_SNoL_or_SNoR_impred u0 v0 Hu0a Hv0a Lu0v0lt.
            - let w.
              assume Hwv0: w :e SNoL v0.
              assume Hwu0: w :e SNoR u0.
              apply SNoR_E u0 Hu0a w Hwu0.
              assume Hwu0a: SNo w.
              assume Hwu0b: SNoLev w :e SNoLev u0.
              assume Hwu0c: u0 < w.
              claim LLevwLevx: SNoLev w :e SNoLev x.
              { exact ordinal_TransSet (SNoLev x) (SNoLev_ordinal x Hx) (SNoLev u0) Hu0b (SNoLev w) Hwu0b. }
              claim LwSx: w :e SNoS_ (SNoLev x).
              { exact SNoS_I2 w x Hwu0a Hx LLevwLevx. }
              claim Lwz: SNo (w * z).
              { apply IHx w LwSx z Hza. assume H _ _ _ _. exact H. }
              claim Lwy: SNo (w * y).
              { apply IHx w LwSx y Hy. assume H _ _ _ _. exact H. }
              claim L3a: u0 * y + w * z < u0 * z + w * y.
              { rewrite add_SNo_com (u0 * z) (w * y) Lu0z Lwy.
                apply IHx u0 (SNoL_SNoS x Hx u0 Hu0) y Hy.
                assume _ _ _ _ IHx4.
                exact IHx4 w Hwu0 z Hz.
              }
              claim L3b: v0 * z + w * y < v0 * y + w * z.
              { rewrite add_SNo_com (v0 * z) (w * y) Lv0z Lwy.
                apply IHx v0 (SNoR_SNoS x Hx v0 Hv0) y Hy.
                assume _ IHx1 _ _ _.
                exact IHx1 w Hwv0 z Hz.
              }
              rewrite <- add_SNo_com (u0 * z) (v0 * y) Lu0z Lv0y.
              exact add_SNo_Lt_subprop2 (u0 * y) (v0 * z) (u0 * z) (v0 * y) (w * z) (w * y)
                       Lu0y Lv0z Lu0z Lv0y Lwz Lwy
                       L3a L3b.
            - assume Hu0v0: u0 :e SNoL v0.
              apply IHx v0 (SNoR_SNoS x Hx v0 Hv0) y Hy.
              assume _ IHx1 _ _ _.
              exact IHx1 u0 Hu0v0 z Hz.
            - assume Hv0u0: v0 :e SNoR u0.
              apply IHx u0 (SNoL_SNoS x Hx u0 Hu0) y Hy.
              assume _ _ _ _ IHx4.
              exact IHx4 v0 Hv0u0 z Hz.
          }
          claim L3u1: u0 * y + v0 * u1 < v0 * y + u0 * u1.
          { exact L3 u1 Hu1. }
          claim L3v1: u0 * y + v0 * v1 < v0 * y + u0 * v1.
          { exact L3 v1 Hv1. }
          claim L3u1imp: x * u1 + v0 * v1 < v0 * u1 + x * v1 -> u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          { exact add_SNo_Lt_subprop3b (u0 * y) (x * u1 + v0 * v1) (v0 * y) (x * v1) (u0 * u1) (v0 * u1)
                            Lu0y (SNo_add_SNo (x * u1) (v0 * v1) Lxu1 Lv0v1) Lv0y Lxv1 Lu0u1 Lv0u1
                            L3u1.
          }
          claim L3v1imp: x * u1 + u0 * v1 < x * v1 + u0 * u1 -> u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          { exact add_SNo_Lt_subprop3a (u0 * y) (x * u1) (v0 * v1) (v0 * y) (x * v1 + u0 * u1) (u0 * v1)
                            Lu0y Lxu1 Lv0v1 Lv0y (SNo_add_SNo (x * v1) (u0 * u1) Lxv1 Lu0u1) Lu0v1 L3v1.
          }
          apply SNoL_or_SNoR_impred v1 u1 Hv1a Hu1a.
          - assume Hv1u1: v1 = u1. rewrite Hv1u1.
            prove u0 * y + x * u1 + v0 * u1 < v0 * y + x * u1 + u0 * u1.
            rewrite add_SNo_com_3_0_1 (u0 * y) (x * u1) (v0 * u1) Lu0y Lxu1 Lv0u1.
            rewrite add_SNo_com_3_0_1 (v0 * y) (x * u1) (u0 * u1) Lv0y Lxu1 Lu0u1.
            apply add_SNo_Lt2 (x * u1) (u0 * y + v0 * u1) (v0 * y + u0 * u1) Lxu1 (SNo_add_SNo (u0 * y) (v0 * u1) Lu0y Lv0u1) (SNo_add_SNo (v0 * y) (u0 * u1) Lv0y Lu0u1).
            prove u0 * y + v0 * u1 < v0 * y + u0 * u1.
            exact L3u1.
          - let z.
            assume Hzu1: z :e SNoL u1.
            assume Hzv1: z :e SNoR v1.
            apply SNoL_E u1 Hu1a z Hzu1.
            assume Hza: SNo z.
            assume Hzb: SNoLev z :e SNoLev u1.
            assume Hzc: z < u1.
            claim Lz: z :e SNoL y.
            { apply SNoL_I y Hy z Hza.
              - prove SNoLev z :e SNoLev y.
                exact ordinal_TransSet (SNoLev y) (SNoLev_ordinal y Hy) (SNoLev u1) Hu1b (SNoLev z) Hzb.
              - prove z < y. exact SNoLt_tra z u1 y Hza Hu1a Hy Hzc Hu1c.
            }
            claim L4: x * u1 + v0 * z < x * z + v0 * u1.
            { rewrite add_SNo_com (x * z) (v0 * u1) (LxLy z Lz) Lv0u1.
              prove x * u1 + v0 * z < v0 * u1 + x * z.
              apply IHy u1 (SNoL_SNoS y Hy u1 Hu1).
              assume _ _ _ _ IHy4.
              exact IHy4 v0 Hv0 z Hzu1.
            }
            claim L5: x * z + v0 * v1 < x * v1 + v0 * z.
            { rewrite add_SNo_com (x * z) (v0 * v1) (LxLy z Lz) Lv0v1.
              apply IHy v1 (SNoL_SNoS y Hy v1 Hv1).
              assume _ _ IHy2 _ _.
              exact IHy2 v0 Hv0 z Hzv1.
            }
            prove u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
            rewrite add_SNo_com_3_0_1 (u0 * y) (x * u1) (v0 * v1) Lu0y Lxu1 Lv0v1.
            rewrite add_SNo_com_3_0_1 (v0 * y) (x * v1) (u0 * u1) Lv0y Lxv1 Lu0u1.
            prove x * u1 + u0 * y + v0 * v1 < x * v1 + v0 * y + u0 * u1.
            exact add_SNo_Lt_subprop3c (x * u1) (u0 * y) (v0 * v1) (x * v1) (v0 * y + u0 * u1) (v0 * z) (x * z) (v0 * u1)
                                       Lxu1 Lu0y Lv0v1 Lxv1
                                       (SNo_add_SNo (v0 * y) (u0 * u1) Lv0y Lu0u1)
                                       (LRx v0 Hv0 z Hza)
                                       (LxLy z Lz)
                                       Lv0u1
                                       L4 L3u1 L5.
          - assume Hv1u1: v1 :e SNoL u1. apply L3u1imp.
            prove x * u1 + v0 * v1 < v0 * u1 + x * v1.
            apply IHy u1 (SNoL_SNoS y Hy u1 Hu1).
            assume _ _ _ _ IHy4.
            exact IHy4 v0 Hv0 v1 Hv1u1.
          - assume Hu1v1: u1 :e SNoR v1. apply L3u1imp.
            prove x * u1 + v0 * v1 < v0 * u1 + x * v1.
            rewrite add_SNo_com (x * u1) (v0 * v1) Lxu1 Lv0v1.
            rewrite add_SNo_com (v0 * u1) (x * v1) Lv0u1 Lxv1.
            apply IHy v1 (SNoL_SNoS y Hy v1 Hv1).
            assume _ _ IHy2 _ _.
            exact IHy2 v0 Hv0 u1 Hu1v1.
          - let z.
            assume Hzu1: z :e SNoR u1.
            assume Hzv1: z :e SNoL v1.
            apply SNoL_E v1 Hv1a z Hzv1.
            assume Hza: SNo z.
            assume Hzb: SNoLev z :e SNoLev v1.
            assume Hzc: z < v1.
            claim Lz: z :e SNoL y.
            { apply SNoL_I y Hy z Hza.
              - prove SNoLev z :e SNoLev y.
                exact ordinal_TransSet (SNoLev y) (SNoLev_ordinal y Hy) (SNoLev v1) Hv1b (SNoLev z) Hzb.
              - prove z < y. exact SNoLt_tra z v1 y Hza Hv1a Hy Hzc Hv1c.
            }
            claim L6: x * u1 + u0 * z < x * z + u0 * u1.
            { rewrite add_SNo_com (x * z) (u0 * u1) (LxLy z Lz) Lu0u1.
              apply IHy u1 (SNoL_SNoS y Hy u1 Hu1).
              assume _ _ _ IHy3 _.
              exact IHy3 u0 Hu0 z Hzu1.
            }
            claim L7: x * z + u0 * v1 < x * v1 + u0 * z.
            { rewrite add_SNo_com (x * z) (u0 * v1) (LxLy z Lz) Lu0v1.
              apply IHy v1 (SNoL_SNoS y Hy v1 Hv1).
              assume _ IHy1 _ _ _.
              exact IHy1 u0 Hu0 z Hzv1.
            }
            prove u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
            rewrite add_SNo_com_3_0_1 (u0 * y) (x * u1) (v0 * v1) Lu0y Lxu1 Lv0v1.
            rewrite add_SNo_com_3_0_1 (v0 * y) (x * v1) (u0 * u1) Lv0y Lxv1 Lu0u1.
            prove x * u1 + u0 * y + v0 * v1 < x * v1 + v0 * y + u0 * u1.
            apply add_SNo_Lt_subprop3d (x * u1) (u0 * y + v0 * v1) (x * v1) (v0 * y) (u0 * u1) (u0 * z) (x * z) (u0 * v1)
                       Lxu1 (SNo_add_SNo (u0 * y) (v0 * v1) Lu0y Lv0v1)
                       Lxv1 Lv0y Lu0u1
                       (LLx u0 Hu0 z Hza) (LxLy z Lz) Lu0v1 L6.
            + prove u0 * y + v0 * v1 < u0 * v1 + v0 * y.
              rewrite add_SNo_com (u0 * v1) (v0 * y) Lu0v1 Lv0y.
              exact L3v1.
            + exact L7.
          - assume Hv1u1: v1 :e SNoR u1. apply L3v1imp.
            prove x * u1 + u0 * v1 < x * v1 + u0 * u1.
            rewrite add_SNo_com (x * v1) (u0 * u1) Lxv1 Lu0u1.
            apply IHy u1 (SNoL_SNoS y Hy u1 Hu1).
            assume _ _ _ IHy3 _.
            exact IHy3 u0 Hu0 v1 Hv1u1.
          - assume Hu1v1: u1 :e SNoL v1. apply L3v1imp.
            prove x * u1 + u0 * v1 < x * v1 + u0 * u1.
            rewrite add_SNo_com (x * u1) (u0 * v1) Lxu1 Lu0v1.
            apply IHy v1 (SNoL_SNoS y Hy v1 Hv1).
            assume _ IHy1 _ _ _.
            exact IHy1 u0 Hu0 u1 Hu1v1.
        }
    + let u0. assume Hu0. let u1. assume Hu1 Hue.
      apply SNoR_E x Hx u0 Hu0.
      assume Hu0a: SNo u0.
      assume Hu0b: SNoLev u0 :e SNoLev x.
      assume Hu0c: x < u0.
      apply SNoR_E y Hy u1 Hu1.
      assume Hu1a: SNo u1.
      assume Hu1b: SNoLev u1 :e SNoLev y.
      assume Hu1c: y < u1.
      apply HRE v Hv.
      * { let v0. assume Hv0. let v1. assume Hv1 Hve.
          apply SNoL_E x Hx v0 Hv0.
          assume Hv0a: SNo v0.
          assume Hv0b: SNoLev v0 :e SNoLev x.
          assume Hv0c: v0 < x.
          apply SNoR_E y Hy v1 Hv1.
          assume Hv1a: SNo v1.
          assume Hv1b: SNoLev v1 :e SNoLev y.
          assume Hv1c: y < v1.
          apply Luvimp u0 (SNoR_SNoS x Hx u0 Hu0) v0 (SNoL_SNoS x Hx v0 Hv0)
                       u1 (SNoR_SNoS y Hy u1 Hu1) v1 (SNoR_SNoS y Hy v1 Hv1).
          assume Lu0y Lxu1 Lu0u1 Lv0y Lxv1 Lv0v1 Lu0v1 Lv0u1 Luv.
          apply Luv Hue Hve.
          prove u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          claim Lv0u0lt: v0 < u0.
          { exact SNoLt_tra v0 x u0 Hv0a Hx Hu0a Hv0c Hu0c. }
          claim L3: forall z :e SNoR y, u0 * y + v0 * z < v0 * y + u0 * z.
          { let z. assume Hz.
            apply SNoR_E y Hy z Hz.
            assume Hza: SNo z.
            assume Hzb: SNoLev z :e SNoLev y.
            assume Hzc: y < z.
            claim Lu0z: SNo (u0 * z).
            { exact LRx u0 Hu0 z Hza. }
            claim Lv0z: SNo (v0 * z).
            { exact LLx v0 Hv0 z Hza. }
            apply SNoLt_SNoL_or_SNoR_impred v0 u0 Hv0a Hu0a Lv0u0lt.
            - let w.
              assume Hwu0: w :e SNoL u0.
              assume Hwv0: w :e SNoR v0.
              apply SNoL_E u0 Hu0a w Hwu0.
              assume Hwu0a: SNo w.
              assume Hwu0b: SNoLev w :e SNoLev u0.
              assume Hwu0c: w < u0.
              claim LLevwLevx: SNoLev w :e SNoLev x.
              { exact ordinal_TransSet (SNoLev x) (SNoLev_ordinal x Hx) (SNoLev u0) Hu0b (SNoLev w) Hwu0b. }
              claim LwSx: w :e SNoS_ (SNoLev x).
              { exact SNoS_I2 w x Hwu0a Hx LLevwLevx. }
              claim Lwz: SNo (w * z).
              { apply IHx w LwSx z Hza. assume H _ _ _ _. exact H. }
              claim Lwy: SNo (w * y).
              { apply IHx w LwSx y Hy. assume H _ _ _ _. exact H. }
              claim L3a: u0 * y + w * z < u0 * z + w * y.
              { rewrite add_SNo_com (u0 * z) (w * y) Lu0z Lwy.
                apply IHx u0 (SNoR_SNoS x Hx u0 Hu0) y Hy.
                assume _ _ _ IHx3 _.
                exact IHx3 w Hwu0 z Hz.
              }
              claim L3b: v0 * z + w * y < v0 * y + w * z.
              { rewrite add_SNo_com (v0 * z) (w * y) Lv0z Lwy.
                apply IHx v0 (SNoL_SNoS x Hx v0 Hv0) y Hy.
                assume _ _ IHx2 _ _.
                exact IHx2 w Hwv0 z Hz.
              }
              rewrite add_SNo_com (v0 * y) (u0 * z) Lv0y Lu0z.
              exact add_SNo_Lt_subprop2 (u0 * y) (v0 * z) (u0 * z) (v0 * y) (w * z) (w * y)
                       Lu0y Lv0z Lu0z Lv0y Lwz Lwy
                       L3a L3b.
            - assume Hv0u0: v0 :e SNoL u0.
              apply IHx u0 (SNoR_SNoS x Hx u0 Hu0) y Hy.
              assume _ _ _ IHx3 _.
              exact IHx3 v0 Hv0u0 z Hz.
            - assume Hu0v0: u0 :e SNoR v0.
              apply IHx v0 (SNoL_SNoS x Hx v0 Hv0) y Hy.
              assume _ _ IHx2 _ _.
              exact IHx2 u0 Hu0v0 z Hz.
          }
          claim L3u1: u0 * y + v0 * u1 < v0 * y + u0 * u1.
          { exact L3 u1 Hu1. }
          claim L3v1: u0 * y + v0 * v1 < v0 * y + u0 * v1.
          { exact L3 v1 Hv1. }
          claim L3u1imp: x * u1 + v0 * v1 < v0 * u1 + x * v1 -> u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          { exact add_SNo_Lt_subprop3b (u0 * y) (x * u1 + v0 * v1) (v0 * y) (x * v1) (u0 * u1) (v0 * u1)
                            Lu0y (SNo_add_SNo (x * u1) (v0 * v1) Lxu1 Lv0v1) Lv0y Lxv1 Lu0u1 Lv0u1
                            L3u1.
          }
          claim L3v1imp: x * u1 + u0 * v1 < x * v1 + u0 * u1 -> u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          { exact add_SNo_Lt_subprop3a (u0 * y) (x * u1) (v0 * v1) (v0 * y) (x * v1 + u0 * u1) (u0 * v1)
                            Lu0y Lxu1 Lv0v1 Lv0y (SNo_add_SNo (x * v1) (u0 * u1) Lxv1 Lu0u1) Lu0v1 L3v1.
          }
          apply SNoL_or_SNoR_impred v1 u1 Hv1a Hu1a.
          - assume Hv1u1: v1 = u1. rewrite Hv1u1.
            prove u0 * y + x * u1 + v0 * u1 < v0 * y + x * u1 + u0 * u1.
            rewrite add_SNo_com_3_0_1 (u0 * y) (x * u1) (v0 * u1) Lu0y Lxu1 Lv0u1.
            rewrite add_SNo_com_3_0_1 (v0 * y) (x * u1) (u0 * u1) Lv0y Lxu1 Lu0u1.
            apply add_SNo_Lt2 (x * u1) (u0 * y + v0 * u1) (v0 * y + u0 * u1) Lxu1 (SNo_add_SNo (u0 * y) (v0 * u1) Lu0y Lv0u1) (SNo_add_SNo (v0 * y) (u0 * u1) Lv0y Lu0u1).
            prove u0 * y + v0 * u1 < v0 * y + u0 * u1.
            exact L3u1.
          - let z.
            assume Hzu1: z :e SNoL u1.
            assume Hzv1: z :e SNoR v1.
            apply SNoR_E v1 Hv1a z Hzv1.
            assume Hza: SNo z.
            assume Hzb: SNoLev z :e SNoLev v1.
            assume Hzc: v1 < z.
            claim Lz: z :e SNoR y.
            { apply SNoR_I y Hy z Hza.
              - prove SNoLev z :e SNoLev y.
                exact ordinal_TransSet (SNoLev y) (SNoLev_ordinal y Hy) (SNoLev v1) Hv1b (SNoLev z) Hzb.
              - prove y < z. exact SNoLt_tra y v1 z Hy Hv1a Hza Hv1c Hzc.
            }
            claim L4: x * u1 + u0 * z < x * z + u0 * u1.
            { rewrite add_SNo_com (x * z) (u0 * u1) (LxRy z Lz) Lu0u1.
              apply IHy u1 (SNoR_SNoS y Hy u1 Hu1).
              assume _ _ _ _ IHy4.
              exact IHy4 u0 Hu0 z Hzu1.
            }
            claim L5: x * z + u0 * v1 < x * v1 + u0 * z.
            { rewrite add_SNo_com (x * z) (u0 * v1) (LxRy z Lz) Lu0v1.
              apply IHy v1 (SNoR_SNoS y Hy v1 Hv1).
              assume _ _ IHy2 _ _.
              exact IHy2 u0 Hu0 z Hzv1.
            }
            prove u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
            rewrite add_SNo_com_3_0_1 (u0 * y) (x * u1) (v0 * v1) Lu0y Lxu1 Lv0v1.
            rewrite add_SNo_com_3_0_1 (v0 * y) (x * v1) (u0 * u1) Lv0y Lxv1 Lu0u1.
            prove x * u1 + u0 * y + v0 * v1 < x * v1 + v0 * y + u0 * u1.
            apply add_SNo_Lt_subprop3d (x * u1) (u0 * y + v0 * v1) (x * v1) (v0 * y) (u0 * u1) (u0 * z) (x * z) (u0 * v1)
                                       Lxu1 
                                       (SNo_add_SNo (u0 * y) (v0 * v1) Lu0y Lv0v1)
                                       Lxv1 Lv0y Lu0u1
                                       (LRx u0 Hu0 z Hza)
                                       (LxRy z Lz)
                                       Lu0v1
                                       L4.
            + prove u0 * y + v0 * v1 < u0 * v1 + v0 * y.
              rewrite add_SNo_com (u0 * v1) (v0 * y) Lu0v1 Lv0y.
              exact L3v1.
            + exact L5.
          - assume Hv1u1: v1 :e SNoL u1. apply L3v1imp.
            prove x * u1 + u0 * v1 < x * v1 + u0 * u1.
            rewrite add_SNo_com (x * v1) (u0 * u1) Lxv1 Lu0u1.
            prove x * u1 + u0 * v1 < u0 * u1 + x * v1.
            apply IHy u1 (SNoR_SNoS y Hy u1 Hu1).
            assume _ _ _ _ IHy4.
            exact IHy4 u0 Hu0 v1 Hv1u1.
          - assume Hu1v1: u1 :e SNoR v1. apply L3v1imp.
            prove x * u1 + u0 * v1 < x * v1 + u0 * u1.
            rewrite add_SNo_com (x * u1) (u0 * v1) Lxu1 Lu0v1.
            apply IHy v1 (SNoR_SNoS y Hy v1 Hv1).
            assume _ _ IHy2 _ _.
            exact IHy2 u0 Hu0 u1 Hu1v1.
          - let z.
            assume Hzu1: z :e SNoR u1.
            assume Hzv1: z :e SNoL v1.
            apply SNoR_E u1 Hu1a z Hzu1.
            assume Hza: SNo z.
            assume Hzb: SNoLev z :e SNoLev u1.
            assume Hzc: u1 < z.
            claim Lz: z :e SNoR y.
            { apply SNoR_I y Hy z Hza.
              - prove SNoLev z :e SNoLev y.
                exact ordinal_TransSet (SNoLev y) (SNoLev_ordinal y Hy) (SNoLev u1) Hu1b (SNoLev z) Hzb.
              - prove y < z. exact SNoLt_tra y u1 z Hy Hu1a Hza Hu1c Hzc.
            }
            claim L6: x * u1 + v0 * z < x * z + v0 * u1.
            { rewrite add_SNo_com (x * z) (v0 * u1) (LxRy z Lz) Lv0u1.
              prove x * u1 + v0 * z < v0 * u1 + x * z.
              apply IHy u1 (SNoR_SNoS y Hy u1 Hu1).
              assume _ _ _ IHy3 _.
              exact IHy3 v0 Hv0 z Hzu1.
            }
            claim L7: x * z + v0 * v1 < x * v1 + v0 * z.
            { rewrite add_SNo_com (x * z) (v0 * v1) (LxRy z Lz) Lv0v1.
              apply IHy v1 (SNoR_SNoS y Hy v1 Hv1).
              assume _ IHy1 _ _ _.
              exact IHy1 v0 Hv0 z Hzv1.
            }
            prove u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
            rewrite add_SNo_com_3_0_1 (u0 * y) (x * u1) (v0 * v1) Lu0y Lxu1 Lv0v1.
            rewrite add_SNo_com_3_0_1 (v0 * y) (x * v1) (u0 * u1) Lv0y Lxv1 Lu0u1.
            prove x * u1 + u0 * y + v0 * v1 < x * v1 + v0 * y + u0 * u1.
            exact add_SNo_Lt_subprop3c (x * u1) (u0 * y) (v0 * v1) (x * v1) (v0 * y + u0 * u1) (v0 * z) (x * z) (v0 * u1)
                       Lxu1 Lu0y Lv0v1
                       Lxv1 (SNo_add_SNo (v0 * y) (u0 * u1) Lv0y Lu0u1)
                       (LLx v0 Hv0 z Hza) (LxRy z Lz) Lv0u1 L6 L3u1 L7.
          - assume Hv1u1: v1 :e SNoR u1. apply L3u1imp.
            prove x * u1 + v0 * v1 < v0 * u1 + x * v1.
            apply IHy u1 (SNoR_SNoS y Hy u1 Hu1).
            assume _ _ _ IHy3 _.
            exact IHy3 v0 Hv0 v1 Hv1u1.
          - assume Hu1v1: u1 :e SNoL v1. apply L3u1imp.
            prove x * u1 + v0 * v1 < v0 * u1 + x * v1.
            rewrite add_SNo_com (x * u1) (v0 * v1) Lxu1 Lv0v1.
            rewrite add_SNo_com (v0 * u1) (x * v1) Lv0u1 Lxv1.
            apply IHy v1 (SNoR_SNoS y Hy v1 Hv1).
            assume _ IHy1 _ _ _.
            exact IHy1 v0 Hv0 u1 Hu1v1.
        }
      * { let v0. assume Hv0. let v1. assume Hv1 Hve.
          apply SNoR_E x Hx v0 Hv0.
          assume Hv0a: SNo v0.
          assume Hv0b: SNoLev v0 :e SNoLev x.
          assume Hv0c: x < v0.
          apply SNoL_E y Hy v1 Hv1.
          assume Hv1a: SNo v1.
          assume Hv1b: SNoLev v1 :e SNoLev y.
          assume Hv1c: v1 < y.
          apply Luvimp u0 (SNoR_SNoS x Hx u0 Hu0) v0 (SNoR_SNoS x Hx v0 Hv0)
                       u1 (SNoR_SNoS y Hy u1 Hu1) v1 (SNoL_SNoS y Hy v1 Hv1).
          assume Lu0y Lxu1 Lu0u1 Lv0y Lxv1 Lv0v1 Lu0v1 Lv0u1 Luv.
          apply Luv Hue Hve.
          prove u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          claim Lv1u1lt: v1 < u1.
          { exact SNoLt_tra v1 y u1 Hv1a Hy Hu1a Hv1c Hu1c. }
          claim L3: forall z :e SNoR x, x * u1 + z * v1 < z * u1 + x * v1.
          { let z. assume Hz.
            claim Lzu1: SNo (z * u1).
            { exact LRx z Hz u1 Hu1a. }
            claim Lzv1: SNo (z * v1).
            { exact LRx z Hz v1 Hv1a. }
            apply SNoLt_SNoL_or_SNoR_impred v1 u1 Hv1a Hu1a Lv1u1lt.
            - let w.
              assume Hwu1: w :e SNoL u1.
              assume Hwv1: w :e SNoR v1.
              apply SNoL_E u1 Hu1a w Hwu1.
              assume Hwu1a: SNo w.
              assume Hwu1b: SNoLev w :e SNoLev u1.
              assume Hwu1c: w < u1.
              claim LwSy: w :e SNoS_ (SNoLev y).
              { apply SNoS_I2 w y Hwu1a Hy.
                prove SNoLev w :e SNoLev y.
                exact ordinal_TransSet (SNoLev y) (SNoLev_ordinal y Hy) (SNoLev u1) Hu1b (SNoLev w) Hwu1b.
              }
              claim Lzw: SNo (z * w).
              { exact LRx z Hz w Hwu1a. }
              claim Lxw: SNo (x * w).
              { apply IHy w LwSy. assume H1 _ _ _ _. exact H1. }
              claim L3a: z * v1 + x * w < x * v1 + z * w.
              { apply IHy v1 (SNoL_SNoS y Hy v1 Hv1).
                assume _ _ IHy2 _ _.
                exact IHy2 z Hz w Hwv1.
              }
              claim L3b: x * u1 + z * w < z * u1 + x * w.
              { apply IHy u1 (SNoR_SNoS y Hy u1 Hu1).
                assume _ _ _ _ IHy4.
                exact IHy4 z Hz w Hwu1.
              }
              exact add_SNo_Lt_subprop2 (x * u1) (z * v1) (z * u1) (x * v1) (z * w) (x * w)
                       Lxu1 Lzv1 Lzu1 Lxv1 Lzw Lxw
                       L3b L3a.
            - assume Hv1u1: v1 :e SNoL u1.
              apply IHy u1 (SNoR_SNoS y Hy u1 Hu1).
              assume _ _ _ _ IHy4.
              exact IHy4 z Hz v1 Hv1u1.
            - assume Hu1v1: u1 :e SNoR v1.
              apply IHy v1 (SNoL_SNoS y Hy v1 Hv1).
              assume _ _ IHy2 _ _.
              rewrite add_SNo_com (x * u1) (z * v1) Lxu1 Lzv1.
              rewrite add_SNo_com (z * u1) (x * v1) Lzu1 Lxv1.
              prove z * v1 + x * u1 < x * v1 + z * u1.
              exact IHy2 z Hz u1 Hu1v1.
          }
          claim L3u0: x * u1 + u0 * v1 < u0 * u1 + x * v1.
          { exact L3 u0 Hu0. }
          claim L3v0: x * u1 + v0 * v1 < v0 * u1 + x * v1.
          { exact L3 v0 Hv0. }
          claim L3u0imp: u0 * y + v0 * v1 < v0 * y + u0 * v1 -> u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          { assume H1.
            apply add_SNo_Lt_subprop3a (u0 * y) (x * u1) (v0 * v1) (v0 * y) (x * v1 + u0 * u1) (u0 * v1)
                            Lu0y Lxu1 Lv0v1 Lv0y
                            (SNo_add_SNo (x * v1) (u0 * u1) Lxv1 Lu0u1)
                            Lu0v1 H1.
            prove x * u1 + u0 * v1 < x * v1 + u0 * u1.
            rewrite add_SNo_com (x * v1) (u0 * u1) Lxv1 Lu0u1.
            exact L3u0.
          }
          claim L3v0imp: u0 * y + v0 * u1 < v0 * y + u0 * u1 -> u0 * y + x * u1 + v0 * v1 < v0 * y + x * v1 + u0 * u1.
          { assume H1.
            apply add_SNo_Lt_subprop3b (u0 * y) (x * u1 + v0 * v1) (v0 * y) (x * v1) (u0 * u1) (v0 * u1)
                            Lu0y
                            (SNo_add_SNo (x * u1) (v0 * v1) Lxu1 Lv0v1)
                            Lv0y Lxv1 Lu0u1 Lv0u1.
            - prove u0 * y + v0 * u1 < v0 * y + u0 * u1. exact H1.
            - prove x * u1 + v0 * v1 < v0 * u1 + x * v1. exact L3v0.
          }
          apply SNoL_or_SNoR_impred v0 u0 Hv0a Hu0a.
          - assume Hv0u0: v0 = u0. rewrite Hv0u0.
            prove u0 * y + (x * u1 + u0 * v1) < u0 * y + (x * v1 + u0 * u1).
            apply add_SNo_Lt2 (u0 * y) (x * u1 + u0 * v1) (x * v1 + u0 * u1)
                              Lu0y
                              (SNo_add_SNo (x * u1) (u0 * v1) Lxu1 Lu0v1)
                              (SNo_add_SNo (x * v1) (u0 * u1) Lxv1 Lu0u1).
            prove x * u1 + u0 * v1 < x * v1 + u0 * u1.
            rewrite add_SNo_com (x * v1) (u0 * u1) Lxv1 Lu0u1.
            exact L3u0.
          - let z.
            assume Hzu0: z :e SNoL u0.
            assume Hzv0: z :e SNoR v0.
            apply SNoR_E v0 Hv0a z Hzv0.
            assume Hza: SNo z.
            assume Hzb: SNoLev z :e SNoLev v0.
            assume Hzc: v0 < z.
            claim Lz: z :e SNoR x.
            { apply SNoR_I x Hx z Hza.
              - prove SNoLev z :e SNoLev x.
                exact ordinal_TransSet (SNoLev x) (SNoLev_ordinal x Hx) (SNoLev v0) Hv0b (SNoLev z) Hzb.
              - prove x < z. exact SNoLt_tra x v0 z Hx Hv0a Hza Hv0c Hzc.
            }
            claim L4: u0 * y + z * u1 < z * y + u0 * u1.
            { apply IHx u0 (SNoR_SNoS x Hx u0 Hu0) y Hy.
              assume _ _ _ IHx3 _.
              exact IHx3 z Hzu0 u1 Hu1.
            }
            claim L5: z * y + v0 * u1 < v0 * y + z * u1.
            { apply IHx v0 (SNoR_SNoS x Hx v0 Hv0) y Hy.
              assume _ _ IHx2 _ _.
              exact IHx2 z Hzv0 u1 Hu1.
            }
            exact add_SNo_Lt_subprop3d (u0 * y) (x * u1 + v0 * v1) (v0 * y) (x * v1) (u0 * u1) (z * u1) (z * y) (v0 * u1)
                                       Lu0y
                                       (SNo_add_SNo (x * u1) (v0 * v1) Lxu1 Lv0v1)
                                       Lv0y Lxv1 Lu0u1
                                       (LRx z Lz u1 Hu1a) (LRxy z Lz)
                                       Lv0u1 L4 L3v0 L5.
          - assume Hv0u0: v0 :e SNoL u0. apply L3v0imp.
            prove u0 * y + v0 * u1 < v0 * y + u0 * u1.
            apply IHx u0 (SNoR_SNoS x Hx u0 Hu0) y Hy.
            assume _ _ _ IHx3 _.
            exact IHx3 v0 Hv0u0 u1 Hu1.
          - assume Hu0v0: u0 :e SNoR v0. apply L3v0imp.
            prove u0 * y + v0 * u1 < v0 * y + u0 * u1.
            apply IHx v0 (SNoR_SNoS x Hx v0 Hv0) y Hy.
            assume _ _ IHx2 _ _.
            exact IHx2 u0 Hu0v0 u1 Hu1.
          - let z.
            assume Hzu0: z :e SNoR u0.
            assume Hzv0: z :e SNoL v0.
            apply SNoR_E u0 Hu0a z Hzu0.
            assume Hza: SNo z.
            assume Hzb: SNoLev z :e SNoLev u0.
            assume Hzc: u0 < z.
            claim Lz: z :e SNoR x.
            { apply SNoR_I x Hx z Hza.
              - prove SNoLev z :e SNoLev x.
                exact ordinal_TransSet (SNoLev x) (SNoLev_ordinal x Hx) (SNoLev u0) Hu0b (SNoLev z) Hzb.
              - prove x < z. exact SNoLt_tra x u0 z Hx Hu0a Hza Hu0c Hzc.
            }
            claim L6: u0 * y + z * v1 < z * y + u0 * v1.
            { apply IHx u0 (SNoR_SNoS x Hx u0 Hu0) y Hy.
              assume _ _ _ _ IHx4.
              exact IHx4 z Hzu0 v1 Hv1.
            }
            claim L7: z * y + v0 * v1 < v0 * y + z * v1.
            { apply IHx v0 (SNoR_SNoS x Hx v0 Hv0) y Hy.
              assume _ IHx1 _ _ _.
              exact IHx1 z Hzv0 v1 Hv1.
            }
            apply add_SNo_Lt_subprop3c (u0 * y) (x * u1) (v0 * v1) (v0 * y) (x * v1 + u0 * u1) (z * v1) (z * y) (u0 * v1)
                       Lu0y Lxu1 Lv0v1 Lv0y
                       (SNo_add_SNo (x * v1) (u0 * u1) Lxv1 Lu0u1)
                       (LRx z Lz v1 Hv1a) (LRxy z Lz)
                       Lu0v1 L6.
            + prove x * u1 + u0 * v1 < x * v1 + u0 * u1.
              rewrite add_SNo_com (x * v1) (u0 * u1) Lxv1 Lu0u1.
              exact L3u0.
            + prove z * y + v0 * v1 < v0 * y + z * v1.
              exact L7.
          - assume Hv0u0: v0 :e SNoR u0. apply L3u0imp.
            prove u0 * y + v0 * v1 < v0 * y + u0 * v1.
            apply IHx u0 (SNoR_SNoS x Hx u0 Hu0) y Hy.
            assume _ _ _ _ IHx4.
            exact IHx4 v0 Hv0u0 v1 Hv1.
          - assume Hu0v0: u0 :e SNoL v0. apply L3u0imp.
            prove u0 * y + v0 * v1 < v0 * y + u0 * v1.
            apply IHx v0 (SNoR_SNoS x Hx v0 Hv0) y Hy.
            assume _ IHx1 _ _ _.
            exact IHx1 u0 Hu0v0 v1 Hv1.
        }
}
claim Lxy: SNo (x * y).
{ rewrite Hxy. prove SNo (SNoCut L R). exact SNoCutP_SNo_SNoCut L R LLR1. }
let p. assume Hp. prove p. apply Hp.
- exact Lxy.
- prove forall u :e SNoL x, forall v :e SNoL y, u * y + x * v < x * y + u * v.
  let u. assume Hu. let v. assume Hv.
  apply SNoL_E y Hy v Hv.
  assume Hva _ _.
  prove u * y + x * v < x * y + u * v.
  claim L1: u * y + x * v + - u * v < x * y.
  { rewrite Hxy.
    prove u * y + x * v + - u * v < SNoCut L R.
    apply SNoCutP_SNoCut_L L R LLR1.
    prove u * y + x * v + - u * v :e L.
    exact HLI1 u Hu v Hv.
  }
  apply add_SNo_minus_Lt1 (u * y + x * v) (u * v) (x * y).
  + exact SNo_add_SNo (u * y) (x * v) (LLx u Hu y Hy) (LxLy v Hv).
  + exact LLx u Hu v Hva.
  + exact Lxy.
  + prove (u * y + x * v) + - u * v < x * y.
    rewrite <- add_SNo_assoc (u * y) (x * v) (- (u * v)) (LLx u Hu y Hy) (LxLy v Hv) (SNo_minus_SNo (u * v) (LLx u Hu v Hva)).
    exact L1.
- prove forall u :e SNoR x, forall v :e SNoR y, u * y + x * v < x * y + u * v.
  let u. assume Hu. let v. assume Hv.
  apply SNoR_E y Hy v Hv.
  assume Hva _ _.
  prove u * y + x * v < x * y + u * v.
  claim L1: u * y + x * v + - u * v < x * y.
  { rewrite Hxy.
    prove u * y + x * v + - u * v < SNoCut L R.
    apply SNoCutP_SNoCut_L L R LLR1.
    prove u * y + x * v + - u * v :e L.
    exact HLI2 u Hu v Hv.
  }
  apply add_SNo_minus_Lt1 (u * y + x * v) (u * v) (x * y).
  + exact SNo_add_SNo (u * y) (x * v) (LRx u Hu y Hy) (LxRy v Hv).
  + exact LRx u Hu v Hva.
  + exact Lxy.
  + prove (u * y + x * v) + - u * v < x * y.
    rewrite <- add_SNo_assoc (u * y) (x * v) (- (u * v)) (LRx u Hu y Hy) (LxRy v Hv) (SNo_minus_SNo (u * v) (LRx u Hu v Hva)).
    exact L1.
- prove forall u :e SNoL x, forall v :e SNoR y, x * y + u * v < u * y + x * v.
  let u. assume Hu. let v. assume Hv.
  apply SNoR_E y Hy v Hv.
  assume Hva _ _.
  prove x * y + u * v < u * y + x * v.
  claim L1: x * y < u * y + x * v + - u * v.
  { rewrite Hxy.
    prove SNoCut L R < u * y + x * v + - u * v.
    apply SNoCutP_SNoCut_R L R LLR1.
    prove u * y + x * v + - u * v :e R.
    exact HRI1 u Hu v Hv.
  }
  apply add_SNo_minus_Lt2 (u * y + x * v) (u * v) (x * y).
  + exact SNo_add_SNo (u * y) (x * v) (LLx u Hu y Hy) (LxRy v Hv).
  + exact LLx u Hu v Hva.
  + exact Lxy.
  + prove x * y < (u * y + x * v) + - u * v.
    rewrite <- add_SNo_assoc (u * y) (x * v) (- (u * v)) (LLx u Hu y Hy) (LxRy v Hv) (SNo_minus_SNo (u * v) (LLx u Hu v Hva)).
    exact L1.
- prove forall u :e SNoR x, forall v :e SNoL y, x * y + u * v < u * y + x * v.
  let u. assume Hu. let v. assume Hv.
  apply SNoL_E y Hy v Hv.
  assume Hva _ _.
  prove x * y + u * v < u * y + x * v.
  claim L1: x * y < u * y + x * v + - u * v.
  { rewrite Hxy.
    prove SNoCut L R < u * y + x * v + - u * v.
    apply SNoCutP_SNoCut_R L R LLR1.
    prove u * y + x * v + - u * v :e R.
    exact HRI2 u Hu v Hv.
  }
  apply add_SNo_minus_Lt2 (u * y + x * v) (u * v) (x * y).
  + exact SNo_add_SNo (u * y) (x * v) (LRx u Hu y Hy) (LxLy v Hv).
  + exact LRx u Hu v Hva.
  + exact Lxy.
  + prove x * y < (u * y + x * v) + - u * v.
    rewrite <- add_SNo_assoc (u * y) (x * v) (- (u * v)) (LRx u Hu y Hy) (LxLy v Hv) (SNo_minus_SNo (u * v) (LRx u Hu v Hva)).
    exact L1.
Qed.

Theorem SNo_mul_SNo : forall x y, SNo x -> SNo y -> SNo (x * y).
let x y. assume Hx Hy. apply mul_SNo_prop_1 x Hx y Hy.
assume H _ _ _ _. exact H.
Qed.

Theorem SNo_mul_SNo_lem : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v -> SNo (u * y + x * v + - (u * v)).
let x y u v. assume Hx Hy Hu Hv.
apply SNo_add_SNo_3c.
- apply SNo_mul_SNo.
  + exact Hu.
  + exact Hy.
- apply SNo_mul_SNo.
  + exact Hx.
  + exact Hv.
- apply SNo_mul_SNo.
  + exact Hu.
  + exact Hv.
Qed.

Theorem SNo_mul_SNo_3 : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x * y * z).
let x y z. assume Hx Hy Hz.
apply SNo_mul_SNo.
- exact Hx.
- apply SNo_mul_SNo.
  + exact Hy.
  + exact Hz.
Qed.

Theorem mul_SNo_eq_3 : forall x y, SNo x -> SNo y ->
  forall p:prop,
    (forall L R, SNoCutP L R
       -> (forall u, u :e L ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall w1 :e SNoL y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e SNoR x, forall z1 :e SNoR y, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall w1 :e SNoL y, w0 * y + x * w1 + - w0 * w1 :e L)
      -> (forall z0 :e SNoR x, forall z1 :e SNoR y, z0 * y + x * z1 + - z0 * z1 :e L)
      -> (forall u, u :e R ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall z1 :e SNoR y, u = w0 * y + x * z1 + - w0 * z1 -> q)
             -> (forall z0 :e SNoR x, forall w1 :e SNoL y, u = z0 * y + x * w1 + - z0 * w1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall z1 :e SNoR y, w0 * y + x * z1 + - w0 * z1 :e R)
      -> (forall z0 :e SNoR x, forall w1 :e SNoL y, z0 * y + x * w1 + - z0 * w1 :e R)
      -> x * y = SNoCut L R
      -> p)
   -> p.
let x y. assume Hx Hy. let p. assume Hp.
apply mul_SNo_eq_2 x y Hx Hy.
let L R.
assume HLE HLI1 HLI2 HRE HRI1 HRI2 He.
apply mul_SNo_prop_1 x Hx y Hy.
assume Hxy: SNo (x * y).
assume Hxy1: forall u :e SNoL x, forall v :e SNoL y, u * y + x * v < x * y + u * v.
assume Hxy2: forall u :e SNoR x, forall v :e SNoR y, u * y + x * v < x * y + u * v.
assume Hxy3: forall u :e SNoL x, forall v :e SNoR y, x * y + u * v < u * y + x * v.
assume Hxy4: forall u :e SNoR x, forall v :e SNoL y, x * y + u * v < u * y + x * v.
claim LLR: SNoCutP L R.
{ prove (forall w :e L, SNo w)
     /\ (forall z :e R, SNo z)
     /\ (forall w :e L, forall z :e R, w < z).
  apply and3I.
  - let w. assume Hw. prove SNo w.
    apply HLE w Hw.
    + let u. assume Hu. let v. assume Hv Hwe.
      apply SNoL_E x Hx u Hu.
      assume Hua _ _.
      apply SNoL_E y Hy v Hv.
      assume Hva _ _.
      rewrite Hwe.
      prove SNo (u * y + x * v + - u * v).
      apply SNo_mul_SNo_lem.
      * exact Hx.
      * exact Hy.
      * exact Hua.
      * exact Hva.
    + let u. assume Hu. let v. assume Hv Hwe.
      apply SNoR_E x Hx u Hu.
      assume Hua _ _.
      apply SNoR_E y Hy v Hv.
      assume Hva _ _.
      rewrite Hwe.
      prove SNo (u * y + x * v + - u * v).
      apply SNo_mul_SNo_lem.
      * exact Hx.
      * exact Hy.
      * exact Hua.
      * exact Hva.
  - let z. assume Hz. prove SNo z.
    apply HRE z Hz.
    + let u. assume Hu. let v. assume Hv Hze.
      apply SNoL_E x Hx u Hu.
      assume Hua _ _.
      apply SNoR_E y Hy v Hv.
      assume Hva _ _.
      rewrite Hze.
      prove SNo (u * y + x * v + - u * v).
      apply SNo_mul_SNo_lem.
      * exact Hx.
      * exact Hy.
      * exact Hua.
      * exact Hva.
    + let u. assume Hu. let v. assume Hv Hze.
      apply SNoR_E x Hx u Hu.
      assume Hua _ _.
      apply SNoL_E y Hy v Hv.
      assume Hva _ _.
      rewrite Hze.
      prove SNo (u * y + x * v + - u * v).
      apply SNo_mul_SNo_lem.
      * exact Hx.
      * exact Hy.
      * exact Hua.
      * exact Hva.
  - let w. assume Hw. let z. assume Hz. prove w < z.
    apply HLE w Hw.
    + let u. assume Hu. let v. assume Hv Hwe.
      apply SNoL_E x Hx u Hu.
      assume Hua: SNo u. assume _ _.
      apply SNoL_E y Hy v Hv.
      assume Hva: SNo v. assume _ _.
      claim Luy: SNo (u * y).
      { exact SNo_mul_SNo u y Hua Hy. }
      claim Lxv: SNo (x * v).
      { exact SNo_mul_SNo x v Hx Hva. }
      claim Luv: SNo (u * v).
      { exact SNo_mul_SNo u v Hua Hva. }
      apply HRE z Hz.
      * { let u'. assume Hu'. let v'. assume Hv' Hze.
          apply SNoL_E x Hx u' Hu'.
          assume Hu'a: SNo u'. assume _ _.
          apply SNoR_E y Hy v' Hv'.
          assume Hv'a: SNo v'. assume _ _.
          claim Lu'y: SNo (u' * y).
          { exact SNo_mul_SNo u' y Hu'a Hy. }
          claim Lxv': SNo (x * v').
          { exact SNo_mul_SNo x v' Hx Hv'a. }
          claim Lu'v': SNo (u' * v').
          { exact SNo_mul_SNo u' v' Hu'a Hv'a. }
          rewrite Hwe. rewrite Hze.
          prove u * y + x * v + - u * v < u' * y + x * v' + - u' * v'.
          apply add_SNo_minus_Lt_lem (u * y) (x * v) (u * v) (u' * y) (x * v') (u' * v') Luy Lxv Luv Lu'y Lxv' Lu'v'.
          prove u * y + x * v + u' * v' < u' * y + x * v' + u * v.
          apply SNoLt_tra (u * y + x * v + u' * v')
                          (x * y + u * v + u' * v')
                          (u' * y + x * v' + u * v)
                          (SNo_add_SNo_3 (u * y) (x * v) (u' * v') Luy Lxv Lu'v')
                          (SNo_add_SNo_3 (x * y) (u * v) (u' * v') Hxy Luv Lu'v')
                          (SNo_add_SNo_3 (u' * y) (x * v') (u * v) Lu'y Lxv' Luv).
          - prove u * y + x * v + u' * v' < x * y + u * v + u' * v'.
            apply add_SNo_3_3_3_Lt1 (u * y) (x * v) (x * y) (u * v) (u' * v') Luy Lxv Hxy Luv Lu'v'.
            prove u * y + x * v < x * y + u * v.
            exact Hxy1 u Hu v Hv.
          - prove x * y + u * v + u' * v' < u' * y + x * v' + u * v.
            apply add_SNo_3_2_3_Lt1 (x * y) (u' * v') (u' * y) (x * v') (u * v) Hxy Lu'v' Lu'y Lxv' Luv.
            prove u' * v' + x * y < u' * y + x * v'.
            rewrite add_SNo_com (u' * v') (x * y) Lu'v' Hxy.
            exact Hxy3 u' Hu' v' Hv'.
        }
      * { let u'. assume Hu'. let v'. assume Hv' Hze.
          apply SNoR_E x Hx u' Hu'.
          assume Hu'a: SNo u'. assume _ _.
          apply SNoL_E y Hy v' Hv'.
          assume Hv'a: SNo v'. assume _ _.
          claim Lu'y: SNo (u' * y).
          { exact SNo_mul_SNo u' y Hu'a Hy. }
          claim Lxv': SNo (x * v').
          { exact SNo_mul_SNo x v' Hx Hv'a. }
          claim Lu'v': SNo (u' * v').
          { exact SNo_mul_SNo u' v' Hu'a Hv'a. }
          rewrite Hwe. rewrite Hze.
          prove u * y + x * v + - u * v < u' * y + x * v' + - u' * v'.
          apply add_SNo_minus_Lt_lem (u * y) (x * v) (u * v) (u' * y) (x * v') (u' * v') Luy Lxv Luv Lu'y Lxv' Lu'v'.
          prove u * y + x * v + u' * v' < u' * y + x * v' + u * v.
          apply SNoLt_tra (u * y + x * v + u' * v')
                          (x * y + u * v + u' * v')
                          (u' * y + x * v' + u * v)
                          (SNo_add_SNo_3 (u * y) (x * v) (u' * v') Luy Lxv Lu'v')
                          (SNo_add_SNo_3 (x * y) (u * v) (u' * v') Hxy Luv Lu'v')
                          (SNo_add_SNo_3 (u' * y) (x * v') (u * v) Lu'y Lxv' Luv).
          - prove u * y + x * v + u' * v' < x * y + u * v + u' * v'.
            apply add_SNo_3_3_3_Lt1 (u * y) (x * v) (x * y) (u * v) (u' * v') Luy Lxv Hxy Luv Lu'v'.
            prove u * y + x * v < x * y + u * v.
            exact Hxy1 u Hu v Hv.
          - prove x * y + u * v + u' * v' < u' * y + x * v' + u * v.
            apply add_SNo_3_2_3_Lt1 (x * y) (u' * v') (u' * y) (x * v') (u * v) Hxy Lu'v' Lu'y Lxv' Luv.
            prove u' * v' + x * y < u' * y + x * v'.
            rewrite add_SNo_com (u' * v') (x * y) Lu'v' Hxy.
            exact Hxy4 u' Hu' v' Hv'.
        }
    + let u. assume Hu. let v. assume Hv Hwe.
      apply SNoR_E x Hx u Hu.
      assume Hua: SNo u. assume _ _.
      apply SNoR_E y Hy v Hv.
      assume Hva: SNo v. assume _ _.
      claim Luy: SNo (u * y).
      { exact SNo_mul_SNo u y Hua Hy. }
      claim Lxv: SNo (x * v).
      { exact SNo_mul_SNo x v Hx Hva. }
      claim Luv: SNo (u * v).
      { exact SNo_mul_SNo u v Hua Hva. }
      apply HRE z Hz.
      * { let u'. assume Hu'. let v'. assume Hv' Hze.
          apply SNoL_E x Hx u' Hu'.
          assume Hu'a: SNo u'. assume _ _.
          apply SNoR_E y Hy v' Hv'.
          assume Hv'a: SNo v'. assume _ _.
          claim Lu'y: SNo (u' * y).
          { exact SNo_mul_SNo u' y Hu'a Hy. }
          claim Lxv': SNo (x * v').
          { exact SNo_mul_SNo x v' Hx Hv'a. }
          claim Lu'v': SNo (u' * v').
          { exact SNo_mul_SNo u' v' Hu'a Hv'a. }
          rewrite Hwe. rewrite Hze.
          prove u * y + x * v + - u * v < u' * y + x * v' + - u' * v'.
          apply add_SNo_minus_Lt_lem (u * y) (x * v) (u * v) (u' * y) (x * v') (u' * v') Luy Lxv Luv Lu'y Lxv' Lu'v'.
          prove u * y + x * v + u' * v' < u' * y + x * v' + u * v.
          apply SNoLt_tra (u * y + x * v + u' * v')
                          (x * y + u * v + u' * v')
                          (u' * y + x * v' + u * v)
                          (SNo_add_SNo_3 (u * y) (x * v) (u' * v') Luy Lxv Lu'v')
                          (SNo_add_SNo_3 (x * y) (u * v) (u' * v') Hxy Luv Lu'v')
                          (SNo_add_SNo_3 (u' * y) (x * v') (u * v) Lu'y Lxv' Luv).
          - prove u * y + x * v + u' * v' < x * y + u * v + u' * v'.
            apply add_SNo_3_3_3_Lt1 (u * y) (x * v) (x * y) (u * v) (u' * v') Luy Lxv Hxy Luv Lu'v'.
            prove u * y + x * v < x * y + u * v.
            exact Hxy2 u Hu v Hv.
          - prove x * y + u * v + u' * v' < u' * y + x * v' + u * v.
            apply add_SNo_3_2_3_Lt1 (x * y) (u' * v') (u' * y) (x * v') (u * v) Hxy Lu'v' Lu'y Lxv' Luv.
            prove u' * v' + x * y < u' * y + x * v'.
            rewrite add_SNo_com (u' * v') (x * y) Lu'v' Hxy.
            exact Hxy3 u' Hu' v' Hv'.
        }
      * { let u'. assume Hu'. let v'. assume Hv' Hze.
          apply SNoR_E x Hx u' Hu'.
          assume Hu'a: SNo u'. assume _ _.
          apply SNoL_E y Hy v' Hv'.
          assume Hv'a: SNo v'. assume _ _.
          claim Lu'y: SNo (u' * y).
          { exact SNo_mul_SNo u' y Hu'a Hy. }
          claim Lxv': SNo (x * v').
          { exact SNo_mul_SNo x v' Hx Hv'a. }
          claim Lu'v': SNo (u' * v').
          { exact SNo_mul_SNo u' v' Hu'a Hv'a. }
          rewrite Hwe. rewrite Hze.
          prove u * y + x * v + - u * v < u' * y + x * v' + - u' * v'.
          apply add_SNo_minus_Lt_lem (u * y) (x * v) (u * v) (u' * y) (x * v') (u' * v') Luy Lxv Luv Lu'y Lxv' Lu'v'.
          prove u * y + x * v + u' * v' < u' * y + x * v' + u * v.
          apply SNoLt_tra (u * y + x * v + u' * v')
                          (x * y + u * v + u' * v')
                          (u' * y + x * v' + u * v)
                          (SNo_add_SNo_3 (u * y) (x * v) (u' * v') Luy Lxv Lu'v')
                          (SNo_add_SNo_3 (x * y) (u * v) (u' * v') Hxy Luv Lu'v')
                          (SNo_add_SNo_3 (u' * y) (x * v') (u * v) Lu'y Lxv' Luv).
          - prove u * y + x * v + u' * v' < x * y + u * v + u' * v'.
            apply add_SNo_3_3_3_Lt1 (u * y) (x * v) (x * y) (u * v) (u' * v') Luy Lxv Hxy Luv Lu'v'.
            prove u * y + x * v < x * y + u * v.
            exact Hxy2 u Hu v Hv.
          - prove x * y + u * v + u' * v' < u' * y + x * v' + u * v.
            apply add_SNo_3_2_3_Lt1 (x * y) (u' * v') (u' * y) (x * v') (u * v) Hxy Lu'v' Lu'y Lxv' Luv.
            prove u' * v' + x * y < u' * y + x * v'.
            rewrite add_SNo_com (u' * v') (x * y) Lu'v' Hxy.
            exact Hxy4 u' Hu' v' Hv'.
        }
}
exact Hp L R LLR HLE HLI1 HLI2 HRE HRI1 HRI2 He.
Qed.

Theorem mul_SNo_Lt : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u < x -> v < y -> u * y + x * v < x * y + u * v.
let x y u v. assume Hx Hy Hu Hv Hux Hvy.
apply mul_SNo_prop_1 x Hx y Hy.
assume Hxy: SNo (x * y).
assume Hxy1: forall u :e SNoL x, forall v :e SNoL y, u * y + x * v < x * y + u * v.
assume Hxy2: forall u :e SNoR x, forall v :e SNoR y, u * y + x * v < x * y + u * v.
assume Hxy3: forall u :e SNoL x, forall v :e SNoR y, x * y + u * v < u * y + x * v.
assume Hxy4: forall u :e SNoR x, forall v :e SNoL y, x * y + u * v < u * y + x * v.
apply mul_SNo_prop_1 u Hu y Hy.
assume Huy: SNo (u * y).
assume Huy1: forall x :e SNoL u, forall v :e SNoL y, x * y + u * v < u * y + x * v.
assume Huy2: forall x :e SNoR u, forall v :e SNoR y, x * y + u * v < u * y + x * v.
assume Huy3: forall x :e SNoL u, forall v :e SNoR y, u * y + x * v < x * y + u * v.
assume Huy4: forall x :e SNoR u, forall v :e SNoL y, u * y + x * v < x * y + u * v.
apply mul_SNo_prop_1 x Hx v Hv.
assume Hxv: SNo (x * v).
assume Hxv1: forall u :e SNoL x, forall y :e SNoL v, u * v + x * y < x * v + u * y.
assume Hxv2: forall u :e SNoR x, forall y :e SNoR v, u * v + x * y < x * v + u * y.
assume Hxv3: forall u :e SNoL x, forall y :e SNoR v, x * v + u * y < u * v + x * y.
assume Hxv4: forall u :e SNoR x, forall y :e SNoL v, x * v + u * y < u * v + x * y.
apply mul_SNo_prop_1 u Hu v Hv.
assume Huv: SNo (u * v).
assume Huv1: forall x :e SNoL u, forall y :e SNoL v, x * v + u * y < u * v + x * y.
assume Huv2: forall x :e SNoR u, forall y :e SNoR v, x * v + u * y < u * v + x * y.
assume Huv3: forall x :e SNoL u, forall y :e SNoR v, u * v + x * y < x * v + u * y.
assume Huv4: forall x :e SNoR u, forall y :e SNoL v, u * v + x * y < x * v + u * y.
claim Luyxv: SNo (u * y + x * v).
{ exact SNo_add_SNo (u * y) (x * v) Huy Hxv. }
claim Lxyuv: SNo (x * y + u * v).
{ exact SNo_add_SNo (x * y) (u * v) Hxy Huv. }
apply SNoLtE u x Hu Hx Hux.
- let w.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev u :/\: SNoLev x.
  assume Hw3: SNoEq_ (SNoLev w) w u.
  assume Hw4: SNoEq_ (SNoLev w) w x.
  assume Hw5: u < w.
  assume Hw6: w < x.
  assume Hw7: SNoLev w /:e u.
  assume Hw8: SNoLev w :e x.
  apply binintersectE (SNoLev u) (SNoLev x) (SNoLev w) Hw2.
  assume Hw2a Hw2b.
  claim Lwx: w :e SNoL x.
  { exact SNoL_I x Hx w Hw1 Hw2b Hw6. }
  claim Lwu: w :e SNoR u.
  { exact SNoR_I u Hu w Hw1 Hw2a Hw5. }
  claim Lwy: SNo (w * y).
  { exact SNo_mul_SNo w y Hw1 Hy. }
  claim Lwv: SNo (w * v).
  { exact SNo_mul_SNo w v Hw1 Hv. }
  claim Lwyxv: SNo (w * y + x * v).
  { exact SNo_add_SNo (w * y) (x * v) Lwy Hxv. }
  claim Lwyuv: SNo (w * y + u * v).
  { exact SNo_add_SNo (w * y) (u * v) Lwy Huv. }
  claim Lxywv: SNo (x * y + w * v).
  { exact SNo_add_SNo (x * y) (w * v) Hxy Lwv. }
  claim Luywv: SNo (u * y + w * v).
  { exact SNo_add_SNo (u * y) (w * v) Huy Lwv. }
  claim Luvwy: SNo (u * v + w * y).
  { exact SNo_add_SNo (u * v) (w * y) Huv Lwy. }
  claim Lwvxy: SNo (w * v + x * y).
  { exact SNo_add_SNo (w * v) (x * y) Lwv Hxy. }
  claim Lxvwy: SNo (x * v + w * y).
  { exact SNo_add_SNo (x * v) (w * y) Hxv Lwy. }
  claim Lwvuy: SNo (w * v + u * y).
  { exact SNo_add_SNo (w * v) (u * y) Lwv Huy. }
  apply SNoLtE v y Hv Hy Hvy.
  + let z.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev v :/\: SNoLev y.
    assume Hz3: SNoEq_ (SNoLev z) z v.
    assume Hz4: SNoEq_ (SNoLev z) z y.
    assume Hz5: v < z.
    assume Hz6: z < y.
    assume Hz7: SNoLev z /:e v.
    assume Hz8: SNoLev z :e y.
    apply binintersectE (SNoLev v) (SNoLev y) (SNoLev z) Hz2.
    assume Hz2a Hz2b.
    claim Lzy: z :e SNoL y.
    { exact SNoL_I y Hy z Hz1 Hz2b Hz6. }
    claim Lzv: z :e SNoR v.
    { exact SNoR_I v Hv z Hz1 Hz2a Hz5. }
    claim Lxz: SNo (x * z).
    { exact SNo_mul_SNo x z Hx Hz1. }
    claim Luz: SNo (u * z).
    { exact SNo_mul_SNo u z Hu Hz1. }
    claim Lwz: SNo (w * z).
    { exact SNo_mul_SNo w z Hw1 Hz1. }
    claim L1: w * y + x * z < x * y + w * z.
    { exact Hxy1 w Lwx z Lzy. }
    claim L2: w * v + u * z < u * v + w * z.
    { exact Huv2 w Lwu z Lzv. }
    claim L3: x * v + w * z < w * v + x * z.
    { exact Hxv3 w Lwx z Lzv. }
    claim L4: u * y + w * z < w * y + u * z.
    { exact Huy4 w Lwu z Lzy. }
    claim Lwzwz: SNo (w * z + w * z).
    { exact SNo_add_SNo (w * z) (w * z) Lwz Lwz. }
    apply add_SNo_Lt1_cancel (u * y + x * v) (w * z + w * z) (x * y + u * v) Luyxv Lwzwz Lxyuv.
    prove (u * y + x * v) + (w * z + w * z) < (x * y + u * v) + (w * z + w * z).
    claim Lwyuz: SNo (w * y + u * z).
    { exact SNo_add_SNo (w * y) (u * z) Lwy Luz. }
    claim Lwvxz: SNo (w * v + x * z).
    { exact SNo_add_SNo (w * v) (x * z) Lwv Lxz. }
    claim Luywz: SNo (u * y + w * z).
    { exact SNo_add_SNo (u * y) (w * z) Huy Lwz. }
    claim Lxvwz: SNo (x * v + w * z).
    { exact SNo_add_SNo (x * v) (w * z) Hxv Lwz. }
    claim Lwvuz: SNo (w * v + u * z).
    { exact SNo_add_SNo (w * v) (u * z) Lwv Luz. }
    claim Lxyxz: SNo (x * y + x * z).
    { exact SNo_add_SNo (x * y) (x * z) Hxy Lxz. }
    claim Lwyxz: SNo (w * y + x * z).
    { exact SNo_add_SNo (w * y) (x * z) Lwy Lxz. }
    claim Lxywz: SNo (x * y + w * z).
    { exact SNo_add_SNo (x * y) (w * z) Hxy Lwz. }
    claim Luvwz: SNo (u * v + w * z).
    { exact SNo_add_SNo (u * v) (w * z) Huv Lwz. }
    apply SNoLt_tra ((u * y + x * v) + (w * z + w * z))
                    ((w * y + u * z) + (w * v + x * z))
                    ((x * y + u * v) + (w * z + w * z))
                    (SNo_add_SNo (u * y + x * v) (w * z + w * z) Luyxv Lwzwz)
                    (SNo_add_SNo (w * y + u * z) (w * v + x * z) Lwyuz Lwvxz)
                    (SNo_add_SNo (x * y + u * v) (w * z + w * z) Lxyuv Lwzwz).
    * { prove (u * y + x * v) + (w * z + w * z) < (w * y + u * z) + (w * v + x * z).
        rewrite add_SNo_com_4_inner_mid (u * y) (x * v) (w * z) (w * z) Huy Hxv Lwz Lwz.
        prove (u * y + w * z) + (x * v + w * z) < (w * y + u * z) + (w * v + x * z).
        apply add_SNo_Lt3 (u * y + w * z) (x * v + w * z) (w * y + u * z) (w * v + x * z) Luywz Lxvwz Lwyuz Lwvxz.
        - prove u * y + w * z < w * y + u * z. exact L4.
        - prove x * v + w * z < w * v + x * z. exact L3.
      }
    * { prove (w * y + u * z) + (w * v + x * z) < (x * y + u * v) + (w * z + w * z).
        rewrite add_SNo_com_4_inner_mid (x * y) (u * v) (w * z) (w * z) Hxy Huv Lwz Lwz.
        prove (w * y + u * z) + (w * v + x * z) < (x * y + w * z) + (u * v + w * z).
        rewrite add_SNo_com (w * y) (u * z) Lwy Luz.
        rewrite add_SNo_com_4_inner_mid (u * z) (w * y) (w * v) (x * z) Luz Lwy Lwv Lxz.
        rewrite <- add_SNo_com (w * v) (u * z) Lwv Luz.
        prove (w * v + u * z) + (w * y + x * z) < (x * y + w * z) + (u * v + w * z).
        rewrite add_SNo_com (w * v + u * z) (w * y + x * z) Lwvuz Lwyxz.
        prove (w * y + x * z) + (w * v + u * z) < (x * y + w * z) + (u * v + w * z).
        apply add_SNo_Lt3 (w * y + x * z) (w * v + u * z) (x * y + w * z) (u * v + w * z) Lwyxz Lwvuz Lxywz Luvwz.
        - exact L1.
        - exact L2.
      }
  + assume H4: SNoLev v :e SNoLev y.
    assume H5: SNoEq_ (SNoLev v) v y.
    assume H6: SNoLev v :e y.
    claim Lvy: v :e SNoL y.
    { exact SNoL_I y Hy v Hv H4 Hvy. }
    claim L1: w * y + x * v < x * y + w * v.
    { exact Hxy1 w Lwx v Lvy. }
    claim L2: u * y + w * v < w * y + u * v.
    { exact Huy4 w Lwu v Lvy. }
    prove u * y + x * v < x * y + u * v.
    apply add_SNo_Lt2_cancel (w * y) (u * y + x * v) (x * y + u * v) Lwy Luyxv Lxyuv.
    prove w * y + u * y + x * v < w * y + x * y + u * v.
    apply SNoLt_tra (w * y + u * y + x * v) (u * y + w * v + x * y) (w * y + x * y + u * v)
                    (SNo_add_SNo (w * y) (u * y + x * v) Lwy Luyxv)
                    (SNo_add_SNo (u * y) (w * v + x * y) Huy (SNo_add_SNo (w * v) (x * y) Lwv Hxy))
                    (SNo_add_SNo (w * y) (x * y + u * v) Lwy Lxyuv).
    * prove w * y + u * y + x * v < u * y + w * v + x * y.
      rewrite add_SNo_com_3_0_1 (w * y) (u * y) (x * v) Lwy Huy Hxv.
      prove u * y + w * y + x * v < u * y + w * v + x * y.
      rewrite add_SNo_com (w * v) (x * y) Lwv Hxy.
      exact add_SNo_Lt2 (u * y) (w * y + x * v) (x * y + w * v)
                        Huy Lwyxv Lxywv L1.
    * prove u * y + w * v + x * y < w * y + x * y + u * v.
      rewrite add_SNo_assoc (u * y) (w * v) (x * y) Huy Lwv Hxy.
      prove (u * y + w * v) + x * y < w * y + x * y + u * v.
      rewrite add_SNo_com (x * y) (u * v) Hxy Huv.
      prove (u * y + w * v) + x * y < w * y + u * v + x * y.
      rewrite add_SNo_assoc (w * y) (u * v) (x * y) Lwy Huv Hxy.
      prove (u * y + w * v) + x * y < (w * y + u * v) + x * y.
      exact add_SNo_Lt1 (u * y + w * v) (x * y) (w * y + u * v)
                        Luywv Hxy Lwyuv L2.
  + assume H4: SNoLev y :e SNoLev v.
    assume H5: SNoEq_ (SNoLev y) v y.
    assume H6: SNoLev y /:e v.
    claim Lyv: y :e SNoR v.
    { exact SNoR_I v Hv y Hy H4 Hvy. }
    claim L1: x * v + w * y < w * v + x * y.
    { exact Hxv3 w Lwx y Lyv. }
    claim L2: w * v + u * y < u * v + w * y.
    { exact Huv2 w Lwu y Lyv. }
    prove u * y + x * v < x * y + u * v.
    apply add_SNo_Lt2_cancel (w * y) (u * y + x * v) (x * y + u * v) Lwy Luyxv Lxyuv.
    prove w * y + u * y + x * v < w * y + x * y + u * v.
    apply SNoLt_tra (w * y + u * y + x * v) (u * y + w * v + x * y) (w * y + x * y + u * v)
                    (SNo_add_SNo (w * y) (u * y + x * v) Lwy Luyxv)
                    (SNo_add_SNo (u * y) (w * v + x * y) Huy (SNo_add_SNo (w * v) (x * y) Lwv Hxy))
                    (SNo_add_SNo (w * y) (x * y + u * v) Lwy Lxyuv).
    * prove w * y + u * y + x * v < u * y + w * v + x * y.
      rewrite <- add_SNo_rotate_3_1 (u * y) (x * v) (w * y) Huy Hxv Lwy.
      prove u * y + x * v + w * y < u * y + w * v + x * y.
      exact add_SNo_Lt2 (u * y) (x * v + w * y) (w * v + x * y)
                        Huy Lxvwy Lwvxy L1.
    * prove u * y + w * v + x * y < w * y + x * y + u * v.
      rewrite add_SNo_rotate_3_1 (w * y) (x * y) (u * v) Lwy Hxy Huv.
      prove u * y + w * v + x * y < u * v + w * y + x * y.
      rewrite add_SNo_assoc (u * y) (w * v) (x * y) Huy Lwv Hxy.
      rewrite add_SNo_assoc (u * v) (w * y) (x * y) Huv Lwy Hxy.
      prove (u * y + w * v) + x * y < (u * v + w * y) + x * y.
      rewrite add_SNo_com (u * y) (w * v) Huy Lwv.
      prove (w * v + u * y) + x * y < (u * v + w * y) + x * y.
      apply add_SNo_Lt1 (w * v + u * y) (x * y) (u * v + w * y)
                        Lwvuy Hxy Luvwy L2.
- assume H1: SNoLev u :e SNoLev x.
  assume H2: SNoEq_ (SNoLev u) u x.
  assume H3: SNoLev u :e x.
  claim Lux: u :e SNoL x.
  { exact SNoL_I x Hx u Hu H1 Hux. }
  apply SNoLtE v y Hv Hy Hvy.
  + let z.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev v :/\: SNoLev y.
    assume Hz3: SNoEq_ (SNoLev z) z v.
    assume Hz4: SNoEq_ (SNoLev z) z y.
    assume Hz5: v < z.
    assume Hz6: z < y.
    assume Hz7: SNoLev z /:e v.
    assume Hz8: SNoLev z :e y.
    apply binintersectE (SNoLev v) (SNoLev y) (SNoLev z) Hz2.
    assume Hz2a Hz2b.
    claim Lzy: z :e SNoL y.
    { exact SNoL_I y Hy z Hz1 Hz2b Hz6. }
    claim Lzv: z :e SNoR v.
    { exact SNoR_I v Hv z Hz1 Hz2a Hz5. }
    claim Lxz: SNo (x * z).
    { exact SNo_mul_SNo x z Hx Hz1. }
    claim Luz: SNo (u * z).
    { exact SNo_mul_SNo u z Hu Hz1. }
    claim Luyxz: SNo (u * y + x * z).
    { exact SNo_add_SNo (u * y) (x * z) Huy Lxz. }
    claim Luvxz: SNo (u * v + x * z).
    { exact SNo_add_SNo (u * v) (x * z) Huv Lxz. }
    claim Lxyuz: SNo (x * y + u * z).
    { exact SNo_add_SNo (x * y) (u * z) Hxy Luz. }
    claim Lxvuz: SNo (x * v + u * z).
    { exact SNo_add_SNo (x * v) (u * z) Hxv Luz. }
    claim L1: u * y + x * z < x * y + u * z.
    { exact Hxy1 u Lux z Lzy. }
    claim L2: x * v + u * z < u * v + x * z.
    { exact Hxv3 u Lux z Lzv. }
    prove u * y + x * v < x * y + u * v.
    apply add_SNo_Lt2_cancel (x * z) (u * y + x * v) (x * y + u * v) Lxz Luyxv Lxyuv.
    prove x * z + u * y + x * v < x * z + x * y + u * v.
    apply SNoLt_tra (x * z + u * y + x * v) (x * y + u * z + x * v) (x * z + x * y + u * v)
                    (SNo_add_SNo (x * z) (u * y + x * v) Lxz Luyxv)
                    (SNo_add_SNo (x * y) (u * z + x * v) Hxy (SNo_add_SNo (u * z) (x * v) Luz Hxv))
                    (SNo_add_SNo (x * z) (x * y + u * v) Lxz Lxyuv).
    * prove x * z + u * y + x * v < x * y + u * z + x * v.
      rewrite add_SNo_assoc (x * z) (u * y) (x * v) Lxz Huy Hxv.
      rewrite add_SNo_com (x * z) (u * y) Lxz Huy.
      prove (u * y + x * z) + x * v < x * y + u * z + x * v.
      rewrite add_SNo_assoc (x * y) (u * z) (x * v) Hxy Luz Hxv.
      exact add_SNo_Lt1 (u * y + x * z) (x * v) (x * y + u * z)
                        Luyxz Hxv Lxyuz L1.
    * prove x * y + u * z + x * v < x * z + x * y + u * v.
      rewrite <- add_SNo_rotate_3_1 (x * y) (u * v) (x * z) Hxy Huv Lxz.
      prove x * y + u * z + x * v < x * y + u * v + x * z.
      rewrite add_SNo_com (u * z) (x * v) Luz Hxv.
      prove x * y + x * v + u * z < x * y + u * v + x * z.
      exact add_SNo_Lt2 (x * y) (x * v + u * z) (u * v + x * z)
                        Hxy Lxvuz Luvxz L2.
  + assume H4: SNoLev v :e SNoLev y.
    assume H5: SNoEq_ (SNoLev v) v y.
    assume H6: SNoLev v :e y.
    claim Lvy: v :e SNoL y.
    { exact SNoL_I y Hy v Hv H4 Hvy. }
    exact Hxy1 u Lux v Lvy.
  + assume H4: SNoLev y :e SNoLev v.
    assume H5: SNoEq_ (SNoLev y) v y.
    assume H6: SNoLev y /:e v.
    claim Lyv: y :e SNoR v.
    { exact SNoR_I v Hv y Hy H4 Hvy. }
    prove u * y + x * v < x * y + u * v.
    rewrite add_SNo_com (u * y) (x * v) Huy Hxv.
    rewrite add_SNo_com (x * y) (u * v) Hxy Huv.
    exact Hxv3 u Lux y Lyv.
- assume H1: SNoLev x :e SNoLev u.
  assume H2: SNoEq_ (SNoLev x) u x.
  assume H3: SNoLev x /:e u.
  claim Lxu: x :e SNoR u.
  { exact SNoR_I u Hu x Hx H1 Hux. }
  apply SNoLtE v y Hv Hy Hvy.
  + let z.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev v :/\: SNoLev y.
    assume Hz3: SNoEq_ (SNoLev z) z v.
    assume Hz4: SNoEq_ (SNoLev z) z y.
    assume Hz5: v < z.
    assume Hz6: z < y.
    assume Hz7: SNoLev z /:e v.
    assume Hz8: SNoLev z :e y.
    apply binintersectE (SNoLev v) (SNoLev y) (SNoLev z) Hz2.
    assume Hz2a Hz2b.
    claim Lzy: z :e SNoL y.
    { exact SNoL_I y Hy z Hz1 Hz2b Hz6. }
    claim Lzv: z :e SNoR v.
    { exact SNoR_I v Hv z Hz1 Hz2a Hz5. }
    claim Lxz: SNo (x * z).
    { exact SNo_mul_SNo x z Hx Hz1. }
    claim Luz: SNo (u * z).
    { exact SNo_mul_SNo u z Hu Hz1. }
    claim L1: u * y + x * z < x * y + u * z.
    { exact Huy4 x Lxu z Lzy. }
    claim L2: x * v + u * z < u * v + x * z.
    { exact Huv2 x Lxu z Lzv. }
    prove u * y + x * v < x * y + u * v.
    apply add_SNo_Lt1_cancel (u * y + x * v) (x * z) (x * y + u * v) Luyxv Lxz Lxyuv.
    prove (u * y + x * v) + x * z < (x * y + u * v) + x * z.
    rewrite add_SNo_com (u * y) (x * v) Huy Hxv.
    prove (x * v + u * y) + x * z < (x * y + u * v) + x * z.
    rewrite <- add_SNo_assoc (x * v) (u * y) (x * z) Hxv Huy Lxz.
    rewrite <- add_SNo_assoc (x * y) (u * v) (x * z) Hxy Huv Lxz.
    prove x * v + u * y + x * z < x * y + u * v + x * z.
    claim Luyxz: SNo (u * y + x * z).
    { exact SNo_add_SNo (u * y) (x * z) Huy Lxz. }
    claim Luzxy: SNo (u * z + x * y).
    { exact SNo_add_SNo (u * z) (x * y) Luz Hxy. }
    claim Luvxz: SNo (u * v + x * z).
    { exact SNo_add_SNo (u * v) (x * z) Huv Lxz. }
    apply SNoLt_tra (x * v + u * y + x * z)
                    (x * v + u * z + x * y)
                    (x * y + u * v + x * z)
                    (SNo_add_SNo (x * v) (u * y + x * z) Hxv Luyxz)
                    (SNo_add_SNo (x * v) (u * z + x * y) Hxv Luzxy)
                    (SNo_add_SNo (x * y) (u * v + x * z) Hxy Luvxz).
    * prove x * v + u * y + x * z < x * v + u * z + x * y.
      rewrite add_SNo_com (u * z) (x * y) Luz Hxy.
      exact add_SNo_Lt2 (x * v) (u * y + x * z) (x * y + u * z)
                        Hxv Luyxz (SNo_add_SNo (x * y) (u * z) Hxy Luz) L1.
    * prove x * v + u * z + x * y < x * y + u * v + x * z.
      rewrite add_SNo_rotate_3_1 (x * v) (u * z) (x * y) Hxv Luz Hxy.
      prove x * y + x * v + u * z < x * y + u * v + x * z.
      exact add_SNo_Lt2 (x * y) (x * v + u * z) (u * v + x * z)
                        Hxy (SNo_add_SNo (x * v) (u * z) Hxv Luz) Luvxz L2.
  + assume H4: SNoLev v :e SNoLev y.
    assume H5: SNoEq_ (SNoLev v) v y.
    assume H6: SNoLev v :e y.
    claim Lvy: v :e SNoL y.
    { exact SNoL_I y Hy v Hv H4 Hvy. }
    prove u * y + x * v < x * y + u * v.
    exact Huy4 x Lxu v Lvy.
  + assume H4: SNoLev y :e SNoLev v.
    assume H5: SNoEq_ (SNoLev y) v y.
    assume H6: SNoLev y /:e v.
    claim Lyv: y :e SNoR v.
    { exact SNoR_I v Hv y Hy H4 Hvy. }
    prove u * y + x * v < x * y + u * v.
    rewrite add_SNo_com (u * y) (x * v) Huy Hxv.
    rewrite add_SNo_com (x * y) (u * v) Hxy Huv.
    exact Huv2 x Lxu y Lyv.
Qed.

Theorem mul_SNo_Le : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u <= x -> v <= y -> u * y + x * v <= x * y + u * v.
let x y u v. assume Hx Hy Hu Hv Hux Hvy.
apply SNoLeE u x Hu Hx Hux.
- assume Hux: u < x.
  apply SNoLeE v y Hv Hy Hvy.
  + assume Hvy: v < y.
    apply SNoLtLe.
    exact mul_SNo_Lt x y u v Hx Hy Hu Hv Hux Hvy.
  + assume Hvy: v = y. rewrite Hvy.
    prove u * y + x * y <= x * y + u * y.
    rewrite add_SNo_com (u * y) (x * y) (SNo_mul_SNo u y Hu Hy) (SNo_mul_SNo x y Hx Hy).
    prove x * y + u * y <= x * y + u * y.
    apply SNoLe_ref.
- assume Hux: u = x. rewrite Hux.
  prove x * y + x * v <= x * y + x * v.
  apply SNoLe_ref.
Qed.

Theorem mul_SNo_SNoL_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 (exists v :e SNoL x, exists w :e SNoL y, u + v * w <= v * y + x * w)
 \/
 (exists v :e SNoR x, exists w :e SNoR y, u + v * w <= v * y + x * w).
let x y. assume Hx Hy.
set P1 : set -> prop :=
  fun u => exists v :e SNoL x, exists w :e SNoL y, u + v * w <= v * y + x * w.
set P2 : set -> prop :=
  fun u => exists v :e SNoR x, exists w :e SNoR y, u + v * w <= v * y + x * w.
set P : set -> prop := fun u => P1 u \/ P2 u.
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Hx Hy. }
claim LI: forall u, SNo u -> SNoLev u :e SNoLev (x * y) -> u < x * y -> P u.
{ apply SNoLev_ind.
  let u.
  assume Hu1: SNo u.
  assume IH: forall z :e SNoS_ (SNoLev u), SNoLev z :e SNoLev (x * y) -> z < x * y -> P z.
  assume Hu2: SNoLev u :e SNoLev (x * y).
  assume Hu3: u < x * y.
  apply dneg.
  assume HNC: ~P u.
  claim L1: forall v :e SNoL x, forall w :e SNoL y, v * y + x * w < u + v * w.
  { let v. assume Hv. let w. assume Hw.
    apply SNoL_E x Hx v Hv.
    assume Hv1 Hv2 Hv3.
    apply SNoL_E y Hy w Hw.
    assume Hw1 Hw2 Hw3.
    apply SNoLtLe_or (v * y + x * w) (u + v * w)
           (SNo_add_SNo (v * y) (x * w) (SNo_mul_SNo v y Hv1 Hy) (SNo_mul_SNo x w Hx Hw1))
           (SNo_add_SNo u (v * w) Hu1 (SNo_mul_SNo v w Hv1 Hw1)).
    - assume H. exact H.
    - assume H. apply HNC. apply orIL.
      witness v. apply andI.
      + exact Hv.
      + witness w. apply andI.
        * exact Hw.
        * exact H.
  }
  claim L2: forall v :e SNoR x, forall w :e SNoR y, v * y + x * w < u + v * w.
  { let v. assume Hv. let w. assume Hw.
    apply SNoR_E x Hx v Hv.
    assume Hv1 Hv2 Hv3.
    apply SNoR_E y Hy w Hw.
    assume Hw1 Hw2 Hw3.
    apply SNoLtLe_or (v * y + x * w) (u + v * w)
           (SNo_add_SNo (v * y) (x * w) (SNo_mul_SNo v y Hv1 Hy) (SNo_mul_SNo x w Hx Hw1))
           (SNo_add_SNo u (v * w) Hu1 (SNo_mul_SNo v w Hv1 Hw1)).
    - assume H. exact H.
    - assume H. apply HNC. apply orIR.
      witness v. apply andI.
      + exact Hv.
      + witness w. apply andI.
        * exact Hw.
        * exact H.
  }
  apply SNoLt_irref u.
  apply SNoLtLe_tra u (x * y) u Hu1 Lxy Hu1 Hu3.
  prove x * y <= u.
  apply mul_SNo_eq_3 x y Hx Hy.
  let L R. assume HLR HLE HLI1 HLI2 HRE HRI1 HRI2.
  assume HE: x * y = SNoCut L R.
  rewrite HE.
  prove SNoCut L R <= u.
  rewrite SNo_eta u Hu1.
  prove SNoCut L R <= SNoCut (SNoL u) (SNoR u).
  apply SNoCut_Le L R (SNoL u) (SNoR u) HLR (SNoCutP_SNoL_SNoR u Hu1).
  - prove forall z :e L, z < SNoCut (SNoL u) (SNoR u).
    let z. assume Hz.
    rewrite <- SNo_eta u Hu1.
    prove z < u.
    apply HLE z Hz.
    + let v. assume Hv: v :e SNoL x. let w. assume Hw: w :e SNoL y.
      assume Hze: z = v * y + x * w + - v * w.
      rewrite Hze.
      prove v * y + x * w + - v * w < u.
      apply SNoL_E x Hx v Hv.
      assume Hv1 Hv2 Hv3.
      apply SNoL_E y Hy w Hw.
      assume Hw1 Hw2 Hw3.
      apply add_SNo_minus_Lt1b3 (v * y) (x * w) (v * w) u (SNo_mul_SNo v y Hv1 Hy) (SNo_mul_SNo x w Hx Hw1) (SNo_mul_SNo v w Hv1 Hw1) Hu1.
      prove v * y + x * w < u + v * w.
      exact L1 v Hv w Hw.
    + let v. assume Hv: v :e SNoR x. let w. assume Hw: w :e SNoR y.
      assume Hze: z = v * y + x * w + - v * w.
      rewrite Hze.
      prove v * y + x * w + - v * w < u.
      apply SNoR_E x Hx v Hv.
      assume Hv1 Hv2 Hv3.
      apply SNoR_E y Hy w Hw.
      assume Hw1 Hw2 Hw3.
      apply add_SNo_minus_Lt1b3 (v * y) (x * w) (v * w) u (SNo_mul_SNo v y Hv1 Hy) (SNo_mul_SNo x w Hx Hw1) (SNo_mul_SNo v w Hv1 Hw1) Hu1.
      prove v * y + x * w < u + v * w.
      exact L2 v Hv w Hw.
  - prove forall z :e SNoR u, SNoCut L R < z.
    let z. assume Hz: z :e SNoR u.
    rewrite <- HE.
    prove x * y < z.
    apply SNoR_E u Hu1 z Hz.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev u.
    assume Hz3: u < z.
    apply SNoLt_trichotomy_or_impred z (x * y) Hz1 Lxy.
    + assume H1: z < x * y.
      claim LPz: P z.
      { apply IH z.
        - prove z :e SNoS_ (SNoLev u). apply SNoS_I2.
          + exact Hz1.
          + exact Hu1.
          + exact Hz2.
        - prove SNoLev z :e SNoLev (x * y).
          exact ordinal_TransSet (SNoLev (x * y)) (SNoLev_ordinal (x * y) Lxy)
                                 (SNoLev u) Hu2 (SNoLev z) Hz2.
        - prove z < x * y. exact H1.
      }
      apply LPz.
      * assume H2: P1 z. apply H2.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoL x. assume H2. apply H2.
        let w. assume H2. apply H2.
        assume Hw: w :e SNoL y.
        assume Hvw: z + v * w <= v * y + x * w.
        apply SNoL_E x Hx v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoL_E y Hy w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim L3: z + v * w < u + v * w.
        { apply SNoLeLt_tra (z + v * w) (v * y + x * w) (u + v * w)
                            (SNo_add_SNo z (v * w) Hz1 Lvw)
                            (SNo_add_SNo (v * y) (x * w)
                                         (SNo_mul_SNo v y Hv1 Hy)
                                         (SNo_mul_SNo x w Hx Hw1))
                            (SNo_add_SNo u (v * w) Hu1 Lvw)
                            Hvw.
          prove v * y + x * w < u + v * w.
          exact L1 v Hv w Hw.
        }
        claim L4: z < u.
        { exact add_SNo_Lt1_cancel z (v * w) u Hz1 Lvw Hu1 L3. }
        apply SNoLt_irref u.
        exact SNoLt_tra u z u Hu1 Hz1 Hu1 Hz3 L4.
      * assume H2: P2 z. apply H2.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoR x. assume H2. apply H2.
        let w. assume H2. apply H2.
        assume Hw: w :e SNoR y.
        assume Hvw: z + v * w <= v * y + x * w.
        apply SNoR_E x Hx v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoR_E y Hy w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim L5: z + v * w < u + v * w.
        { apply SNoLeLt_tra (z + v * w) (v * y + x * w) (u + v * w)
                            (SNo_add_SNo z (v * w) Hz1 Lvw)
                            (SNo_add_SNo (v * y) (x * w)
                                         (SNo_mul_SNo v y Hv1 Hy)
                                         (SNo_mul_SNo x w Hx Hw1))
                            (SNo_add_SNo u (v * w) Hu1 Lvw)
                            Hvw.
          prove v * y + x * w < u + v * w.
          exact L2 v Hv w Hw.
        }
        claim L6: z < u.
        { exact add_SNo_Lt1_cancel z (v * w) u Hz1 Lvw Hu1 L5. }
        apply SNoLt_irref u.
        exact SNoLt_tra u z u Hu1 Hz1 Hu1 Hz3 L6.
    + assume H1: z = x * y. apply In_no2cycle (SNoLev u) (SNoLev (x * y)) Hu2.
      prove SNoLev (x * y) :e SNoLev u. rewrite <- H1. exact Hz2.
    + assume H1: x * y < z. exact H1.
}
let u.
assume Hu: u :e SNoL (x * y).
apply SNoL_E (x * y) Lxy u Hu.
assume Hu1: SNo u.
assume Hu2: SNoLev u :e SNoLev (x * y).
assume Hu3: u < x * y.
exact LI u Hu1 Hu2 Hu3.
Qed.

Theorem mul_SNo_SNoL_interpolate_impred : forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 forall p:prop,
      (forall v :e SNoL x, forall w :e SNoL y, u + v * w <= v * y + x * w -> p)
   -> (forall v :e SNoR x, forall w :e SNoR y, u + v * w <= v * y + x * w -> p)
   -> p.
let x y. assume Hx Hy. let u. assume Hu.
let p. assume Hp1 Hp2.
apply mul_SNo_SNoL_interpolate x y Hx Hy u Hu.
- assume H1. apply H1.
  let v. assume H1. apply H1.
  assume Hv. assume H1. apply H1.
  let w. assume H1. apply H1.
  assume Hw Hvw.
  exact Hp1 v Hv w Hw Hvw.
- assume H1. apply H1.
  let v. assume H1. apply H1.
  assume Hv. assume H1. apply H1.
  let w. assume H1. apply H1.
  assume Hw Hvw.
  exact Hp2 v Hv w Hw Hvw.
Qed.  

Theorem mul_SNo_SNoR_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 (exists v :e SNoL x, exists w :e SNoR y, v * y + x * w <= u + v * w)
 \/
 (exists v :e SNoR x, exists w :e SNoL y, v * y + x * w <= u + v * w).
let x y. assume Hx Hy.
set P1 : set -> prop :=
  fun u => exists v :e SNoL x, exists w :e SNoR y, v * y + x * w <= u + v * w.
set P2 : set -> prop :=
  fun u => exists v :e SNoR x, exists w :e SNoL y, v * y + x * w <= u + v * w.
set P : set -> prop := fun u => P1 u \/ P2 u.
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Hx Hy. }
claim LI: forall u, SNo u -> SNoLev u :e SNoLev (x * y) -> x * y < u -> P u.
{ apply SNoLev_ind.
  let u.
  assume Hu1: SNo u.
  assume IH: forall z :e SNoS_ (SNoLev u), SNoLev z :e SNoLev (x * y) -> x * y < z -> P z.
  assume Hu2: SNoLev u :e SNoLev (x * y).
  assume Hu3: x * y < u.
  apply dneg.
  assume HNC: ~P u.
  claim L1: forall v :e SNoL x, forall w :e SNoR y, u + v * w < v * y + x * w.
  { let v. assume Hv. let w. assume Hw.
    apply SNoL_E x Hx v Hv.
    assume Hv1 Hv2 Hv3.
    apply SNoR_E y Hy w Hw.
    assume Hw1 Hw2 Hw3.
    apply SNoLtLe_or (u + v * w) (v * y + x * w)
           (SNo_add_SNo u (v * w) Hu1 (SNo_mul_SNo v w Hv1 Hw1))
           (SNo_add_SNo (v * y) (x * w) (SNo_mul_SNo v y Hv1 Hy) (SNo_mul_SNo x w Hx Hw1)).
    - assume H. exact H.
    - assume H. apply HNC. apply orIL.
      witness v. apply andI.
      + exact Hv.
      + witness w. apply andI.
        * exact Hw.
        * exact H.
  }
  claim L2: forall v :e SNoR x, forall w :e SNoL y, u + v * w < v * y + x * w.
  { let v. assume Hv. let w. assume Hw.
    apply SNoR_E x Hx v Hv.
    assume Hv1 Hv2 Hv3.
    apply SNoL_E y Hy w Hw.
    assume Hw1 Hw2 Hw3.
    apply SNoLtLe_or (u + v * w) (v * y + x * w)
           (SNo_add_SNo u (v * w) Hu1 (SNo_mul_SNo v w Hv1 Hw1))
           (SNo_add_SNo (v * y) (x * w) (SNo_mul_SNo v y Hv1 Hy) (SNo_mul_SNo x w Hx Hw1)).
    - assume H. exact H.
    - assume H. apply HNC. apply orIR.
      witness v. apply andI.
      + exact Hv.
      + witness w. apply andI.
        * exact Hw.
        * exact H.
  }
  apply SNoLt_irref (x * y).
  apply SNoLtLe_tra (x * y) u (x * y) Lxy Hu1 Lxy Hu3.
  prove u <= x * y.
  apply mul_SNo_eq_3 x y Hx Hy.
  let L R. assume HLR HLE HLI1 HLI2 HRE HRI1 HRI2.
  assume HE: x * y = SNoCut L R.
  rewrite HE.
  prove u <= SNoCut L R.
  rewrite SNo_eta u Hu1.
  prove SNoCut (SNoL u) (SNoR u) <= SNoCut L R.
  apply SNoCut_Le (SNoL u) (SNoR u) L R (SNoCutP_SNoL_SNoR u Hu1) HLR.
  - prove forall z :e SNoL u, z < SNoCut L R.
    let z. assume Hz: z :e SNoL u.
    rewrite <- HE.
    prove z < x * y.
    apply SNoL_E u Hu1 z Hz.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev u.
    assume Hz3: z < u.
    apply SNoLt_trichotomy_or_impred z (x * y) Hz1 Lxy.
    + assume H1: z < x * y. exact H1.
    + assume H1: z = x * y. apply In_no2cycle (SNoLev u) (SNoLev (x * y)) Hu2.
      prove SNoLev (x * y) :e SNoLev u. rewrite <- H1. exact Hz2.
    + assume H1: x * y < z.
      claim LPz: P z.
      { apply IH z.
        - prove z :e SNoS_ (SNoLev u). apply SNoS_I2.
          + exact Hz1.
          + exact Hu1.
          + exact Hz2.
        - prove SNoLev z :e SNoLev (x * y).
          exact ordinal_TransSet (SNoLev (x * y)) (SNoLev_ordinal (x * y) Lxy)
                                 (SNoLev u) Hu2 (SNoLev z) Hz2.
        - prove x * y < z. exact H1.
      }
      apply LPz.
      * assume H2: P1 z. apply H2.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoL x. assume H2. apply H2.
        let w. assume H2. apply H2.
        assume Hw: w :e SNoR y.
        assume Hvw: v * y + x * w <= z + v * w.
        apply SNoL_E x Hx v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoR_E y Hy w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim L3: u + v * w < z + v * w.
        { apply SNoLtLe_tra (u + v * w) (v * y + x * w) (z + v * w)
                            (SNo_add_SNo u (v * w) Hu1 Lvw)
                            (SNo_add_SNo (v * y) (x * w)
                                         (SNo_mul_SNo v y Hv1 Hy)
                                         (SNo_mul_SNo x w Hx Hw1))
                            (SNo_add_SNo z (v * w) Hz1 Lvw).
          - prove u + v * w < v * y + x * w.
            exact L1 v Hv w Hw.
          - exact Hvw.
        }
        claim L4: u < z.
        { exact add_SNo_Lt1_cancel u (v * w) z Hu1 Lvw Hz1 L3. }
        apply SNoLt_irref u.
        exact SNoLt_tra u z u Hu1 Hz1 Hu1 L4 Hz3.
      * assume H2: P2 z. apply H2.
        let v. assume H2. apply H2.
        assume Hv: v :e SNoR x. assume H2. apply H2.
        let w. assume H2. apply H2.
        assume Hw: w :e SNoL y.
        assume Hvw: v * y + x * w <= z + v * w.
        apply SNoR_E x Hx v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoL_E y Hy w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim L5: u + v * w < z + v * w.
        { apply SNoLtLe_tra (u + v * w) (v * y + x * w) (z + v * w)
                            (SNo_add_SNo u (v * w) Hu1 Lvw)
                            (SNo_add_SNo (v * y) (x * w)
                                         (SNo_mul_SNo v y Hv1 Hy)
                                         (SNo_mul_SNo x w Hx Hw1))
                            (SNo_add_SNo z (v * w) Hz1 Lvw).
          - prove u + v * w < v * y + x * w.
            exact L2 v Hv w Hw.
          - exact Hvw.
        }
        claim L6: u < z.
        { exact add_SNo_Lt1_cancel u (v * w) z Hu1 Lvw Hz1 L5. }
        apply SNoLt_irref u.
        exact SNoLt_tra u z u Hu1 Hz1 Hu1 L6 Hz3.
  - prove forall z :e R, SNoCut (SNoL u) (SNoR u) < z.
    let z. assume Hz.
    rewrite <- SNo_eta u Hu1.
    prove u < z.
    apply HRE z Hz.
    + let v. assume Hv: v :e SNoL x. let w. assume Hw: w :e SNoR y.
      assume Hze: z = v * y + x * w + - v * w.
      rewrite Hze.
      prove u < v * y + x * w + - v * w.
      apply SNoL_E x Hx v Hv.
      assume Hv1 Hv2 Hv3.
      apply SNoR_E y Hy w Hw.
      assume Hw1 Hw2 Hw3.
      apply add_SNo_minus_Lt2b3 (v * y) (x * w) (v * w) u (SNo_mul_SNo v y Hv1 Hy) (SNo_mul_SNo x w Hx Hw1) (SNo_mul_SNo v w Hv1 Hw1) Hu1.
      prove u + v * w < v * y + x * w.
      exact L1 v Hv w Hw.
    + let v. assume Hv: v :e SNoR x. let w. assume Hw: w :e SNoL y.
      assume Hze: z = v * y + x * w + - v * w.
      rewrite Hze.
      prove u < v * y + x * w + - v * w.
      apply SNoR_E x Hx v Hv.
      assume Hv1 Hv2 Hv3.
      apply SNoL_E y Hy w Hw.
      assume Hw1 Hw2 Hw3.
      apply add_SNo_minus_Lt2b3 (v * y) (x * w) (v * w) u (SNo_mul_SNo v y Hv1 Hy) (SNo_mul_SNo x w Hx Hw1) (SNo_mul_SNo v w Hv1 Hw1) Hu1.
      prove u + v * w < v * y + x * w.
      exact L2 v Hv w Hw.
}
let u.
assume Hu: u :e SNoR (x * y).
apply SNoR_E (x * y) Lxy u Hu.
assume Hu1: SNo u.
assume Hu2: SNoLev u :e SNoLev (x * y).
assume Hu3: x * y < u.
exact LI u Hu1 Hu2 Hu3.
Qed.

Theorem mul_SNo_SNoR_interpolate_impred : forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 forall p:prop,
     (forall v :e SNoL x, forall w :e SNoR y, v * y + x * w <= u + v * w -> p)
  -> (forall v :e SNoR x, forall w :e SNoL y, v * y + x * w <= u + v * w -> p)
  -> p.
let x y. assume Hx Hy. let u. assume Hu.
let p. assume Hp1 Hp2.
apply mul_SNo_SNoR_interpolate x y Hx Hy u Hu.
- assume H1. apply H1.
  let v. assume H1. apply H1.
  assume Hv. assume H1. apply H1.
  let w. assume H1. apply H1.
  assume Hw Hvw.
  exact Hp1 v Hv w Hw Hvw.
- assume H1. apply H1.
  let v. assume H1. apply H1.
  assume Hv. assume H1. apply H1.
  let w. assume H1. apply H1.
  assume Hw Hvw.
  exact Hp2 v Hv w Hw Hvw.
Qed.

(** This could be useful for proving L c= L', L = L', R c= R' or R = R'
    when corresponding conditions hold. **)
Theorem mul_SNo_Subq_lem : forall x y X Y Z W,
  forall U U',
      (forall u, u :e U ->
         (forall q:prop,
                (forall w0 :e X, forall w1 :e Y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e Z, forall z1 :e W, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
   -> (forall w0 :e X, forall w1 :e Y, w0 * y + x * w1 + - w0 * w1 :e U')
   -> (forall w0 :e Z, forall w1 :e W, w0 * y + x * w1 + - w0 * w1 :e U')
   -> U c= U'.
let x y X Y Z W U U'. assume HUE HU'I1 HU'I2.
let u. assume Hu: u :e U.
apply HUE u Hu.
- let w. assume Hw. let z. assume Hz Huwz. rewrite Huwz. apply HU'I1.
  + exact Hw.
  + exact Hz.
- let w. assume Hw. let z. assume Hz Huwz. rewrite Huwz. apply HU'I2.
  + exact Hw.
  + exact Hz.
Qed.

(** Part of Conway Chapter 2 Theorem 7 **)
Theorem mul_SNo_zeroR : forall x, SNo x -> x * 0 = 0.
let x.
assume Hx: SNo x.
apply mul_SNo_eq_2 x 0 Hx SNo_0.
let L R.
assume HLE HLI1 HLI2 HRE HRI1 HRI2 Hx0.
prove x * 0 = 0.
rewrite Hx0.
prove SNoCut L R = 0.
claim LL0: L = 0.
{ apply Empty_Subq_eq.
  let w. assume Hw: w :e L.
  prove False.
  apply HLE w Hw.
  - let u. assume Hu: u :e SNoL x.
    let v. rewrite SNoL_0. assume Hv: v :e 0.
    prove False.
    exact EmptyE v Hv.
  - let u. assume Hu: u :e SNoR x.
    let v. rewrite SNoR_0. assume Hv: v :e 0.
    prove False.
    exact EmptyE v Hv.
}
claim LR0: R = 0.
{ apply Empty_Subq_eq.
  let w. assume Hw: w :e R.
  prove False.
  apply HRE w Hw.
  - let u. assume Hu: u :e SNoL x.
    let v. rewrite SNoR_0. assume Hv: v :e 0.
    prove False.
    exact EmptyE v Hv.
  - let u. assume Hu: u :e SNoR x.
    let v. rewrite SNoL_0. assume Hv: v :e 0.
    prove False.
    exact EmptyE v Hv.
}
rewrite LL0. rewrite LR0.
exact SNoCut_0_0.
Qed.

Theorem mul_SNo_oneR : forall x, SNo x -> x * 1 = x.
apply SNoLev_ind.
let x. assume Hx.
assume IHx: forall w :e SNoS_ (SNoLev x), w * 1 = w.
apply mul_SNo_eq_3 x 1 Hx SNo_1.
let L R.
assume HLR HLE HLI1 HLI2 HRE HRI1 HRI2 Hx1e.
prove x * 1 = x.
apply mul_SNo_prop_1 x Hx 1 SNo_1.
assume Hx1: SNo (x * 1).
assume Hx11: forall u :e SNoL x, forall v :e SNoL 1, u * 1 + x * v < x * 1 + u * v.
assume Hx12: forall u :e SNoR x, forall v :e SNoR 1, u * 1 + x * v < x * 1 + u * v.
assume Hx13: forall u :e SNoL x, forall v :e SNoR 1, x * 1 + u * v < u * 1 + x * v.
assume Hx14: forall u :e SNoR x, forall v :e SNoL 1, x * 1 + u * v < u * 1 + x * v.
claim L0L1: 0 :e SNoL 1.
{ rewrite SNoL_1. exact In_0_1. }
rewrite Hx1e.
prove SNoCut L R = x.
rewrite SNo_eta x Hx.
prove SNoCut L R = SNoCut (SNoL x) (SNoR x).
apply SNoCut_ext L R (SNoL x) (SNoR x) HLR (SNoCutP_SNoL_SNoR x Hx).
- prove forall w :e L, w < SNoCut (SNoL x) (SNoR x).
  let w. assume Hw.
  apply SNoCutP_SNoCut_L (SNoL x) (SNoR x) (SNoCutP_SNoL_SNoR x Hx).
  prove w :e SNoL x.
  apply HLE w Hw.
  + let u. assume Hu: u :e SNoL x.
    let v. rewrite SNoL_1. assume Hv: v :e 1.
    apply cases_1 v Hv.
    assume Hwuv: w = u * 1 + x * 0 + - u * 0.
    apply SNoL_E x Hx u Hu.
    assume Hua _ _.
    claim L1: w = u.
    { rewrite Hwuv.
      transitivity u * 1 + 0, u * 1.
      - prove u * 1 + x * 0 + - u * 0 = u * 1 + 0.
        f_equal.
        prove x * 0 + - u * 0 = 0.
        transitivity x * 0 + 0, x * 0.
        + prove x * 0 + - u * 0 = x * 0 + 0.
          f_equal.
          prove - u * 0 = 0.
          transitivity - 0.
          * prove - u * 0 = - 0. f_equal. exact mul_SNo_zeroR u Hua.
          * exact minus_SNo_0.
        + prove x * 0 + 0 = x * 0. exact add_SNo_0R (x * 0) (SNo_mul_SNo x 0 Hx SNo_0).
        + prove x * 0 = 0. exact mul_SNo_zeroR x Hx.
      - prove u * 1 + 0 = u * 1. exact add_SNo_0R (u * 1) (SNo_mul_SNo u 1 Hua SNo_1).
      - prove u * 1 = u. exact IHx u (SNoL_SNoS x Hx u Hu).
    }
    rewrite L1. exact Hu.
  + let u. assume Hu: u :e SNoR x.
    let v. rewrite SNoR_1. assume Hv: v :e 0.
    prove False. exact EmptyE v Hv.
- prove forall z :e R, SNoCut (SNoL x) (SNoR x) < z.
  let z. assume Hz.
  apply SNoCutP_SNoCut_R (SNoL x) (SNoR x) (SNoCutP_SNoL_SNoR x Hx).
  prove z :e SNoR x.
  apply HRE z Hz.
  + let u. assume Hu: u :e SNoL x.
    let v. rewrite SNoR_1. assume Hv: v :e 0.
    prove False. exact EmptyE v Hv.
  + let u. assume Hu: u :e SNoR x.
    let v. rewrite SNoL_1. assume Hv: v :e 1.
    apply cases_1 v Hv.
    assume Hzuv: z = u * 1 + x * 0 + - u * 0.
    apply SNoR_E x Hx u Hu.
    assume Hua _ _.
    claim L1: z = u.
    { rewrite Hzuv.
      transitivity u * 1 + 0, u * 1.
      - prove u * 1 + x * 0 + - u * 0 = u * 1 + 0.
        f_equal.
        prove x * 0 + - u * 0 = 0.
        transitivity x * 0 + 0, x * 0.
        + prove x * 0 + - u * 0 = x * 0 + 0.
          f_equal.
          prove - u * 0 = 0.
          transitivity - 0.
          * prove - u * 0 = - 0. f_equal. exact mul_SNo_zeroR u Hua.
          * exact minus_SNo_0.
        + prove x * 0 + 0 = x * 0. exact add_SNo_0R (x * 0) (SNo_mul_SNo x 0 Hx SNo_0).
        + prove x * 0 = 0. exact mul_SNo_zeroR x Hx.
      - prove u * 1 + 0 = u * 1. exact add_SNo_0R (u * 1) (SNo_mul_SNo u 1 Hua SNo_1).
      - prove u * 1 = u. exact IHx u (SNoR_SNoS x Hx u Hu).
    }
    rewrite L1. exact Hu.
- prove forall w :e SNoL x, w < SNoCut L R.
  let w. assume Hw.
  apply SNoL_E x Hx w Hw.
  assume Hwa _ _.
  rewrite <- Hx1e.
  prove w < x * 1.
  claim L1: w * 1 + x * 0 = w.
  { transitivity w * 1 + 0, w * 1.
    - f_equal. prove x * 0 = 0. exact mul_SNo_zeroR x Hx.
    - exact add_SNo_0R (w * 1) (SNo_mul_SNo w 1 Hwa SNo_1).
    - exact IHx w (SNoL_SNoS x Hx w Hw).
  }
  claim L2: x * 1 + w * 0 = x * 1.
  { transitivity x * 1 + 0.
    - f_equal. exact mul_SNo_zeroR w Hwa.
    - exact add_SNo_0R (x * 1) (SNo_mul_SNo x 1 Hx SNo_1).
  }
  rewrite <- L1. rewrite <- L2.
  prove w * 1 + x * 0 < x * 1 + w * 0.
  exact Hx11 w Hw 0 L0L1.
- prove forall z :e SNoR x, SNoCut L R < z.
  let z. assume Hz.
  apply SNoR_E x Hx z Hz.
  assume Hza _ _.
  rewrite <- Hx1e.
  prove x * 1 < z.
  claim L1: x * 1 + z * 0 = x * 1.
  { transitivity x * 1 + 0.
    - f_equal. exact mul_SNo_zeroR z Hza.
    - exact add_SNo_0R (x * 1) (SNo_mul_SNo x 1 Hx SNo_1).
  }
  claim L2: z * 1 + x * 0 = z.
  { transitivity z * 1 + 0, z * 1.
    - f_equal. prove x * 0 = 0. exact mul_SNo_zeroR x Hx.
    - exact add_SNo_0R (z * 1) (SNo_mul_SNo z 1 Hza SNo_1).
    - exact IHx z (SNoR_SNoS x Hx z Hz).
  }
  rewrite <- L2. rewrite <- L1.
  exact Hx14 z Hz 0 L0L1.
Qed.

Theorem mul_SNo_com : forall x y, SNo x -> SNo y -> x * y = y * x.
apply SNoLev_ind2.
let x y.
assume Hx Hy.
assume IHx: forall w :e SNoS_ (SNoLev x), w * y = y * w.
assume IHy: forall z :e SNoS_ (SNoLev y), x * z = z * x.
assume IHxy: forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), w * z = z * w.
apply mul_SNo_eq_3 x y Hx Hy.
let L R.
assume HLR HLE HLI1 HLI2 HRE HRI1 HRI2 Hxye.
apply mul_SNo_eq_3 y x Hy Hx.
let L' R'.
assume HL'R' HL'E HL'I1 HL'I2 HR'E HR'I1 HR'I2 Hyxe.
rewrite Hxye. rewrite Hyxe.
prove SNoCut L R = SNoCut L' R'.
claim LLL': L = L'.
{ apply set_ext.
  - prove L c= L'.
    apply mul_SNo_Subq_lem x y (SNoL x) (SNoL y) (SNoR x) (SNoR y) L L' HLE.
    + let u. assume Hu: u :e SNoL x.
      let v. assume Hv: v :e SNoL y.
      apply SNoL_E x Hx u Hu.
      assume Hua _ _.
      apply SNoL_E y Hy v Hv.
      assume Hva _ _.
      rewrite IHx u (SNoL_SNoS x Hx u Hu).
      rewrite IHy v (SNoL_SNoS y Hy v Hv).
      rewrite IHxy u (SNoL_SNoS x Hx u Hu) v (SNoL_SNoS y Hy v Hv).
      rewrite add_SNo_com_3_0_1 (y * u) (v * x) (- v * u)
                                (SNo_mul_SNo y u Hy Hua)
                                (SNo_mul_SNo v x Hva Hx)
                                (SNo_minus_SNo (v * u) (SNo_mul_SNo v u Hva Hua)).
      apply HL'I1.
      * exact Hv.
      * exact Hu.
    + let u. assume Hu: u :e SNoR x.
      let v. assume Hv: v :e SNoR y.
      apply SNoR_E x Hx u Hu.
      assume Hua _ _.
      apply SNoR_E y Hy v Hv.
      assume Hva _ _.
      rewrite IHx u (SNoR_SNoS x Hx u Hu).
      rewrite IHy v (SNoR_SNoS y Hy v Hv).
      rewrite IHxy u (SNoR_SNoS x Hx u Hu) v (SNoR_SNoS y Hy v Hv).
      rewrite add_SNo_com_3_0_1 (y * u) (v * x) (- v * u)
                                (SNo_mul_SNo y u Hy Hua)
                                (SNo_mul_SNo v x Hva Hx)
                                (SNo_minus_SNo (v * u) (SNo_mul_SNo v u Hva Hua)).
      apply HL'I2.
      * exact Hv.
      * exact Hu.
  - prove L' c= L.
    apply mul_SNo_Subq_lem y x (SNoL y) (SNoL x) (SNoR y) (SNoR x) L' L HL'E.
    + let v. assume Hv: v :e SNoL y.
      let u. assume Hu: u :e SNoL x.
      apply SNoL_E x Hx u Hu.
      assume Hua _ _.
      apply SNoL_E y Hy v Hv.
      assume Hva _ _.
      rewrite <- IHx u (SNoL_SNoS x Hx u Hu).
      rewrite <- IHy v (SNoL_SNoS y Hy v Hv).
      rewrite <- IHxy u (SNoL_SNoS x Hx u Hu) v (SNoL_SNoS y Hy v Hv).
      rewrite add_SNo_com_3_0_1 (x * v) (u * y) (- u * v)
                                (SNo_mul_SNo x v Hx Hva)
                                (SNo_mul_SNo u y Hua Hy)
                                (SNo_minus_SNo (u * v) (SNo_mul_SNo u v Hua Hva)).
      apply HLI1.
      * exact Hu.
      * exact Hv.
    + let v. assume Hv: v :e SNoR y.
      let u. assume Hu: u :e SNoR x.
      apply SNoR_E x Hx u Hu.
      assume Hua _ _.
      apply SNoR_E y Hy v Hv.
      assume Hva _ _.
      rewrite <- IHx u (SNoR_SNoS x Hx u Hu).
      rewrite <- IHy v (SNoR_SNoS y Hy v Hv).
      rewrite <- IHxy u (SNoR_SNoS x Hx u Hu) v (SNoR_SNoS y Hy v Hv).
      rewrite add_SNo_com_3_0_1 (x * v) (u * y) (- u * v)
                                (SNo_mul_SNo x v Hx Hva)
                                (SNo_mul_SNo u y Hua Hy)
                                (SNo_minus_SNo (u * v) (SNo_mul_SNo u v Hua Hva)).
      apply HLI2.
      * exact Hu.
      * exact Hv.
}
claim LRR': R = R'.
{ apply set_ext.
  - apply mul_SNo_Subq_lem x y (SNoL x) (SNoR y) (SNoR x) (SNoL y) R R' HRE.
    + let u. assume Hu: u :e SNoL x.
      let v. assume Hv: v :e SNoR y.
      apply SNoL_E x Hx u Hu.
      assume Hua _ _.
      apply SNoR_E y Hy v Hv.
      assume Hva _ _.
      rewrite IHx u (SNoL_SNoS x Hx u Hu).
      rewrite IHy v (SNoR_SNoS y Hy v Hv).
      rewrite IHxy u (SNoL_SNoS x Hx u Hu) v (SNoR_SNoS y Hy v Hv).
      rewrite add_SNo_com_3_0_1 (y * u) (v * x) (- v * u)
                                (SNo_mul_SNo y u Hy Hua)
                                (SNo_mul_SNo v x Hva Hx)
                                (SNo_minus_SNo (v * u) (SNo_mul_SNo v u Hva Hua)).
      apply HR'I2.
      * exact Hv.
      * exact Hu.
    + let u. assume Hu: u :e SNoR x.
      let v. assume Hv: v :e SNoL y.
      apply SNoR_E x Hx u Hu.
      assume Hua _ _.
      apply SNoL_E y Hy v Hv.
      assume Hva _ _.
      rewrite IHx u (SNoR_SNoS x Hx u Hu).
      rewrite IHy v (SNoL_SNoS y Hy v Hv).
      rewrite IHxy u (SNoR_SNoS x Hx u Hu) v (SNoL_SNoS y Hy v Hv).
      rewrite add_SNo_com_3_0_1 (y * u) (v * x) (- v * u)
                                (SNo_mul_SNo y u Hy Hua)
                                (SNo_mul_SNo v x Hva Hx)
                                (SNo_minus_SNo (v * u) (SNo_mul_SNo v u Hva Hua)).
      apply HR'I1.
      * exact Hv.
      * exact Hu.
  - apply mul_SNo_Subq_lem y x (SNoL y) (SNoR x) (SNoR y) (SNoL x) R' R HR'E.
    + let v. assume Hv: v :e SNoL y.
      let u. assume Hu: u :e SNoR x.
      apply SNoR_E x Hx u Hu.
      assume Hua _ _.
      apply SNoL_E y Hy v Hv.
      assume Hva _ _.
      rewrite <- IHx u (SNoR_SNoS x Hx u Hu).
      rewrite <- IHy v (SNoL_SNoS y Hy v Hv).
      rewrite <- IHxy u (SNoR_SNoS x Hx u Hu) v (SNoL_SNoS y Hy v Hv).
      rewrite add_SNo_com_3_0_1 (x * v) (u * y) (- u * v)
                                (SNo_mul_SNo x v Hx Hva)
                                (SNo_mul_SNo u y Hua Hy)
                                (SNo_minus_SNo (u * v) (SNo_mul_SNo u v Hua Hva)).
      apply HRI2.
      * exact Hu.
      * exact Hv.
    + let v. assume Hv: v :e SNoR y.
      let u. assume Hu: u :e SNoL x.
      apply SNoL_E x Hx u Hu.
      assume Hua _ _.
      apply SNoR_E y Hy v Hv.
      assume Hva _ _.
      rewrite <- IHx u (SNoL_SNoS x Hx u Hu).
      rewrite <- IHy v (SNoR_SNoS y Hy v Hv).
      rewrite <- IHxy u (SNoL_SNoS x Hx u Hu) v (SNoR_SNoS y Hy v Hv).
      rewrite add_SNo_com_3_0_1 (x * v) (u * y) (- u * v)
                                (SNo_mul_SNo x v Hx Hva)
                                (SNo_mul_SNo u y Hua Hy)
                                (SNo_minus_SNo (u * v) (SNo_mul_SNo u v Hua Hva)).
      apply HRI1.
      * exact Hu.
      * exact Hv.
}
rewrite LLL'. rewrite LRR'.
reflexivity.
Qed.

Theorem mul_SNo_minus_distrL : forall x y, SNo x -> SNo y -> (- x) * y = - x * y.
apply SNoLev_ind2.
let x y.
assume Hx Hy.
assume IHx: forall w :e SNoS_ (SNoLev x), (- w) * y = - w * y.
assume IHy: forall z :e SNoS_ (SNoLev y), (- x) * z = - x * z.
assume IHxy: forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), (- w) * z = - w * z.
claim Lmx: SNo (- x).
{ exact SNo_minus_SNo x Hx. }
apply mul_SNo_eq_3 x y Hx Hy.
let L R.
assume HLR HLE HLI1 HLI2 HRE HRI1 HRI2.
assume Hxye: x * y = SNoCut L R.
apply mul_SNo_eq_3 (- x) y (SNo_minus_SNo x Hx) Hy.
let L' R'.
assume HL'R' HL'E HL'I1 HL'I2 HR'E HR'I1 HR'I2.
assume Hmxye: (- x) * y = SNoCut L' R'.
claim L1: - (x * y) = SNoCut {- z | z :e R} {- w | w :e L}.
{ rewrite Hxye. exact minus_SNoCut_eq L R HLR. }
rewrite L1. rewrite Hmxye.
prove SNoCut L' R' = SNoCut {- z | z :e R} {- w | w :e L}.
f_equal.
- prove L' = {- z | z :e R}.
  apply set_ext.
  + apply mul_SNo_Subq_lem (- x) y (SNoL (- x)) (SNoL y) (SNoR (- x)) (SNoR y) L' {- z | z :e R} HL'E.
    * { let u. assume Hu: u :e SNoL (- x).
        let v. assume Hv: v :e SNoL y.
        apply SNoL_E (- x) Lmx u Hu.
        assume Hua: SNo u.
        assume Hub: SNoLev u :e SNoLev (- x).
        assume Huc: u < - x.
        apply SNoL_E y Hy v Hv.
        assume Hva _ _.
        claim Lmu1: SNo (- u).
        { exact SNo_minus_SNo u Hua. }
        claim Lmu2: - u :e SNoR x.
        { apply SNoR_I x Hx (- u) Lmu1.
          - prove SNoLev (- u) :e SNoLev x.
            rewrite minus_SNo_Lev u Hua.
            rewrite <- minus_SNo_Lev x Hx.
            exact Hub.
          - prove x < - u. exact minus_SNo_Lt_contra2 u x Hua Hx Huc.
        }
        prove u * y + (- x) * v + - u * v :e {- z | z :e R}.
        claim L1: u * y + (- x) * v + - u * v = - ((- u) * y + x * v + - (- u) * v).
        { symmetry.
          transitivity - (- u) * y + - x * v + - - (- u) * v.
          - exact minus_add_SNo_distr_3 ((- u) * y) (x * v) (- (- u) * v)
                          (SNo_mul_SNo (- u) y Lmu1 Hy)
                          (SNo_mul_SNo x v Hx Hva)
                          (SNo_minus_SNo ((- u) * v) (SNo_mul_SNo (- u) v Lmu1 Hva)).
          - f_equal.
            + prove - (- u) * y = u * y.
              transitivity (- - u) * y.
              * symmetry. exact IHx (- u) (SNoR_SNoS x Hx (- u) Lmu2).
              * rewrite minus_SNo_invol u Hua. reflexivity.
            + f_equal.
              * prove - x * v = (- x) * v.
                symmetry.
                exact IHy v (SNoL_SNoS y Hy v Hv).
              * { f_equal. prove - (- u) * v = u * v.
                  transitivity (- - u) * v.
                  - symmetry. prove (- - u) * v = - (- u) * v.
                    exact IHxy (- u) (SNoR_SNoS x Hx (- u) Lmu2) v (SNoL_SNoS y Hy v Hv).
                  - rewrite minus_SNo_invol u Hua. reflexivity.
                }
        }
        rewrite L1.
        prove - ((- u) * y + x * v + - (- u) * v) :e {- z | z :e R}.
        apply ReplI R (fun z => - z).
        prove (- u) * y + x * v + - (- u) * v :e R.
        apply HRI2.
        - prove - u :e SNoR x. exact Lmu2.
        - prove v :e SNoL y. exact Hv.
      }
    * { let u. assume Hu: u :e SNoR (- x).
        let v. assume Hv: v :e SNoR y.
        apply SNoR_E (- x) Lmx u Hu.
        assume Hua: SNo u.
        assume Hub: SNoLev u :e SNoLev (- x).
        assume Huc: -x < u.
        apply SNoR_E y Hy v Hv.
        assume Hva _ _.
        claim Lmu1: SNo (- u).
        { exact SNo_minus_SNo u Hua. }
        claim Lmu2: - u :e SNoL x.
        { apply SNoL_I x Hx (- u) Lmu1.
          - prove SNoLev (- u) :e SNoLev x.
            rewrite minus_SNo_Lev u Hua.
            rewrite <- minus_SNo_Lev x Hx.
            exact Hub.
          - prove -u < x. exact minus_SNo_Lt_contra1 x u Hx Hua Huc.
        }
        prove u * y + (- x) * v + - u * v :e {- z | z :e R}.
        claim L1: u * y + (- x) * v + - u * v = - ((- u) * y + x * v + - (- u) * v).
        { symmetry.
          transitivity - (- u) * y + - x * v + - - (- u) * v.
          - exact minus_add_SNo_distr_3 ((- u) * y) (x * v) (- (- u) * v)
                          (SNo_mul_SNo (- u) y Lmu1 Hy)
                          (SNo_mul_SNo x v Hx Hva)
                          (SNo_minus_SNo ((- u) * v) (SNo_mul_SNo (- u) v Lmu1 Hva)).
          - f_equal.
            + prove - (- u) * y = u * y.
              transitivity (- - u) * y.
              * symmetry. exact IHx (- u) (SNoL_SNoS x Hx (- u) Lmu2).
              * rewrite minus_SNo_invol u Hua. reflexivity.
            + f_equal.
              * prove - x * v = (- x) * v.
                symmetry.
                exact IHy v (SNoR_SNoS y Hy v Hv).
              * { f_equal. prove - (- u) * v = u * v.
                  transitivity (- - u) * v.
                  - symmetry. prove (- - u) * v = - (- u) * v.
                    exact IHxy (- u) (SNoL_SNoS x Hx (- u) Lmu2) v (SNoR_SNoS y Hy v Hv).
                  - rewrite minus_SNo_invol u Hua. reflexivity.
                }
        }
        rewrite L1.
        prove - ((- u) * y + x * v + - (- u) * v) :e {- z | z :e R}.
        apply ReplI R (fun z => - z).
        prove (- u) * y + x * v + - (- u) * v :e R.
        apply HRI1.
        - prove - u :e SNoL x. exact Lmu2.
        - prove v :e SNoR y. exact Hv.
      }
  + prove {- z | z :e R} c= L'.
    let a. assume Ha.
    apply ReplE_impred R (fun z => - z) a Ha.
    let z. assume Hz: z :e R. assume Hze: a = - z.
    rewrite Hze.
    prove - z :e L'.
    apply HRE z Hz.
    * { let u. assume Hu: u :e SNoL x.
        let v. assume Hv: v :e SNoR y.
        assume Hzuv: z = u * y + x * v + - u * v.
        apply SNoL_E x Hx u Hu.
        assume Hua: SNo u.
        assume Hub: SNoLev u :e SNoLev x.
        assume Huc: u < x.
        apply SNoR_E y Hy v Hv.
        assume Hva _ _.
        claim Lmu1: SNo (- u).
        { exact SNo_minus_SNo u Hua. }
        claim Lmu2: - u :e SNoR (- x).
        { apply SNoR_I (- x) (SNo_minus_SNo x Hx) (- u) Lmu1.
          - prove SNoLev (- u) :e SNoLev (- x).
            rewrite minus_SNo_Lev u Hua.
            rewrite minus_SNo_Lev x Hx.
            exact Hub.
          - prove -x < -u. exact minus_SNo_Lt_contra u x Hua Hx Huc.
        }
        claim L1: - z = (- u) * y + (- x) * v + - (- u) * v.
        { rewrite Hzuv.
          rewrite minus_add_SNo_distr_3 (u * y) (x * v) (- (u * v))
                                        (SNo_mul_SNo u y Hua Hy)
                                        (SNo_mul_SNo x v Hx Hva)
                                        (SNo_minus_SNo (u * v) (SNo_mul_SNo u v Hua Hva)).
          f_equal.
          - prove - (u * y) = (- u) * y. symmetry. exact IHx u (SNoL_SNoS x Hx u Hu).
          - f_equal.
            + prove - (x * v) = (- x) * v. symmetry. exact IHy v (SNoR_SNoS y Hy v Hv).
            + f_equal. prove - (u * v) = (- u) * v. symmetry. exact IHxy u (SNoL_SNoS x Hx u Hu) v (SNoR_SNoS y Hy v Hv).
        }
        rewrite L1.
        prove (- u) * y + (- x) * v + - (- u) * v :e L'.
        apply HL'I2.
        + exact Lmu2.
        + exact Hv.
      }
    * { let u. assume Hu: u :e SNoR x.
        let v. assume Hv: v :e SNoL y.
        assume Hzuv: z = u * y + x * v + - u * v.
        apply SNoR_E x Hx u Hu.
        assume Hua: SNo u.
        assume Hub: SNoLev u :e SNoLev x.
        assume Huc: x < u.
        apply SNoL_E y Hy v Hv.
        assume Hva _ _.
        claim Lmu1: SNo (- u).
        { exact SNo_minus_SNo u Hua. }
        claim Lmu2: - u :e SNoL (- x).
        { apply SNoL_I (- x) (SNo_minus_SNo x Hx) (- u) Lmu1.
          - prove SNoLev (- u) :e SNoLev (- x).
            rewrite minus_SNo_Lev u Hua.
            rewrite minus_SNo_Lev x Hx.
            exact Hub.
          - prove -u < -x. exact minus_SNo_Lt_contra x u Hx Hua Huc.
        }
        claim L1: - z = (- u) * y + (- x) * v + - (- u) * v.
        { rewrite Hzuv.
          rewrite minus_add_SNo_distr_3 (u * y) (x * v) (- (u * v))
                                        (SNo_mul_SNo u y Hua Hy)
                                        (SNo_mul_SNo x v Hx Hva)
                                        (SNo_minus_SNo (u * v) (SNo_mul_SNo u v Hua Hva)).
          f_equal.
          - prove - (u * y) = (- u) * y. symmetry. exact IHx u (SNoR_SNoS x Hx u Hu).
          - f_equal.
            + prove - (x * v) = (- x) * v. symmetry. exact IHy v (SNoL_SNoS y Hy v Hv).
            + f_equal. prove - (u * v) = (- u) * v. symmetry. exact IHxy u (SNoR_SNoS x Hx u Hu) v (SNoL_SNoS y Hy v Hv).
        }
        rewrite L1.
        prove (- u) * y + (- x) * v + - (- u) * v :e L'.
        apply HL'I1.
        + exact Lmu2.
        + exact Hv.
      }
- prove R' = {- w | w :e L}.
  apply set_ext.
  + apply mul_SNo_Subq_lem (- x) y (SNoL (- x)) (SNoR y) (SNoR (- x)) (SNoL y) R' {- w | w :e L} HR'E.
    * { let u. assume Hu: u :e SNoL (- x).
        let v. assume Hv: v :e SNoR y.
        apply SNoL_E (- x) Lmx u Hu.
        assume Hua: SNo u.
        assume Hub: SNoLev u :e SNoLev (- x).
        assume Huc: u < - x.
        apply SNoR_E y Hy v Hv.
        assume Hva _ _.
        claim Lmu1: SNo (- u).
        { exact SNo_minus_SNo u Hua. }
        claim Lmu2: - u :e SNoR x.
        { apply SNoR_I x Hx (- u) Lmu1.
          - prove SNoLev (- u) :e SNoLev x.
            rewrite minus_SNo_Lev u Hua.
            rewrite <- minus_SNo_Lev x Hx.
            exact Hub.
          - prove x < - u. exact minus_SNo_Lt_contra2 u x Hua Hx Huc.
        }
        prove u * y + (- x) * v + - u * v :e {- w | w :e L}.
        claim L1: u * y + (- x) * v + - u * v = - ((- u) * y + x * v + - (- u) * v).
        { symmetry.
          transitivity - (- u) * y + - x * v + - - (- u) * v.
          - exact minus_add_SNo_distr_3 ((- u) * y) (x * v) (- (- u) * v)
                          (SNo_mul_SNo (- u) y Lmu1 Hy)
                          (SNo_mul_SNo x v Hx Hva)
                          (SNo_minus_SNo ((- u) * v) (SNo_mul_SNo (- u) v Lmu1 Hva)).
          - f_equal.
            + prove - (- u) * y = u * y.
              transitivity (- - u) * y.
              * symmetry. exact IHx (- u) (SNoR_SNoS x Hx (- u) Lmu2).
              * rewrite minus_SNo_invol u Hua. reflexivity.
            + f_equal.
              * prove - x * v = (- x) * v.
                symmetry.
                exact IHy v (SNoR_SNoS y Hy v Hv).
              * { f_equal. prove - (- u) * v = u * v.
                  transitivity (- - u) * v.
                  - symmetry. prove (- - u) * v = - (- u) * v.
                    exact IHxy (- u) (SNoR_SNoS x Hx (- u) Lmu2) v (SNoR_SNoS y Hy v Hv).
                  - rewrite minus_SNo_invol u Hua. reflexivity.
                }
        }
        rewrite L1.
        prove - ((- u) * y + x * v + - (- u) * v) :e {- w | w :e L}.
        apply ReplI L (fun w => - w).
        prove (- u) * y + x * v + - (- u) * v :e L.
        apply HLI2.
        - prove - u :e SNoR x. exact Lmu2.
        - prove v :e SNoR y. exact Hv.
      }
    * { let u. assume Hu: u :e SNoR (- x).
        let v. assume Hv: v :e SNoL y.
        apply SNoR_E (- x) Lmx u Hu.
        assume Hua: SNo u.
        assume Hub: SNoLev u :e SNoLev (- x).
        assume Huc: -x < u.
        apply SNoL_E y Hy v Hv.
        assume Hva _ _.
        claim Lmu1: SNo (- u).
        { exact SNo_minus_SNo u Hua. }
        claim Lmu2: - u :e SNoL x.
        { apply SNoL_I x Hx (- u) Lmu1.
          - prove SNoLev (- u) :e SNoLev x.
            rewrite minus_SNo_Lev u Hua.
            rewrite <- minus_SNo_Lev x Hx.
            exact Hub.
          - prove -u < x. exact minus_SNo_Lt_contra1 x u Hx Hua Huc.
        }
        prove u * y + (- x) * v + - u * v :e {- w | w :e L}.
        claim L1: u * y + (- x) * v + - u * v = - ((- u) * y + x * v + - (- u) * v).
        { symmetry.
          transitivity - (- u) * y + - x * v + - - (- u) * v.
          - exact minus_add_SNo_distr_3 ((- u) * y) (x * v) (- (- u) * v)
                          (SNo_mul_SNo (- u) y Lmu1 Hy)
                          (SNo_mul_SNo x v Hx Hva)
                          (SNo_minus_SNo ((- u) * v) (SNo_mul_SNo (- u) v Lmu1 Hva)).
          - f_equal.
            + prove - (- u) * y = u * y.
              transitivity (- - u) * y.
              * symmetry. exact IHx (- u) (SNoL_SNoS x Hx (- u) Lmu2).
              * rewrite minus_SNo_invol u Hua. reflexivity.
            + f_equal.
              * prove - x * v = (- x) * v.
                symmetry.
                exact IHy v (SNoL_SNoS y Hy v Hv).
              * { f_equal. prove - (- u) * v = u * v.
                  transitivity (- - u) * v.
                  - symmetry. prove (- - u) * v = - (- u) * v.
                    exact IHxy (- u) (SNoL_SNoS x Hx (- u) Lmu2) v (SNoL_SNoS y Hy v Hv).
                  - rewrite minus_SNo_invol u Hua. reflexivity.
                }
        }
        rewrite L1.
        prove - ((- u) * y + x * v + - (- u) * v) :e {- w | w :e L}.
        apply ReplI L (fun w => - w).
        prove (- u) * y + x * v + - (- u) * v :e L.
        apply HLI1.
        - prove - u :e SNoL x. exact Lmu2.
        - prove v :e SNoL y. exact Hv.
      }
  + prove {- w | w :e L} c= R'.
    let a. assume Ha.
    apply ReplE_impred L (fun w => - w) a Ha.
    let w. assume Hw: w :e L. assume Hwe: a = - w.
    rewrite Hwe.
    prove - w :e R'.
    apply HLE w Hw.
    * { let u. assume Hu: u :e SNoL x.
        let v. assume Hv: v :e SNoL y.
        assume Hwuv: w = u * y + x * v + - u * v.
        apply SNoL_E x Hx u Hu.
        assume Hua: SNo u.
        assume Hub: SNoLev u :e SNoLev x.
        assume Huc: u < x.
        apply SNoL_E y Hy v Hv.
        assume Hva _ _.
        claim Lmu1: SNo (- u).
        { exact SNo_minus_SNo u Hua. }
        claim Lmu2: - u :e SNoR (- x).
        { apply SNoR_I (- x) (SNo_minus_SNo x Hx) (- u) Lmu1.
          - prove SNoLev (- u) :e SNoLev (- x).
            rewrite minus_SNo_Lev u Hua.
            rewrite minus_SNo_Lev x Hx.
            exact Hub.
          - prove -x < -u. exact minus_SNo_Lt_contra u x Hua Hx Huc.
        }
        claim L1: - w = (- u) * y + (- x) * v + - (- u) * v.
        { rewrite Hwuv.
          rewrite minus_add_SNo_distr_3 (u * y) (x * v) (- (u * v))
                                        (SNo_mul_SNo u y Hua Hy)
                                        (SNo_mul_SNo x v Hx Hva)
                                        (SNo_minus_SNo (u * v) (SNo_mul_SNo u v Hua Hva)).
          f_equal.
          - prove - (u * y) = (- u) * y. symmetry. exact IHx u (SNoL_SNoS x Hx u Hu).
          - f_equal.
            + prove - (x * v) = (- x) * v. symmetry. exact IHy v (SNoL_SNoS y Hy v Hv).
            + f_equal. prove - (u * v) = (- u) * v. symmetry. exact IHxy u (SNoL_SNoS x Hx u Hu) v (SNoL_SNoS y Hy v Hv).
        }
        rewrite L1.
        prove (- u) * y + (- x) * v + - (- u) * v :e R'.
        apply HR'I2.
        + exact Lmu2.
        + exact Hv.
      }
    * { let u. assume Hu: u :e SNoR x.
        let v. assume Hv: v :e SNoR y.
        assume Hwuv: w = u * y + x * v + - u * v.
        apply SNoR_E x Hx u Hu.
        assume Hua: SNo u.
        assume Hub: SNoLev u :e SNoLev x.
        assume Huc: x < u.
        apply SNoR_E y Hy v Hv.
        assume Hva _ _.
        claim Lmu1: SNo (- u).
        { exact SNo_minus_SNo u Hua. }
        claim Lmu2: - u :e SNoL (- x).
        { apply SNoL_I (- x) (SNo_minus_SNo x Hx) (- u) Lmu1.
          - prove SNoLev (- u) :e SNoLev (- x).
            rewrite minus_SNo_Lev u Hua.
            rewrite minus_SNo_Lev x Hx.
            exact Hub.
          - prove -u < -x. exact minus_SNo_Lt_contra x u Hx Hua Huc.
        }
        claim L1: - w = (- u) * y + (- x) * v + - (- u) * v.
        { rewrite Hwuv.
          rewrite minus_add_SNo_distr_3 (u * y) (x * v) (- (u * v))
                                        (SNo_mul_SNo u y Hua Hy)
                                        (SNo_mul_SNo x v Hx Hva)
                                        (SNo_minus_SNo (u * v) (SNo_mul_SNo u v Hua Hva)).
          f_equal.
          - prove - (u * y) = (- u) * y. symmetry. exact IHx u (SNoR_SNoS x Hx u Hu).
          - f_equal.
            + prove - (x * v) = (- x) * v. symmetry. exact IHy v (SNoR_SNoS y Hy v Hv).
            + f_equal. prove - (u * v) = (- u) * v. symmetry. exact IHxy u (SNoR_SNoS x Hx u Hu) v (SNoR_SNoS y Hy v Hv).
        }
        rewrite L1.
        prove (- u) * y + (- x) * v + - (- u) * v :e R'.
        apply HR'I1.
        + exact Lmu2.
        + exact Hv.
      }
Qed.

Theorem mul_SNo_minus_distrR: forall x y, SNo x -> SNo y -> x * (- y) = - (x * y).
let x y. assume Hx Hy.
rewrite mul_SNo_com x y Hx Hy.
rewrite mul_SNo_com x (- y) Hx (SNo_minus_SNo y Hy).
exact mul_SNo_minus_distrL y x Hy Hx.
Qed.

Theorem mul_SNo_distrR : forall x y z, SNo x -> SNo y -> SNo z
  -> (x + y) * z = x * z + y * z.
set P : set -> set -> set -> prop := fun x y z => (x + y) * z = x * z + y * z.
prove forall x y z, SNo x -> SNo y -> SNo z -> P x y z.
apply SNoLev_ind3 P.
let x y z. assume Hx Hy Hz.
assume IHx: forall u :e SNoS_ (SNoLev x), (u + y) * z = u * z + y * z.
assume IHy: forall v :e SNoS_ (SNoLev y), (x + v) * z = x * z + v * z.
assume IHz: forall w :e SNoS_ (SNoLev z), (x + y) * w = x * w + y * w.
assume IHxy: forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), (u + v) * z = u * z + v * z.
assume IHxz: forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), (u + y) * w = u * w + y * w.
assume IHyz: forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), (x + v) * w = x * w + v * w.
assume IHxyz: forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), (u + v) * w = u * w + v * w.
prove (x + y) * z = x * z + y * z.
apply mul_SNo_eq_3 (x + y) z (SNo_add_SNo x y Hx Hy) Hz.
let L R. assume HLR HLE HLI1 HLI2 HRE HRI1 HRI2.
assume HE: (x + y) * z = SNoCut L R.
set L1 := {w + y * z | w :e SNoL (x * z)}.
set L2 := {x * z + w | w :e SNoL (y * z)}.
set R1 := {w + y * z | w :e SNoR (x * z)}.
set R2 := {x * z + w | w :e SNoR (y * z)}.
claim Lxy: SNo (x + y).
{ exact SNo_add_SNo x y Hx Hy. }
claim Lxyz: SNo ((x + y) * z).
{ exact SNo_mul_SNo (x + y) z Lxy Hz. }
claim Lxz: SNo (x * z).
{ exact SNo_mul_SNo x z Hx Hz. }
claim Lyz: SNo (y * z).
{ exact SNo_mul_SNo y z Hy Hz. }
claim Lxzyz: SNo (x * z + y * z).
{ exact SNo_add_SNo (x * z) (y * z) Lxz Lyz. }
claim LE: x * z + y * z = SNoCut (L1 :\/: L2) (R1 :\/: R2).
{ exact add_SNo_eq (x * z) (SNo_mul_SNo x z Hx Hz) (y * z) (SNo_mul_SNo y z Hy Hz). }
rewrite HE. rewrite LE.
apply SNoCut_ext.
- exact HLR.
- exact add_SNo_SNoCutP (x * z) (y * z) (SNo_mul_SNo x z Hx Hz) (SNo_mul_SNo y z Hy Hz).
- let u. assume Hu: u :e L. rewrite <- LE.
  prove u < x * z + y * z.
  apply HLE u Hu.
  + let v. assume Hv: v :e SNoL (x + y).
    let w. assume Hw: w :e SNoL z.
    assume Hue: u = v * z + (x + y) * w + - v * w.
    rewrite Hue.
    prove v * z + (x + y) * w + - v * w < x * z + y * z.
    apply SNoL_E (x + y) Lxy v Hv.
    assume Hv1 Hv2 Hv3.
    apply SNoL_E z Hz w Hw.
    assume Hw1 Hw2 Hw3.
    claim Lxw: SNo (x * w).
    { exact SNo_mul_SNo x w Hx Hw1. }
    claim Lyw: SNo (y * w).
    { exact SNo_mul_SNo y w Hy Hw1. }
    claim Lvz: SNo (v * z).
    { exact SNo_mul_SNo v z Hv1 Hz. }
    claim Lxyw: SNo ((x + y) * w).
    { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
    claim Lxwyw: SNo (x * w + y * w).
    { exact SNo_add_SNo (x * w) (y * w) Lxw Lyw. }
    claim Lvw: SNo (v * w).
    { exact SNo_mul_SNo v w Hv1 Hw1. }
    claim Lvzxwyw: SNo (v * z + x * w + y * w).
    { exact SNo_add_SNo_3 (v * z) (x * w) (y * w) Lvz Lxw Lyw. }
    claim Lxzyzvw: SNo (x * z + y * z + v * w).
    { exact SNo_add_SNo_3 (x * z) (y * z) (v * w) Lxz Lyz Lvw. }
    apply add_SNo_minus_Lt1b3 (v * z) ((x + y) * w) (v * w) (x * z + y * z)
                              Lvz Lxyw Lvw Lxzyz.
    prove v * z + (x + y) * w < (x * z + y * z) + v * w.
    rewrite IHz w (SNoL_SNoS z Hz w Hw).
    prove v * z + x * w + y * w < (x * z + y * z) + v * w.
    rewrite <- add_SNo_assoc (x * z) (y * z) (v * w) Lxz Lyz Lvw.
    prove v * z + x * w + y * w < x * z + y * z + v * w.
    apply add_SNo_SNoL_interpolate x y Hx Hy v Hv.
    * { assume H1. apply H1.
        let u. assume H1. apply H1.
        assume Hu: u :e SNoL x.
        assume Hvu: v <= u + y.
        apply SNoL_E x Hx u Hu.
        assume Hu1 Hu2 Hu3.
        claim Luw: SNo (u * w).
        { exact SNo_mul_SNo u w Hu1 Hw1. }
        claim Luz: SNo (u * z).
        { exact SNo_mul_SNo u z Hu1 Hz. }
        claim Luy: SNo (u + y).
        { exact SNo_add_SNo u y Hu1 Hy. }
        apply add_SNo_Lt1_cancel (v * z + x * w + y * w)
                                 (u * w)
                                 (x * z + y * z + v * w)
                                   Lvzxwyw Luw Lxzyzvw.
        prove (v * z + x * w + y * w) + u * w < (x * z + y * z + v * w) + u * w.
        rewrite <- add_SNo_assoc_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw.
        rewrite <- add_SNo_assoc_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw.
        prove v * z + x * w + y * w + u * w < x * z + y * z + v * w + u * w.
        apply SNoLeLt_tra (v * z + x * w + y * w + u * w)
                          (u * z + y * z + v * w + x * w)
                          (x * z + y * z + v * w + u * w)
                          (SNo_add_SNo_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw)
                          (SNo_add_SNo_4 (u * z) (y * z) (v * w) (x * w) Luz Lyz Lvw Lxw)
                          (SNo_add_SNo_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw).
        - prove v * z + x * w + y * w + u * w <= u * z + y * z + v * w + x * w.
          rewrite add_SNo_com_3_0_1 (v * z) (x * w) (y * w + u * w) Lvz Lxw (SNo_add_SNo (y * w) (u * w) Lyw Luw).
          prove x * w + v * z + y * w + u * w <= u * z + y * z + v * w + x * w.
          rewrite add_SNo_rotate_4_1 (u * z) (y * z) (v * w) (x * w) Luz Lyz Lvw Lxw.
          prove x * w + v * z + y * w + u * w <= x * w + u * z + y * z + v * w.
          apply add_SNo_Le2 (x * w) (v * z + y * w + u * w) (u * z + y * z + v * w)
                            Lxw
                            (SNo_add_SNo_3 (v * z) (y * w) (u * w) Lvz Lyw Luw)
                            (SNo_add_SNo_3 (u * z) (y * z) (v * w) Luz Lyz Lvw).
          prove v * z + y * w + u * w <= u * z + y * z + v * w.
          rewrite add_SNo_com (y * w) (u * w) Lyw Luw.
          prove v * z + u * w + y * w <= u * z + y * z + v * w.
          rewrite <- IHxz u (SNoL_SNoS x Hx u Hu) w (SNoL_SNoS z Hz w Hw).
          prove v * z + (u + y) * w <= u * z + y * z + v * w.
          rewrite add_SNo_assoc (u * z) (y * z) (v * w) Luz Lyz Lvw.
          prove v * z + (u + y) * w <= (u * z + y * z) + v * w.
          rewrite <- IHx u (SNoL_SNoS x Hx u Hu).
          prove v * z + (u + y) * w <= (u + y) * z + v * w.
          apply mul_SNo_Le (u + y) z v w Luy Hz Hv1 Hw1.
          + prove v <= u + y. exact Hvu.
          + prove w <= z. apply SNoLtLe. prove w < z. exact Hw3.
        - prove u * z + y * z + v * w + x * w < x * z + y * z + v * w + u * w.
          rewrite add_SNo_com_3_0_1 (u * z) (y * z) (v * w + x * w) Luz Lyz (SNo_add_SNo (v * w) (x * w) Lvw Lxw).
          rewrite add_SNo_com_3_0_1 (x * z) (y * z) (v * w + u * w) Lxz Lyz (SNo_add_SNo (v * w) (u * w) Lvw Luw).
          prove y * z + u * z + v * w + x * w < y * z + x * z + v * w + u * w.
          apply add_SNo_Lt2 (y * z) (u * z + v * w + x * w) (x * z + v * w + u * w)
                            Lyz
                            (SNo_add_SNo_3 (u * z) (v * w) (x * w) Luz Lvw Lxw)
                            (SNo_add_SNo_3 (x * z) (v * w) (u * w) Lxz Lvw Luw).
          prove u * z + v * w + x * w < x * z + v * w + u * w.
          rewrite add_SNo_com_3_0_1 (u * z) (v * w) (x * w) Luz Lvw Lxw.
          rewrite add_SNo_com_3_0_1 (x * z) (v * w) (u * w) Lxz Lvw Luw.
          prove v * w + u * z + x * w < v * w + x * z + u * w.
          apply add_SNo_Lt2 (v * w) (u * z + x * w) (x * z + u * w) Lvw
                            (SNo_add_SNo (u * z) (x * w) Luz Lxw)
                            (SNo_add_SNo (x * z) (u * w) Lxz Luw).
          prove u * z + x * w < x * z + u * w.
          exact mul_SNo_Lt x z u w Hx Hz Hu1 Hw1 Hu3 Hw3.
      }
    * { assume H1. apply H1.
        let u. assume H1. apply H1.
        assume Hu: u :e SNoL y.
        assume Hvu: v <= x + u.
        apply SNoL_E y Hy u Hu.
        assume Hu1 Hu2 Hu3.
        claim Luw: SNo (u * w).
        { exact SNo_mul_SNo u w Hu1 Hw1. }
        claim Luz: SNo (u * z).
        { exact SNo_mul_SNo u z Hu1 Hz. }
        claim Lxu: SNo (x + u).
        { exact SNo_add_SNo x u Hx Hu1. }
        apply add_SNo_Lt1_cancel (v * z + x * w + y * w)
                                 (u * w)
                                 (x * z + y * z + v * w)
                                   Lvzxwyw Luw Lxzyzvw.
        prove (v * z + x * w + y * w) + u * w < (x * z + y * z + v * w) + u * w.
        rewrite <- add_SNo_assoc_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw.
        rewrite <- add_SNo_assoc_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw.
        prove v * z + x * w + y * w + u * w < x * z + y * z + v * w + u * w.
        apply SNoLeLt_tra (v * z + x * w + y * w + u * w)
                          (x * z + u * z + v * w + y * w)
                          (x * z + y * z + v * w + u * w)
                          (SNo_add_SNo_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw)
                          (SNo_add_SNo_4 (x * z) (u * z) (v * w) (y * w) Lxz Luz Lvw Lyw)
                          (SNo_add_SNo_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw).
        - prove v * z + x * w + y * w + u * w <= x * z + u * z + v * w + y * w.
          rewrite add_SNo_com (y * w) (u * w) Lyw Luw.
          prove v * z + x * w + u * w + y * w <= x * z + u * z + v * w + y * w.
          rewrite add_SNo_rotate_4_1 (v * z) (x * w) (u * w) (y * w) Lvz Lxw Luw Lyw.
          prove y * w + v * z + x * w + u * w <= x * z + u * z + v * w + y * w.
          rewrite add_SNo_rotate_4_1 (x * z) (u * z) (v * w) (y * w) Lxz Luz Lvw Lyw.
          prove y * w + v * z + x * w + u * w <= y * w + x * z + u * z + v * w.
          apply add_SNo_Le2 (y * w) (v * z + x * w + u * w) (x * z + u * z + v * w)
                            Lyw
                            (SNo_add_SNo_3 (v * z) (x * w) (u * w) Lvz Lxw Luw)
                            (SNo_add_SNo_3 (x * z) (u * z) (v * w) Lxz Luz Lvw).
          prove v * z + x * w + u * w <= x * z + u * z + v * w.
          rewrite <- IHyz u (SNoL_SNoS y Hy u Hu) w (SNoL_SNoS z Hz w Hw).
          prove v * z + (x + u) * w <= x * z + u * z + v * w.
          rewrite add_SNo_assoc (x * z) (u * z) (v * w) Lxz Luz Lvw.
          prove v * z + (x + u) * w <= (x * z + u * z) + v * w.
          rewrite <- IHy u (SNoL_SNoS y Hy u Hu).
          prove v * z + (x + u) * w <= (x + u) * z + v * w.
          apply mul_SNo_Le (x + u) z v w Lxu Hz Hv1 Hw1.
          + prove v <= x + u. exact Hvu.
          + prove w <= z. apply SNoLtLe. prove w < z. exact Hw3.
        - prove x * z + u * z + v * w + y * w < x * z + y * z + v * w + u * w.
          apply add_SNo_Lt2 (x * z) (u * z + v * w + y * w) (y * z + v * w + u * w)
                            Lxz
                            (SNo_add_SNo_3 (u * z) (v * w) (y * w) Luz Lvw Lyw)
                            (SNo_add_SNo_3 (y * z) (v * w) (u * w) Lyz Lvw Luw).
          prove u * z + v * w + y * w < y * z + v * w + u * w.
          rewrite add_SNo_com_3_0_1 (u * z) (v * w) (y * w) Luz Lvw Lyw.
          rewrite add_SNo_com_3_0_1 (y * z) (v * w) (u * w) Lyz Lvw Luw.
          prove v * w + u * z + y * w < v * w + y * z + u * w.
          apply add_SNo_Lt2 (v * w) (u * z + y * w) (y * z + u * w) Lvw
                            (SNo_add_SNo (u * z) (y * w) Luz Lyw)
                            (SNo_add_SNo (y * z) (u * w) Lyz Luw).
          prove u * z + y * w < y * z + u * w.
          exact mul_SNo_Lt y z u w Hy Hz Hu1 Hw1 Hu3 Hw3.
      }
  + let v. assume Hv: v :e SNoR (x + y).
    let w. assume Hw: w :e SNoR z.
    assume Hue: u = v * z + (x + y) * w + - v * w.
    rewrite Hue.
    prove v * z + (x + y) * w + - v * w < x * z + y * z.
    apply SNoR_E (x + y) Lxy v Hv.
    assume Hv1 Hv2 Hv3.
    apply SNoR_E z Hz w Hw.
    assume Hw1 Hw2 Hw3.
    claim Lxw: SNo (x * w).
    { exact SNo_mul_SNo x w Hx Hw1. }
    claim Lyw: SNo (y * w).
    { exact SNo_mul_SNo y w Hy Hw1. }
    claim Lvz: SNo (v * z).
    { exact SNo_mul_SNo v z Hv1 Hz. }
    claim Lxyw: SNo ((x + y) * w).
    { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
    claim Lxwyw: SNo (x * w + y * w).
    { exact SNo_add_SNo (x * w) (y * w) Lxw Lyw. }
    claim Lvw: SNo (v * w).
    { exact SNo_mul_SNo v w Hv1 Hw1. }
    claim Lvzxwyw: SNo (v * z + x * w + y * w).
    { exact SNo_add_SNo_3 (v * z) (x * w) (y * w) Lvz Lxw Lyw. }
    claim Lxzyzvw: SNo (x * z + y * z + v * w).
    { exact SNo_add_SNo_3 (x * z) (y * z) (v * w) Lxz Lyz Lvw. }
    apply add_SNo_minus_Lt1b3 (v * z) ((x + y) * w) (v * w) (x * z + y * z)
                              Lvz Lxyw Lvw Lxzyz.
    prove v * z + (x + y) * w < (x * z + y * z) + v * w.
    rewrite IHz w (SNoR_SNoS z Hz w Hw).
    prove v * z + x * w + y * w < (x * z + y * z) + v * w.
    rewrite <- add_SNo_assoc (x * z) (y * z) (v * w) Lxz Lyz Lvw.
    prove v * z + x * w + y * w < x * z + y * z + v * w.
    apply add_SNo_SNoR_interpolate x y Hx Hy v Hv.
    * { assume H1. apply H1.
        let u. assume H1. apply H1.
        assume Hu: u :e SNoR x.
        assume Hvu: u + y <= v.
        apply SNoR_E x Hx u Hu.
        assume Hu1 Hu2 Hu3.
        claim Luw: SNo (u * w).
        { exact SNo_mul_SNo u w Hu1 Hw1. }
        claim Luz: SNo (u * z).
        { exact SNo_mul_SNo u z Hu1 Hz. }
        claim Luy: SNo (u + y).
        { exact SNo_add_SNo u y Hu1 Hy. }
        apply add_SNo_Lt1_cancel (v * z + x * w + y * w)
                                 (u * w)
                                 (x * z + y * z + v * w)
                                   Lvzxwyw Luw Lxzyzvw.
        prove (v * z + x * w + y * w) + u * w < (x * z + y * z + v * w) + u * w.
        rewrite <- add_SNo_assoc_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw.
        rewrite <- add_SNo_assoc_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw.
        prove v * z + x * w + y * w + u * w < x * z + y * z + v * w + u * w.
        apply SNoLeLt_tra (v * z + x * w + y * w + u * w)
                          (u * z + y * z + v * w + x * w)
                          (x * z + y * z + v * w + u * w)
                          (SNo_add_SNo_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw)
                          (SNo_add_SNo_4 (u * z) (y * z) (v * w) (x * w) Luz Lyz Lvw Lxw)
                          (SNo_add_SNo_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw).
        - prove v * z + x * w + y * w + u * w <= u * z + y * z + v * w + x * w.
          rewrite add_SNo_com_3_0_1 (v * z) (x * w) (y * w + u * w) Lvz Lxw (SNo_add_SNo (y * w) (u * w) Lyw Luw).
          prove x * w + v * z + y * w + u * w <= u * z + y * z + v * w + x * w.
          rewrite add_SNo_rotate_4_1 (u * z) (y * z) (v * w) (x * w) Luz Lyz Lvw Lxw.
          prove x * w + v * z + y * w + u * w <= x * w + u * z + y * z + v * w.
          apply add_SNo_Le2 (x * w) (v * z + y * w + u * w) (u * z + y * z + v * w)
                            Lxw
                            (SNo_add_SNo_3 (v * z) (y * w) (u * w) Lvz Lyw Luw)
                            (SNo_add_SNo_3 (u * z) (y * z) (v * w) Luz Lyz Lvw).
          prove v * z + y * w + u * w <= u * z + y * z + v * w.
          rewrite add_SNo_com (y * w) (u * w) Lyw Luw.
          prove v * z + u * w + y * w <= u * z + y * z + v * w.
          rewrite <- IHxz u (SNoR_SNoS x Hx u Hu) w (SNoR_SNoS z Hz w Hw).
          prove v * z + (u + y) * w <= u * z + y * z + v * w.
          rewrite add_SNo_assoc (u * z) (y * z) (v * w) Luz Lyz Lvw.
          prove v * z + (u + y) * w <= (u * z + y * z) + v * w.
          rewrite <- IHx u (SNoR_SNoS x Hx u Hu).
          prove v * z + (u + y) * w <= (u + y) * z + v * w.
          rewrite add_SNo_com ((u + y) * z) (v * w) (SNo_mul_SNo (u + y) z Luy Hz) Lvw.
          rewrite add_SNo_com (v * z) ((u + y) * w) Lvz (SNo_mul_SNo (u + y) w Luy Hw1).
          apply mul_SNo_Le v w (u + y) z Hv1 Hw1 Luy Hz.
          + prove u + y <= v. exact Hvu.
          + prove z <= w. apply SNoLtLe. prove z < w. exact Hw3.
        - prove u * z + y * z + v * w + x * w < x * z + y * z + v * w + u * w.
          rewrite add_SNo_com_3_0_1 (u * z) (y * z) (v * w + x * w) Luz Lyz (SNo_add_SNo (v * w) (x * w) Lvw Lxw).
          rewrite add_SNo_com_3_0_1 (x * z) (y * z) (v * w + u * w) Lxz Lyz (SNo_add_SNo (v * w) (u * w) Lvw Luw).
          prove y * z + u * z + v * w + x * w < y * z + x * z + v * w + u * w.
          apply add_SNo_Lt2 (y * z) (u * z + v * w + x * w) (x * z + v * w + u * w)
                            Lyz
                            (SNo_add_SNo_3 (u * z) (v * w) (x * w) Luz Lvw Lxw)
                            (SNo_add_SNo_3 (x * z) (v * w) (u * w) Lxz Lvw Luw).
          prove u * z + v * w + x * w < x * z + v * w + u * w.
          rewrite add_SNo_com_3_0_1 (u * z) (v * w) (x * w) Luz Lvw Lxw.
          rewrite add_SNo_com_3_0_1 (x * z) (v * w) (u * w) Lxz Lvw Luw.
          prove v * w + u * z + x * w < v * w + x * z + u * w.
          apply add_SNo_Lt2 (v * w) (u * z + x * w) (x * z + u * w) Lvw
                            (SNo_add_SNo (u * z) (x * w) Luz Lxw)
                            (SNo_add_SNo (x * z) (u * w) Lxz Luw).
          prove u * z + x * w < x * z + u * w.
          rewrite add_SNo_com (x * z) (u * w) Lxz Luw.
          rewrite add_SNo_com (u * z) (x * w) Luz Lxw.
          prove x * w + u * z < u * w + x * z.
          exact mul_SNo_Lt u w x z Hu1 Hw1 Hx Hz Hu3 Hw3.
      }
    * { assume H1. apply H1.
        let u. assume H1. apply H1.
        assume Hu: u :e SNoR y.
        assume Hvu: x + u <= v.
        apply SNoR_E y Hy u Hu.
        assume Hu1 Hu2 Hu3.
        claim Luw: SNo (u * w).
        { exact SNo_mul_SNo u w Hu1 Hw1. }
        claim Luz: SNo (u * z).
        { exact SNo_mul_SNo u z Hu1 Hz. }
        claim Lxu: SNo (x + u).
        { exact SNo_add_SNo x u Hx Hu1. }
        apply add_SNo_Lt1_cancel (v * z + x * w + y * w)
                                 (u * w)
                                 (x * z + y * z + v * w)
                                   Lvzxwyw Luw Lxzyzvw.
        prove (v * z + x * w + y * w) + u * w < (x * z + y * z + v * w) + u * w.
        rewrite <- add_SNo_assoc_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw.
        rewrite <- add_SNo_assoc_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw.
        prove v * z + x * w + y * w + u * w < x * z + y * z + v * w + u * w.
        apply SNoLeLt_tra (v * z + x * w + y * w + u * w)
                          (x * z + u * z + v * w + y * w)
                          (x * z + y * z + v * w + u * w)
                          (SNo_add_SNo_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw)
                          (SNo_add_SNo_4 (x * z) (u * z) (v * w) (y * w) Lxz Luz Lvw Lyw)
                          (SNo_add_SNo_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw).
        - prove v * z + x * w + y * w + u * w <= x * z + u * z + v * w + y * w.
          rewrite add_SNo_com (y * w) (u * w) Lyw Luw.
          prove v * z + x * w + u * w + y * w <= x * z + u * z + v * w + y * w.
          rewrite add_SNo_rotate_4_1 (v * z) (x * w) (u * w) (y * w) Lvz Lxw Luw Lyw.
          prove y * w + v * z + x * w + u * w <= x * z + u * z + v * w + y * w.
          rewrite add_SNo_rotate_4_1 (x * z) (u * z) (v * w) (y * w) Lxz Luz Lvw Lyw.
          prove y * w + v * z + x * w + u * w <= y * w + x * z + u * z + v * w.
          apply add_SNo_Le2 (y * w) (v * z + x * w + u * w) (x * z + u * z + v * w)
                            Lyw
                            (SNo_add_SNo_3 (v * z) (x * w) (u * w) Lvz Lxw Luw)
                            (SNo_add_SNo_3 (x * z) (u * z) (v * w) Lxz Luz Lvw).
          prove v * z + x * w + u * w <= x * z + u * z + v * w.
          rewrite <- IHyz u (SNoR_SNoS y Hy u Hu) w (SNoR_SNoS z Hz w Hw).
          prove v * z + (x + u) * w <= x * z + u * z + v * w.
          rewrite add_SNo_assoc (x * z) (u * z) (v * w) Lxz Luz Lvw.
          prove v * z + (x + u) * w <= (x * z + u * z) + v * w.
          rewrite <- IHy u (SNoR_SNoS y Hy u Hu).
          prove v * z + (x + u) * w <= (x + u) * z + v * w.
          rewrite add_SNo_com ((x + u) * z) (v * w) (SNo_mul_SNo (x + u) z Lxu Hz) Lvw.
          rewrite add_SNo_com (v * z) ((x + u) * w) Lvz (SNo_mul_SNo (x + u) w Lxu Hw1).
          apply mul_SNo_Le v w (x + u) z Hv1 Hw1 Lxu Hz.
          + prove x + u <= v. exact Hvu.
          + prove z <= w. apply SNoLtLe. prove z < w. exact Hw3.
        - prove x * z + u * z + v * w + y * w < x * z + y * z + v * w + u * w.
          apply add_SNo_Lt2 (x * z) (u * z + v * w + y * w) (y * z + v * w + u * w)
                            Lxz
                            (SNo_add_SNo_3 (u * z) (v * w) (y * w) Luz Lvw Lyw)
                            (SNo_add_SNo_3 (y * z) (v * w) (u * w) Lyz Lvw Luw).
          prove u * z + v * w + y * w < y * z + v * w + u * w.
          rewrite add_SNo_com_3_0_1 (u * z) (v * w) (y * w) Luz Lvw Lyw.
          rewrite add_SNo_com_3_0_1 (y * z) (v * w) (u * w) Lyz Lvw Luw.
          prove v * w + u * z + y * w < v * w + y * z + u * w.
          apply add_SNo_Lt2 (v * w) (u * z + y * w) (y * z + u * w) Lvw
                            (SNo_add_SNo (u * z) (y * w) Luz Lyw)
                            (SNo_add_SNo (y * z) (u * w) Lyz Luw).
          prove u * z + y * w < y * z + u * w.
          rewrite add_SNo_com (y * z) (u * w) Lyz Luw.
          rewrite add_SNo_com (u * z) (y * w) Luz Lyw.
          prove y * w + u * z < u * w + y * z.
          exact mul_SNo_Lt u w y z Hu1 Hw1 Hy Hz Hu3 Hw3.
      }
- let u. assume Hu: u :e R. rewrite <- LE.
  prove x * z + y * z < u.
  apply HRE u Hu.
  + let v. assume Hv: v :e SNoL (x + y).
    let w. assume Hw: w :e SNoR z.
    assume Hue: u = v * z + (x + y) * w + - v * w.
    rewrite Hue.
    prove x * z + y * z < v * z + (x + y) * w + - v * w.
    apply SNoL_E (x + y) Lxy v Hv.
    assume Hv1 Hv2 Hv3.
    apply SNoR_E z Hz w Hw.
    assume Hw1 Hw2 Hw3.
    claim Lxw: SNo (x * w).
    { exact SNo_mul_SNo x w Hx Hw1. }
    claim Lyw: SNo (y * w).
    { exact SNo_mul_SNo y w Hy Hw1. }
    claim Lvz: SNo (v * z).
    { exact SNo_mul_SNo v z Hv1 Hz. }
    claim Lxyw: SNo ((x + y) * w).
    { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
    claim Lxwyw: SNo (x * w + y * w).
    { exact SNo_add_SNo (x * w) (y * w) Lxw Lyw. }
    claim Lvw: SNo (v * w).
    { exact SNo_mul_SNo v w Hv1 Hw1. }
    claim Lvzxwyw: SNo (v * z + x * w + y * w).
    { exact SNo_add_SNo_3 (v * z) (x * w) (y * w) Lvz Lxw Lyw. }
    claim Lxzyzvw: SNo (x * z + y * z + v * w).
    { exact SNo_add_SNo_3 (x * z) (y * z) (v * w) Lxz Lyz Lvw. }
    prove x * z + y * z < v * z + (x + y) * w + - v * w.
    apply add_SNo_minus_Lt2b3 (v * z) ((x + y) * w) (v * w) (x * z + y * z)
                              Lvz Lxyw Lvw Lxzyz.
    prove (x * z + y * z) + v * w < v * z + (x + y) * w.
    rewrite IHz w (SNoR_SNoS z Hz w Hw).
    prove (x * z + y * z) + v * w < v * z + x * w + y * w.
    rewrite <- add_SNo_assoc (x * z) (y * z) (v * w) Lxz Lyz Lvw.
    prove x * z + y * z + v * w < v * z + x * w + y * w.
    apply add_SNo_SNoL_interpolate x y Hx Hy v Hv.
    * { assume H1. apply H1.
        let u. assume H1. apply H1.
        assume Hu: u :e SNoL x.
        assume Hvu: v <= u + y.
        apply SNoL_E x Hx u Hu.
        assume Hu1 Hu2 Hu3.
        claim Luw: SNo (u * w).
        { exact SNo_mul_SNo u w Hu1 Hw1. }
        claim Luz: SNo (u * z).
        { exact SNo_mul_SNo u z Hu1 Hz. }
        claim Luy: SNo (u + y).
        { exact SNo_add_SNo u y Hu1 Hy. }
        apply add_SNo_Lt1_cancel (x * z + y * z + v * w)
                                 (u * w)
                                 (v * z + x * w + y * w)
                                   Lxzyzvw Luw Lvzxwyw.
        prove (x * z + y * z + v * w) + u * w < (v * z + x * w + y * w) + u * w.
        rewrite <- add_SNo_assoc_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw.
        rewrite <- add_SNo_assoc_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw.
        prove x * z + y * z + v * w + u * w < v * z + x * w + y * w + u * w.
        apply SNoLtLe_tra (x * z + y * z + v * w + u * w)
                          (u * z + y * z + v * w + x * w)
                          (v * z + x * w + y * w + u * w)
                          (SNo_add_SNo_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw)
                          (SNo_add_SNo_4 (u * z) (y * z) (v * w) (x * w) Luz Lyz Lvw Lxw)
                          (SNo_add_SNo_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw).
        - prove x * z + y * z + v * w + u * w < u * z + y * z + v * w + x * w.
          rewrite add_SNo_com_3_0_1 (u * z) (y * z) (v * w + x * w) Luz Lyz (SNo_add_SNo (v * w) (x * w) Lvw Lxw).
          rewrite add_SNo_com_3_0_1 (x * z) (y * z) (v * w + u * w) Lxz Lyz (SNo_add_SNo (v * w) (u * w) Lvw Luw).
          prove y * z + x * z + v * w + u * w < y * z + u * z + v * w + x * w.
          apply add_SNo_Lt2 (y * z) (x * z + v * w + u * w) (u * z + v * w + x * w)
                            Lyz
                            (SNo_add_SNo_3 (x * z) (v * w) (u * w) Lxz Lvw Luw)
                            (SNo_add_SNo_3 (u * z) (v * w) (x * w) Luz Lvw Lxw).
          prove x * z + v * w + u * w < u * z + v * w + x * w.
          rewrite add_SNo_com_3_0_1 (u * z) (v * w) (x * w) Luz Lvw Lxw.
          rewrite add_SNo_com_3_0_1 (x * z) (v * w) (u * w) Lxz Lvw Luw.
          prove v * w + x * z + u * w < v * w + u * z + x * w.
          apply add_SNo_Lt2 (v * w) (x * z + u * w) (u * z + x * w)
                            Lvw
                            (SNo_add_SNo (x * z) (u * w) Lxz Luw)
                            (SNo_add_SNo (u * z) (x * w) Luz Lxw).
          prove x * z + u * w < u * z + x * w.
          rewrite add_SNo_com (x * z) (u * w) Lxz Luw.
          rewrite add_SNo_com (u * z) (x * w) Luz Lxw.
          exact mul_SNo_Lt x w u z Hx Hw1 Hu1 Hz Hu3 Hw3.
        - prove u * z + y * z + v * w + x * w <= v * z + x * w + y * w + u * w.
          rewrite add_SNo_com_3_0_1 (v * z) (x * w) (y * w + u * w) Lvz Lxw (SNo_add_SNo (y * w) (u * w) Lyw Luw).
          prove u * z + y * z + v * w + x * w <= x * w + v * z + y * w + u * w.
          rewrite add_SNo_rotate_4_1 (u * z) (y * z) (v * w) (x * w) Luz Lyz Lvw Lxw.
          prove x * w + u * z + y * z + v * w <= x * w + v * z + y * w + u * w.
          apply add_SNo_Le2 (x * w) (u * z + y * z + v * w) (v * z + y * w + u * w)
                            Lxw
                            (SNo_add_SNo_3 (u * z) (y * z) (v * w) Luz Lyz Lvw)
                            (SNo_add_SNo_3 (v * z) (y * w) (u * w) Lvz Lyw Luw).
          prove u * z + y * z + v * w <= v * z + y * w + u * w.
          rewrite add_SNo_com (y * w) (u * w) Lyw Luw.
          prove u * z + y * z + v * w <= v * z + u * w + y * w.
          rewrite <- IHxz u (SNoL_SNoS x Hx u Hu) w (SNoR_SNoS z Hz w Hw).
          prove u * z + y * z + v * w <= v * z + (u + y) * w.
          rewrite add_SNo_assoc (u * z) (y * z) (v * w) Luz Lyz Lvw.
          prove (u * z + y * z) + v * w <= v * z + (u + y) * w.
          rewrite <- IHx u (SNoL_SNoS x Hx u Hu).
          prove (u + y) * z + v * w <= v * z + (u + y) * w.
          rewrite add_SNo_com ((u + y) * z) (v * w) (SNo_mul_SNo (u + y) z Luy Hz) Lvw.
          rewrite add_SNo_com (v * z) ((u + y) * w) Lvz (SNo_mul_SNo (u + y) w Luy Hw1).
          prove v * w + (u + y) * z  <= (u + y) * w + v * z.
          apply mul_SNo_Le (u + y) w v z Luy Hw1 Hv1 Hz.
          + prove v <= u + y. exact Hvu.
          + prove z <= w. apply SNoLtLe. prove z < w. exact Hw3.
      }
    * { assume H1. apply H1.
        let u. assume H1. apply H1.
        assume Hu: u :e SNoL y.
        assume Hvu: v <= x + u.
        apply SNoL_E y Hy u Hu.
        assume Hu1 Hu2 Hu3.
        claim Luw: SNo (u * w).
        { exact SNo_mul_SNo u w Hu1 Hw1. }
        claim Luz: SNo (u * z).
        { exact SNo_mul_SNo u z Hu1 Hz. }
        claim Lxu: SNo (x + u).
        { exact SNo_add_SNo x u Hx Hu1. }
        apply add_SNo_Lt1_cancel (x * z + y * z + v * w)
                                 (u * w)
                                 (v * z + x * w + y * w)
                                   Lxzyzvw Luw Lvzxwyw.
        prove (x * z + y * z + v * w) + u * w < (v * z + x * w + y * w) + u * w.
        rewrite <- add_SNo_assoc_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw.
        rewrite <- add_SNo_assoc_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw.
        prove x * z + y * z + v * w + u * w < v * z + x * w + y * w + u * w.
        apply SNoLtLe_tra (x * z + y * z + v * w + u * w)
                          (x * z + u * z + v * w + y * w)
                          (v * z + x * w + y * w + u * w)
                          (SNo_add_SNo_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw)
                          (SNo_add_SNo_4 (x * z) (u * z) (v * w) (y * w) Lxz Luz Lvw Lyw)
                          (SNo_add_SNo_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw).
        - prove x * z + y * z + v * w + u * w < x * z + u * z + v * w + y * w.
          apply add_SNo_Lt2 (x * z) (y * z + v * w + u * w) (u * z + v * w + y * w)
                            Lxz
                            (SNo_add_SNo_3 (y * z) (v * w) (u * w) Lyz Lvw Luw)
                            (SNo_add_SNo_3 (u * z) (v * w) (y * w) Luz Lvw Lyw).
          prove y * z + v * w + u * w < u * z + v * w + y * w.
          rewrite add_SNo_com_3_0_1 (u * z) (v * w) (y * w) Luz Lvw Lyw.
          rewrite add_SNo_com_3_0_1 (y * z) (v * w) (u * w) Lyz Lvw Luw.
          prove v * w + y * z + u * w < v * w + u * z + y * w.
          apply add_SNo_Lt2 (v * w) (y * z + u * w) (u * z + y * w)
                            Lvw
                            (SNo_add_SNo (y * z) (u * w) Lyz Luw)
                            (SNo_add_SNo (u * z) (y * w) Luz Lyw).
          prove y * z + u * w < u * z + y * w.
          rewrite add_SNo_com (y * z) (u * w) Lyz Luw.
          rewrite add_SNo_com (u * z) (y * w) Luz Lyw.
          exact mul_SNo_Lt y w u z Hy Hw1 Hu1 Hz Hu3 Hw3.
        - prove x * z + u * z + v * w + y * w <= v * z + x * w + y * w + u * w.
          rewrite add_SNo_com (y * w) (u * w) Lyw Luw.
          prove x * z + u * z + v * w + y * w <= v * z + x * w + u * w + y * w.
          rewrite add_SNo_rotate_4_1 (v * z) (x * w) (u * w) (y * w) Lvz Lxw Luw Lyw.
          prove x * z + u * z + v * w + y * w <= y * w + v * z + x * w + u * w.
          rewrite add_SNo_rotate_4_1 (x * z) (u * z) (v * w) (y * w) Lxz Luz Lvw Lyw.
          prove y * w + x * z + u * z + v * w <= y * w + v * z + x * w + u * w.
          apply add_SNo_Le2 (y * w) (x * z + u * z + v * w) (v * z + x * w + u * w)
                            Lyw
                            (SNo_add_SNo_3 (x * z) (u * z) (v * w) Lxz Luz Lvw)
                            (SNo_add_SNo_3 (v * z) (x * w) (u * w) Lvz Lxw Luw).
          prove x * z + u * z + v * w <= v * z + x * w + u * w.
          rewrite <- IHyz u (SNoL_SNoS y Hy u Hu) w (SNoR_SNoS z Hz w Hw).
          prove x * z + u * z + v * w <= v * z + (x + u) * w.
          rewrite add_SNo_assoc (x * z) (u * z) (v * w) Lxz Luz Lvw.
          prove (x * z + u * z) + v * w <= v * z + (x + u) * w.
          rewrite <- IHy u (SNoL_SNoS y Hy u Hu).
          prove (x + u) * z + v * w <= v * z + (x + u) * w.
          rewrite add_SNo_com ((x + u) * z) (v * w) (SNo_mul_SNo (x + u) z Lxu Hz) Lvw.
          rewrite add_SNo_com (v * z) ((x + u) * w) Lvz (SNo_mul_SNo (x + u) w Lxu Hw1).
          prove v * w + (x + u) * z  <= (x + u) * w + v * z.
          apply mul_SNo_Le (x + u) w v z Lxu Hw1 Hv1 Hz.
          + prove v <= x + u. exact Hvu.
          + prove z <= w. apply SNoLtLe. prove z < w. exact Hw3.
      }
  + let v. assume Hv: v :e SNoR (x + y).
    let w. assume Hw: w :e SNoL z.
    assume Hue: u = v * z + (x + y) * w + - v * w.
    rewrite Hue.
    prove x * z + y * z < v * z + (x + y) * w + - v * w.
    apply SNoR_E (x + y) Lxy v Hv.
    assume Hv1 Hv2 Hv3.
    apply SNoL_E z Hz w Hw.
    assume Hw1 Hw2 Hw3.
    claim Lxw: SNo (x * w).
    { exact SNo_mul_SNo x w Hx Hw1. }
    claim Lyw: SNo (y * w).
    { exact SNo_mul_SNo y w Hy Hw1. }
    claim Lvz: SNo (v * z).
    { exact SNo_mul_SNo v z Hv1 Hz. }
    claim Lxyw: SNo ((x + y) * w).
    { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
    claim Lxwyw: SNo (x * w + y * w).
    { exact SNo_add_SNo (x * w) (y * w) Lxw Lyw. }
    claim Lvw: SNo (v * w).
    { exact SNo_mul_SNo v w Hv1 Hw1. }
    claim Lvzxwyw: SNo (v * z + x * w + y * w).
    { exact SNo_add_SNo_3 (v * z) (x * w) (y * w) Lvz Lxw Lyw. }
    claim Lxzyzvw: SNo (x * z + y * z + v * w).
    { exact SNo_add_SNo_3 (x * z) (y * z) (v * w) Lxz Lyz Lvw. }
    prove x * z + y * z < v * z + (x + y) * w + - v * w.
    apply add_SNo_minus_Lt2b3 (v * z) ((x + y) * w) (v * w) (x * z + y * z)
                              Lvz Lxyw Lvw Lxzyz.
    prove (x * z + y * z) + v * w < v * z + (x + y) * w.
    rewrite IHz w (SNoL_SNoS z Hz w Hw).
    prove (x * z + y * z) + v * w < v * z + x * w + y * w.
    rewrite <- add_SNo_assoc (x * z) (y * z) (v * w) Lxz Lyz Lvw.
    prove x * z + y * z + v * w < v * z + x * w + y * w.
    apply add_SNo_SNoR_interpolate x y Hx Hy v Hv.
    * { assume H1. apply H1.
        let u. assume H1. apply H1.
        assume Hu: u :e SNoR x.
        assume Hvu: u + y <= v.
        apply SNoR_E x Hx u Hu.
        assume Hu1 Hu2 Hu3.
        claim Luw: SNo (u * w).
        { exact SNo_mul_SNo u w Hu1 Hw1. }
        claim Luz: SNo (u * z).
        { exact SNo_mul_SNo u z Hu1 Hz. }
        claim Luy: SNo (u + y).
        { exact SNo_add_SNo u y Hu1 Hy. }
        apply add_SNo_Lt1_cancel (x * z + y * z + v * w)
                                 (u * w)
                                 (v * z + x * w + y * w)
                                   Lxzyzvw Luw Lvzxwyw.
        prove (x * z + y * z + v * w) + u * w < (v * z + x * w + y * w) + u * w.
        rewrite <- add_SNo_assoc_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw.
        rewrite <- add_SNo_assoc_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw.
        prove x * z + y * z + v * w + u * w < v * z + x * w + y * w + u * w.
        apply SNoLtLe_tra (x * z + y * z + v * w + u * w)
                          (u * z + y * z + v * w + x * w)
                          (v * z + x * w + y * w + u * w)
                          (SNo_add_SNo_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw)
                          (SNo_add_SNo_4 (u * z) (y * z) (v * w) (x * w) Luz Lyz Lvw Lxw)
                          (SNo_add_SNo_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw).
        - prove x * z + y * z + v * w + u * w < u * z + y * z + v * w + x * w.
          rewrite add_SNo_com_3_0_1 (u * z) (y * z) (v * w + x * w) Luz Lyz (SNo_add_SNo (v * w) (x * w) Lvw Lxw).
          rewrite add_SNo_com_3_0_1 (x * z) (y * z) (v * w + u * w) Lxz Lyz (SNo_add_SNo (v * w) (u * w) Lvw Luw).
          prove y * z + x * z + v * w + u * w < y * z + u * z + v * w + x * w.
          apply add_SNo_Lt2 (y * z) (x * z + v * w + u * w) (u * z + v * w + x * w)
                            Lyz
                            (SNo_add_SNo_3 (x * z) (v * w) (u * w) Lxz Lvw Luw)
                            (SNo_add_SNo_3 (u * z) (v * w) (x * w) Luz Lvw Lxw).
          prove x * z + v * w + u * w < u * z + v * w + x * w.
          rewrite add_SNo_com_3_0_1 (u * z) (v * w) (x * w) Luz Lvw Lxw.
          rewrite add_SNo_com_3_0_1 (x * z) (v * w) (u * w) Lxz Lvw Luw.
          prove v * w + x * z + u * w < v * w + u * z + x * w.
          apply add_SNo_Lt2 (v * w) (x * z + u * w) (u * z + x * w)
                            Lvw
                            (SNo_add_SNo (x * z) (u * w) Lxz Luw)
                            (SNo_add_SNo (u * z) (x * w) Luz Lxw).
          prove x * z + u * w < u * z + x * w.
          exact mul_SNo_Lt u z x w Hu1 Hz Hx Hw1 Hu3 Hw3.
        - prove u * z + y * z + v * w + x * w <= v * z + x * w + y * w + u * w.
          rewrite add_SNo_com_3_0_1 (v * z) (x * w) (y * w + u * w) Lvz Lxw (SNo_add_SNo (y * w) (u * w) Lyw Luw).
          prove u * z + y * z + v * w + x * w <= x * w + v * z + y * w + u * w.
          rewrite add_SNo_rotate_4_1 (u * z) (y * z) (v * w) (x * w) Luz Lyz Lvw Lxw.
          prove x * w + u * z + y * z + v * w <= x * w + v * z + y * w + u * w.
          apply add_SNo_Le2 (x * w) (u * z + y * z + v * w) (v * z + y * w + u * w)
                            Lxw
                            (SNo_add_SNo_3 (u * z) (y * z) (v * w) Luz Lyz Lvw)
                            (SNo_add_SNo_3 (v * z) (y * w) (u * w) Lvz Lyw Luw).
          prove u * z + y * z + v * w <= v * z + y * w + u * w.
          rewrite add_SNo_com (y * w) (u * w) Lyw Luw.
          prove u * z + y * z + v * w <= v * z + u * w + y * w.
          rewrite <- IHxz u (SNoR_SNoS x Hx u Hu) w (SNoL_SNoS z Hz w Hw).
          prove u * z + y * z + v * w <= v * z + (u + y) * w.
          rewrite add_SNo_assoc (u * z) (y * z) (v * w) Luz Lyz Lvw.
          prove (u * z + y * z) + v * w <= v * z + (u + y) * w.
          rewrite <- IHx u (SNoR_SNoS x Hx u Hu).
          prove (u + y) * z + v * w <= v * z + (u + y) * w.
          apply mul_SNo_Le v z (u + y) w Hv1 Hz Luy Hw1.
          + prove u + y <= v. exact Hvu.
          + prove w <= z. apply SNoLtLe. prove w < z. exact Hw3.
      }
    * { assume H1. apply H1.
        let u. assume H1. apply H1.
        assume Hu: u :e SNoR y.
        assume Hvu: x + u <= v.
        apply SNoR_E y Hy u Hu.
        assume Hu1 Hu2 Hu3.
        claim Luw: SNo (u * w).
        { exact SNo_mul_SNo u w Hu1 Hw1. }
        claim Luz: SNo (u * z).
        { exact SNo_mul_SNo u z Hu1 Hz. }
        claim Lxu: SNo (x + u).
        { exact SNo_add_SNo x u Hx Hu1. }
        apply add_SNo_Lt1_cancel (x * z + y * z + v * w)
                                 (u * w)
                                 (v * z + x * w + y * w)
                                   Lxzyzvw Luw Lvzxwyw.
        prove (x * z + y * z + v * w) + u * w < (v * z + x * w + y * w) + u * w.
        rewrite <- add_SNo_assoc_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw.
        rewrite <- add_SNo_assoc_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw.
        prove x * z + y * z + v * w + u * w < v * z + x * w + y * w + u * w.
        apply SNoLtLe_tra (x * z + y * z + v * w + u * w)
                          (x * z + u * z + v * w + y * w)
                          (v * z + x * w + y * w + u * w)
                          (SNo_add_SNo_4 (x * z) (y * z) (v * w) (u * w) Lxz Lyz Lvw Luw)
                          (SNo_add_SNo_4 (x * z) (u * z) (v * w) (y * w) Lxz Luz Lvw Lyw)
                          (SNo_add_SNo_4 (v * z) (x * w) (y * w) (u * w) Lvz Lxw Lyw Luw).
        - prove x * z + y * z + v * w + u * w < x * z + u * z + v * w + y * w.
          apply add_SNo_Lt2 (x * z) (y * z + v * w + u * w) (u * z + v * w + y * w)
                            Lxz
                            (SNo_add_SNo_3 (y * z) (v * w) (u * w) Lyz Lvw Luw)
                            (SNo_add_SNo_3 (u * z) (v * w) (y * w) Luz Lvw Lyw).
          prove y * z + v * w + u * w < u * z + v * w + y * w.
          rewrite add_SNo_com_3_0_1 (u * z) (v * w) (y * w) Luz Lvw Lyw.
          rewrite add_SNo_com_3_0_1 (y * z) (v * w) (u * w) Lyz Lvw Luw.
          prove v * w + y * z + u * w < v * w + u * z + y * w.
          apply add_SNo_Lt2 (v * w) (y * z + u * w) (u * z + y * w)
                            Lvw
                            (SNo_add_SNo (y * z) (u * w) Lyz Luw)
                            (SNo_add_SNo (u * z) (y * w) Luz Lyw).
          prove y * z + u * w < u * z + y * w.
          exact mul_SNo_Lt u z y w Hu1 Hz Hy Hw1 Hu3 Hw3.
        - prove x * z + u * z + v * w + y * w <= v * z + x * w + y * w + u * w.
          rewrite add_SNo_com (y * w) (u * w) Lyw Luw.
          prove x * z + u * z + v * w + y * w <= v * z + x * w + u * w + y * w.
          rewrite add_SNo_rotate_4_1 (v * z) (x * w) (u * w) (y * w) Lvz Lxw Luw Lyw.
          prove x * z + u * z + v * w + y * w <= y * w + v * z + x * w + u * w.
          rewrite add_SNo_rotate_4_1 (x * z) (u * z) (v * w) (y * w) Lxz Luz Lvw Lyw.
          prove y * w + x * z + u * z + v * w <= y * w + v * z + x * w + u * w.
          apply add_SNo_Le2 (y * w) (x * z + u * z + v * w) (v * z + x * w + u * w)
                            Lyw
                            (SNo_add_SNo_3 (x * z) (u * z) (v * w) Lxz Luz Lvw)
                            (SNo_add_SNo_3 (v * z) (x * w) (u * w) Lvz Lxw Luw).
          prove x * z + u * z + v * w <= v * z + x * w + u * w.
          rewrite <- IHyz u (SNoR_SNoS y Hy u Hu) w (SNoL_SNoS z Hz w Hw).
          prove x * z + u * z + v * w <= v * z + (x + u) * w.
          rewrite add_SNo_assoc (x * z) (u * z) (v * w) Lxz Luz Lvw.
          prove (x * z + u * z) + v * w <= v * z + (x + u) * w.
          rewrite <- IHy u (SNoR_SNoS y Hy u Hu).
          prove (x + u) * z + v * w <= v * z + (x + u) * w.
          apply mul_SNo_Le v z (x + u) w Hv1 Hz Lxu Hw1.
          + prove x + u <= v. exact Hvu.
          + prove w <= z. apply SNoLtLe. prove w < z. exact Hw3.
      }
- let u'. assume Hu': u' :e L1 :\/: L2. rewrite <- HE.
  prove u' < (x + y) * z.
  apply binunionE L1 L2 u' Hu'.
  + assume Hu': u' :e L1.
    apply ReplE_impred (SNoL (x * z)) (fun w => w + y * z) u' Hu'.
    let u. assume Hu: u :e SNoL (x * z).
    assume Hu'u: u' = u + y * z.
    rewrite Hu'u.
    prove u + y * z < (x + y) * z.
    apply SNoL_E (x * z) Lxz u Hu.
    assume Hu1 Hu2 Hu3.
    apply mul_SNo_SNoL_interpolate_impred x z Hx Hz u Hu.
    * { let v. assume Hv: v :e SNoL x.
        let w. assume Hw: w :e SNoL z.
        assume Hvw: u + v * w <= v * z + x * w.
        apply SNoL_E x Hx v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoL_E z Hz w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim Lvy: SNo (v + y).
        { exact SNo_add_SNo v y Hv1 Hy. }
        claim Luvw: SNo (u + v * w).
        { exact SNo_add_SNo u (v * w) Hu1 Lvw. }
        claim Lxyw: SNo ((x + y) * w).
        { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
        claim Lvz: SNo (v * z).
        { exact SNo_mul_SNo v z Hv1 Hz. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        claim Lyw: SNo (y * w).
        { exact SNo_mul_SNo y w Hy Hw1. }
        claim Luyz: SNo (u + y * z).
        { exact SNo_add_SNo u (y * z) Hu1 Lyz. }
        claim Lvwyw: SNo (v * w + y * w).
        { exact SNo_add_SNo (v * w) (y * w) Lvw Lyw. }
        claim Lvzxw: SNo (v * z + x * w).
        { exact SNo_add_SNo (v * z) (x * w) Lvz Lxw. }
        prove u + y * z < (x + y) * z.
        apply add_SNo_Lt1_cancel (u + y * z) (v * w + y * w) ((x + y) * z)
                                 Luyz Lvwyw Lxyz.
        prove (u + y * z) + v * w + y * w < (x + y) * z + v * w + y * w.
        rewrite add_SNo_com_4_inner_mid u (y * z) (v * w) (y * w) Hu1 Lyz Lvw Lyw.
        prove (u + v * w) + y * z + y * w < (x + y) * z + v * w + y * w.
        apply SNoLeLt_tra ((u + v * w) + y * z + y * w)
                          (v * z + y * z + x * w + y * w)
                          ((x + y) * z + v * w + y * w)
                          (SNo_add_SNo_3 (u + v * w) (y * z) (y * w) Luvw Lyz Lyw)
                          (SNo_add_SNo_4 (v * z) (y * z) (x * w) (y * w) Lvz Lyz Lxw Lyw)
                          (SNo_add_SNo_3 ((x + y) * z) (v * w) (y * w) Lxyz Lvw Lyw).
        - prove (u + v * w) + y * z + y * w <= v * z + y * z + x * w + y * w.
          rewrite add_SNo_assoc (v * z) (y * z) (x * w + y * w)
                                Lvz Lyz (SNo_add_SNo (x * w) (y * w) Lxw Lyw).
          prove (u + v * w) + y * z + y * w <= (v * z + y * z) + x * w + y * w.
          rewrite add_SNo_com_4_inner_mid (v * z) (y * z) (x * w) (y * w) Lvz Lyz Lxw Lyw.
          prove (u + v * w) + y * z + y * w <= (v * z + x * w) + y * z + y * w.
          apply add_SNo_Le1 (u + v * w) (y * z + y * w) (v * z + x * w)
                            Luvw
                            (SNo_add_SNo (y * z) (y * w) Lyz Lyw)
                            (SNo_add_SNo (v * z) (x * w) Lvz Lxw).
          prove u + v * w <= v * z + x * w.
          exact Hvw.
        - prove v * z + y * z + x * w + y * w < (x + y) * z + v * w + y * w.
          rewrite <- IHz w (SNoL_SNoS z Hz w Hw).
          prove v * z + y * z + (x + y) * w < (x + y) * z + v * w + y * w.
          rewrite <- IHxz v (SNoL_SNoS x Hx v Hv) w (SNoL_SNoS z Hz w Hw).
          prove v * z + y * z + (x + y) * w < (x + y) * z + (v + y) * w.
          rewrite add_SNo_assoc (v * z) (y * z) ((x + y) * w) Lvz Lyz Lxyw.
          rewrite <- IHx v (SNoL_SNoS x Hx v Hv).
          prove (v + y) * z + (x + y) * w < (x + y) * z + (v + y) * w.
          apply mul_SNo_Lt (x + y) z (v + y) w Lxy Hz Lvy Hw1.
          + prove v + y < x + y. apply add_SNo_Lt1 v y x Hv1 Hy Hx. exact Hv3.
          + prove w < z. exact Hw3.
      }
    * { let v. assume Hv: v :e SNoR x.
        let w. assume Hw: w :e SNoR z.
        assume Hvw: u + v * w <= v * z + x * w.
        apply SNoR_E x Hx v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoR_E z Hz w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim Lvy: SNo (v + y).
        { exact SNo_add_SNo v y Hv1 Hy. }
        claim Luvw: SNo (u + v * w).
        { exact SNo_add_SNo u (v * w) Hu1 Lvw. }
        claim Lxyw: SNo ((x + y) * w).
        { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
        claim Lvz: SNo (v * z).
        { exact SNo_mul_SNo v z Hv1 Hz. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        claim Lyw: SNo (y * w).
        { exact SNo_mul_SNo y w Hy Hw1. }
        claim Luyz: SNo (u + y * z).
        { exact SNo_add_SNo u (y * z) Hu1 Lyz. }
        claim Lvwyw: SNo (v * w + y * w).
        { exact SNo_add_SNo (v * w) (y * w) Lvw Lyw. }
        prove u + y * z < (x + y) * z.
        apply add_SNo_Lt1_cancel (u + y * z) (v * w + y * w) ((x + y) * z)
                                 Luyz Lvwyw Lxyz.
        prove (u + y * z) + v * w + y * w < (x + y) * z + v * w + y * w.
        rewrite add_SNo_com_4_inner_mid u (y * z) (v * w) (y * w) Hu1 Lyz Lvw Lyw.
        prove (u + v * w) + y * z + y * w < (x + y) * z + v * w + y * w.
        apply SNoLeLt_tra ((u + v * w) + y * z + y * w)
                          (v * z + y * z + x * w + y * w)
                          ((x + y) * z + v * w + y * w)
                          (SNo_add_SNo_3 (u + v * w) (y * z) (y * w) Luvw Lyz Lyw)
                          (SNo_add_SNo_4 (v * z) (y * z) (x * w) (y * w) Lvz Lyz Lxw Lyw)
                          (SNo_add_SNo_3 ((x + y) * z) (v * w) (y * w) Lxyz Lvw Lyw).
        - prove (u + v * w) + y * z + y * w <= v * z + y * z + x * w + y * w.
          rewrite add_SNo_assoc (v * z) (y * z) (x * w + y * w)
                                Lvz Lyz (SNo_add_SNo (x * w) (y * w) Lxw Lyw).
          prove (u + v * w) + y * z + y * w <= (v * z + y * z) + x * w + y * w.
          rewrite add_SNo_com_4_inner_mid (v * z) (y * z) (x * w) (y * w) Lvz Lyz Lxw Lyw.
          prove (u + v * w) + y * z + y * w <= (v * z + x * w) + y * z + y * w.
          apply add_SNo_Le1 (u + v * w) (y * z + y * w) (v * z + x * w)
                            Luvw
                            (SNo_add_SNo (y * z) (y * w) Lyz Lyw)
                            (SNo_add_SNo (v * z) (x * w) Lvz Lxw).
          prove u + v * w <= v * z + x * w.
          exact Hvw.
        - prove v * z + y * z + x * w + y * w < (x + y) * z + v * w + y * w.
          rewrite <- IHz w (SNoR_SNoS z Hz w Hw).
          prove v * z + y * z + (x + y) * w < (x + y) * z + v * w + y * w.
          rewrite <- IHxz v (SNoR_SNoS x Hx v Hv) w (SNoR_SNoS z Hz w Hw).
          prove v * z + y * z + (x + y) * w < (x + y) * z + (v + y) * w.
          rewrite add_SNo_assoc (v * z) (y * z) ((x + y) * w) Lvz Lyz Lxyw.
          rewrite <- IHx v (SNoR_SNoS x Hx v Hv).
          prove (v + y) * z + (x + y) * w < (x + y) * z + (v + y) * w.
          rewrite add_SNo_com ((v + y) * z) ((x + y) * w)
                              (SNo_mul_SNo (v + y) z Lvy Hz)
                              Lxyw.
          rewrite add_SNo_com ((x + y) * z) ((v + y) * w) Lxyz
                                (SNo_mul_SNo (v + y) w Lvy Hw1).
          apply mul_SNo_Lt (v + y) w (x + y) z Lvy Hw1 Lxy Hz.
          + prove x + y < v + y. apply add_SNo_Lt1 x y v Hx Hy Hv1. exact Hv3.
          + prove z < w. exact Hw3.
      }
  + assume Hu': u' :e L2.
    apply ReplE_impred (SNoL (y * z)) (fun w => x * z + w) u' Hu'.
    let u. assume Hu: u :e SNoL (y * z).
    assume Hu'u: u' = x * z + u.
    rewrite Hu'u.
    prove x * z + u < (x + y) * z.
    apply SNoL_E (y * z) Lyz u Hu.
    assume Hu1 Hu2 Hu3.
    rewrite add_SNo_com (x * z) u Lxz Hu1.
    prove u + x * z < (x + y) * z.
    apply mul_SNo_SNoL_interpolate_impred y z Hy Hz u Hu.
    * { let v. assume Hv: v :e SNoL y.
        let w. assume Hw: w :e SNoL z.
        assume Hvw: u + v * w <= v * z + y * w.
        apply SNoL_E y Hy v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoL_E z Hz w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim Lxv: SNo (x + v).
        { exact SNo_add_SNo x v Hx Hv1. }
        claim Luvw: SNo (u + v * w).
        { exact SNo_add_SNo u (v * w) Hu1 Lvw. }
        claim Lxyw: SNo ((x + y) * w).
        { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
        claim Lvz: SNo (v * z).
        { exact SNo_mul_SNo v z Hv1 Hz. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        claim Lyw: SNo (y * w).
        { exact SNo_mul_SNo y w Hy Hw1. }
        claim Luxz: SNo (u + x * z).
        { exact SNo_add_SNo u (x * z) Hu1 Lxz. }
        claim Lvwxw: SNo (v * w + x * w).
        { exact SNo_add_SNo (v * w) (x * w) Lvw Lxw. }
        prove u + x * z < (x + y) * z.
        apply add_SNo_Lt1_cancel (u + x * z) (v * w + x * w) ((x + y) * z)
                                 Luxz Lvwxw Lxyz.
        prove (u + x * z) + v * w + x * w < (x + y) * z + v * w + x * w.
        rewrite add_SNo_com_4_inner_mid u (x * z) (v * w) (x * w) Hu1 Lxz Lvw Lxw.
        prove (u + v * w) + x * z + x * w < (x + y) * z + v * w + x * w.
        apply SNoLeLt_tra ((u + v * w) + x * z + x * w)
                          (v * z + x * z + x * w + y * w)
                          ((x + y) * z + v * w + x * w)
                          (SNo_add_SNo_3 (u + v * w) (x * z) (x * w) Luvw Lxz Lxw)
                          (SNo_add_SNo_4 (v * z) (x * z) (x * w) (y * w) Lvz Lxz Lxw Lyw)
                          (SNo_add_SNo_3 ((x + y) * z) (v * w) (x * w) Lxyz Lvw Lxw).
        - prove (u + v * w) + x * z + x * w <= v * z + x * z + x * w + y * w.
          rewrite add_SNo_assoc (v * z) (x * z) (x * w + y * w)
                                Lvz Lxz (SNo_add_SNo (x * w) (y * w) Lxw Lyw).
          prove (u + v * w) + x * z + x * w <= (v * z + x * z) + x * w + y * w.
          rewrite add_SNo_com (x * w) (y * w) Lxw Lyw.
          prove (u + v * w) + x * z + x * w <= (v * z + x * z) + y * w + x * w.
          rewrite add_SNo_com_4_inner_mid (v * z) (x * z) (y * w) (x * w) Lvz Lxz Lyw Lxw.
          prove (u + v * w) + x * z + x * w <= (v * z + y * w) + x * z + x * w.
          apply add_SNo_Le1 (u + v * w) (x * z + x * w) (v * z + y * w)
                            Luvw
                            (SNo_add_SNo (x * z) (x * w) Lxz Lxw)
                            (SNo_add_SNo (v * z) (y * w) Lvz Lyw).
          prove u + v * w <= v * z + y * w.
          exact Hvw.
        - prove v * z + x * z + x * w + y * w < (x + y) * z + v * w + x * w.
          rewrite <- IHz w (SNoL_SNoS z Hz w Hw).
          prove v * z + x * z + (x + y) * w < (x + y) * z + v * w + x * w.
          rewrite add_SNo_com (v * w) (x * w) Lvw Lxw.
          rewrite <- IHyz v (SNoL_SNoS y Hy v Hv) w (SNoL_SNoS z Hz w Hw).
          prove v * z + x * z + (x + y) * w < (x + y) * z + (x + v) * w.
          rewrite add_SNo_assoc (v * z) (x * z) ((x + y) * w) Lvz Lxz Lxyw.
          prove (v * z + x * z) + (x + y) * w < (x + y) * z + (x + v) * w.
          rewrite add_SNo_com (v * z) (x * z) Lvz Lxz.
          prove (x * z + v * z) + (x + y) * w < (x + y) * z + (x + v) * w.
          rewrite <- IHy v (SNoL_SNoS y Hy v Hv).
          prove (x + v) * z + (x + y) * w < (x + y) * z + (x + v) * w.
          apply mul_SNo_Lt (x + y) z (x + v) w Lxy Hz Lxv Hw1.
          + prove x + v < x + y. apply add_SNo_Lt2 x v y Hx Hv1 Hy. exact Hv3.
          + prove w < z. exact Hw3.
      }
    * { let v. assume Hv: v :e SNoR y.
        let w. assume Hw: w :e SNoR z.
        assume Hvw: u + v * w <= v * z + y * w.
        apply SNoR_E y Hy v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoR_E z Hz w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim Lxv: SNo (x + v).
        { exact SNo_add_SNo x v Hx Hv1. }
        claim Luvw: SNo (u + v * w).
        { exact SNo_add_SNo u (v * w) Hu1 Lvw. }
        claim Lxyw: SNo ((x + y) * w).
        { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
        claim Lvz: SNo (v * z).
        { exact SNo_mul_SNo v z Hv1 Hz. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        claim Lyw: SNo (y * w).
        { exact SNo_mul_SNo y w Hy Hw1. }
        claim Luxz: SNo (u + x * z).
        { exact SNo_add_SNo u (x * z) Hu1 Lxz. }
        claim Lvwxw: SNo (v * w + x * w).
        { exact SNo_add_SNo (v * w) (x * w) Lvw Lxw. }
        claim Lvzxw: SNo (v * z + x * w).
        { exact SNo_add_SNo (v * z) (x * w) Lvz Lxw. }
        prove u + x * z < (x + y) * z.
        apply add_SNo_Lt1_cancel (u + x * z) (v * w + x * w) ((x + y) * z)
                                 Luxz Lvwxw Lxyz.
        prove (u + x * z) + v * w + x * w < (x + y) * z + v * w + x * w.
        rewrite add_SNo_com_4_inner_mid u (x * z) (v * w) (x * w) Hu1 Lxz Lvw Lxw.
        prove (u + v * w) + x * z + x * w < (x + y) * z + v * w + x * w.
        apply SNoLeLt_tra ((u + v * w) + x * z + x * w)
                          (v * z + x * z + x * w + y * w)
                          ((x + y) * z + v * w + x * w)
                          (SNo_add_SNo_3 (u + v * w) (x * z) (x * w) Luvw Lxz Lxw)
                          (SNo_add_SNo_4 (v * z) (x * z) (x * w) (y * w) Lvz Lxz Lxw Lyw)
                          (SNo_add_SNo_3 ((x + y) * z) (v * w) (x * w) Lxyz Lvw Lxw).
        - prove (u + v * w) + x * z + x * w <= v * z + x * z + x * w + y * w.
          rewrite add_SNo_assoc (v * z) (x * z) (x * w + y * w)
                                Lvz Lxz (SNo_add_SNo (x * w) (y * w) Lxw Lyw).
          rewrite <- add_SNo_com (y * w) (x * w) Lyw Lxw.
          prove (u + v * w) + x * z + x * w <= (v * z + x * z) + y * w + x * w.
          rewrite add_SNo_com_4_inner_mid (v * z) (x * z) (y * w) (x * w) Lvz Lxz Lyw Lxw.
          prove (u + v * w) + x * z + x * w <= (v * z + y * w) + x * z + x * w.
          apply add_SNo_Le1 (u + v * w) (x * z + x * w) (v * z + y * w)
                            Luvw
                            (SNo_add_SNo (x * z) (x * w) Lxz Lxw)
                            (SNo_add_SNo (v * z) (y * w) Lvz Lyw).
          prove u + v * w <= v * z + y * w.
          exact Hvw.
        - prove v * z + x * z + x * w + y * w < (x + y) * z + v * w + x * w.
          rewrite <- IHz w (SNoR_SNoS z Hz w Hw).
          prove v * z + x * z + (x + y) * w < (x + y) * z + v * w + x * w.
          rewrite add_SNo_com (v * w) (x * w) Lvw Lxw.
          prove v * z + x * z + (x + y) * w < (x + y) * z + x * w + v * w.
          rewrite <- IHyz v (SNoR_SNoS y Hy v Hv) w (SNoR_SNoS z Hz w Hw).
          prove v * z + x * z + (x + y) * w < (x + y) * z + (x + v) * w.
          rewrite add_SNo_assoc (v * z) (x * z) ((x + y) * w) Lvz Lxz Lxyw.
          prove (v * z + x * z) + (x + y) * w < (x + y) * z + (x + v) * w.
          rewrite add_SNo_com (v * z) (x * z) Lvz Lxz.
          rewrite <- IHy v (SNoR_SNoS y Hy v Hv).
          prove (x + v) * z + (x + y) * w < (x + y) * z + (x + v) * w.
          rewrite add_SNo_com ((x + v) * z) ((x + y) * w)
                              (SNo_mul_SNo (x + v) z Lxv Hz)
                              Lxyw.
          rewrite add_SNo_com ((x + y) * z) ((x + v) * w) Lxyz
                                (SNo_mul_SNo (x + v) w Lxv Hw1).
          prove (x + y) * w + (x + v) * z < (x + v) * w + (x + y) * z.
          apply mul_SNo_Lt (x + v) w (x + y) z Lxv Hw1 Lxy Hz.
          + prove x + y < x + v. apply add_SNo_Lt2 x y v Hx Hy Hv1. exact Hv3.
          + prove z < w. exact Hw3.
      }
- let u'. assume Hu': u' :e R1 :\/: R2. rewrite <- HE.
  prove (x + y) * z < u'.
  apply binunionE R1 R2 u' Hu'.
  + assume Hu': u' :e R1.
    apply ReplE_impred (SNoR (x * z)) (fun w => w + y * z) u' Hu'.
    let u. assume Hu: u :e SNoR (x * z).
    assume Hu'u: u' = u + y * z.
    rewrite Hu'u.
    prove (x + y) * z < u + y * z.
    apply SNoR_E (x * z) Lxz u Hu.
    assume Hu1 Hu2 Hu3.
    apply mul_SNo_SNoR_interpolate_impred x z Hx Hz u Hu.
    * { let v. assume Hv: v :e SNoL x.
        let w. assume Hw: w :e SNoR z.
        assume Hvw: v * z + x * w <= u + v * w.
        apply SNoL_E x Hx v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoR_E z Hz w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim Lvy: SNo (v + y).
        { exact SNo_add_SNo v y Hv1 Hy. }
        claim Luvw: SNo (u + v * w).
        { exact SNo_add_SNo u (v * w) Hu1 Lvw. }
        claim Lxyw: SNo ((x + y) * w).
        { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
        claim Lvz: SNo (v * z).
        { exact SNo_mul_SNo v z Hv1 Hz. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        claim Lyw: SNo (y * w).
        { exact SNo_mul_SNo y w Hy Hw1. }
        claim Luyz: SNo (u + y * z).
        { exact SNo_add_SNo u (y * z) Hu1 Lyz. }
        claim Lvwyw: SNo (v * w + y * w).
        { exact SNo_add_SNo (v * w) (y * w) Lvw Lyw. }
        claim Lvzxw: SNo (v * z + x * w).
        { exact SNo_add_SNo (v * z) (x * w) Lvz Lxw. }
        prove (x + y) * z < u + y * z.
        apply add_SNo_Lt1_cancel ((x + y) * z) (v * w + y * w) (u + y * z)
                                 Lxyz Lvwyw Luyz.
        prove (x + y) * z + v * w + y * w < (u + y * z) + v * w + y * w.
        rewrite add_SNo_com_4_inner_mid u (y * z) (v * w) (y * w) Hu1 Lyz Lvw Lyw.
        prove (x + y) * z + v * w + y * w < (u + v * w) + y * z + y * w.
        apply SNoLtLe_tra ((x + y) * z + v * w + y * w)
                          (v * z + y * z + x * w + y * w)
                          ((u + v * w) + y * z + y * w)
                          (SNo_add_SNo_3 ((x + y) * z) (v * w) (y * w) Lxyz Lvw Lyw)
                          (SNo_add_SNo_4 (v * z) (y * z) (x * w) (y * w) Lvz Lyz Lxw Lyw)
                          (SNo_add_SNo_3 (u + v * w) (y * z) (y * w) Luvw Lyz Lyw).
        - prove (x + y) * z + v * w + y * w < v * z + y * z + x * w + y * w.
          rewrite <- IHz w (SNoR_SNoS z Hz w Hw).
          prove (x + y) * z + v * w + y * w < v * z + y * z + (x + y) * w.
          rewrite <- IHxz v (SNoL_SNoS x Hx v Hv) w (SNoR_SNoS z Hz w Hw).
          prove (x + y) * z + (v + y) * w < v * z + y * z + (x + y) * w.
          rewrite add_SNo_assoc (v * z) (y * z) ((x + y) * w) Lvz Lyz Lxyw.
          rewrite <- IHx v (SNoL_SNoS x Hx v Hv).
          prove (x + y) * z + (v + y) * w < (v + y) * z + (x + y) * w.
          rewrite add_SNo_com ((x + y) * z) ((v + y) * w)
                              Lxyz
                              (SNo_mul_SNo (v + y) w Lvy Hw1).
          rewrite add_SNo_com ((v + y) * z) ((x + y) * w)
                              (SNo_mul_SNo (v + y) z Lvy Hz)
                              Lxyw.
          prove (v + y) * w + (x + y) * z < (x + y) * w + (v + y) * z.
          apply mul_SNo_Lt (x + y) w (v + y) z Lxy Hw1 Lvy Hz.
          + prove v + y < x + y. apply add_SNo_Lt1 v y x Hv1 Hy Hx. exact Hv3.
          + prove z < w. exact Hw3.
        - prove v * z + y * z + x * w + y * w <= (u + v * w) + y * z + y * w.
          rewrite add_SNo_assoc (v * z) (y * z) (x * w + y * w)
                                Lvz Lyz (SNo_add_SNo (x * w) (y * w) Lxw Lyw).
          prove (v * z + y * z) + x * w + y * w <= (u + v * w) + y * z + y * w.
          rewrite add_SNo_com_4_inner_mid (v * z) (y * z) (x * w) (y * w) Lvz Lyz Lxw Lyw.
          prove (v * z + x * w) + y * z + y * w <= (u + v * w) + y * z + y * w.
          apply add_SNo_Le1 (v * z + x * w) (y * z + y * w) (u + v * w)
                            (SNo_add_SNo (v * z) (x * w) Lvz Lxw)
                            (SNo_add_SNo (y * z) (y * w) Lyz Lyw)
                            Luvw.
          prove v * z + x * w <= u + v * w.
          exact Hvw.
      }
    * { let v. assume Hv: v :e SNoR x.
        let w. assume Hw: w :e SNoL z.
        assume Hvw: v * z + x * w <= u + v * w.
        apply SNoR_E x Hx v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoL_E z Hz w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim Lvy: SNo (v + y).
        { exact SNo_add_SNo v y Hv1 Hy. }
        claim Luvw: SNo (u + v * w).
        { exact SNo_add_SNo u (v * w) Hu1 Lvw. }
        claim Lxyw: SNo ((x + y) * w).
        { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
        claim Lvz: SNo (v * z).
        { exact SNo_mul_SNo v z Hv1 Hz. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        claim Lyw: SNo (y * w).
        { exact SNo_mul_SNo y w Hy Hw1. }
        claim Luyz: SNo (u + y * z).
        { exact SNo_add_SNo u (y * z) Hu1 Lyz. }
        claim Lvwyw: SNo (v * w + y * w).
        { exact SNo_add_SNo (v * w) (y * w) Lvw Lyw. }
        prove (x + y) * z < u + y * z.
        apply add_SNo_Lt1_cancel ((x + y) * z) (v * w + y * w) (u + y * z)
                                 Lxyz Lvwyw Luyz.
        prove (x + y) * z + v * w + y * w < (u + y * z) + v * w + y * w.
        rewrite add_SNo_com_4_inner_mid u (y * z) (v * w) (y * w) Hu1 Lyz Lvw Lyw.
        prove (x + y) * z + v * w + y * w < (u + v * w) + y * z + y * w.
        apply SNoLtLe_tra ((x + y) * z + v * w + y * w)
                          (v * z + y * z + x * w + y * w)
                          ((u + v * w) + y * z + y * w)
                          (SNo_add_SNo_3 ((x + y) * z) (v * w) (y * w) Lxyz Lvw Lyw)
                          (SNo_add_SNo_4 (v * z) (y * z) (x * w) (y * w) Lvz Lyz Lxw Lyw)
                          (SNo_add_SNo_3 (u + v * w) (y * z) (y * w) Luvw Lyz Lyw).
        - prove (x + y) * z + v * w + y * w < v * z + y * z + x * w + y * w.
          rewrite <- IHz w (SNoL_SNoS z Hz w Hw).
          prove (x + y) * z + v * w + y * w < v * z + y * z + (x + y) * w.
          rewrite <- IHxz v (SNoR_SNoS x Hx v Hv) w (SNoL_SNoS z Hz w Hw).
          prove (x + y) * z + (v + y) * w < v * z + y * z + (x + y) * w.
          rewrite add_SNo_assoc (v * z) (y * z) ((x + y) * w) Lvz Lyz Lxyw.
          rewrite <- IHx v (SNoR_SNoS x Hx v Hv).
          prove (x + y) * z + (v + y) * w < (v + y) * z + (x + y) * w.
          apply mul_SNo_Lt (v + y) z (x + y) w Lvy Hz Lxy Hw1.
          + prove x + y < v + y. apply add_SNo_Lt1 x y v Hx Hy Hv1. exact Hv3.
          + prove w < z. exact Hw3.
        - prove v * z + y * z + x * w + y * w <= (u + v * w) + y * z + y * w.
          rewrite add_SNo_assoc (v * z) (y * z) (x * w + y * w)
                                Lvz Lyz (SNo_add_SNo (x * w) (y * w) Lxw Lyw).
          prove (v * z + y * z) + x * w + y * w <= (u + v * w) + y * z + y * w.
          rewrite add_SNo_com_4_inner_mid (v * z) (y * z) (x * w) (y * w) Lvz Lyz Lxw Lyw.
          prove (v * z + x * w) + y * z + y * w <= (u + v * w) + y * z + y * w.
          apply add_SNo_Le1 (v * z + x * w) (y * z + y * w) (u + v * w)
                            (SNo_add_SNo (v * z) (x * w) Lvz Lxw)
                            (SNo_add_SNo (y * z) (y * w) Lyz Lyw)
                            Luvw.
          prove v * z + x * w <= u + v * w.
          exact Hvw.
      }
  + assume Hu': u' :e R2.
    apply ReplE_impred (SNoR (y * z)) (fun w => x * z + w) u' Hu'.
    let u. assume Hu: u :e SNoR (y * z).
    assume Hu'u: u' = x * z + u.
    rewrite Hu'u.
    prove (x + y) * z < x * z + u.
    apply SNoR_E (y * z) Lyz u Hu.
    assume Hu1 Hu2 Hu3.
    rewrite add_SNo_com (x * z) u Lxz Hu1.
    prove (x + y) * z < u + x * z.
    apply mul_SNo_SNoR_interpolate_impred y z Hy Hz u Hu.
    * { let v. assume Hv: v :e SNoL y.
        let w. assume Hw: w :e SNoR z.
        assume Hvw: v * z + y * w <= u + v * w.
        apply SNoL_E y Hy v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoR_E z Hz w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim Lxv: SNo (x + v).
        { exact SNo_add_SNo x v Hx Hv1. }
        claim Luvw: SNo (u + v * w).
        { exact SNo_add_SNo u (v * w) Hu1 Lvw. }
        claim Lxyw: SNo ((x + y) * w).
        { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
        claim Lvz: SNo (v * z).
        { exact SNo_mul_SNo v z Hv1 Hz. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        claim Lyw: SNo (y * w).
        { exact SNo_mul_SNo y w Hy Hw1. }
        claim Luxz: SNo (u + x * z).
        { exact SNo_add_SNo u (x * z) Hu1 Lxz. }
        claim Lvwxw: SNo (v * w + x * w).
        { exact SNo_add_SNo (v * w) (x * w) Lvw Lxw. }
        prove (x + y) * z < u + x * z.
        apply add_SNo_Lt1_cancel ((x + y) * z) (v * w + x * w) (u + x * z)
                                 Lxyz Lvwxw Luxz.
        prove (x + y) * z + v * w + x * w < (u + x * z) + v * w + x * w.
        rewrite add_SNo_com_4_inner_mid u (x * z) (v * w) (x * w) Hu1 Lxz Lvw Lxw.
        prove (x + y) * z + v * w + x * w < (u + v * w) + x * z + x * w.
        apply SNoLtLe_tra ((x + y) * z + v * w + x * w)
                          (v * z + x * z + x * w + y * w)
                          ((u + v * w) + x * z + x * w)
                          (SNo_add_SNo_3 ((x + y) * z) (v * w) (x * w) Lxyz Lvw Lxw)
                          (SNo_add_SNo_4 (v * z) (x * z) (x * w) (y * w) Lvz Lxz Lxw Lyw)
                          (SNo_add_SNo_3 (u + v * w) (x * z) (x * w) Luvw Lxz Lxw).
        - prove (x + y) * z + v * w + x * w < v * z + x * z + x * w + y * w.
          rewrite <- IHz w (SNoR_SNoS z Hz w Hw).
          prove (x + y) * z + v * w + x * w < v * z + x * z + (x + y) * w.
          rewrite add_SNo_com (v * w) (x * w) Lvw Lxw.
          rewrite <- IHyz v (SNoL_SNoS y Hy v Hv) w (SNoR_SNoS z Hz w Hw).
          prove (x + y) * z + (x + v) * w < v * z + x * z + (x + y) * w.
          rewrite add_SNo_assoc (v * z) (x * z) ((x + y) * w) Lvz Lxz Lxyw.
          prove (x + y) * z + (x + v) * w < (v * z + x * z) + (x + y) * w.
          rewrite add_SNo_com (v * z) (x * z) Lvz Lxz.
          prove (x + y) * z + (x + v) * w < (x * z + v * z) + (x + y) * w.
          rewrite <- IHy v (SNoL_SNoS y Hy v Hv).
          prove (x + y) * z + (x + v) * w < (x + v) * z + (x + y) * w.
          rewrite add_SNo_com ((x + y) * z) ((x + v) * w)
                              Lxyz
                              (SNo_mul_SNo (x + v) w Lxv Hw1).
          rewrite add_SNo_com ((x + v) * z) ((x + y) * w)
                              (SNo_mul_SNo (x + v) z Lxv Hz)
                              Lxyw.
          prove (x + v) * w + (x + y) * z < (x + y) * w + (x + v) * z.
          apply mul_SNo_Lt (x + y) w (x + v) z Lxy Hw1 Lxv Hz.
          + prove x + v < x + y. apply add_SNo_Lt2 x v y Hx Hv1 Hy. exact Hv3.
          + prove z < w. exact Hw3.
        - prove v * z + x * z + x * w + y * w <= (u + v * w) + x * z + x * w.
          rewrite add_SNo_assoc (v * z) (x * z) (x * w + y * w)
                                Lvz Lxz (SNo_add_SNo (x * w) (y * w) Lxw Lyw).
          prove (v * z + x * z) + x * w + y * w <= (u + v * w) + x * z + x * w.
          rewrite add_SNo_com (x * w) (y * w) Lxw Lyw.
          prove (v * z + x * z) + y * w + x * w <= (u + v * w) + x * z + x * w.
          rewrite add_SNo_com_4_inner_mid (v * z) (x * z) (y * w) (x * w) Lvz Lxz Lyw Lxw.
          prove (v * z + y * w) + x * z + x * w <= (u + v * w) + x * z + x * w.
          apply add_SNo_Le1 (v * z + y * w) (x * z + x * w) (u + v * w)
                            (SNo_add_SNo (v * z) (y * w) Lvz Lyw)
                            (SNo_add_SNo (x * z) (x * w) Lxz Lxw)
                            Luvw.
          prove v * z + y * w <= u + v * w.
          exact Hvw.
      }
    * { let v. assume Hv: v :e SNoR y.
        let w. assume Hw: w :e SNoL z.
        assume Hvw: v * z + y * w <= u + v * w.
        apply SNoR_E y Hy v Hv.
        assume Hv1 Hv2 Hv3.
        apply SNoL_E z Hz w Hw.
        assume Hw1 Hw2 Hw3.
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Hv1 Hw1. }
        claim Lxv: SNo (x + v).
        { exact SNo_add_SNo x v Hx Hv1. }
        claim Luvw: SNo (u + v * w).
        { exact SNo_add_SNo u (v * w) Hu1 Lvw. }
        claim Lxyw: SNo ((x + y) * w).
        { exact SNo_mul_SNo (x + y) w Lxy Hw1. }
        claim Lvz: SNo (v * z).
        { exact SNo_mul_SNo v z Hv1 Hz. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        claim Lyw: SNo (y * w).
        { exact SNo_mul_SNo y w Hy Hw1. }
        claim Luxz: SNo (u + x * z).
        { exact SNo_add_SNo u (x * z) Hu1 Lxz. }
        claim Lvwxw: SNo (v * w + x * w).
        { exact SNo_add_SNo (v * w) (x * w) Lvw Lxw. }
        claim Lvzxw: SNo (v * z + x * w).
        { exact SNo_add_SNo (v * z) (x * w) Lvz Lxw. }
        prove (x + y) * z < u + x * z.
        apply add_SNo_Lt1_cancel ((x + y) * z) (v * w + x * w) (u + x * z)
                                 Lxyz Lvwxw Luxz.
        prove (x + y) * z + v * w + x * w < (u + x * z) + v * w + x * w.
        rewrite add_SNo_com_4_inner_mid u (x * z) (v * w) (x * w) Hu1 Lxz Lvw Lxw.
        prove (x + y) * z + v * w + x * w < (u + v * w) + x * z + x * w.
        apply SNoLtLe_tra ((x + y) * z + v * w + x * w)
                          (v * z + x * z + x * w + y * w)
                          ((u + v * w) + x * z + x * w)
                          (SNo_add_SNo_3 ((x + y) * z) (v * w) (x * w) Lxyz Lvw Lxw)
                          (SNo_add_SNo_4 (v * z) (x * z) (x * w) (y * w) Lvz Lxz Lxw Lyw)
                          (SNo_add_SNo_3 (u + v * w) (x * z) (x * w) Luvw Lxz Lxw).
        - prove (x + y) * z + v * w + x * w < v * z + x * z + x * w + y * w.
          rewrite <- IHz w (SNoL_SNoS z Hz w Hw).
          prove (x + y) * z + v * w + x * w < v * z + x * z + (x + y) * w.
          rewrite add_SNo_com (v * w) (x * w) Lvw Lxw.
          prove (x + y) * z + x * w + v * w < v * z + x * z + (x + y) * w.
          rewrite <- IHyz v (SNoR_SNoS y Hy v Hv) w (SNoL_SNoS z Hz w Hw).
          prove (x + y) * z + (x + v) * w < v * z + x * z + (x + y) * w.
          rewrite add_SNo_assoc (v * z) (x * z) ((x + y) * w) Lvz Lxz Lxyw.
          prove (x + y) * z + (x + v) * w < (v * z + x * z) + (x + y) * w.
          rewrite add_SNo_com (v * z) (x * z) Lvz Lxz.
          rewrite <- IHy v (SNoR_SNoS y Hy v Hv).
          prove (x + y) * z + (x + v) * w < (x + v) * z + (x + y) * w.
          rewrite add_SNo_com ((x + v) * z) ((x + y) * w)
                              (SNo_mul_SNo (x + v) z Lxv Hz)
                              Lxyw.
          rewrite add_SNo_com ((x + y) * z) ((x + v) * w) Lxyz
                                (SNo_mul_SNo (x + v) w Lxv Hw1).
          prove (x + v) * w + (x + y) * z < (x + y) * w + (x + v) * z.
          rewrite add_SNo_com ((x + v) * w) ((x + y) * z)
                              (SNo_mul_SNo (x + v) w Lxv Hw1)
                              Lxyz.
          rewrite add_SNo_com ((x + y) * w) ((x + v) * z)
                              Lxyw
                              (SNo_mul_SNo (x + v) z Lxv Hz).
          prove (x + y) * z + (x + v) * w < (x + v) * z + (x + y) * w.
          apply mul_SNo_Lt (x + v) z (x + y) w Lxv Hz Lxy Hw1.
          + prove x + y < x + v. apply add_SNo_Lt2 x y v Hx Hy Hv1. exact Hv3.
          + prove w < z. exact Hw3.
        - prove v * z + x * z + x * w + y * w <= (u + v * w) + x * z + x * w.
          rewrite add_SNo_assoc (v * z) (x * z) (x * w + y * w)
                                Lvz Lxz (SNo_add_SNo (x * w) (y * w) Lxw Lyw).
          rewrite <- add_SNo_com (y * w) (x * w) Lyw Lxw.
          prove (v * z + x * z) + y * w + x * w <= (u + v * w) + x * z + x * w.
          rewrite add_SNo_com_4_inner_mid (v * z) (x * z) (y * w) (x * w) Lvz Lxz Lyw Lxw.
          prove (v * z + y * w) + x * z + x * w <= (u + v * w) + x * z + x * w.
          apply add_SNo_Le1 (v * z + y * w) (x * z + x * w) (u + v * w)
                            (SNo_add_SNo (v * z) (y * w) Lvz Lyw)
                            (SNo_add_SNo (x * z) (x * w) Lxz Lxw)
                            Luvw.
          prove v * z + y * w <= u + v * w.
          exact Hvw.
      }
Qed.

Theorem mul_SNo_distrL : forall x y z, SNo x -> SNo y -> SNo z
  -> x * (y + z) = x * y + x * z.
let x y z. assume Hx Hy Hz.
transitivity ((y + z) * x),
             (y * x + z * x).
- exact mul_SNo_com x (y + z) Hx (SNo_add_SNo y z Hy Hz).
- exact mul_SNo_distrR y z x Hy Hz Hx.
- prove y * x + z * x = x * y + x * z.
  f_equal.
  + exact mul_SNo_com y x Hy Hx.
  + exact mul_SNo_com z x Hz Hx.
Qed.

Section mul_SNo_assoc_lems.
Variable M:set -> set -> set.
Infix * 355 right := M.
Hypothesis SNo_M : forall x y, SNo x -> SNo y -> SNo (x * y).
Hypothesis DL: forall x y z, SNo x -> SNo y -> SNo z -> x * (y + z) = x * y + x * z.
Hypothesis DR: forall x y z, SNo x -> SNo y -> SNo z -> (x + y) * z = x * z + y * z.
Hypothesis IL: forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 forall p:prop,
      (forall v :e SNoL x, forall w :e SNoL y, u + v * w <= v * y + x * w -> p)
   -> (forall v :e SNoR x, forall w :e SNoR y, u + v * w <= v * y + x * w -> p)
   -> p.
Hypothesis IR: forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 forall p:prop,
     (forall v :e SNoL x, forall w :e SNoR y, v * y + x * w <= u + v * w -> p)
  -> (forall v :e SNoR x, forall w :e SNoL y, v * y + x * w <= u + v * w -> p)
  -> p.
Hypothesis M_Lt: forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u < x -> v < y -> u * y + x * v < x * y + u * v.
Hypothesis M_Le: forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u <= x -> v <= y -> u * y + x * v <= x * y + u * v.

Theorem mul_SNo_assoc_lem1 : forall x y z, SNo x -> SNo y -> SNo z
 -> (forall u :e SNoS_ (SNoLev x), u * (y * z) = (u * y) * z)
 -> (forall v :e SNoS_ (SNoLev y), x * (v * z) = (x * v) * z)
 -> (forall w :e SNoS_ (SNoLev z), x * (y * w) = (x * y) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), u * (v * z) = (u * v) * z)
 -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), u * (y * w) = (u * y) * w)
 -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), x * (v * w) = (x * v) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), u * (v * w) = (u * v) * w)
 -> forall L,
    (forall u :e L,
     forall q:prop,
         (forall v :e SNoL x, forall w :e SNoL (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> (forall v :e SNoR x, forall w :e SNoR (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> q)
 -> forall u :e L, u < (x * y) * z.
let x y z. assume Hx Hy Hz.
assume IHx IHy IHz IHxy IHxz IHyz IHxyz.
let L. assume HLE.
let u. assume Hu: u :e L.
prove u < (x * y) * z.
claim Lxy: SNo (x * y).
{ exact SNo_M x y Hx Hy. }
claim Lyz: SNo (y * z).
{ exact SNo_M y z Hy Hz. }
claim Lxyz2: SNo ((x * y) * z).
{ exact SNo_M (x * y) z Lxy Hz. }
claim L1: forall v :e SNoS_ (SNoLev x),
          forall w, SNo w ->
          forall w1 :e SNoS_ (SNoLev y),
          forall w2 :e SNoS_ (SNoLev z),
        u = v * (y * z) + x * w + - v * w
     -> v * (w1 * z + y * w2) + x * (w + w1 * w2) <= x * (w1 * z + y * w2) + v * (w + w1 * w2)
     -> (v * y + x * w1) * z + (x * y + v * w1) * w2 < (x * y + v * w1) * z + (v * y + x * w1) * w2
     -> u < (x * y) * z.
{ let v. assume Hv. let w. assume Hw. let w1. assume Hw1. let w2. assume Hw2.
  assume Hue H1 H2.
  apply SNoS_E2 (SNoLev x) (SNoLev_ordinal x Hx) v Hv.
  assume Hv1 Hv2 Hv3 Hv4.
  apply SNoS_E2 (SNoLev y) (SNoLev_ordinal y Hy) w1 Hw1.
  assume Hw11 Hw12 Hw13 Hw14.
  apply SNoS_E2 (SNoLev z) (SNoLev_ordinal z Hz) w2 Hw2.
  assume Hw21 Hw22 Hw23 Hw24.
  claim Lvyz: SNo (v * (y * z)).
  { exact SNo_M v (y * z) Hv3 Lyz. }
  claim Lxw: SNo (x * w).
  { exact SNo_M x w Hx Hw. }
  claim Lxw1: SNo (x * w1).
  { exact SNo_M x w1 Hx Hw13. }
  claim Lvw: SNo (v * w).
  { exact SNo_M v w Hv3 Hw. }
  claim Lvw1: SNo (v * w1).
  { exact SNo_M v w1 Hv3 Hw13. }
  claim Lvy: SNo (v * y).
  { exact SNo_M v y Hv3 Hy. }
  claim Lw1z: SNo (w1 * z).
  { exact SNo_M w1 z Hw13 Hz. }
  claim Lyw2: SNo (y * w2).
  { exact SNo_M y w2 Hy Hw23. }
  claim Lvw1z: SNo (v * (w1 * z)).
  { exact SNo_M v (w1 * z) Hv3 Lw1z. }
  claim Lvyw2: SNo (v * (y * w2)).
  { exact SNo_M v (y * w2) Hv3 Lyw2. }
  claim Lw1w2: SNo (w1 * w2).
  { exact SNo_M w1 w2 Hw13 Hw23. }
  claim Lxw1w2: SNo (x * (w1 * w2)).
  { exact SNo_M x (w1 * w2) Hx Lw1w2. }
  claim Lxw1z: SNo (x * (w1 * z)).
  { exact SNo_M x (w1 * z) Hx Lw1z. }
  claim Lxyw2: SNo (x * (y * w2)).
  { exact SNo_M x (y * w2) Hx Lyw2. }
  claim Lvyzxw: SNo (v * (y * z) + x * w).
  { exact SNo_add_SNo (v * (y * z)) (x * w) Lvyz Lxw. }
  claim Lxyzvw: SNo ((x * y) * z + v * w).
  { exact SNo_add_SNo ((x * y) * z) (v * w) Lxyz2 Lvw. }
  claim Lvw1w2: SNo (v * (w1 * w2)).
  { exact SNo_M v (w1 * w2) Hv3 Lw1w2. }
  claim Lww1w2: SNo (w + w1 * w2).
  { exact SNo_add_SNo w (w1 * w2) Hw Lw1w2. }
  claim Lvww1w2: SNo (v * (w + w1 * w2)).
  { exact SNo_M v (w + w1 * w2) Hv3 Lww1w2. }
  claim Lvw1zyw2: SNo (v * (w1 * z + y * w2)).
  { exact SNo_M v (w1 * z + y * w2) Hv3 (SNo_add_SNo (w1 * z) (y * w2) Lw1z Lyw2). }
  claim Lvwvw1w2: SNo (v * w + v * (w1 * w2)).
  { exact SNo_add_SNo (v * w) (v * (w1 * w2)) Lvw Lvw1w2. }
  claim Lvyzxw1zxyw2vwvw1w2: SNo (v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2)).
  { exact SNo_add_SNo_4 (v * (y * z)) (x * (w1 * z)) (x * (y * w2)) (v * w + v * (w1 * w2))
                        Lvyz Lxw1z Lxyw2 Lvwvw1w2.
  }
  claim Lvw1zvyw2xw1w2: SNo (v * (w1 * z) + v * (y * w2) + x * (w1 * w2)).
  { exact SNo_add_SNo_3 (v * (w1 * z)) (v * (y * w2)) (x * (w1 * w2)) Lvw1z Lvyw2 Lxw1w2. }
  prove u < (x * y) * z.
  rewrite Hue.
  prove (v * (y * z)) + (x * w) + - (v * w) < (x * y) * z.
  apply add_SNo_minus_Lt1b3 (v * (y * z)) (x * w) (v * w) ((x * y) * z) Lvyz Lxw Lvw Lxyz2.
  prove v * (y * z) + x * w < (x * y) * z + v * w.
  apply add_SNo_Lt1_cancel (v * (y * z) + x * w)
                           (v * (w1 * z) + v * (y * w2) + x * (w1 * w2))
                           ((x * y) * z + v * w)
                           Lvyzxw
                           Lvw1zvyw2xw1w2
                           Lxyzvw.
  prove (v * (y * z) + x * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2)
      < ((x * y) * z + v * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2).
  apply SNoLeLt_tra ((v * (y * z) + x * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2))
                    (v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2))
                    (((x * y) * z + v * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2)).
  - apply SNo_add_SNo.
    + exact Lvyzxw.
    + exact Lvw1zvyw2xw1w2.
  - exact Lvyzxw1zxyw2vwvw1w2.
  - apply SNo_add_SNo.
    + exact Lxyzvw.
    + exact Lvw1zvyw2xw1w2.
  - prove (v * (y * z) + x * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2)
       <= v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2).
    rewrite <- add_SNo_assoc (v * (y * z)) (x * w) (v * (w1 * z) + v * (y * w2) + x * (w1 * w2)) Lvyz Lxw Lvw1zvyw2xw1w2.
    prove v * (y * z) + x * w + v * (w1 * z) + v * (y * w2) + x * (w1 * w2)
       <= v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2).
    apply add_SNo_Le2 (v * (y * z))
                      (x * w + v * (w1 * z) + v * (y * w2) + x * (w1 * w2))
                      (x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2))
                      Lvyz
                      (SNo_add_SNo (x * w) (v * (w1 * z) + v * (y * w2) + x * (w1 * w2)) Lxw Lvw1zvyw2xw1w2)
                      (SNo_add_SNo_4 (x * (w1 * z)) (x * (y * w2)) (v * w) (v * (w1 * w2)) Lxw1z Lxyw2 Lvw Lvw1w2).
    prove x * w + v * (w1 * z) + v * (y * w2) + x * (w1 * w2)
       <= x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2).
    rewrite add_SNo_assoc (v * (w1 * z)) (v * (y * w2)) (x * (w1 * w2)) Lvw1z Lvyw2 Lxw1w2.
    rewrite <- DL v (w1 * z) (y * w2) Hv3 Lw1z Lyw2.
    prove x * w + v * (w1 * z + y * w2) + x * (w1 * w2)
       <= x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2).
    rewrite add_SNo_com_3_0_1 (x * w) (v * (w1 * z + y * w2)) (x * (w1 * w2))
                              Lxw Lvw1zyw2 Lxw1w2.
    prove v * (w1 * z + y * w2) + x * w + x * (w1 * w2)
       <= x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2).
    rewrite <- DL x w (w1 * w2) Hx Hw Lw1w2.
    prove v * (w1 * z + y * w2) + x * (w + w1 * w2)
       <= x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2).
    rewrite <- DL v w (w1 * w2) Hv3 Hw Lw1w2.
    prove v * (w1 * z + y * w2) + x * (w + w1 * w2)
       <= x * (w1 * z) + x * (y * w2) + v * (w + w1 * w2).
    rewrite add_SNo_assoc (x * (w1 * z)) (x * (y * w2)) (v * (w + w1 * w2))
                          Lxw1z Lxyw2 Lvww1w2.
    rewrite <- DL x (w1 * z) (y * w2) Hx Lw1z Lyw2.
    prove v * (w1 * z + y * w2) + x * (w + w1 * w2)
       <= x * (w1 * z + y * w2) + v * (w + w1 * w2).
    exact H1.
  - prove v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2)
        < ((x * y) * z + v * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2).
    rewrite add_SNo_com ((x * y) * z) (v * w) Lxyz2 Lvw.
    rewrite <- add_SNo_assoc (v * w) ((x * y) * z) (v * (w1 * z) + v * (y * w2) + x * (w1 * w2))
                             Lvw Lxyz2 Lvw1zvyw2xw1w2.
    prove v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2)
        < v * w + (x * y) * z + v * (w1 * z) + v * (y * w2) + x * (w1 * w2).
    rewrite add_SNo_rotate_5_2 (v * (y * z)) (x * (w1 * z)) (x * (y * w2)) (v * w) (v * (w1 * w2))
                               Lvyz Lxw1z Lxyw2 Lvw Lvw1w2.
    prove v * w + v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2)
        < v * w + (x * y) * z + v * (w1 * z) + v * (y * w2) + x * (w1 * w2).
    apply add_SNo_Lt2 (v * w)
                      (v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2))
                      ((x * y) * z + v * (w1 * z) + v * (y * w2) + x * (w1 * w2))
                      Lvw
                      (SNo_add_SNo_4 (v * (w1 * w2)) (v * (y * z)) (x * (w1 * z)) (x * (y * w2)) Lvw1w2 Lvyz Lxw1z Lxyw2)
                      (SNo_add_SNo_4 ((x * y) * z) (v * (w1 * z)) (v * (y * w2)) (x * (w1 * w2)) Lxyz2 Lvw1z Lvyw2 Lxw1w2).
    prove v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2)
        < (x * y) * z + v * (w1 * z) + v * (y * w2) + x * (w1 * w2).
    rewrite add_SNo_assoc ((x * y) * z) (v * (w1 * z)) (v * (y * w2) + x * (w1 * w2)) Lxyz2 Lvw1z (SNo_add_SNo (v * (y * w2)) (x * (w1 * w2)) Lvyw2 Lxw1w2).
    prove v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2)
        < ((x * y) * z + v * (w1 * z)) + v * (y * w2) + x * (w1 * w2).
    rewrite IHxz v Hv w2 Hw2. rewrite IHyz w1 Hw1 w2 Hw2.
    prove v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2)
        < ((x * y) * z + v * (w1 * z)) + (v * y) * w2 + (x * w1) * w2.
    rewrite <- DR (v * y) (x * w1) w2 Lvy Lxw1 Hw23.
    prove v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2)
        < ((x * y) * z + v * (w1 * z)) + (v * y + x * w1) * w2.
    rewrite IHxy v Hv w1 Hw1.
    rewrite <- DR (x * y) (v * w1) z Lxy Lvw1 Hz.
    prove v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2)
        < (x * y + v * w1) * z + (v * y + x * w1) * w2.
    rewrite <- add_SNo_rotate_4_1 (v * (y * z)) (x * (w1 * z)) (x * (y * w2)) (v * (w1 * w2)) Lvyz Lxw1z Lxyw2 Lvw1w2.
    prove v * (y * z) + x * (w1 * z) + x * (y * w2) + v * (w1 * w2)
        < (x * y + v * w1) * z + (v * y + x * w1) * w2.
    rewrite add_SNo_assoc (v * (y * z)) (x * (w1 * z)) (x * (y * w2) + v * (w1 * w2))
                          Lvyz Lxw1z (SNo_add_SNo (x * (y * w2)) (v * (w1 * w2)) Lxyw2 Lvw1w2).
    prove (v * (y * z) + x * (w1 * z)) + x * (y * w2) + v * (w1 * w2)
        < (x * y + v * w1) * z + (v * y + x * w1) * w2.
    rewrite IHx v Hv. rewrite IHy w1 Hw1. rewrite IHz w2 Hw2.
    rewrite IHxyz v Hv w1 Hw1 w2 Hw2.
    prove ((v * y) * z + (x * w1) * z) + (x * y) * w2 + (v * w1) * w2
        < (x * y + v * w1) * z + (v * y + x * w1) * w2.
    rewrite <- DR (v * y) (x * w1) z Lvy Lxw1 Hz.
    rewrite <- DR (x * y) (v * w1) w2 Lxy Lvw1 Hw23.
    prove (v * y + x * w1) * z + (x * y + v * w1) * w2
        < (x * y + v * w1) * z + (v * y + x * w1) * w2.
    exact H2.
}
apply HLE u Hu.
+ let v. assume Hv: v :e SNoL x.
  let w. assume Hw: w :e SNoL (y * z).
  assume Hue: u = v * (y * z) + x * w + - v * w.
  apply SNoL_E x Hx v Hv.
  assume Hv1 Hv2 Hv3.
  claim Lw: SNo w.
  { apply SNoL_E (y * z) Lyz w Hw. assume H _ _. exact H. }
  apply IL y z Hy Hz w Hw.
  * { let w1. assume Hw1: w1 :e SNoL y.
      let w2. assume Hw2: w2 :e SNoL z.
      assume Hwl: w + w1 * w2 <= w1 * z + y * w2.
      apply SNoL_E y Hy w1 Hw1.
      assume Hw11 Hw12 Hw13.
      apply SNoL_E z Hz w2 Hw2.
      assume Hw21 Hw22 Hw23.
      claim Lw1z: SNo (w1 * z).
      { exact SNo_M w1 z Hw11 Hz. }
      claim Lyw2: SNo (y * w2).
      { exact SNo_M y w2 Hy Hw21. }
      claim Lw1zyw2: SNo (w1 * z + y * w2).
      { exact SNo_add_SNo (w1 * z) (y * w2) Lw1z Lyw2. }
      claim Lw1w2: SNo (w1 * w2).
      { exact SNo_M w1 w2 Hw11 Hw21. }
      claim Lww1w2: SNo (w + w1 * w2).
      { exact SNo_add_SNo w (w1 * w2) Lw Lw1w2. }
      apply L1 v (SNoL_SNoS x Hx v Hv) w Lw
               w1 (SNoL_SNoS y Hy w1 Hw1) w2 (SNoL_SNoS z Hz w2 Hw2)
               Hue.
      - prove v * (w1 * z + y * w2) + x * (w + w1 * w2) <= x * (w1 * z + y * w2) + v * (w + w1 * w2).
        apply M_Le x (w1 * z + y * w2) v (w + w1 * w2) Hx Lw1zyw2 Hv1 Lww1w2.
        + prove v <= x. apply SNoLtLe. exact Hv3.
        + prove w + w1 * w2 <= w1 * z + y * w2. exact Hwl.
      - prove (v * y + x * w1) * z + (x * y + v * w1) * w2 < (x * y + v * w1) * z + (v * y + x * w1) * w2.
        apply M_Lt (x * y + v * w1) z (v * y + x * w1) w2
                         (SNo_add_SNo (x * y) (v * w1) Lxy (SNo_M v w1 Hv1 Hw11))
                         Hz
                         (SNo_add_SNo (v * y) (x * w1) (SNo_M v y Hv1 Hy) (SNo_M x w1 Hx Hw11))
                         Hw21.
        + prove v * y + x * w1 < x * y + v * w1.
          apply M_Lt x y v w1 Hx Hy Hv1 Hw11.
          * prove v < x. exact Hv3.
          * prove w1 < y. exact Hw13.
        + prove w2 < z. exact Hw23.
    }
  * { let w1. assume Hw1: w1 :e SNoR y.
      let w2. assume Hw2: w2 :e SNoR z.
      assume Hwl: w + w1 * w2 <= w1 * z + y * w2.
      apply SNoR_E y Hy w1 Hw1.
      assume Hw11 Hw12 Hw13.
      apply SNoR_E z Hz w2 Hw2.
      assume Hw21 Hw22 Hw23.
      claim Lvy: SNo (v * y).
      { exact SNo_M v y Hv1 Hy. }
      claim Lvw1: SNo (v * w1).
      { exact SNo_M v w1 Hv1 Hw11. }
      claim Lxw1: SNo (x * w1).
      { exact SNo_M x w1 Hx Hw11. }
      claim Lw1z: SNo (w1 * z).
      { exact SNo_M w1 z Hw11 Hz. }
      claim Lyw2: SNo (y * w2).
      { exact SNo_M y w2 Hy Hw21. }
      claim Lw1zyw2: SNo (w1 * z + y * w2).
      { exact SNo_add_SNo (w1 * z) (y * w2) Lw1z Lyw2. }
      claim Lw1w2: SNo (w1 * w2).
      { exact SNo_M w1 w2 Hw11 Hw21. }
      claim Lww1w2: SNo (w + w1 * w2).
      { exact SNo_add_SNo w (w1 * w2) Lw Lw1w2. }
      apply L1 v (SNoL_SNoS x Hx v Hv) w Lw
               w1 (SNoR_SNoS y Hy w1 Hw1) w2 (SNoR_SNoS z Hz w2 Hw2)
               Hue.
      - prove v * (w1 * z + y * w2) + x * (w + w1 * w2) <= x * (w1 * z + y * w2) + v * (w + w1 * w2).
        apply M_Le x (w1 * z + y * w2) v (w + w1 * w2) Hx Lw1zyw2 Hv1 Lww1w2.
        + prove v <= x. apply SNoLtLe. exact Hv3.
        + prove w + w1 * w2 <= w1 * z + y * w2. exact Hwl.
      - prove (v * y + x * w1) * z + (x * y + v * w1) * w2 < (x * y + v * w1) * z + (v * y + x * w1) * w2.
        claim Lvyxw1: SNo (v * y + x * w1).
        { exact SNo_add_SNo (v * y) (x * w1) (SNo_M v y Hv1 Hy) (SNo_M x w1 Hx Hw11). }
        claim Lxyvw1: SNo (x * y + v * w1).
        { exact SNo_add_SNo (x * y) (v * w1) Lxy (SNo_M v w1 Hv1 Hw11). }
        claim Lvyxw1z: SNo ((v * y + x * w1) * z).
        { exact SNo_M (v * y + x * w1) z Lvyxw1 Hz. }
        claim Lxyvw1z: SNo ((x * y + v * w1) * z).
        { exact SNo_M (x * y + v * w1) z Lxyvw1 Hz. }
        claim Lvyxw1w2: SNo ((v * y + x * w1) * w2).
        { exact SNo_M (v * y + x * w1) w2 Lvyxw1 Hw21. }
        claim Lxyvw1w2: SNo ((x * y + v * w1) * w2).
        { exact SNo_M (x * y + v * w1) w2 Lxyvw1 Hw21. }
        rewrite add_SNo_com ((v * y + x * w1) * z)
                            ((x * y + v * w1) * w2)
                            Lvyxw1z Lxyvw1w2.
        rewrite add_SNo_com ((x * y + v * w1) * z)
                            ((v * y + x * w1) * w2)
                            Lxyvw1z Lvyxw1w2.
        prove (x * y + v * w1) * w2 + (v * y + x * w1) * z < (v * y + x * w1) * w2 + (x * y + v * w1) * z.
        apply M_Lt (v * y + x * w1) w2 (x * y + v * w1) z
                         Lvyxw1
                         Hw21
                         Lxyvw1
                         Hz.
        + prove x * y + v * w1 < v * y + x * w1.
          rewrite add_SNo_com (x * y) (v * w1) Lxy Lvw1.
          rewrite add_SNo_com (v * y) (x * w1) Lvy Lxw1.
          apply M_Lt x w1 v y Hx Hw11 Hv1 Hy.
          * prove v < x. exact Hv3.
          * prove y < w1. exact Hw13.
        + prove z < w2. exact Hw23.
    }
+ let v. assume Hv: v :e SNoR x.
  let w. assume Hw: w :e SNoR (y * z).
  assume Hue: u = v * (y * z) + x * w + - v * w.
  apply SNoR_E x Hx v Hv.
  assume Hv1 Hv2 Hv3.
  claim Lw: SNo w.
  { apply SNoR_E (y * z) Lyz w Hw. assume H _ _. exact H. }
  claim Lvw: SNo (v * w).
  { exact SNo_M v w Hv1 Lw. }
  apply IR y z Hy Hz w Hw.
  * { let w1. assume Hw1: w1 :e SNoL y.
      let w2. assume Hw2: w2 :e SNoR z.
      assume Hwl: w1 * z + y * w2 <= w + w1 * w2.
      apply SNoL_E y Hy w1 Hw1.
      assume Hw11 Hw12 Hw13.
      apply SNoR_E z Hz w2 Hw2.
      assume Hw21 Hw22 Hw23.
      claim Lvy: SNo (v * y).
      { exact SNo_M v y Hv1 Hy. }
      claim Lvw1: SNo (v * w1).
      { exact SNo_M v w1 Hv1 Hw11. }
      claim Lxw1: SNo (x * w1).
      { exact SNo_M x w1 Hx Hw11. }
      claim Lw1z: SNo (w1 * z).
      { exact SNo_M w1 z Hw11 Hz. }
      claim Lyw2: SNo (y * w2).
      { exact SNo_M y w2 Hy Hw21. }
      claim Lw1zyw2: SNo (w1 * z + y * w2).
      { exact SNo_add_SNo (w1 * z) (y * w2) Lw1z Lyw2. }
      claim Lw1w2: SNo (w1 * w2).
      { exact SNo_M w1 w2 Hw11 Hw21. }
      claim Lww1w2: SNo (w + w1 * w2).
      { exact SNo_add_SNo w (w1 * w2) Lw Lw1w2. }
      claim Lxww1w2: SNo (x * (w + w1 * w2)).
      { exact SNo_M x (w + w1 * w2) Hx Lww1w2. }
      claim Lvww1w2: SNo (v * (w + w1 * w2)).
      { exact SNo_M v (w + w1 * w2) Hv1 Lww1w2. }
      claim Lvw1w2: SNo (v * (w1 * w2)).
      { exact SNo_M v (w1 * w2) Hv1 Lw1w2. }
      claim Lvw1zyw2: SNo (v * (w1 * z + y * w2)).
      { exact SNo_M v (w1 * z + y * w2) Hv1 Lw1zyw2. }
      claim Lvwvw1w2: SNo (v * w + v * (w1 * w2)).
      { exact SNo_add_SNo (v * w) (v * (w1 * w2)) Lvw Lvw1w2. }
      claim Lxw1zyw2: SNo (x * (w1 * z + y * w2)).
      { exact SNo_M x (w1 * z + y * w2) Hx Lw1zyw2. }
      claim Lvyxw1: SNo (v * y + x * w1).
      { exact SNo_add_SNo (v * y) (x * w1) Lvy Lxw1. }
      claim Lxyvw1: SNo (x * y + v * w1).
      { exact SNo_add_SNo (x * y) (v * w1) Lxy Lvw1. }
      claim Lvyxw1z: SNo ((v * y + x * w1) * z).
      { exact SNo_M (v * y + x * w1) z Lvyxw1 Hz. }
      claim Lxyvw1z: SNo ((x * y + v * w1) * z).
      { exact SNo_M (x * y + v * w1) z Lxyvw1 Hz. }
      claim Lvyxw1w2: SNo ((v * y + x * w1) * w2).
      { exact SNo_M (v * y + x * w1) w2 Lvyxw1 Hw21. }
      claim Lxyvw1w2: SNo ((x * y + v * w1) * w2).
      { exact SNo_M (x * y + v * w1) w2 Lxyvw1 Hw21. }
      apply L1 v (SNoR_SNoS x Hx v Hv) w Lw
               w1 (SNoL_SNoS y Hy w1 Hw1) w2 (SNoR_SNoS z Hz w2 Hw2)
               Hue.
      - prove v * (w1 * z + y * w2) + x * (w + w1 * w2) <= x * (w1 * z + y * w2) + v * (w + w1 * w2).
        rewrite add_SNo_com (v * (w1 * z + y * w2)) (x * (w + w1 * w2)) Lvw1zyw2 Lxww1w2.
        prove x * (w + w1 * w2) + v * (w1 * z + y * w2) <= x * (w1 * z + y * w2) + v * (w + w1 * w2).
        rewrite add_SNo_com (x * (w1 * z + y * w2)) (v * (w + w1 * w2)) Lxw1zyw2 Lvww1w2.
        prove x * (w + w1 * w2) + v * (w1 * z + y * w2) <= v * (w + w1 * w2) + x * (w1 * z + y * w2).
        apply M_Le v (w + w1 * w2) x (w1 * z + y * w2) Hv1 Lww1w2 Hx Lw1zyw2.
        + prove x <= v. apply SNoLtLe. exact Hv3.
        + prove w1 * z + y * w2 <= w + w1 * w2. exact Hwl.
      - prove (v * y + x * w1) * z + (x * y + v * w1) * w2 < (x * y + v * w1) * z + (v * y + x * w1) * w2.
        rewrite add_SNo_com ((v * y + x * w1) * z) ((x * y + v * w1) * w2) Lvyxw1z Lxyvw1w2.
        rewrite add_SNo_com ((x * y + v * w1) * z) ((v * y + x * w1) * w2) Lxyvw1z Lvyxw1w2.
        prove (x * y + v * w1) * w2 + (v * y + x * w1) * z < (v * y + x * w1) * w2 + (x * y + v * w1) * z.
        apply M_Lt (v * y + x * w1) w2 (x * y + v * w1) z
                         Lvyxw1 Hw21 Lxyvw1 Hz.
        + prove x * y + v * w1 < v * y + x * w1.
          apply M_Lt v y x w1 Hv1 Hy Hx Hw11.
          * prove x < v. exact Hv3.
          * prove w1 < y. exact Hw13.
        + prove z < w2. exact Hw23.
    }
  * { let w1. assume Hw1: w1 :e SNoR y.
      let w2. assume Hw2: w2 :e SNoL z.
      assume Hwl: w1 * z + y * w2 <= w + w1 * w2.
      apply SNoR_E y Hy w1 Hw1.
      assume Hw11 Hw12 Hw13.
      apply SNoL_E z Hz w2 Hw2.
      assume Hw21 Hw22 Hw23.
      claim Lvy: SNo (v * y).
      { exact SNo_M v y Hv1 Hy. }
      claim Lvw1: SNo (v * w1).
      { exact SNo_M v w1 Hv1 Hw11. }
      claim Lxw1: SNo (x * w1).
      { exact SNo_M x w1 Hx Hw11. }
      claim Lw1z: SNo (w1 * z).
      { exact SNo_M w1 z Hw11 Hz. }
      claim Lyw2: SNo (y * w2).
      { exact SNo_M y w2 Hy Hw21. }
      claim Lw1zyw2: SNo (w1 * z + y * w2).
      { exact SNo_add_SNo (w1 * z) (y * w2) Lw1z Lyw2. }
      claim Lw1w2: SNo (w1 * w2).
      { exact SNo_M w1 w2 Hw11 Hw21. }
      claim Lww1w2: SNo (w + w1 * w2).
      { exact SNo_add_SNo w (w1 * w2) Lw Lw1w2. }
      claim Lxww1w2: SNo (x * (w + w1 * w2)).
      { exact SNo_M x (w + w1 * w2) Hx Lww1w2. }
      claim Lvww1w2: SNo (v * (w + w1 * w2)).
      { exact SNo_M v (w + w1 * w2) Hv1 Lww1w2. }
      claim Lvw1w2: SNo (v * (w1 * w2)).
      { exact SNo_M v (w1 * w2) Hv1 Lw1w2. }
      claim Lvw1zyw2: SNo (v * (w1 * z + y * w2)).
      { exact SNo_M v (w1 * z + y * w2) Hv1 Lw1zyw2. }
      claim Lvwvw1w2: SNo (v * w + v * (w1 * w2)).
      { exact SNo_add_SNo (v * w) (v * (w1 * w2)) Lvw Lvw1w2. }
      claim Lxw1zyw2: SNo (x * (w1 * z + y * w2)).
      { exact SNo_M x (w1 * z + y * w2) Hx Lw1zyw2. }
      claim Lvyxw1: SNo (v * y + x * w1).
      { exact SNo_add_SNo (v * y) (x * w1) Lvy Lxw1. }
      claim Lxyvw1: SNo (x * y + v * w1).
      { exact SNo_add_SNo (x * y) (v * w1) Lxy Lvw1. }
      claim Lvyxw1z: SNo ((v * y + x * w1) * z).
      { exact SNo_M (v * y + x * w1) z Lvyxw1 Hz. }
      claim Lxyvw1z: SNo ((x * y + v * w1) * z).
      { exact SNo_M (x * y + v * w1) z Lxyvw1 Hz. }
      claim Lvyxw1w2: SNo ((v * y + x * w1) * w2).
      { exact SNo_M (v * y + x * w1) w2 Lvyxw1 Hw21. }
      claim Lxyvw1w2: SNo ((x * y + v * w1) * w2).
      { exact SNo_M (x * y + v * w1) w2 Lxyvw1 Hw21. }
      apply L1 v (SNoR_SNoS x Hx v Hv) w Lw
               w1 (SNoR_SNoS y Hy w1 Hw1) w2 (SNoL_SNoS z Hz w2 Hw2)
               Hue.
      - prove v * (w1 * z + y * w2) + x * (w + w1 * w2) <= x * (w1 * z + y * w2) + v * (w + w1 * w2).
        rewrite add_SNo_com (v * (w1 * z + y * w2)) (x * (w + w1 * w2)) Lvw1zyw2 Lxww1w2.
        prove x * (w + w1 * w2) + v * (w1 * z + y * w2) <= x * (w1 * z + y * w2) + v * (w + w1 * w2).
        rewrite add_SNo_com (x * (w1 * z + y * w2)) (v * (w + w1 * w2)) Lxw1zyw2 Lvww1w2.
        prove x * (w + w1 * w2) + v * (w1 * z + y * w2) <= v * (w + w1 * w2) + x * (w1 * z + y * w2).
        apply M_Le v (w + w1 * w2) x (w1 * z + y * w2) Hv1 Lww1w2 Hx Lw1zyw2.
        + prove x <= v. apply SNoLtLe. exact Hv3.
        + prove w1 * z + y * w2 <= w + w1 * w2. exact Hwl.
      - prove (v * y + x * w1) * z + (x * y + v * w1) * w2 < (x * y + v * w1) * z + (v * y + x * w1) * w2.
        claim Lvyxw1: SNo (v * y + x * w1).
        { exact SNo_add_SNo (v * y) (x * w1) (SNo_M v y Hv1 Hy) (SNo_M x w1 Hx Hw11). }
        claim Lxyvw1: SNo (x * y + v * w1).
        { exact SNo_add_SNo (x * y) (v * w1) Lxy (SNo_M v w1 Hv1 Hw11). }
        apply M_Lt (x * y + v * w1) z (v * y + x * w1) w2
                         Lxyvw1 Hz
                         Lvyxw1 Hw21.
        + prove v * y + x * w1 < x * y + v * w1.
          rewrite add_SNo_com (x * y) (v * w1) Lxy Lvw1.
          rewrite add_SNo_com (v * y) (x * w1) Lvy Lxw1.
          prove x * w1 + v * y < v * w1 + x * y.
          apply M_Lt v w1 x y Hv1 Hw11 Hx Hy.
          * prove x < v. exact Hv3.
          * prove y < w1. exact Hw13.
        + prove w2 < z. exact Hw23.
    }
Qed.

Theorem mul_SNo_assoc_lem2 : forall x y z, SNo x -> SNo y -> SNo z
 -> (forall u :e SNoS_ (SNoLev x), u * (y * z) = (u * y) * z)
 -> (forall v :e SNoS_ (SNoLev y), x * (v * z) = (x * v) * z)
 -> (forall w :e SNoS_ (SNoLev z), x * (y * w) = (x * y) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), u * (v * z) = (u * v) * z)
 -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), u * (y * w) = (u * y) * w)
 -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), x * (v * w) = (x * v) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), u * (v * w) = (u * v) * w)
 -> forall R,
    (forall u :e R,
     forall q:prop,
         (forall v :e SNoL x, forall w :e SNoR (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> (forall v :e SNoR x, forall w :e SNoL (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> q)
 -> forall u :e R, (x * y) * z < u.
let x y z. assume Hx Hy Hz.
assume IHx IHy IHz IHxy IHxz IHyz IHxyz.
let R. assume HRE.
let u. assume Hu: u :e R.
prove (x * y) * z < u.
claim Lxy: SNo (x * y).
{ exact SNo_M x y Hx Hy. }
claim Lyz: SNo (y * z).
{ exact SNo_M y z Hy Hz. }
claim Lxyz2: SNo ((x * y) * z).
{ exact SNo_M (x * y) z Lxy Hz. }
claim L2: forall v :e SNoS_ (SNoLev x),
          forall w, SNo w ->
          forall w1 :e SNoS_ (SNoLev y),
          forall w2 :e SNoS_ (SNoLev z),
        u = v * (y * z) + x * w + - v * w
     -> x * (w1 * z + y * w2) + v * (w + w1 * w2) <= v * (w1 * z + y * w2) + x * (w + w1 * w2)
     -> (x * y + v * w1) * z + (v * y + x * w1) * w2 < (v * y + x * w1) * z + (x * y + v * w1) * w2
     -> (x * y) * z < u.
{ let v. assume Hv. let w. assume Hw. let w1. assume Hw1. let w2. assume Hw2.
  assume Hue H1 H2.
  apply SNoS_E2 (SNoLev x) (SNoLev_ordinal x Hx) v Hv.
  assume Hv1 Hv2 Hv3 Hv4.
  apply SNoS_E2 (SNoLev y) (SNoLev_ordinal y Hy) w1 Hw1.
  assume Hw11 Hw12 Hw13 Hw14.
  apply SNoS_E2 (SNoLev z) (SNoLev_ordinal z Hz) w2 Hw2.
  assume Hw21 Hw22 Hw23 Hw24.
  claim Lvyz: SNo (v * (y * z)).
  { exact SNo_M v (y * z) Hv3 Lyz. }
  claim Lxw: SNo (x * w).
  { exact SNo_M x w Hx Hw. }
  claim Lxw1: SNo (x * w1).
  { exact SNo_M x w1 Hx Hw13. }
  claim Lvw: SNo (v * w).
  { exact SNo_M v w Hv3 Hw. }
  claim Lvw1: SNo (v * w1).
  { exact SNo_M v w1 Hv3 Hw13. }
  claim Lvy: SNo (v * y).
  { exact SNo_M v y Hv3 Hy. }
  claim Lw1z: SNo (w1 * z).
  { exact SNo_M w1 z Hw13 Hz. }
  claim Lyw2: SNo (y * w2).
  { exact SNo_M y w2 Hy Hw23. }
  claim Lvw1z: SNo (v * (w1 * z)).
  { exact SNo_M v (w1 * z) Hv3 Lw1z. }
  claim Lvyw2: SNo (v * (y * w2)).
  { exact SNo_M v (y * w2) Hv3 Lyw2. }
  claim Lw1w2: SNo (w1 * w2).
  { exact SNo_M w1 w2 Hw13 Hw23. }
  claim Lxw1w2: SNo (x * (w1 * w2)).
  { exact SNo_M x (w1 * w2) Hx Lw1w2. }
  claim Lxw1z: SNo (x * (w1 * z)).
  { exact SNo_M x (w1 * z) Hx Lw1z. }
  claim Lxyw2: SNo (x * (y * w2)).
  { exact SNo_M x (y * w2) Hx Lyw2. }
  claim Lvyzxw: SNo (v * (y * z) + x * w).
  { exact SNo_add_SNo (v * (y * z)) (x * w) Lvyz Lxw. }
  claim Lxyzvw: SNo ((x * y) * z + v * w).
  { exact SNo_add_SNo ((x * y) * z) (v * w) Lxyz2 Lvw. }
  claim Lvw1w2: SNo (v * (w1 * w2)).
  { exact SNo_M v (w1 * w2) Hv3 Lw1w2. }
  claim Lww1w2: SNo (w + w1 * w2).
  { exact SNo_add_SNo w (w1 * w2) Hw Lw1w2. }
  claim Lvww1w2: SNo (v * (w + w1 * w2)).
  { exact SNo_M v (w + w1 * w2) Hv3 Lww1w2. }
  claim Lvw1zyw2: SNo (v * (w1 * z + y * w2)).
  { exact SNo_M v (w1 * z + y * w2) Hv3 (SNo_add_SNo (w1 * z) (y * w2) Lw1z Lyw2). }
  claim Lvwvw1w2: SNo (v * w + v * (w1 * w2)).
  { exact SNo_add_SNo (v * w) (v * (w1 * w2)) Lvw Lvw1w2. }
  claim Lvyzxw1zxyw2vwvw1w2: SNo (v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2)).
  { exact SNo_add_SNo_4 (v * (y * z)) (x * (w1 * z)) (x * (y * w2)) (v * w + v * (w1 * w2))
                        Lvyz Lxw1z Lxyw2 Lvwvw1w2.
  }
  claim Lvw1zvyw2xw1w2: SNo (v * (w1 * z) + v * (y * w2) + x * (w1 * w2)).
  { exact SNo_add_SNo_3 (v * (w1 * z)) (v * (y * w2)) (x * (w1 * w2)) Lvw1z Lvyw2 Lxw1w2. }
  rewrite Hue.
  apply add_SNo_minus_Lt2b3 (v * (y * z)) (x * w) (v * w) ((x * y) * z) Lvyz Lxw Lvw Lxyz2.
  prove (x * y) * z + v * w < v * (y * z) + x * w.
  apply add_SNo_Lt1_cancel ((x * y) * z + v * w)
                           (v * (w1 * z) + v * (y * w2) + x * (w1 * w2))
                           (v * (y * z) + x * w)
                           Lxyzvw
                           Lvw1zvyw2xw1w2
                           Lvyzxw.
  prove ((x * y) * z + v * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2)
      < (v * (y * z) + x * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2).
  apply SNoLtLe_tra (((x * y) * z + v * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2))
                    (v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2))
                    ((v * (y * z) + x * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2)).
  - apply SNo_add_SNo.
    + exact Lxyzvw.
    + exact Lvw1zvyw2xw1w2.
  - exact Lvyzxw1zxyw2vwvw1w2.
  - apply SNo_add_SNo.
    + exact Lvyzxw.
    + exact Lvw1zvyw2xw1w2.
  - prove ((x * y) * z + v * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2)
        < v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2).
    rewrite add_SNo_com ((x * y) * z) (v * w) Lxyz2 Lvw.
    rewrite <- add_SNo_assoc (v * w) ((x * y) * z) (v * (w1 * z) + v * (y * w2) + x * (w1 * w2))
                             Lvw Lxyz2 Lvw1zvyw2xw1w2.
    prove v * w + (x * y) * z + v * (w1 * z) + v * (y * w2) + x * (w1 * w2)
        < v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2).
    rewrite add_SNo_rotate_5_2 (v * (y * z)) (x * (w1 * z)) (x * (y * w2)) (v * w) (v * (w1 * w2))
                               Lvyz Lxw1z Lxyw2 Lvw Lvw1w2.
    prove v * w + (x * y) * z + v * (w1 * z) + v * (y * w2) + x * (w1 * w2)
        < v * w + v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2).
    apply add_SNo_Lt2 (v * w)
                      ((x * y) * z + v * (w1 * z) + v * (y * w2) + x * (w1 * w2))
                      (v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2))
                      Lvw
                      (SNo_add_SNo_4 ((x * y) * z) (v * (w1 * z)) (v * (y * w2)) (x * (w1 * w2)) Lxyz2 Lvw1z Lvyw2 Lxw1w2)
                      (SNo_add_SNo_4 (v * (w1 * w2)) (v * (y * z)) (x * (w1 * z)) (x * (y * w2)) Lvw1w2 Lvyz Lxw1z Lxyw2).
    prove (x * y) * z + v * (w1 * z) + v * (y * w2) + x * (w1 * w2)
        < v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2).
    rewrite add_SNo_assoc ((x * y) * z) (v * (w1 * z)) (v * (y * w2) + x * (w1 * w2)) Lxyz2 Lvw1z (SNo_add_SNo (v * (y * w2)) (x * (w1 * w2)) Lvyw2 Lxw1w2).
    prove ((x * y) * z + v * (w1 * z)) + v * (y * w2) + x * (w1 * w2)
        < v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2).
    rewrite IHxz v Hv w2 Hw2. rewrite IHyz w1 Hw1 w2 Hw2.
    prove ((x * y) * z + v * (w1 * z)) + (v * y) * w2 + (x * w1) * w2
        < v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2).
    rewrite <- DR (v * y) (x * w1) w2 Lvy Lxw1 Hw23.
    prove ((x * y) * z + v * (w1 * z)) + (v * y + x * w1) * w2
        < v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2).
    rewrite IHxy v Hv w1 Hw1.
    rewrite <- DR (x * y) (v * w1) z Lxy Lvw1 Hz.
    prove (x * y + v * w1) * z + (v * y + x * w1) * w2
        < v * (w1 * w2) + v * (y * z) + x * (w1 * z) + x * (y * w2).
    rewrite <- add_SNo_rotate_4_1 (v * (y * z)) (x * (w1 * z)) (x * (y * w2)) (v * (w1 * w2)) Lvyz Lxw1z Lxyw2 Lvw1w2.
    prove (x * y + v * w1) * z + (v * y + x * w1) * w2
        < v * (y * z) + x * (w1 * z) + x * (y * w2) + v * (w1 * w2).
    rewrite add_SNo_assoc (v * (y * z)) (x * (w1 * z)) (x * (y * w2) + v * (w1 * w2))
                          Lvyz Lxw1z (SNo_add_SNo (x * (y * w2)) (v * (w1 * w2)) Lxyw2 Lvw1w2).
    prove (x * y + v * w1) * z + (v * y + x * w1) * w2
        < (v * (y * z) + x * (w1 * z)) + x * (y * w2) + v * (w1 * w2).
    rewrite IHx v Hv. rewrite IHy w1 Hw1. rewrite IHz w2 Hw2.
    rewrite IHxyz v Hv w1 Hw1 w2 Hw2.
    prove (x * y + v * w1) * z + (v * y + x * w1) * w2
        < ((v * y) * z + (x * w1) * z) + (x * y) * w2 + (v * w1) * w2.
    rewrite <- DR (v * y) (x * w1) z Lvy Lxw1 Hz.
    rewrite <- DR (x * y) (v * w1) w2 Lxy Lvw1 Hw23.
    prove (x * y + v * w1) * z + (v * y + x * w1) * w2
        < (v * y + x * w1) * z + (x * y + v * w1) * w2.
    exact H2.
  - prove v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2)
       <= (v * (y * z) + x * w) + v * (w1 * z) + v * (y * w2) + x * (w1 * w2).
    rewrite <- add_SNo_assoc (v * (y * z)) (x * w) (v * (w1 * z) + v * (y * w2) + x * (w1 * w2)) Lvyz Lxw Lvw1zvyw2xw1w2.
    prove v * (y * z) + x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2)
       <= v * (y * z) + x * w + v * (w1 * z) + v * (y * w2) + x * (w1 * w2).
    apply add_SNo_Le2 (v * (y * z))
                      (x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2))
                      (x * w + v * (w1 * z) + v * (y * w2) + x * (w1 * w2))
                      Lvyz
                      (SNo_add_SNo_4 (x * (w1 * z)) (x * (y * w2)) (v * w) (v * (w1 * w2)) Lxw1z Lxyw2 Lvw Lvw1w2)
                      (SNo_add_SNo (x * w) (v * (w1 * z) + v * (y * w2) + x * (w1 * w2)) Lxw Lvw1zvyw2xw1w2).
    prove x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2)
       <= x * w + v * (w1 * z) + v * (y * w2) + x * (w1 * w2).
    rewrite add_SNo_assoc (v * (w1 * z)) (v * (y * w2)) (x * (w1 * w2)) Lvw1z Lvyw2 Lxw1w2.
    rewrite <- DL v (w1 * z) (y * w2) Hv3 Lw1z Lyw2.
    prove x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2)
       <= x * w + v * (w1 * z + y * w2) + x * (w1 * w2).
    rewrite add_SNo_com_3_0_1 (x * w) (v * (w1 * z + y * w2)) (x * (w1 * w2))
                              Lxw Lvw1zyw2 Lxw1w2.
    prove x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2)
       <= v * (w1 * z + y * w2) + x * w + x * (w1 * w2).
    rewrite <- DL x w (w1 * w2) Hx Hw Lw1w2.
    prove x * (w1 * z) + x * (y * w2) + v * w + v * (w1 * w2)
       <= v * (w1 * z + y * w2) + x * (w + w1 * w2).
    rewrite <- DL v w (w1 * w2) Hv3 Hw Lw1w2.
    prove x * (w1 * z) + x * (y * w2) + v * (w + w1 * w2)
       <= v * (w1 * z + y * w2) + x * (w + w1 * w2).
    rewrite add_SNo_assoc (x * (w1 * z)) (x * (y * w2)) (v * (w + w1 * w2))
                          Lxw1z Lxyw2 Lvww1w2.
    rewrite <- DL x (w1 * z) (y * w2) Hx Lw1z Lyw2.
    prove x * (w1 * z + y * w2) + v * (w + w1 * w2)
       <= v * (w1 * z + y * w2) + x * (w + w1 * w2).
    exact H1.
}
apply HRE u Hu.
+ let v. assume Hv: v :e SNoL x.
  let w. assume Hw: w :e SNoR (y * z).
  assume Hue: u = v * (y * z) + x * w + - v * w.
  apply SNoL_E x Hx v Hv.
  assume Hv1 Hv2 Hv3.
  claim Lw: SNo w.
  { apply SNoR_E (y * z) Lyz w Hw. assume H _ _. exact H. }
  claim Lvw: SNo (v * w).
  { exact SNo_M v w Hv1 Lw. }
  claim Lvy: SNo (v * y).
  { exact SNo_M v y Hv1 Hy. }
  apply IR y z Hy Hz w Hw.
  * { let w1. assume Hw1: w1 :e SNoL y.
      let w2. assume Hw2: w2 :e SNoR z.
      assume Hwl: w1 * z + y * w2 <= w + w1 * w2.
      apply SNoL_E y Hy w1 Hw1.
      assume Hw11 Hw12 Hw13.
      apply SNoR_E z Hz w2 Hw2.
      assume Hw21 Hw22 Hw23.
      claim Lxw1: SNo (x * w1).
      { exact SNo_M x w1 Hx Hw11. }
      claim Lw1z: SNo (w1 * z).
      { exact SNo_M w1 z Hw11 Hz. }
      claim Lyw2: SNo (y * w2).
      { exact SNo_M y w2 Hy Hw21. }
      claim Lw1zyw2: SNo (w1 * z + y * w2).
      { exact SNo_add_SNo (w1 * z) (y * w2) Lw1z Lyw2. }
      claim Lw1w2: SNo (w1 * w2).
      { exact SNo_M w1 w2 Hw11 Hw21. }
      claim Lww1w2: SNo (w + w1 * w2).
      { exact SNo_add_SNo w (w1 * w2) Lw Lw1w2. }
      claim Lxww1w2: SNo (x * (w + w1 * w2)).
      { exact SNo_M x (w + w1 * w2) Hx Lww1w2. }
      claim Lvww1w2: SNo (v * (w + w1 * w2)).
      { exact SNo_M v (w + w1 * w2) Hv1 Lww1w2. }
      claim Lvw1w2: SNo (v * (w1 * w2)).
      { exact SNo_M v (w1 * w2) Hv1 Lw1w2. }
      claim Lvw1zyw2: SNo (v * (w1 * z + y * w2)).
      { exact SNo_M v (w1 * z + y * w2) Hv1 Lw1zyw2. }
      claim Lvwvw1w2: SNo (v * w + v * (w1 * w2)).
      { exact SNo_add_SNo (v * w) (v * (w1 * w2)) Lvw Lvw1w2. }
      claim Lxw1zyw2: SNo (x * (w1 * z + y * w2)).
      { exact SNo_M x (w1 * z + y * w2) Hx Lw1zyw2. }
      claim Lxyvw1: SNo (x * y + v * w1).
      { exact SNo_add_SNo (x * y) (v * w1) Lxy (SNo_M v w1 Hv1 Hw11). }
      claim Lvyxw1: SNo (v * y + x * w1).
      { exact SNo_add_SNo (v * y) (x * w1) Lvy Lxw1. }
      claim Lxyvw1z: SNo ((x * y + v * w1) * z).
      { exact SNo_M (x * y + v * w1) z Lxyvw1 Hz. }
      claim Lvyxw1z: SNo ((v * y + x * w1) * z).
      { exact SNo_M (v * y + x * w1) z Lvyxw1 Hz. }
      claim Lxyvw1: SNo (x * y + v * w1).
      { exact SNo_add_SNo (x * y) (v * w1) Lxy (SNo_M v w1 Hv1 Hw11). }
      claim Lxyvw1w2: SNo ((x * y + v * w1) * w2).
      { exact SNo_M (x * y + v * w1) w2 Lxyvw1 Hw21. }
      claim Lvyxw1w2: SNo ((v * y + x * w1) * w2).
      { exact SNo_M (v * y + x * w1) w2 Lvyxw1 Hw21. }
      apply L2 v (SNoL_SNoS x Hx v Hv) w Lw
               w1 (SNoL_SNoS y Hy w1 Hw1) w2 (SNoR_SNoS z Hz w2 Hw2)
               Hue.
      - prove x * (w1 * z + y * w2) + v * (w + w1 * w2) <= v * (w1 * z + y * w2) + x * (w + w1 * w2).
        rewrite add_SNo_com (v * (w1 * z + y * w2)) (x * (w + w1 * w2)) Lvw1zyw2 Lxww1w2.
        rewrite add_SNo_com (x * (w1 * z + y * w2)) (v * (w + w1 * w2)) Lxw1zyw2 Lvww1w2.
        prove v * (w + w1 * w2) + x * (w1 * z + y * w2) <= x * (w + w1 * w2) + v * (w1 * z + y * w2).
        apply M_Le x (w + w1 * w2) v (w1 * z + y * w2) Hx Lww1w2 Hv1 Lw1zyw2.
        + prove v <= x. apply SNoLtLe. exact Hv3.
        + exact Hwl.
      - prove (x * y + v * w1) * z + (v * y + x * w1) * w2 < (v * y + x * w1) * z + (x * y + v * w1) * w2.
        rewrite add_SNo_com ((v * y + x * w1) * z) ((x * y + v * w1) * w2) Lvyxw1z Lxyvw1w2.
        rewrite add_SNo_com ((x * y + v * w1) * z) ((v * y + x * w1) * w2) Lxyvw1z Lvyxw1w2.
        prove (v * y + x * w1) * w2 + (x * y + v * w1) * z < (x * y + v * w1) * w2 + (v * y + x * w1) * z.
        apply M_Lt (x * y + v * w1) w2 (v * y + x * w1) z
                         (SNo_add_SNo (x * y) (v * w1) Lxy (SNo_M v w1 Hv1 Hw11))
                         Hw21
                         (SNo_add_SNo (v * y) (x * w1) (SNo_M v y Hv1 Hy) (SNo_M x w1 Hx Hw11))
                         Hz.
        + prove v * y + x * w1 < x * y + v * w1.
          apply M_Lt x y v w1 Hx Hy Hv1 Hw11.
          * prove v < x. exact Hv3.
          * prove w1 < y. exact Hw13.
        + prove z < w2. exact Hw23.
    }
  * { let w1. assume Hw1: w1 :e SNoR y.
      let w2. assume Hw2: w2 :e SNoL z.
      assume Hwl: w1 * z + y * w2 <= w + w1 * w2.
      apply SNoR_E y Hy w1 Hw1.
      assume Hw11 Hw12 Hw13.
      apply SNoL_E z Hz w2 Hw2.
      assume Hw21 Hw22 Hw23.
      claim Lvy: SNo (v * y).
      { exact SNo_M v y Hv1 Hy. }
      claim Lvw1: SNo (v * w1).
      { exact SNo_M v w1 Hv1 Hw11. }
      claim Lxw1: SNo (x * w1).
      { exact SNo_M x w1 Hx Hw11. }
      claim Lw1z: SNo (w1 * z).
      { exact SNo_M w1 z Hw11 Hz. }
      claim Lyw2: SNo (y * w2).
      { exact SNo_M y w2 Hy Hw21. }
      claim Lw1zyw2: SNo (w1 * z + y * w2).
      { exact SNo_add_SNo (w1 * z) (y * w2) Lw1z Lyw2. }
      claim Lw1w2: SNo (w1 * w2).
      { exact SNo_M w1 w2 Hw11 Hw21. }
      claim Lww1w2: SNo (w + w1 * w2).
      { exact SNo_add_SNo w (w1 * w2) Lw Lw1w2. }
      claim Lvww1w2: SNo (v * (w + w1 * w2)).
      { exact SNo_M v (w + w1 * w2) Hv1 Lww1w2. }
      claim Lvw1zyw2: SNo (v * (w1 * z + y * w2)).
      { exact SNo_M v (w1 * z + y * w2) Hv1 Lw1zyw2. }
      claim Lxww1w2: SNo (x * (w + w1 * w2)).
      { exact SNo_M x (w + w1 * w2) Hx Lww1w2. }
      claim Lxw1zyw2: SNo (x * (w1 * z + y * w2)).
      { exact SNo_M x (w1 * z + y * w2) Hx Lw1zyw2. }
      apply L2 v (SNoL_SNoS x Hx v Hv) w Lw
               w1 (SNoR_SNoS y Hy w1 Hw1) w2 (SNoL_SNoS z Hz w2 Hw2)
               Hue.
      - prove x * (w1 * z + y * w2) + v * (w + w1 * w2) <= v * (w1 * z + y * w2) + x * (w + w1 * w2).
        rewrite add_SNo_com (v * (w1 * z + y * w2)) (x * (w + w1 * w2)) Lvw1zyw2 Lxww1w2.
        rewrite add_SNo_com (x * (w1 * z + y * w2)) (v * (w + w1 * w2)) Lxw1zyw2 Lvww1w2.
        apply M_Le x (w + w1 * w2) v (w1 * z + y * w2) Hx Lww1w2 Hv1 Lw1zyw2.
        + prove v <= x. apply SNoLtLe. exact Hv3.
        + exact Hwl.
      - prove (x * y + v * w1) * z + (v * y + x * w1) * w2 < (v * y + x * w1) * z + (x * y + v * w1) * w2.
        claim Lvyxw1: SNo (v * y + x * w1).
        { exact SNo_add_SNo (v * y) (x * w1) (SNo_M v y Hv1 Hy) (SNo_M x w1 Hx Hw11). }
        claim Lxyvw1: SNo (x * y + v * w1).
        { exact SNo_add_SNo (x * y) (v * w1) Lxy (SNo_M v w1 Hv1 Hw11). }
        apply M_Lt (v * y + x * w1) z (x * y + v * w1) w2
                         Lvyxw1
                         Hz
                         Lxyvw1
                         Hw21.
        + prove x * y + v * w1 < v * y + x * w1.
          rewrite add_SNo_com (x * y) (v * w1) Lxy Lvw1.
          rewrite add_SNo_com (v * y) (x * w1) Lvy Lxw1.
          apply M_Lt x w1 v y Hx Hw11 Hv1 Hy.
          * prove v < x. exact Hv3.
          * prove y < w1. exact Hw13.
        + prove w2 < z. exact Hw23.
    }
+ let v. assume Hv: v :e SNoR x.
  let w. assume Hw: w :e SNoL (y * z).
  assume Hue: u = v * (y * z) + x * w + - v * w.
  apply SNoR_E x Hx v Hv.
  assume Hv1 Hv2 Hv3.
  claim Lw: SNo w.
  { apply SNoL_E (y * z) Lyz w Hw. assume H _ _. exact H. }
  claim Lvw: SNo (v * w).
  { exact SNo_M v w Hv1 Lw. }
  apply IL y z Hy Hz w Hw.
  * { let w1. assume Hw1: w1 :e SNoL y.
      let w2. assume Hw2: w2 :e SNoL z.
      assume Hwl: w + w1 * w2 <= w1 * z + y * w2.
      apply SNoL_E y Hy w1 Hw1.
      assume Hw11 Hw12 Hw13.
      apply SNoL_E z Hz w2 Hw2.
      assume Hw21 Hw22 Hw23.
      claim Lvy: SNo (v * y).
      { exact SNo_M v y Hv1 Hy. }
      claim Lvw1: SNo (v * w1).
      { exact SNo_M v w1 Hv1 Hw11. }
      claim Lxw1: SNo (x * w1).
      { exact SNo_M x w1 Hx Hw11. }
      claim Lw1z: SNo (w1 * z).
      { exact SNo_M w1 z Hw11 Hz. }
      claim Lyw2: SNo (y * w2).
      { exact SNo_M y w2 Hy Hw21. }
      claim Lw1zyw2: SNo (w1 * z + y * w2).
      { exact SNo_add_SNo (w1 * z) (y * w2) Lw1z Lyw2. }
      claim Lw1w2: SNo (w1 * w2).
      { exact SNo_M w1 w2 Hw11 Hw21. }
      claim Lww1w2: SNo (w + w1 * w2).
      { exact SNo_add_SNo w (w1 * w2) Lw Lw1w2. }
      claim Lxww1w2: SNo (x * (w + w1 * w2)).
      { exact SNo_M x (w + w1 * w2) Hx Lww1w2. }
      claim Lvww1w2: SNo (v * (w + w1 * w2)).
      { exact SNo_M v (w + w1 * w2) Hv1 Lww1w2. }
      claim Lvw1w2: SNo (v * (w1 * w2)).
      { exact SNo_M v (w1 * w2) Hv1 Lw1w2. }
      claim Lvw1zyw2: SNo (v * (w1 * z + y * w2)).
      { exact SNo_M v (w1 * z + y * w2) Hv1 Lw1zyw2. }
      claim Lvwvw1w2: SNo (v * w + v * (w1 * w2)).
      { exact SNo_add_SNo (v * w) (v * (w1 * w2)) Lvw Lvw1w2. }
      claim Lxw1zyw2: SNo (x * (w1 * z + y * w2)).
      { exact SNo_M x (w1 * z + y * w2) Hx Lw1zyw2. }
      claim Lvyxw1: SNo (v * y + x * w1).
      { exact SNo_add_SNo (v * y) (x * w1) Lvy Lxw1. }
      claim Lxyvw1: SNo (x * y + v * w1).
      { exact SNo_add_SNo (x * y) (v * w1) Lxy Lvw1. }
      claim Lvyxw1z: SNo ((v * y + x * w1) * z).
      { exact SNo_M (v * y + x * w1) z Lvyxw1 Hz. }
      claim Lxyvw1z: SNo ((x * y + v * w1) * z).
      { exact SNo_M (x * y + v * w1) z Lxyvw1 Hz. }
      claim Lvyxw1w2: SNo ((v * y + x * w1) * w2).
      { exact SNo_M (v * y + x * w1) w2 Lvyxw1 Hw21. }
      claim Lxyvw1w2: SNo ((x * y + v * w1) * w2).
      { exact SNo_M (x * y + v * w1) w2 Lxyvw1 Hw21. }
      apply L2 v (SNoR_SNoS x Hx v Hv) w Lw
               w1 (SNoL_SNoS y Hy w1 Hw1) w2 (SNoL_SNoS z Hz w2 Hw2)
               Hue.
      - prove x * (w1 * z + y * w2) + v * (w + w1 * w2) <= v * (w1 * z + y * w2) + x * (w + w1 * w2).
        apply M_Le v (w1 * z + y * w2) x (w + w1 * w2) Hv1 Lw1zyw2 Hx Lww1w2.
        + prove x <= v. apply SNoLtLe. exact Hv3.
        + exact Hwl.
      - prove (x * y + v * w1) * z + (v * y + x * w1) * w2 < (v * y + x * w1) * z + (x * y + v * w1) * w2.
        apply M_Lt (v * y + x * w1) z (x * y + v * w1) w2
                         Lvyxw1 Hz Lxyvw1 Hw21.
        + prove x * y + v * w1 < v * y + x * w1.
          apply M_Lt v y x w1 Hv1 Hy Hx Hw11.
          * prove x < v. exact Hv3.
          * prove w1 < y. exact Hw13.
        + exact Hw23.
    }
  * { let w1. assume Hw1: w1 :e SNoR y.
      let w2. assume Hw2: w2 :e SNoR z.
      assume Hwl: w + w1 * w2 <= w1 * z + y * w2.
      apply SNoR_E y Hy w1 Hw1.
      assume Hw11 Hw12 Hw13.
      apply SNoR_E z Hz w2 Hw2.
      assume Hw21 Hw22 Hw23.
      claim Lvy: SNo (v * y).
      { exact SNo_M v y Hv1 Hy. }
      claim Lvw1: SNo (v * w1).
      { exact SNo_M v w1 Hv1 Hw11. }
      claim Lxw1: SNo (x * w1).
      { exact SNo_M x w1 Hx Hw11. }
      claim Lw1z: SNo (w1 * z).
      { exact SNo_M w1 z Hw11 Hz. }
      claim Lyw2: SNo (y * w2).
      { exact SNo_M y w2 Hy Hw21. }
      claim Lw1zyw2: SNo (w1 * z + y * w2).
      { exact SNo_add_SNo (w1 * z) (y * w2) Lw1z Lyw2. }
      claim Lw1w2: SNo (w1 * w2).
      { exact SNo_M w1 w2 Hw11 Hw21. }
      claim Lww1w2: SNo (w + w1 * w2).
      { exact SNo_add_SNo w (w1 * w2) Lw Lw1w2. }
      claim Lxww1w2: SNo (x * (w + w1 * w2)).
      { exact SNo_M x (w + w1 * w2) Hx Lww1w2. }
      claim Lvww1w2: SNo (v * (w + w1 * w2)).
      { exact SNo_M v (w + w1 * w2) Hv1 Lww1w2. }
      claim Lvw1w2: SNo (v * (w1 * w2)).
      { exact SNo_M v (w1 * w2) Hv1 Lw1w2. }
      claim Lvw1zyw2: SNo (v * (w1 * z + y * w2)).
      { exact SNo_M v (w1 * z + y * w2) Hv1 Lw1zyw2. }
      claim Lvwvw1w2: SNo (v * w + v * (w1 * w2)).
      { exact SNo_add_SNo (v * w) (v * (w1 * w2)) Lvw Lvw1w2. }
      claim Lxw1zyw2: SNo (x * (w1 * z + y * w2)).
      { exact SNo_M x (w1 * z + y * w2) Hx Lw1zyw2. }
      claim Lvyxw1: SNo (v * y + x * w1).
      { exact SNo_add_SNo (v * y) (x * w1) Lvy Lxw1. }
      claim Lxyvw1: SNo (x * y + v * w1).
      { exact SNo_add_SNo (x * y) (v * w1) Lxy Lvw1. }
      claim Lvyxw1z: SNo ((v * y + x * w1) * z).
      { exact SNo_M (v * y + x * w1) z Lvyxw1 Hz. }
      claim Lxyvw1z: SNo ((x * y + v * w1) * z).
      { exact SNo_M (x * y + v * w1) z Lxyvw1 Hz. }
      claim Lvyxw1w2: SNo ((v * y + x * w1) * w2).
      { exact SNo_M (v * y + x * w1) w2 Lvyxw1 Hw21. }
      claim Lxyvw1w2: SNo ((x * y + v * w1) * w2).
      { exact SNo_M (x * y + v * w1) w2 Lxyvw1 Hw21. }
      apply L2 v (SNoR_SNoS x Hx v Hv) w Lw
               w1 (SNoR_SNoS y Hy w1 Hw1) w2 (SNoR_SNoS z Hz w2 Hw2)
               Hue.
      - prove x * (w1 * z + y * w2) + v * (w + w1 * w2) <= v * (w1 * z + y * w2) + x * (w + w1 * w2).
        apply M_Le v (w1 * z + y * w2) x (w + w1 * w2) Hv1 Lw1zyw2 Hx Lww1w2.
        + prove x <= v. apply SNoLtLe. exact Hv3.
        + exact Hwl.
      - prove (x * y + v * w1) * z + (v * y + x * w1) * w2 < (v * y + x * w1) * z + (x * y + v * w1) * w2.
        claim Lvyxw1: SNo (v * y + x * w1).
        { exact SNo_add_SNo (v * y) (x * w1) (SNo_M v y Hv1 Hy) (SNo_M x w1 Hx Hw11). }
        claim Lxyvw1: SNo (x * y + v * w1).
        { exact SNo_add_SNo (x * y) (v * w1) Lxy (SNo_M v w1 Hv1 Hw11). }
        rewrite add_SNo_com ((v * y + x * w1) * z) ((x * y + v * w1) * w2) Lvyxw1z Lxyvw1w2.
        rewrite add_SNo_com ((x * y + v * w1) * z) ((v * y + x * w1) * w2) Lxyvw1z Lvyxw1w2.
        prove (v * y + x * w1) * w2 + (x * y + v * w1) * z < (x * y + v * w1) * w2 + (v * y + x * w1) * z.
        apply M_Lt (x * y + v * w1) w2 (v * y + x * w1) z
                         Lxyvw1 Hw21
                         Lvyxw1 Hz.
        + prove v * y + x * w1 < x * y + v * w1.
          rewrite add_SNo_com (x * y) (v * w1) Lxy Lvw1.
          rewrite add_SNo_com (v * y) (x * w1) Lvy Lxw1.
          prove x * w1 + v * y < v * w1 + x * y.
          apply M_Lt v w1 x y Hv1 Hw11 Hx Hy.
          * prove x < v. exact Hv3.
          * prove y < w1. exact Hw13.
        + exact Hw23.
    }
Qed.

End mul_SNo_assoc_lems.

Theorem mul_SNo_assoc : forall x y z, SNo x -> SNo y -> SNo z
  -> x * (y * z) = (x * y) * z.
set P : set -> set -> set -> prop := fun x y z => x * (y * z) = (x * y) * z.
prove forall x y z, SNo x -> SNo y -> SNo z -> P x y z.
apply SNoLev_ind3 P.
let x y z. assume Hx Hy Hz.
assume IHx: forall u :e SNoS_ (SNoLev x), u * (y * z) = (u * y) * z.
assume IHy: forall v :e SNoS_ (SNoLev y), x * (v * z) = (x * v) * z.
assume IHz: forall w :e SNoS_ (SNoLev z), x * (y * w) = (x * y) * w.
assume IHxy: forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), u * (v * z) = (u * v) * z.
assume IHxz: forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), u * (y * w) = (u * y) * w.
assume IHyz: forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), x * (v * w) = (x * v) * w.
assume IHxyz: forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), u * (v * w) = (u * v) * w.
prove x * (y * z) = (x * y) * z.
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Hx Hy. }
claim Lyz: SNo (y * z).
{ exact SNo_mul_SNo y z Hy Hz. }
claim Lxyz1: SNo (x * (y * z)).
{ exact SNo_mul_SNo x (y * z) Hx Lyz. }
claim Lxyz2: SNo ((x * y) * z).
{ exact SNo_mul_SNo (x * y) z Lxy Hz. }
apply mul_SNo_eq_3 x (y * z) Hx Lyz.
let L R. assume HLR HLE HLI1 HLI2 HRE HRI1 HRI2.
assume HE: x * (y * z) = SNoCut L R.
apply mul_SNo_eq_3 (x * y) z Lxy Hz.
let L' R'. assume HLR' HLE' HLI1' HLI2' HRE' HRI1' HRI2'.
assume HE': (x * y) * z = SNoCut L' R'.
rewrite HE. rewrite HE'.
prove SNoCut L R = SNoCut L' R'.
claim LIL': forall x y, SNo x -> SNo y -> forall u :e SNoL (y * x),
  forall p:prop,
      (forall v :e SNoL x, forall w :e SNoL y, u + w * v <= y * v + w * x -> p)
   -> (forall v :e SNoR x, forall w :e SNoR y, u + w * v <= y * v + w * x -> p)
   -> p.
{ let x y. assume Hx Hy. let u. assume Hu.
  let p. assume Hp1 Hp2.
  apply mul_SNo_SNoL_interpolate_impred y x Hy Hx u Hu.
  - let w. assume Hw: w :e SNoL y. let v. assume Hv: v :e SNoL x.
    apply SNoL_E y Hy w Hw.
    assume Hw1 _ _.
    apply SNoL_E x Hx v Hv.
    assume Hv1 _ _.
    prove u + w * v <= w * x + y * v -> p.
    rewrite add_SNo_com (w * x) (y * v)
                        (SNo_mul_SNo w x Hw1 Hx)
                        (SNo_mul_SNo y v Hy Hv1).
    exact Hp1 v Hv w Hw.
  - let w. assume Hw: w :e SNoR y. let v. assume Hv: v :e SNoR x.
    apply SNoR_E y Hy w Hw.
    assume Hw1 _ _.
    apply SNoR_E x Hx v Hv.
    assume Hv1 _ _.
    prove u + w * v <= w * x + y * v -> p.
    rewrite add_SNo_com (w * x) (y * v)
                        (SNo_mul_SNo w x Hw1 Hx)
                        (SNo_mul_SNo y v Hy Hv1).
    exact Hp2 v Hv w Hw.
}
claim LIR': forall x y, SNo x -> SNo y -> forall u :e SNoR (y * x),
  forall p:prop,
      (forall v :e SNoL x, forall w :e SNoR y, y * v + w * x <= u + w * v -> p)
   -> (forall v :e SNoR x, forall w :e SNoL y, y * v + w * x <= u + w * v -> p)
   -> p.
{ let x y. assume Hx Hy. let u. assume Hu.
  let p. assume Hp1 Hp2.
  apply mul_SNo_SNoR_interpolate_impred y x Hy Hx u Hu.
  - let w. assume Hw: w :e SNoL y. let v. assume Hv: v :e SNoR x.
    apply SNoL_E y Hy w Hw.
    assume Hw1 _ _.
    apply SNoR_E x Hx v Hv.
    assume Hv1 _ _.
    rewrite add_SNo_com (w * x) (y * v)
                        (SNo_mul_SNo w x Hw1 Hx)
                        (SNo_mul_SNo y v Hy Hv1).
    exact Hp2 v Hv w Hw.
  - let w. assume Hw: w :e SNoR y. let v. assume Hv: v :e SNoL x.
    apply SNoR_E y Hy w Hw.
    assume Hw1 _ _.
    apply SNoL_E x Hx v Hv.
    assume Hv1 _ _.
    rewrite add_SNo_com (w * x) (y * v)
                        (SNo_mul_SNo w x Hw1 Hx)
                        (SNo_mul_SNo y v Hy Hv1).
    exact Hp1 v Hv w Hw.
}
claim LMLt': forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
      -> u < x -> v < y -> y * u + v * x < y * x + v * u.
{ let x y u v. assume Hx Hy Hu Hv Hux Hvy.
  rewrite add_SNo_com (y * u) (v * x) (SNo_mul_SNo y u Hy Hu) (SNo_mul_SNo v x Hv Hx).
  prove v * x + y * u < y * x + v * u.
  exact mul_SNo_Lt y x v u Hy Hx Hv Hu Hvy Hux.
}
claim LMLe': forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
      -> u <= x -> v <= y -> y * u + v * x <= y * x + v * u.
{ let x y u v. assume Hx Hy Hu Hv Hux Hvy.
  rewrite add_SNo_com (y * u) (v * x) (SNo_mul_SNo y u Hy Hu) (SNo_mul_SNo v x Hv Hx).
  prove v * x + y * u <= y * x + v * u.
  exact mul_SNo_Le y x v u Hy Hx Hv Hu Hvy Hux.
}
claim LIHx': forall u :e SNoS_ (SNoLev x), (u * y) * z = u * (y * z).
{ let u. assume Hu. symmetry. exact IHx u Hu. }
claim LIHy': forall v :e SNoS_ (SNoLev y), (x * v) * z = x * (v * z).
{ let v. assume Hv. symmetry. exact IHy v Hv. }
claim LIHz': forall w :e SNoS_ (SNoLev z), (x * y) * w = x * (y * w).
{ let w. assume Hw. symmetry. exact IHz w Hw. }
claim LIHyx': forall v :e SNoS_ (SNoLev y), forall u :e SNoS_ (SNoLev x), (u * v) * z = u * (v * z).
{ let v. assume Hv. let u. assume Hu. symmetry.
  exact IHxy u Hu v Hv.
}
claim LIHzx': forall w :e SNoS_ (SNoLev z), forall u :e SNoS_ (SNoLev x), (u * y) * w = u * (y * w).
{ let w. assume Hw. let u. assume Hu. symmetry.
  exact IHxz u Hu w Hw.
}
claim LIHzy': forall w :e SNoS_ (SNoLev z), forall v :e SNoS_ (SNoLev y), (x * v) * w = x * (v * w).
{ let w. assume Hw. let v. assume Hv. symmetry.
  exact IHyz v Hv w Hw.
}
claim LIHzyx': forall w :e SNoS_ (SNoLev z), forall v :e SNoS_ (SNoLev y), forall u :e SNoS_ (SNoLev x), (u * v) * w = u * (v * w).
{ let w. assume Hw. let v. assume Hv. let u. assume Hu. symmetry.
  exact IHxyz u Hu v Hv w Hw.
}
apply SNoCut_ext.
- exact HLR.
- exact HLR'.
- rewrite <- HE'.
  prove forall u :e L, u < (x * y) * z.
  exact mul_SNo_assoc_lem1 mul_SNo SNo_mul_SNo mul_SNo_distrL mul_SNo_distrR
            mul_SNo_SNoL_interpolate_impred
            mul_SNo_SNoR_interpolate_impred
            mul_SNo_Lt mul_SNo_Le
            x y z Hx Hy Hz
            IHx IHy IHz IHxy IHxz IHyz IHxyz L HLE.
- rewrite <- HE'.
  prove forall u :e R, (x * y) * z < u.
  exact mul_SNo_assoc_lem2 mul_SNo SNo_mul_SNo mul_SNo_distrL mul_SNo_distrR
            mul_SNo_SNoL_interpolate_impred
            mul_SNo_SNoR_interpolate_impred
            mul_SNo_Lt mul_SNo_Le
            x y z Hx Hy Hz
            IHx IHy IHz IHxy IHxz IHyz IHxyz R HRE.
- rewrite <- HE.
  prove forall u :e L', u < x * (y * z).
  apply mul_SNo_assoc_lem1 (fun x y => y * x)
     (fun x y Hx Hy => SNo_mul_SNo y x Hy Hx)
     (fun x y z Hx Hy Hz => mul_SNo_distrR y z x Hy Hz Hx)
     (fun x y z Hx Hy Hz => mul_SNo_distrL z x y Hz Hx Hy)
     LIL' LIR' LMLt' LMLe'
     z y x Hz Hy Hx LIHz' LIHy' LIHx' LIHzy' LIHzx' LIHyx' LIHzyx'.
  prove forall u :e L',
     forall q:prop,
         (forall v :e SNoL z, forall w :e SNoL (x * y), u = (x * y) * v + w * z + - w * v -> q)
      -> (forall v :e SNoR z, forall w :e SNoR (x * y), u = (x * y) * v + w * z + - w * v -> q)
      -> q.
  let u. assume Hu. let q. assume Hq1 Hq2. apply HLE' u Hu.
  * let w. assume Hw. let v. assume Hv.
    apply SNoL_E (x * y) Lxy w Hw.
    assume Hw1 _ _.
    apply SNoL_E z Hz v Hv.
    assume Hv1 _ _.
    prove u = w * z + (x * y) * v + - w * v -> q.
    rewrite add_SNo_com_3_0_1 (w * z) ((x * y) * v) (- w * v)
                              (SNo_mul_SNo w z Hw1 Hz)
                              (SNo_mul_SNo (x * y) v Lxy Hv1)
                              (SNo_minus_SNo (w * v) (SNo_mul_SNo w v Hw1 Hv1)).
    exact Hq1 v Hv w Hw.
  * let w. assume Hw. let v. assume Hv.
    apply SNoR_E (x * y) Lxy w Hw.
    assume Hw1 _ _.
    apply SNoR_E z Hz v Hv.
    assume Hv1 _ _.
    prove u = w * z + (x * y) * v + - w * v -> q.
    rewrite add_SNo_com_3_0_1 (w * z) ((x * y) * v) (- w * v)
                              (SNo_mul_SNo w z Hw1 Hz)
                              (SNo_mul_SNo (x * y) v Lxy Hv1)
                              (SNo_minus_SNo (w * v) (SNo_mul_SNo w v Hw1 Hv1)).
    exact Hq2 v Hv w Hw.
- rewrite <- HE.
  prove forall u :e R', x * (y * z) < u.
  apply mul_SNo_assoc_lem2 (fun x y => y * x)
     (fun x y Hx Hy => SNo_mul_SNo y x Hy Hx)
     (fun x y z Hx Hy Hz => mul_SNo_distrR y z x Hy Hz Hx)
     (fun x y z Hx Hy Hz => mul_SNo_distrL z x y Hz Hx Hy)
     LIL' LIR' LMLt' LMLe'
     z y x Hz Hy Hx LIHz' LIHy' LIHx' LIHzy' LIHzx' LIHyx' LIHzyx'.
  prove forall u :e R',
     forall q:prop,
         (forall v :e SNoL z, forall w :e SNoR (x * y), u = (x * y) * v + w * z + - w * v -> q)
      -> (forall v :e SNoR z, forall w :e SNoL (x * y), u = (x * y) * v + w * z + - w * v -> q)
      -> q.
  let u. assume Hu. let q. assume Hq1 Hq2. apply HRE' u Hu.
  * let w. assume Hw. let v. assume Hv.
    apply SNoL_E (x * y) Lxy w Hw.
    assume Hw1 _ _.
    apply SNoR_E z Hz v Hv.
    assume Hv1 _ _.
    prove u = w * z + (x * y) * v + - w * v -> q.
    rewrite add_SNo_com_3_0_1 (w * z) ((x * y) * v) (- w * v)
                              (SNo_mul_SNo w z Hw1 Hz)
                              (SNo_mul_SNo (x * y) v Lxy Hv1)
                              (SNo_minus_SNo (w * v) (SNo_mul_SNo w v Hw1 Hv1)).
    exact Hq2 v Hv w Hw.
  * let w. assume Hw. let v. assume Hv.
    apply SNoR_E (x * y) Lxy w Hw.
    assume Hw1 _ _.
    apply SNoL_E z Hz v Hv.
    assume Hv1 _ _.
    prove u = w * z + (x * y) * v + - w * v -> q.
    rewrite add_SNo_com_3_0_1 (w * z) ((x * y) * v) (- w * v)
                              (SNo_mul_SNo w z Hw1 Hz)
                              (SNo_mul_SNo (x * y) v Lxy Hv1)
                              (SNo_minus_SNo (w * v) (SNo_mul_SNo w v Hw1 Hv1)).
    exact Hq1 v Hv w Hw.
Qed.

Theorem mul_nat_mul_SNo : forall n m :e omega, mul_nat n m = n * m.
let n. assume Hn: n :e omega.
claim Ln1: nat_p n.
{ exact omega_nat_p n Hn. }
claim Ln2: ordinal n.
{ exact nat_p_ordinal n Ln1. }
claim Ln3: SNo n.
{ exact ordinal_SNo n Ln2. }
claim L1: forall m, nat_p m -> mul_nat n m = n * m.
{ apply nat_ind.
  - prove mul_nat n 0 = n * 0.
    rewrite mul_SNo_zeroR n Ln3.
    prove mul_nat n 0 = 0.
    exact mul_nat_0R n.
  - let m.
    assume Hm: nat_p m.
    assume IH: mul_nat n m = n * m.
    prove mul_nat n (ordsucc m) = n * (ordsucc m).
    transitivity add_nat n (mul_nat n m),
                 n + (mul_nat n m),
                 n + (n * m).
    + exact mul_nat_SR n m Hm.
    + exact add_nat_add_SNo n Hn (mul_nat n m) (nat_p_omega (mul_nat n m) (mul_nat_p n Ln1 m Hm)).
    + f_equal. exact IH.
    + prove n + n * m = n * ordsucc m.
      symmetry.
      prove n * ordsucc m = n + n * m.
      rewrite <- add_SNo_0L m (ordinal_SNo m (nat_p_ordinal m Hm)) at 1.
      prove n * ordsucc (0 + m) = n + n * m.
      rewrite <- add_SNo_ordinal_SL 0 ordinal_Empty m (nat_p_ordinal m Hm).
      prove n * (1 + m) = n + n * m.
      rewrite mul_SNo_distrL n 1 m Ln3 SNo_1 (ordinal_SNo m (nat_p_ordinal m Hm)).
      prove n * 1 + n * m = n + n * m.
      f_equal.
      prove n * 1 = n.
      exact mul_SNo_oneR n Ln3.
}
let m. assume Hm: m :e omega.
prove mul_nat n m = n * m.
exact L1 m (omega_nat_p m Hm).
Qed.

Theorem mul_SNo_In_omega : forall n m :e omega, n * m :e omega.
let n. assume Hn. let m. assume Hm.
rewrite <- mul_nat_mul_SNo n Hn m Hm.
apply nat_p_omega. exact mul_nat_p n (omega_nat_p n Hn) m (omega_nat_p m Hm).
Qed.

Theorem mul_SNo_zeroL : forall x, SNo x -> 0 * x = 0.
let x. assume Hx.
rewrite mul_SNo_com 0 x SNo_0 Hx.
exact mul_SNo_zeroR x Hx.
Qed.

Theorem mul_SNo_oneL : forall x, SNo x -> 1 * x = x.
let x. assume Hx.
rewrite mul_SNo_com 1 x SNo_1 Hx.
exact mul_SNo_oneR x Hx.
Qed.

Theorem mul_SNo_rotate_3_1 : forall x y z, SNo x -> SNo y -> SNo z ->
  x * y * z = z * x * y.
let x y z.
assume Hx Hy Hz.
prove x * (y * z) = z * (x * y).
transitivity x * (z * y),
             (x * z) * y,
             (z * x) * y.
- f_equal. exact mul_SNo_com y z Hy Hz.
- exact mul_SNo_assoc x z y Hx Hz Hy.
- f_equal. exact mul_SNo_com x z Hx Hz.
- symmetry. exact mul_SNo_assoc z x y Hz Hx Hy.
Qed.

Theorem pos_mul_SNo_Lt : forall x y z, SNo x -> 0 < x -> SNo y -> SNo z -> y < z -> x * y < x * z.
let x y z.
assume Hx1 Hx2 Hy Hz Hyz.
prove x * y < x * z.
claim L1: 0 * z + x * y = x * y.
{ transitivity 0 + x * y.
  - f_equal. prove 0 * z = 0. exact mul_SNo_zeroL z Hz.
  - exact add_SNo_0L (x * y) (SNo_mul_SNo x y Hx1 Hy).
}
claim L2: x * z + 0 * y = x * z.
{ transitivity x * z + 0.
  - f_equal. exact mul_SNo_zeroL y Hy.
  - exact add_SNo_0R (x * z) (SNo_mul_SNo x z Hx1 Hz).
}
rewrite <- L1. rewrite <- L2.
exact mul_SNo_Lt x z 0 y Hx1 Hz SNo_0 Hy Hx2 Hyz.
Qed.

Theorem nonneg_mul_SNo_Le : forall x y z, SNo x -> 0 <= x -> SNo y -> SNo z -> y <= z -> x * y <= x * z.
let x y z.
assume Hx1 Hx2 Hy Hz Hyz.
prove x * y <= x * z.
claim L1: 0 * z + x * y = x * y.
{ transitivity 0 + x * y.
  - f_equal. prove 0 * z = 0. exact mul_SNo_zeroL z Hz.
  - exact add_SNo_0L (x * y) (SNo_mul_SNo x y Hx1 Hy).
}
claim L2: x * z + 0 * y = x * z.
{ transitivity x * z + 0.
  - f_equal. exact mul_SNo_zeroL y Hy.
  - exact add_SNo_0R (x * z) (SNo_mul_SNo x z Hx1 Hz).
}
rewrite <- L1. rewrite <- L2.
exact mul_SNo_Le x z 0 y Hx1 Hz SNo_0 Hy Hx2 Hyz.
Qed.

Theorem neg_mul_SNo_Lt : forall x y z, SNo x -> x < 0 -> SNo y -> SNo z -> z < y -> x * y < x * z.
let x y z.
assume Hx1 Hx2 Hy Hz Hzy.
prove x * y < x * z.
claim L1: x * y + 0 * z  = x * y.
{ transitivity x * y + 0.
  - f_equal. prove 0 * z = 0. exact mul_SNo_zeroL z Hz.
  - exact add_SNo_0R (x * y) (SNo_mul_SNo x y Hx1 Hy).
}
claim L2: 0 * y + x * z = x * z.
{ transitivity 0 + x * z.
  - f_equal. exact mul_SNo_zeroL y Hy.
  - exact add_SNo_0L (x * z) (SNo_mul_SNo x z Hx1 Hz).
}
rewrite <- L1. rewrite <- L2.
exact mul_SNo_Lt 0 y x z SNo_0 Hy Hx1 Hz Hx2 Hzy.
Qed.

Theorem pos_mul_SNo_Lt' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < z -> x < y -> x * z < y * z.
let x y z. assume Hx Hy Hz Hzpos Hxy.
rewrite mul_SNo_com x z Hx Hz.
rewrite mul_SNo_com y z Hy Hz.
exact pos_mul_SNo_Lt z x y Hz Hzpos Hx Hy Hxy.
Qed.

Theorem mul_SNo_Lt1_pos_Lt : forall x y, SNo x -> SNo y -> x < 1 -> 0 < y -> x * y < y.
let x y. assume Hx Hy Hx1 Hy0.
rewrite <- mul_SNo_oneL y Hy at 2.
prove x * y < 1 * y.
exact pos_mul_SNo_Lt' x 1 y Hx SNo_1 Hy Hy0 Hx1.
Qed.

Theorem nonneg_mul_SNo_Le' : forall x y z, SNo x -> SNo y -> SNo z -> 0 <= z -> x <= y -> x * z <= y * z.
let x y z. assume Hx Hy Hz Hznn Hxy.
rewrite mul_SNo_com x z Hx Hz.
rewrite mul_SNo_com y z Hy Hz.
exact nonneg_mul_SNo_Le z x y Hz Hznn Hx Hy Hxy.
Qed.

Theorem mul_SNo_Le1_nonneg_Le : forall x y, SNo x -> SNo y -> x <= 1 -> 0 <= y -> x * y <= y.
let x y. assume Hx Hy Hx1 Hy0.
rewrite <- mul_SNo_oneL y Hy at 2.
prove x * y <= 1 * y.
exact nonneg_mul_SNo_Le' x 1 y Hx SNo_1 Hy Hy0 Hx1.
Qed.

Theorem pos_mul_SNo_Lt2 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> 0 < x -> 0 < y -> x < z -> y < w -> x * y < z * w.
let x y z w. assume Hx Hy Hz Hw Hxpos Hypos Hxz Hyw.
apply SNoLt_tra (x * y) (x * w) (z * w)
                (SNo_mul_SNo x y Hx Hy)
                (SNo_mul_SNo x w Hx Hw)
                (SNo_mul_SNo z w Hz Hw).
- prove x * y < x * w.
  exact pos_mul_SNo_Lt x y w Hx Hxpos Hy Hw Hyw.
- prove x * w < z * w.
  apply pos_mul_SNo_Lt' x z w Hx Hz Hw.
  + prove 0 < w.
    exact SNoLt_tra 0 y w SNo_0 Hy Hw Hypos Hyw.
  + exact Hxz.
Qed.

Theorem nonneg_mul_SNo_Le2 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> 0 <= x -> 0 <= y -> x <= z -> y <= w -> x * y <= z * w.
let x y z w. assume Hx Hy Hz Hw Hxnn Hynn Hxz Hyw.
apply SNoLe_tra (x * y) (x * w) (z * w)
                (SNo_mul_SNo x y Hx Hy)
                (SNo_mul_SNo x w Hx Hw)
                (SNo_mul_SNo z w Hz Hw).
- prove x * y <= x * w.
  exact nonneg_mul_SNo_Le x y w Hx Hxnn Hy Hw Hyw.
- prove x * w <= z * w.
  apply nonneg_mul_SNo_Le' x z w Hx Hz Hw.
  + prove 0 <= w.
    exact SNoLe_tra 0 y w SNo_0 Hy Hw Hynn Hyw.
  + exact Hxz.
Qed.

Theorem mul_SNo_pos_pos: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> 0 < x * y.
let x y. assume Hx Hy Hx0 Hy0.
prove 0 < x * y.
rewrite <- add_SNo_0R 0 SNo_0.
prove 0 + 0 < x * y.
rewrite <- add_SNo_0R (x * y) (SNo_mul_SNo x y Hx Hy).
prove 0 + 0 < x * y + 0.
rewrite <- mul_SNo_zeroR 0 SNo_0 at 3.
rewrite <- mul_SNo_zeroR x Hx at 2.
rewrite <- mul_SNo_zeroR y Hy at 1.
prove y * 0 + x * 0 < x * y + 0 * 0.
rewrite mul_SNo_com y 0 Hy SNo_0.
prove 0 * y + x * 0 < x * y + 0 * 0.
exact mul_SNo_Lt x y 0 0 Hx Hy SNo_0 SNo_0 Hx0 Hy0.
Qed.

Theorem mul_SNo_pos_neg: forall x y, SNo x -> SNo y -> 0 < x -> y < 0 -> x * y < 0.
let x y. assume Hx Hy Hx0 Hy0.
prove x * y < 0.
rewrite <- add_SNo_0R 0 SNo_0.
rewrite <- add_SNo_0L (x * y) (SNo_mul_SNo x y Hx Hy).
prove 0 + x * y < 0 + 0.
rewrite <- mul_SNo_zeroR y Hy at 3.
rewrite <- mul_SNo_zeroR x Hx at 2.
rewrite <- mul_SNo_zeroR 0 SNo_0 at 1.
rewrite mul_SNo_com y 0 Hy SNo_0.
prove 0 * 0 + x * y < x * 0 + 0 * y.
exact mul_SNo_Lt x 0 0 y Hx SNo_0 SNo_0 Hy Hx0 Hy0.
Qed.

Theorem mul_SNo_neg_pos: forall x y, SNo x -> SNo y -> x < 0 -> 0 < y -> x * y < 0.
let x y. assume Hx Hy Hx0 Hy0.
prove x * y < 0.
rewrite <- add_SNo_0R 0 SNo_0.
rewrite <- add_SNo_0R (x * y) (SNo_mul_SNo x y Hx Hy).
prove x * y + 0 < 0 + 0.
rewrite <- mul_SNo_zeroR x Hx at 3.
rewrite <- mul_SNo_zeroR y Hy at 2.
rewrite <- mul_SNo_zeroR 0 SNo_0 at 1.
rewrite mul_SNo_com y 0 Hy SNo_0.
prove x * y + 0 * 0 < 0 * y + x * 0.
exact mul_SNo_Lt 0 y x 0 SNo_0 Hy Hx SNo_0 Hx0 Hy0.
Qed.

Theorem mul_SNo_neg_neg: forall x y, SNo x -> SNo y -> x < 0 -> y < 0 -> 0 < x * y.
let x y. assume Hx Hy Hx0 Hy0.
prove 0 < x * y.
rewrite <- add_SNo_0R 0 SNo_0.
prove 0 + 0 < x * y.
rewrite <- add_SNo_0L (x * y) (SNo_mul_SNo x y Hx Hy).
prove 0 + 0 < 0 + x * y.
rewrite <- mul_SNo_zeroR 0 SNo_0 at 3.
rewrite <- mul_SNo_zeroR y Hy at 2.
rewrite <- mul_SNo_zeroR x Hx at 1.
prove x * 0 + y * 0 < 0 * 0 + x * y.
rewrite mul_SNo_com y 0 Hy SNo_0.
prove x * 0 + 0 * y < 0 * 0 + x * y.
exact mul_SNo_Lt 0 0 x y SNo_0 SNo_0 Hx Hy Hx0 Hy0.
Qed.

Theorem mul_SNo_nonneg_nonneg: forall x y, SNo x -> SNo y -> 0 <= x -> 0 <= y -> 0 <= x * y.
let x y. assume Hx Hy Hxnn Hynn.
apply SNoLeE 0 x SNo_0 Hx Hxnn.
- assume H1: 0 < x.
  apply SNoLeE 0 y SNo_0 Hy Hynn.
  + assume H2: 0 < y.
    apply SNoLtLe.
    exact mul_SNo_pos_pos x y Hx Hy H1 H2.
  + assume H2: 0 = y.
    rewrite <- H2.
    rewrite mul_SNo_zeroR x Hx. apply SNoLe_ref.
- assume H1: 0 = x.
  rewrite <- H1.
  rewrite mul_SNo_zeroL y Hy. apply SNoLe_ref.
Qed.

Theorem mul_SNo_nonpos_pos: forall x y, SNo x -> SNo y -> x <= 0 -> 0 < y -> x * y <= 0.
let x y. assume Hx Hy Hxnp Hypos.
apply SNoLtLe_or x 0 Hx SNo_0.
- assume H1: x < 0. apply SNoLtLe. prove x * y < 0.
  exact mul_SNo_neg_pos x y Hx Hy H1 Hypos.
- assume H1: 0 <= x.
  claim L1: x = 0.
  { apply SNoLe_antisym x 0 Hx SNo_0.
    - exact Hxnp.
    - exact H1.
  }
  rewrite L1.
  prove 0 * y <= 0.
  rewrite mul_SNo_zeroL y Hy.
  apply SNoLe_ref.
Qed.

Theorem mul_SNo_nonpos_neg: forall x y, SNo x -> SNo y -> x <= 0 -> y < 0 -> 0 <= x * y.
let x y. assume Hx Hy Hxnp Hyneg.
apply SNoLtLe_or x 0 Hx SNo_0.
- assume H1: x < 0. apply SNoLtLe. prove 0 < x * y.
  exact mul_SNo_neg_neg x y Hx Hy H1 Hyneg.
- assume H1: 0 <= x.
  claim L1: x = 0.
  { apply SNoLe_antisym x 0 Hx SNo_0.
    - exact Hxnp.
    - exact H1.
  }
  rewrite L1.
  prove 0 <= 0 * y.
  rewrite mul_SNo_zeroL y Hy.
  apply SNoLe_ref.
Qed.

Theorem nonpos_mul_SNo_Le : forall x y z, SNo x -> x <= 0 -> SNo y -> SNo z -> z <= y -> x * y <= x * z.
let x y z. assume Hx Hxnp Hy Hz Hzy.
apply SNoLtLe_or x 0 Hx SNo_0.
- assume H1: x < 0.
  apply SNoLtLe_or z y Hz Hy.
  + assume H2: z < y. apply SNoLtLe. prove x * y < x * z.
    exact neg_mul_SNo_Lt x y z Hx H1 Hy Hz H2.
  + assume H2: y <= z.
    claim L1: y = z.
    { apply SNoLe_antisym y z Hy Hz.
      - exact H2.
      - exact Hzy.
    }
    rewrite L1.
    apply SNoLe_ref.
- assume H1: 0 <= x.
  claim L1: x = 0.
  { apply SNoLe_antisym x 0 Hx SNo_0.
    - exact Hxnp.
    - exact H1.
  }
  rewrite L1.
  prove 0 * y <= 0 * z.
  rewrite mul_SNo_zeroL y Hy.
  rewrite mul_SNo_zeroL z Hz.
  apply SNoLe_ref.
Qed.

Theorem SNo_zero_or_sqr_pos : forall x, SNo x -> x = 0 \/ 0 < x * x.
let x. assume Hx.
apply SNoLt_trichotomy_or_impred x 0 Hx SNo_0.
- assume H1: x < 0. apply orIR.
  apply mul_SNo_neg_neg.
  + exact Hx.
  + exact Hx.
  + exact H1.
  + exact H1.
- assume H1: x = 0. apply orIL. exact H1.
- assume H1: 0 < x. apply orIR.
  apply mul_SNo_pos_pos.
  + exact Hx.
  + exact Hx.
  + exact H1.
  + exact H1.
Qed.

Theorem SNo_pos_sqr_uniq: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> x * x = y * y -> x = y.
let x y. assume Hx Hy Hxpos Hypos.
assume H1: x * x = y * y.
apply SNoLt_trichotomy_or_impred x y Hx Hy.
- assume H2: x < y. prove False.
  apply SNoLt_irref (x * x).
  prove x * x < x * x.
  rewrite H1 at 2.
  prove x * x < y * y.
  exact pos_mul_SNo_Lt2 x x y y Hx Hx Hy Hy Hxpos Hxpos H2 H2.
- assume H2: x = y. exact H2.
- assume H2: y < x. prove False.
  apply SNoLt_irref (x * x).
  prove x * x < x * x.
  rewrite H1 at 1.
  prove y * y < x * x.
  exact pos_mul_SNo_Lt2 y y x x Hy Hy Hx Hx Hypos Hypos H2 H2.
Qed.

Theorem SNo_nonneg_sqr_uniq: forall x y, SNo x -> SNo y -> 0 <= x -> 0 <= y -> x * x = y * y -> x = y.
let x y. assume Hx Hy Hxnn Hynn.
apply SNoLeE 0 x SNo_0 Hx Hxnn.
- assume H1: 0 < x.
  apply SNoLeE 0 y SNo_0 Hy Hynn.
  + assume H2: 0 < y.
    exact SNo_pos_sqr_uniq x y Hx Hy H1 H2.
  + assume H2: 0 = y. rewrite <- H2.
    rewrite mul_SNo_zeroR 0 SNo_0.
    assume H3: x * x = 0.
    prove x = 0.
    apply SNo_zero_or_sqr_pos x Hx.
    * assume H4: x = 0. exact H4.
    * assume H4: 0 < x * x. prove False. apply SNoLt_irref 0.
      prove 0 < 0. rewrite <- H3 at 2. exact H4.
- assume H1: 0 = x. rewrite <- H1.
  rewrite mul_SNo_zeroR 0 SNo_0.
  assume H2: 0 = y * y.
  prove 0 = y.
  apply SNo_zero_or_sqr_pos y Hy.
  + assume H3: y = 0. symmetry. exact H3.
  + assume H3: 0 < y * y. prove False. apply SNoLt_irref 0.
    prove 0 < 0. rewrite H2 at 2. exact H3.
Qed.

Theorem SNo_foil: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y) * (z + w) = x * z + x * w + y * z + y * w.
let x y z w. assume Hx Hy Hz Hw.
transitivity (x + y) * z + (x + y) * w,
             (x * z + y * z) + (x + y) * w,
             (x * z + y * z) + (x * w + y * w).
- exact mul_SNo_distrL (x + y) z w (SNo_add_SNo x y Hx Hy) Hz Hw.
- f_equal. exact mul_SNo_distrR x y z Hx Hy Hz.
- f_equal. exact mul_SNo_distrR x y w Hx Hy Hw.
- prove (x * z + y * z) + (x * w + y * w)
      = x * z + (x * w + (y * z + y * w)).
  rewrite add_SNo_com_4_inner_mid (x * z) (y * z) (x * w) (y * w)
            (SNo_mul_SNo x z Hx Hz)
            (SNo_mul_SNo y z Hy Hz)
            (SNo_mul_SNo x w Hx Hw)
            (SNo_mul_SNo y w Hy Hw).
  prove (x * z + x * w) + (y * z + y * w)
      = x * z + (x * w + (y * z + y * w)).
  symmetry.
  exact add_SNo_assoc (x * z) (x * w) (y * z + y * w)
            (SNo_mul_SNo x z Hx Hz)
            (SNo_mul_SNo x w Hx Hw)
            (SNo_add_SNo (y * z) (y * w)
                 (SNo_mul_SNo y z Hy Hz)
                 (SNo_mul_SNo y w Hy Hw)).
Qed.

Theorem mul_SNo_minus_minus: forall x y, SNo x -> SNo y -> (- x) * (- y) = x * y.
let x y. assume Hx Hy.
rewrite mul_SNo_minus_distrL x (- y) Hx (SNo_minus_SNo y Hy).
prove - (x * (- y)) = x * y.
rewrite mul_SNo_minus_distrR x y Hx Hy.
prove - - (x * y) = x * y.
exact minus_SNo_invol (x * y) (SNo_mul_SNo x y Hx Hy).
Qed.

Theorem mul_SNo_com_3_0_1 : forall x y z, SNo x -> SNo y -> SNo z
  -> x * y * z = y * x * z.
let x y z.
assume Hx Hy Hz.
rewrite mul_SNo_assoc x y z Hx Hy Hz.
rewrite mul_SNo_assoc y x z Hy Hx Hz.
f_equal.
exact mul_SNo_com x y Hx Hy.
Qed.

Theorem mul_SNo_com_3b_1_2 : forall x y z, SNo x -> SNo y -> SNo z
  -> (x * y) * z = (x * z) * y.
let x y z.
assume Hx Hy Hz.
rewrite <- mul_SNo_assoc x y z Hx Hy Hz.
rewrite <- mul_SNo_assoc x z y Hx Hz Hy.
f_equal.
exact mul_SNo_com y z Hy Hz.
Qed.

Theorem mul_SNo_com_4_inner_mid : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> (x * y) * (z * w) = (x * z) * (y * w).
let x y z w.
assume Hx Hy Hz Hw.
rewrite mul_SNo_assoc (x * y) z w (SNo_mul_SNo x y Hx Hy) Hz Hw.
prove ((x * y) * z) * w = (x * z) * (y * w).
rewrite mul_SNo_com_3b_1_2 x y z Hx Hy Hz.
prove ((x * z) * y) * w = (x * z) * (y * w).
symmetry.
exact mul_SNo_assoc (x * z) y w (SNo_mul_SNo x z Hx Hz) Hy Hw.
Qed.

Theorem SNo_foil_mm: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + - y) * (z + - w) = x * z + - x * w + - y * z + y * w.
let x y z w. assume Hx Hy Hz Hw.
claim Lmy: SNo (- y).
{ exact SNo_minus_SNo y Hy. }
claim Lmw: SNo (- w).
{ exact SNo_minus_SNo w Hw. }
rewrite SNo_foil x (- y) z (- w) Hx Lmy Hz Lmw.
prove x * z + x * (- w) + (- y) * z + (- y) * (- w)
    = x * z + - x * w + - y * z + y * w.
rewrite mul_SNo_minus_minus y w Hy Hw.
rewrite mul_SNo_minus_distrL y z Hy Hz.
rewrite mul_SNo_minus_distrR x w Hx Hw.
reflexivity.
Qed.

Theorem mul_SNo_nonzero_cancel: forall x y z, SNo x -> x <> 0 -> SNo y -> SNo z -> x * y = x * z -> y = z.
let x y z. assume Hx Hxn0 Hy Hz Hxyz.
apply SNoLt_trichotomy_or_impred y z Hy Hz.
- assume H1: y < z. prove False.
  apply SNoLt_trichotomy_or_impred x 0 Hx SNo_0.
  + assume H2: x < 0.
    apply SNoLt_irref (x * y).
    prove x * y < x * y.
    rewrite Hxyz at 1.
    prove x * z < x * y.
    exact neg_mul_SNo_Lt x z y Hx H2 Hz Hy H1.
  + assume H2: x = 0. exact Hxn0 H2.
  + assume H2: 0 < x.
    apply SNoLt_irref (x * y).
    prove x * y < x * y.
    rewrite Hxyz at 2.
    prove x * y < x * z.
    exact pos_mul_SNo_Lt x y z Hx H2 Hy Hz H1.
- assume H1. exact H1.
- assume H1: z < y. prove False.
  apply SNoLt_trichotomy_or_impred x 0 Hx SNo_0.
  + assume H2: x < 0.
    apply SNoLt_irref (x * y).
    prove x * y < x * y.
    rewrite Hxyz at 2.
    prove x * y < x * z.
    exact neg_mul_SNo_Lt x y z Hx H2 Hy Hz H1.
  + assume H2: x = 0. exact Hxn0 H2.
  + assume H2: 0 < x.
    apply SNoLt_irref (x * y).
    prove x * y < x * y.
    rewrite Hxyz at 1.
    prove x * z < x * y.
    exact pos_mul_SNo_Lt x z y Hx H2 Hz Hy H1.
Qed.

Theorem mul_SNoCutP_lem : forall Lx Rx Ly Ry x y,
    SNoCutP Lx Rx
 -> SNoCutP Ly Ry
 -> x = SNoCut Lx Rx
 -> y = SNoCut Ly Ry
 -> SNoCutP ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ly}
              :\/:
             {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ry})
            ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ry}
              :\/:
             {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ly})
 /\ x * y
  = SNoCut ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ly}
             :\/:
            {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ry})
           ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ry}
             :\/:
            {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ly})
 /\ forall q:prop,
     (forall LxLy' RxRy' LxRy' RxLy',
         (forall u :e LxLy', forall p:prop, (forall w :e Lx, forall w' :e Ly, SNo w -> SNo w' -> w < x -> w' < y -> u = w * y + x * w' + - w * w' -> p) -> p)
      -> (forall w :e Lx, forall w' :e Ly, w * y + x * w' + - w * w' :e LxLy')
      -> (forall u :e RxRy', forall p:prop, (forall z :e Rx, forall z' :e Ry, SNo z -> SNo z' -> x < z -> y < z' -> u = z * y + x * z' + - z * z' -> p) -> p)
      -> (forall z :e Rx, forall z' :e Ry, z * y + x * z' + - z * z' :e RxRy')
      -> (forall u :e LxRy', forall p:prop, (forall w :e Lx, forall z :e Ry, SNo w -> SNo z -> w < x -> y < z -> u = w * y + x * z + - w * z -> p) -> p)
      -> (forall w :e Lx, forall z :e Ry, w * y + x * z + - w * z :e LxRy')
      -> (forall u :e RxLy', forall p:prop, (forall z :e Rx, forall w :e Ly, SNo z -> SNo w -> x < z -> w < y -> u = z * y + x * w + - z * w -> p) -> p)
      -> (forall z :e Rx, forall w :e Ly, z * y + x * w + - z * w :e RxLy')
      -> SNoCutP (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> x * y = SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> q)
    -> q.
let Lx Rx Ly Ry x y.
assume HLRx HLRy Hxe Hye.
apply HLRx. assume H. apply H.
assume HLRx1: forall w :e Lx, SNo w.
assume HLRx2: forall z :e Rx, SNo z.
assume HLRx3: forall w :e Lx, forall z :e Rx, w < z.
apply HLRy. assume H. apply H.
assume HLRy1: forall w :e Ly, SNo w.
assume HLRy2: forall z :e Ry, SNo z.
assume HLRy3: forall w :e Ly, forall z :e Ry, w < z.
apply SNoCutP_SNoCut_impred Lx Rx HLRx.
rewrite <- Hxe.
assume Hx1: SNo x.
assume Hx2: SNoLev x :e ordsucc ((\/_ w :e Lx, ordsucc (SNoLev w)) :\/: (\/_ z :e Rx, ordsucc (SNoLev z))).
assume Hx3: forall w :e Lx, w < x.
assume Hx4: forall z :e Rx, x < z.
assume Hx5: (forall u, SNo u -> (forall w :e Lx, w < u) -> (forall z :e Rx, u < z) -> SNoLev x c= SNoLev u /\ SNoEq_ (SNoLev x) x u).
apply SNoCutP_SNoCut_impred Ly Ry HLRy.
rewrite <- Hye.
assume Hy1: SNo y.
assume Hy2: SNoLev y :e ordsucc ((\/_ w :e Ly, ordsucc (SNoLev w)) :\/: (\/_ z :e Ry, ordsucc (SNoLev z))).
assume Hy3: forall w :e Ly, w < y.
assume Hy4: forall z :e Ry, y < z.
assume Hy5: (forall u, SNo u -> (forall w :e Ly, w < u) -> (forall z :e Ry, u < z) -> SNoLev y c= SNoLev u /\ SNoEq_ (SNoLev y) y u).
set LxLy' := {w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ly}.
set RxRy' := {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ry}.
set LxRy' := {w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ry}.
set RxLy' := {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ly}.
claim LxLy'E: forall u :e LxLy', forall p:prop, (forall w :e Lx, forall w' :e Ly, SNo w -> SNo w' -> w < x -> w' < y -> u = w * y + x * w' + - w * w' -> p) -> p.
{ let u. assume Hu. let p. assume Hp.
  apply ReplE_impred (Lx :*: Ly) (fun w => (w 0) * y + x * (w 1) + - (w 0) * (w 1)) u Hu.
  let ww'. assume Hww': ww' :e Lx :*: Ly.
  assume Hue: u = (ww' 0) * y + x * (ww' 1) + - (ww' 0) * (ww' 1).
  claim Lww'0: ww' 0 :e Lx.
  { exact ap0_Sigma Lx (fun _ => Ly) ww' Hww'. }
  claim Lww'1: ww' 1 :e Ly.
  { exact ap1_Sigma Lx (fun _ => Ly) ww' Hww'. }
  apply Hp (ww' 0) Lww'0 (ww' 1) Lww'1.
  - prove SNo (ww' 0). exact HLRx1 (ww' 0) Lww'0.
  - prove SNo (ww' 1). exact HLRy1 (ww' 1) Lww'1.
  - prove ww' 0 < x. exact Hx3 (ww' 0) Lww'0.
  - prove ww' 1 < y. exact Hy3 (ww' 1) Lww'1.
  - exact Hue.
}
claim LxLy'I: forall w :e Lx, forall w' :e Ly, w * y + x * w' + - w * w' :e LxLy'.
{ let w. assume Hw. let w'. assume Hw'.
  rewrite <- tuple_2_0_eq w w'.
  rewrite <- tuple_2_1_eq w w' at 2 4.
  apply ReplI (Lx :*: Ly) (fun w => w 0 * y + x * w 1 + - w 0 * w 1) (w,w').
  prove (w,w') :e Lx :*: Ly.
  exact tuple_2_setprod Lx Ly w Hw w' Hw'.
}
claim RxRy'E: forall u :e RxRy', forall p:prop, (forall z :e Rx, forall z' :e Ry, SNo z -> SNo z' -> x < z -> y < z' -> u = z * y + x * z' + - z * z' -> p) -> p.
{ let u. assume Hu. let p. assume Hp.
  apply ReplE_impred (Rx :*: Ry) (fun z => (z 0) * y + x * (z 1) + - (z 0) * (z 1)) u Hu.
  let zz'. assume Hzz': zz' :e Rx :*: Ry.
  assume Hue: u = (zz' 0) * y + x * (zz' 1) + - (zz' 0) * (zz' 1).
  claim Lzz'0: zz' 0 :e Rx.
  { exact ap0_Sigma Rx (fun _ => Ry) zz' Hzz'. }
  claim Lzz'1: zz' 1 :e Ry.
  { exact ap1_Sigma Rx (fun _ => Ry) zz' Hzz'. }
  apply Hp (zz' 0) Lzz'0 (zz' 1) Lzz'1.
  - prove SNo (zz' 0). exact HLRx2 (zz' 0) Lzz'0.
  - prove SNo (zz' 1). exact HLRy2 (zz' 1) Lzz'1.
  - prove x < zz' 0. exact Hx4 (zz' 0) Lzz'0.
  - prove y < zz' 1. exact Hy4 (zz' 1) Lzz'1.
  - exact Hue.
}
claim RxRy'I: forall z :e Rx, forall z' :e Ry, z * y + x * z' + - z * z' :e RxRy'.
{ let z. assume Hz. let z'. assume Hz'.
  rewrite <- tuple_2_0_eq z z'.
  rewrite <- tuple_2_1_eq z z' at 2 4.
  apply ReplI (Rx :*: Ry) (fun z => z 0 * y + x * z 1 + - z 0 * z 1) (z,z').
  prove (z,z') :e Rx :*: Ry.
  exact tuple_2_setprod Rx Ry z Hz z' Hz'.
}
claim LxRy'E: forall u :e LxRy', forall p:prop, (forall w :e Lx, forall z :e Ry, SNo w -> SNo z -> w < x -> y < z -> u = w * y + x * z + - w * z -> p) -> p.
{ let u. assume Hu. let p. assume Hp.
  apply ReplE_impred (Lx :*: Ry) (fun w => (w 0) * y + x * (w 1) + - (w 0) * (w 1)) u Hu.
  let wz. assume Hwz: wz :e Lx :*: Ry.
  assume Hue: u = (wz 0) * y + x * (wz 1) + - (wz 0) * (wz 1).
  claim Lwz0: wz 0 :e Lx.
  { exact ap0_Sigma Lx (fun _ => Ry) wz Hwz. }
  claim Lwz1: wz 1 :e Ry.
  { exact ap1_Sigma Lx (fun _ => Ry) wz Hwz. }
  apply Hp (wz 0) Lwz0 (wz 1) Lwz1.
  - prove SNo (wz 0). exact HLRx1 (wz 0) Lwz0.
  - prove SNo (wz 1). exact HLRy2 (wz 1) Lwz1.
  - prove wz 0 < x. exact Hx3 (wz 0) Lwz0.
  - prove y < wz 1. exact Hy4 (wz 1) Lwz1.
  - exact Hue.
}
claim LxRy'I: forall w :e Lx, forall z :e Ry, w * y + x * z + - w * z :e LxRy'.
{ let w. assume Hw. let z. assume Hz.
  rewrite <- tuple_2_0_eq w z.
  rewrite <- tuple_2_1_eq w z at 2 4.
  apply ReplI (Lx :*: Ry) (fun w => w 0 * y + x * w 1 + - w 0 * w 1) (w,z).
  prove (w,z) :e Lx :*: Ry.
  exact tuple_2_setprod Lx Ry w Hw z Hz.
}
claim RxLy'E: forall u :e RxLy', forall p:prop, (forall z :e Rx, forall w :e Ly, SNo z -> SNo w -> x < z -> w < y -> u = z * y + x * w + - z * w -> p) -> p.
{ let u. assume Hu. let p. assume Hp.
  apply ReplE_impred (Rx :*: Ly) (fun z => (z 0) * y + x * (z 1) + - (z 0) * (z 1)) u Hu.
  let zw. assume Hzw: zw :e Rx :*: Ly.
  assume Hue: u = (zw 0) * y + x * (zw 1) + - (zw 0) * (zw 1).
  claim Lzw0: zw 0 :e Rx.
  { exact ap0_Sigma Rx (fun _ => Ly) zw Hzw. }
  claim Lzw1: zw 1 :e Ly.
  { exact ap1_Sigma Rx (fun _ => Ly) zw Hzw. }
  apply Hp (zw 0) Lzw0 (zw 1) Lzw1.
  - prove SNo (zw 0). exact HLRx2 (zw 0) Lzw0.
  - prove SNo (zw 1). exact HLRy1 (zw 1) Lzw1.
  - prove x < zw 0. exact Hx4 (zw 0) Lzw0.
  - prove zw 1 < y. exact Hy3 (zw 1) Lzw1.
  - exact Hue.
}
claim RxLy'I: forall z :e Rx, forall w :e Ly, z * y + x * w + - z * w :e RxLy'.
{ let z. assume Hz. let w. assume Hw.
  rewrite <- tuple_2_0_eq z w.
  rewrite <- tuple_2_1_eq z w at 2 4.
  apply ReplI (Rx :*: Ly) (fun w => w 0 * y + x * w 1 + - w 0 * w 1) (z,w).
  prove (z,w) :e Rx :*: Ly.
  exact tuple_2_setprod Rx Ly z Hz w Hw.
}
claim L1: SNoCutP (LxLy' :\/: RxRy') (LxRy' :\/: RxLy').
{ prove (forall w :e LxLy' :\/: RxRy', SNo w)
     /\ (forall z :e LxRy' :\/: RxLy', SNo z)
     /\ (forall w :e LxLy' :\/: RxRy', forall z :e LxRy' :\/: RxLy', w < z).
  apply and3I.
  - let w. apply binunionE'.
    + assume Hw: w :e LxLy'.
      apply LxLy'E w Hw.
      let w'. assume Hw': w' :e Lx.
      let w''. assume Hw'': w'' :e Ly.
      assume Hw'1: SNo w'.
      assume Hw''1: SNo w''.
      assume Hw'2: w' < x.
      assume Hw''2: w'' < y.
      assume Hwe. rewrite Hwe.
      prove SNo (w' * y + x * w'' + - w' * w'').
      apply SNo_add_SNo_3.
      * exact SNo_mul_SNo w' y Hw'1 Hy1.
      * exact SNo_mul_SNo x w'' Hx1 Hw''1.
      * apply SNo_minus_SNo.
        exact SNo_mul_SNo w' w'' Hw'1 Hw''1.
    + assume Hw: w :e RxRy'.
      apply RxRy'E w Hw.
      let z'. assume Hz': z' :e Rx.
      let z''. assume Hz'': z'' :e Ry.
      assume Hz'1: SNo z'.
      assume Hz''1: SNo z''.
      assume Hz'2: x < z'.
      assume Hz''2: y < z''.
      assume Hwe. rewrite Hwe.
      prove SNo (z' * y + x * z'' + - z' * z'').
      apply SNo_add_SNo_3.
      * exact SNo_mul_SNo z' y Hz'1 Hy1.
      * exact SNo_mul_SNo x z'' Hx1 Hz''1.
      * apply SNo_minus_SNo.
        exact SNo_mul_SNo z' z'' Hz'1 Hz''1.
  - let z. apply binunionE'.
    + assume Hz: z :e LxRy'.
      apply LxRy'E z Hz.
      let w'. assume Hw': w' :e Lx.
      let z'. assume Hz': z' :e Ry.
      assume Hw'1: SNo w'.
      assume Hz'1: SNo z'.
      assume Hw'2: w' < x.
      assume Hz'2: y < z'.
      assume Hze. rewrite Hze.
      prove SNo (w' * y + x * z' + - w' * z').
      apply SNo_add_SNo_3.
      * exact SNo_mul_SNo w' y Hw'1 Hy1.
      * exact SNo_mul_SNo x z' Hx1 Hz'1.
      * apply SNo_minus_SNo.
        exact SNo_mul_SNo w' z' Hw'1 Hz'1.
    + assume Hz: z :e RxLy'.
      apply RxLy'E z Hz.
      let z'. assume Hz': z' :e Rx.
      let w'. assume Hw': w' :e Ly.
      assume Hz'1: SNo z'.
      assume Hw'1: SNo w'.
      assume Hz'2: x < z'.
      assume Hw'2: w' < y.
      assume Hze. rewrite Hze.
      prove SNo (z' * y + x * w' + - z' * w').
      apply SNo_add_SNo_3.
      * exact SNo_mul_SNo z' y Hz'1 Hy1.
      * exact SNo_mul_SNo x w' Hx1 Hw'1.
      * apply SNo_minus_SNo.
        exact SNo_mul_SNo z' w' Hz'1 Hw'1.
  - let w. apply binunionE'.
    + assume Hw: w :e LxLy'.
      apply LxLy'E w Hw.
      let w'. assume Hw': w' :e Lx.
      let w''. assume Hw'': w'' :e Ly.
      assume Hw'1: SNo w'.
      assume Hw''1: SNo w''.
      assume Hw'2: w' < x.
      assume Hw''2: w'' < y.
      assume Hwe. rewrite Hwe.
      let z. apply binunionE'.
      * { assume Hz: z :e LxRy'.
          apply LxRy'E z Hz.
          let w'''. assume Hw''': w''' :e Lx.
          let z'. assume Hz': z' :e Ry.
          assume Hw'''1: SNo w'''.
          assume Hz'1: SNo z'.
          assume Hw'''2: w''' < x.
          assume Hz'2: y < z'.
          assume Hze. rewrite Hze.
          prove w' * y + x * w'' + - w' * w'' < w''' * y + x * z' + - w''' * z'.
          apply add_SNo_minus_Lt12b3 (w' * y) (x * w'') (w' * w'') (w''' * y) (x * z') (w''' * z')
                       (SNo_mul_SNo w' y Hw'1 Hy1)
                       (SNo_mul_SNo x w'' Hx1 Hw''1)
                       (SNo_mul_SNo w' w'' Hw'1 Hw''1)
                       (SNo_mul_SNo w''' y Hw'''1 Hy1)
                       (SNo_mul_SNo x z' Hx1 Hz'1)
                       (SNo_mul_SNo w''' z' Hw'''1 Hz'1).
          prove w' * y + x * w'' + w''' * z' < w''' * y + x * z' + w' * w''.
          apply SNoLt_tra (w' * y + x * w'' + w''' * z')
                          (x * y + w' * w'' + w''' * z')
                          (w''' * y + x * z' + w' * w'')
                          (SNo_add_SNo_3 (w' * y) (x * w'') (w''' * z')
                              (SNo_mul_SNo w' y Hw'1 Hy1)
                              (SNo_mul_SNo x w'' Hx1 Hw''1)
                              (SNo_mul_SNo w''' z' Hw'''1 Hz'1))
                          (SNo_add_SNo_3 (x * y) (w' * w'') (w''' * z')
                              (SNo_mul_SNo x y Hx1 Hy1)
                              (SNo_mul_SNo w' w'' Hw'1 Hw''1)
                              (SNo_mul_SNo w''' z' Hw'''1 Hz'1))
                          (SNo_add_SNo_3 (w''' * y) (x * z') (w' * w'')
                              (SNo_mul_SNo w''' y Hw'''1 Hy1)
                              (SNo_mul_SNo x z' Hx1 Hz'1)
                              (SNo_mul_SNo w' w'' Hw'1 Hw''1)).
          - prove w' * y + x * w'' + w''' * z' < x * y + w' * w'' + w''' * z'.
            rewrite add_SNo_rotate_3_1 (w' * y) (x * w'') (w''' * z')
                              (SNo_mul_SNo w' y Hw'1 Hy1)
                              (SNo_mul_SNo x w'' Hx1 Hw''1)
                              (SNo_mul_SNo w''' z' Hw'''1 Hz'1).
            rewrite add_SNo_rotate_3_1 (x * y) (w' * w'') (w''' * z')
                              (SNo_mul_SNo x y Hx1 Hy1)
                              (SNo_mul_SNo w' w'' Hw'1 Hw''1)
                              (SNo_mul_SNo w''' z' Hw'''1 Hz'1).
            prove w''' * z' + w' * y + x * w'' < w''' * z' + x * y + w' * w''.
            apply add_SNo_Lt2 (w''' * z') (w' * y + x * w'') (x * y + w' * w'')
                              (SNo_mul_SNo w''' z' Hw'''1 Hz'1)
                              (SNo_add_SNo (w' * y) (x * w'')
                               (SNo_mul_SNo w' y Hw'1 Hy1)
                               (SNo_mul_SNo x w'' Hx1 Hw''1))
                              (SNo_add_SNo (x * y) (w' * w'')
                               (SNo_mul_SNo x y Hx1 Hy1)
                               (SNo_mul_SNo w' w'' Hw'1 Hw''1)).
            prove w' * y + x * w'' < x * y + w' * w''.
            exact mul_SNo_Lt x y w' w'' Hx1 Hy1 Hw'1 Hw''1 Hw'2 Hw''2.
          - prove x * y + w' * w'' + w''' * z' < w''' * y + x * z' + w' * w''.
            rewrite add_SNo_com_3_0_1 (x * y) (w' * w'') (w''' * z')
                              (SNo_mul_SNo x y Hx1 Hy1)
                              (SNo_mul_SNo w' w'' Hw'1 Hw''1)
                              (SNo_mul_SNo w''' z' Hw'''1 Hz'1).
            rewrite add_SNo_rotate_3_1 (w''' * y) (x * z') (w' * w'')
                              (SNo_mul_SNo w''' y Hw'''1 Hy1)
                              (SNo_mul_SNo x z' Hx1 Hz'1)
                              (SNo_mul_SNo w' w'' Hw'1 Hw''1).
            prove w' * w'' + x * y + w''' * z' < w' * w'' + w''' * y + x * z'.
            apply add_SNo_Lt2 (w' * w'') (x * y + w''' * z') (w''' * y + x * z')
                              (SNo_mul_SNo w' w'' Hw'1 Hw''1)
                              (SNo_add_SNo (x * y) (w''' * z')
                               (SNo_mul_SNo x y Hx1 Hy1)
                               (SNo_mul_SNo w''' z' Hw'''1 Hz'1))
                              (SNo_add_SNo (w''' * y) (x * z')
                               (SNo_mul_SNo w''' y Hw'''1 Hy1)
                               (SNo_mul_SNo x z' Hx1 Hz'1)).
            prove x * y + w''' * z' < w''' * y + x * z'.
            rewrite add_SNo_com (x * y) (w''' * z')
                                (SNo_mul_SNo x y Hx1 Hy1)
                                (SNo_mul_SNo w''' z' Hw'''1 Hz'1).
            rewrite add_SNo_com (w''' * y) (x * z')
                                (SNo_mul_SNo w''' y Hw'''1 Hy1)
                                (SNo_mul_SNo x z' Hx1 Hz'1).
            prove w''' * z' + x * y  < x * z' + w''' * y.
            exact mul_SNo_Lt x z' w''' y Hx1 Hz'1 Hw'''1 Hy1 Hw'''2 Hz'2.
        }
      * { assume Hz: z :e RxLy'.
          apply RxLy'E z Hz.
          let z'. assume Hz': z' :e Rx.
          let w'''. assume Hw''': w''' :e Ly.
          assume Hz'1: SNo z'.
          assume Hw'''1: SNo w'''.
          assume Hz'2: x < z'.
          assume Hw'''2: w''' < y.
          assume Hze. rewrite Hze.
          prove w' * y + x * w'' + - w' * w'' < z' * y + x * w''' + - z' * w'''.
          apply add_SNo_minus_Lt12b3 (w' * y) (x * w'') (w' * w'') (z' * y) (x * w''') (z' * w''')
                       (SNo_mul_SNo w' y Hw'1 Hy1)
                       (SNo_mul_SNo x w'' Hx1 Hw''1)
                       (SNo_mul_SNo w' w'' Hw'1 Hw''1)
                       (SNo_mul_SNo z' y Hz'1 Hy1)
                       (SNo_mul_SNo x w''' Hx1 Hw'''1)
                       (SNo_mul_SNo z' w''' Hz'1 Hw'''1).
          prove w' * y + x * w'' + z' * w''' < z' * y + x * w''' + w' * w''.
          apply SNoLt_tra (w' * y + x * w'' + z' * w''')
                          (z' * w''' + x * y + w' * w'')
                          (z' * y + x * w''' + w' * w'')
                          (SNo_add_SNo_3 (w' * y) (x * w'') (z' * w''')
                              (SNo_mul_SNo w' y Hw'1 Hy1)
                              (SNo_mul_SNo x w'' Hx1 Hw''1)
                              (SNo_mul_SNo z' w''' Hz'1 Hw'''1))
                          (SNo_add_SNo_3 (z' * w''') (x * y) (w' * w'')
                              (SNo_mul_SNo z' w''' Hz'1 Hw'''1)
                              (SNo_mul_SNo x y Hx1 Hy1)
                              (SNo_mul_SNo w' w'' Hw'1 Hw''1))
                          (SNo_add_SNo_3 (z' * y) (x * w''') (w' * w'')
                              (SNo_mul_SNo z' y Hz'1 Hy1)
                              (SNo_mul_SNo x w''' Hx1 Hw'''1)
                              (SNo_mul_SNo w' w'' Hw'1 Hw''1)).
          - prove w' * y + x * w'' + z' * w''' < z' * w''' + x * y + w' * w''.
            rewrite add_SNo_rotate_3_1 (w' * y) (x * w'') (z' * w''')
                              (SNo_mul_SNo w' y Hw'1 Hy1)
                              (SNo_mul_SNo x w'' Hx1 Hw''1)
                              (SNo_mul_SNo z' w''' Hz'1 Hw'''1).
            prove z' * w''' + w' * y + x * w'' < z' * w''' + x * y + w' * w''.
            apply add_SNo_Lt2 (z' * w''') (w' * y + x * w'') (x * y + w' * w'')
                              (SNo_mul_SNo z' w''' Hz'1 Hw'''1)
                              (SNo_add_SNo (w' * y) (x * w'')
                               (SNo_mul_SNo w' y Hw'1 Hy1)
                               (SNo_mul_SNo x w'' Hx1 Hw''1))
                              (SNo_add_SNo (x * y) (w' * w'')
                               (SNo_mul_SNo x y Hx1 Hy1)
                               (SNo_mul_SNo w' w'' Hw'1 Hw''1)).
            prove w' * y + x * w'' < x * y + w' * w''.
            exact mul_SNo_Lt x y w' w'' Hx1 Hy1 Hw'1 Hw''1 Hw'2 Hw''2.
          - prove z' * w''' + x * y + w' * w'' < z' * y + x * w''' + w' * w''.
            rewrite add_SNo_rotate_3_1 (z' * w''') (x * y) (w' * w'')
                              (SNo_mul_SNo z' w''' Hz'1 Hw'''1)
                              (SNo_mul_SNo x y Hx1 Hy1)
                              (SNo_mul_SNo w' w'' Hw'1 Hw''1).
            rewrite add_SNo_rotate_3_1 (z' * y) (x * w''') (w' * w'')
                              (SNo_mul_SNo z' y Hz'1 Hy1)
                              (SNo_mul_SNo x w''' Hx1 Hw'''1)
                              (SNo_mul_SNo w' w'' Hw'1 Hw''1).
            prove w' * w'' + z' * w''' + x * y < w' * w'' + z' * y + x * w'''.
            apply add_SNo_Lt2 (w' * w'') (z' * w''' + x * y) (z' * y + x * w''')
                              (SNo_mul_SNo w' w'' Hw'1 Hw''1)
                              (SNo_add_SNo (z' * w''') (x * y)
                               (SNo_mul_SNo z' w''' Hz'1 Hw'''1)
                               (SNo_mul_SNo x y Hx1 Hy1))
                              (SNo_add_SNo (z' * y) (x * w''')
                               (SNo_mul_SNo z' y Hz'1 Hy1)
                               (SNo_mul_SNo x w''' Hx1 Hw'''1)).
            prove z' * w''' + x * y < z' * y + x * w'''.
            rewrite add_SNo_com (z' * w''') (x * y)
                                (SNo_mul_SNo z' w''' Hz'1 Hw'''1)
                                (SNo_mul_SNo x y Hx1 Hy1).
            prove x * y + z' * w''' < z' * y + x * w'''.
            exact mul_SNo_Lt z' y x w''' Hz'1 Hy1 Hx1 Hw'''1 Hz'2 Hw'''2.
        }
    + assume Hw: w :e RxRy'.
      apply RxRy'E w Hw.
      let z'. assume Hz': z' :e Rx.
      let z''. assume Hz'': z'' :e Ry.
      assume Hz'1: SNo z'.
      assume Hz''1: SNo z''.
      assume Hz'2: x < z'.
      assume Hz''2: y < z''.
      assume Hwe. rewrite Hwe.
      let z. apply binunionE'.
      * { assume Hz: z :e LxRy'.
          apply LxRy'E z Hz.
          let w'. assume Hw': w' :e Lx.
          let z'''. assume Hz''': z''' :e Ry.
          assume Hw'1: SNo w'.
          assume Hz'''1: SNo z'''.
          assume Hw'2: w' < x.
          assume Hz'''2: y < z'''.
          assume Hze. rewrite Hze.
          prove z' * y + x * z'' + - z' * z'' < w' * y + x * z''' + - w' * z'''.
          apply add_SNo_minus_Lt12b3 (z' * y) (x * z'') (z' * z'') (w' * y) (x * z''') (w' * z''')
                       (SNo_mul_SNo z' y Hz'1 Hy1)
                       (SNo_mul_SNo x z'' Hx1 Hz''1)
                       (SNo_mul_SNo z' z'' Hz'1 Hz''1)
                       (SNo_mul_SNo w' y Hw'1 Hy1)
                       (SNo_mul_SNo x z''' Hx1 Hz'''1)
                       (SNo_mul_SNo w' z''' Hw'1 Hz'''1).
          prove z' * y + x * z'' + w' * z''' < w' * y + x * z''' + z' * z''.
          apply SNoLt_tra (z' * y + x * z'' + w' * z''')
                          (w' * z''' + z' * z'' + x * y)
                          (w' * y + x * z''' + z' * z'')
                          (SNo_add_SNo_3 (z' * y) (x * z'') (w' * z''')
                              (SNo_mul_SNo z' y Hz'1 Hy1)
                              (SNo_mul_SNo x z'' Hx1 Hz''1)
                              (SNo_mul_SNo w' z''' Hw'1 Hz'''1))
                          (SNo_add_SNo_3 (w' * z''') (z' * z'') (x * y)
                              (SNo_mul_SNo w' z''' Hw'1 Hz'''1)
                              (SNo_mul_SNo z' z'' Hz'1 Hz''1)
                              (SNo_mul_SNo x y Hx1 Hy1))
                          (SNo_add_SNo_3 (w' * y) (x * z''') (z' * z'')
                              (SNo_mul_SNo w' y Hw'1 Hy1)
                              (SNo_mul_SNo x z''' Hx1 Hz'''1)
                              (SNo_mul_SNo z' z'' Hz'1 Hz''1)).
          - prove z' * y + x * z'' + w' * z''' < w' * z''' + z' * z'' + x * y.
            rewrite add_SNo_rotate_3_1 (z' * y) (x * z'') (w' * z''')
                              (SNo_mul_SNo z' y Hz'1 Hy1)
                              (SNo_mul_SNo x z'' Hx1 Hz''1)
                              (SNo_mul_SNo w' z''' Hw'1 Hz'''1).
            prove w' * z''' + z' * y + x * z'' < w' * z''' + z' * z'' + x * y.
            apply add_SNo_Lt2 (w' * z''') (z' * y + x * z'') (z' * z'' + x * y)
                              (SNo_mul_SNo w' z''' Hw'1 Hz'''1)
                              (SNo_add_SNo (z' * y) (x * z'')
                               (SNo_mul_SNo z' y Hz'1 Hy1)
                               (SNo_mul_SNo x z'' Hx1 Hz''1))
                              (SNo_add_SNo (z' * z'') (x * y)
                               (SNo_mul_SNo z' z'' Hz'1 Hz''1)
                               (SNo_mul_SNo x y Hx1 Hy1)).
            prove z' * y + x * z'' < z' * z'' + x * y.
            rewrite add_SNo_com (z' * y) (x * z'')
                                (SNo_mul_SNo z' y Hz'1 Hy1)
                                (SNo_mul_SNo x z'' Hx1 Hz''1).
            exact mul_SNo_Lt z' z'' x y Hz'1 Hz''1 Hx1 Hy1 Hz'2 Hz''2.
          - prove w' * z''' + z' * z'' + x * y < w' * y + x * z''' + z' * z''.
            rewrite add_SNo_com_3_0_1 (w' * z''') (z' * z'') (x * y)
                              (SNo_mul_SNo w' z''' Hw'1 Hz'''1)
                              (SNo_mul_SNo z' z'' Hz'1 Hz''1)
                              (SNo_mul_SNo x y Hx1 Hy1).
            rewrite add_SNo_rotate_3_1 (w' * y) (x * z''') (z' * z'')
                              (SNo_mul_SNo w' y Hw'1 Hy1)
                              (SNo_mul_SNo x z''' Hx1 Hz'''1)
                              (SNo_mul_SNo z' z'' Hz'1 Hz''1).
            prove z' * z'' + w' * z''' + x * y < z' * z'' + w' * y + x * z'''.
            apply add_SNo_Lt2 (z' * z'') (w' * z''' + x * y) (w' * y + x * z''')
                              (SNo_mul_SNo z' z'' Hz'1 Hz''1)
                              (SNo_add_SNo (w' * z''') (x * y)
                               (SNo_mul_SNo w' z''' Hw'1 Hz'''1)
                               (SNo_mul_SNo x y Hx1 Hy1))
                              (SNo_add_SNo (w' * y) (x * z''')
                               (SNo_mul_SNo w' y Hw'1 Hy1)
                               (SNo_mul_SNo x z''' Hx1 Hz'''1)).
            prove w' * z''' + x * y < w' * y + x * z'''.
            rewrite add_SNo_com (w' * y) (x * z''')
                                (SNo_mul_SNo w' y Hw'1 Hy1)
                                (SNo_mul_SNo x z''' Hx1 Hz'''1).
            exact mul_SNo_Lt x z''' w' y Hx1 Hz'''1 Hw'1 Hy1 Hw'2 Hz'''2.
        }
      * { assume Hz: z :e RxLy'.
          apply RxLy'E z Hz.
          let z'''. assume Hz''': z''' :e Rx.
          let w'. assume Hw': w' :e Ly.
          assume Hz'''1: SNo z'''.
          assume Hw'1: SNo w'.
          assume Hz'''2: x < z'''.
          assume Hw'2: w' < y.
          assume Hze. rewrite Hze.
          prove z' * y + x * z'' + - z' * z'' < z''' * y + x * w' + - z''' * w'.
          apply add_SNo_minus_Lt12b3 (z' * y) (x * z'') (z' * z'') (z''' * y) (x * w') (z''' * w')
                       (SNo_mul_SNo z' y Hz'1 Hy1)
                       (SNo_mul_SNo x z'' Hx1 Hz''1)
                       (SNo_mul_SNo z' z'' Hz'1 Hz''1)
                       (SNo_mul_SNo z''' y Hz'''1 Hy1)
                       (SNo_mul_SNo x w' Hx1 Hw'1)
                       (SNo_mul_SNo z''' w' Hz'''1 Hw'1).
          prove z' * y + x * z'' + z''' * w' < z''' * y + x * w' + z' * z''.
          apply SNoLt_tra (z' * y + x * z'' + z''' * w')
                          (z''' * w' + z' * z'' + x * y)
                          (z''' * y + x * w' + z' * z'')        
                          (SNo_add_SNo_3 (z' * y) (x * z'') (z''' * w')
                              (SNo_mul_SNo z' y Hz'1 Hy1)
                              (SNo_mul_SNo x z'' Hx1 Hz''1)
                              (SNo_mul_SNo z''' w' Hz'''1 Hw'1))
                          (SNo_add_SNo_3 (z''' * w') (z' * z'') (x * y)
                              (SNo_mul_SNo z''' w' Hz'''1 Hw'1)
                              (SNo_mul_SNo z' z'' Hz'1 Hz''1)
                              (SNo_mul_SNo x y Hx1 Hy1))
                          (SNo_add_SNo_3 (z''' * y) (x * w') (z' * z'')
                              (SNo_mul_SNo z''' y Hz'''1 Hy1)
                              (SNo_mul_SNo x w' Hx1 Hw'1)
                              (SNo_mul_SNo z' z'' Hz'1 Hz''1)).
          - prove z' * y + x * z'' + z''' * w' < z''' * w' + z' * z'' + x * y.
            rewrite add_SNo_rotate_3_1 (z' * y) (x * z'') (z''' * w')
                              (SNo_mul_SNo z' y Hz'1 Hy1)
                              (SNo_mul_SNo x z'' Hx1 Hz''1)
                              (SNo_mul_SNo z''' w' Hz'''1 Hw'1).
            rewrite add_SNo_com (z' * y) (x * z'')
                                (SNo_mul_SNo z' y Hz'1 Hy1)
                                (SNo_mul_SNo x z'' Hx1 Hz''1).
            prove z''' * w' + x * z'' + z' * y < z''' * w' + z' * z'' + x * y.
            apply add_SNo_Lt2 (z''' * w') (x * z'' + z' * y) (z' * z'' + x * y)
                              (SNo_mul_SNo z''' w' Hz'''1 Hw'1)
                              (SNo_add_SNo (x * z'') (z' * y)
                               (SNo_mul_SNo x z'' Hx1 Hz''1)
                               (SNo_mul_SNo z' y Hz'1 Hy1))
                              (SNo_add_SNo (z' * z'') (x * y)
                               (SNo_mul_SNo z' z'' Hz'1 Hz''1)
                               (SNo_mul_SNo x y Hx1 Hy1)).
            prove x * z'' + z' * y < z' * z'' + x * y.
            exact mul_SNo_Lt z' z'' x y Hz'1 Hz''1 Hx1 Hy1 Hz'2 Hz''2.
          - prove z''' * w' + z' * z'' + x * y < z''' * y + x * w' + z' * z''.
            rewrite add_SNo_com_3_0_1 (z''' * w') (z' * z'') (x * y)
                              (SNo_mul_SNo z''' w' Hz'''1 Hw'1)
                              (SNo_mul_SNo z' z'' Hz'1 Hz''1)
                              (SNo_mul_SNo x y Hx1 Hy1).
            rewrite add_SNo_rotate_3_1 (z''' * y) (x * w') (z' * z'')
                              (SNo_mul_SNo z''' y Hz'''1 Hy1)
                              (SNo_mul_SNo x w' Hx1 Hw'1)
                              (SNo_mul_SNo z' z'' Hz'1 Hz''1).
            prove z' * z'' + z''' * w' + x * y < z' * z'' + z''' * y + x * w'.
            apply add_SNo_Lt2 (z' * z'') (z''' * w' + x * y) (z''' * y + x * w')
                              (SNo_mul_SNo z' z'' Hz'1 Hz''1)
                              (SNo_add_SNo (z''' * w') (x * y)
                               (SNo_mul_SNo z''' w' Hz'''1 Hw'1)
                               (SNo_mul_SNo x y Hx1 Hy1))
                              (SNo_add_SNo (z''' * y) (x * w')
                               (SNo_mul_SNo z''' y Hz'''1 Hy1)
                               (SNo_mul_SNo x w' Hx1 Hw'1)).
            prove z''' * w' + x * y < z''' * y + x * w'.
            rewrite add_SNo_com (z''' * w') (x * y)
                               (SNo_mul_SNo z''' w' Hz'''1 Hw'1)
                               (SNo_mul_SNo x y Hx1 Hy1).
            exact mul_SNo_Lt z''' y x w' Hz'''1 Hy1 Hx1 Hw'1 Hz'''2 Hw'2.
        }
}
claim Lxyeq: x * y = SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy').
{ set v := SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy').
  apply SNoCutP_SNoCut_impred (LxLy' :\/: RxRy') (LxRy' :\/: RxLy') L1.
  assume Hv1: SNo v.
  assume Hv2: SNoLev v :e ordsucc ((\/_ w :e LxLy' :\/: RxRy', ordsucc (SNoLev w)) :\/: (\/_ z :e LxRy' :\/: RxLy', ordsucc (SNoLev z))).
  assume Hv3: forall w :e LxLy' :\/: RxRy', w < v.
  assume Hv4: forall z :e LxRy' :\/: RxLy', v < z.
  assume Hv5: forall u, SNo u -> (forall w :e LxLy' :\/: RxRy', w < u) -> (forall z :e LxRy' :\/: RxLy', u < z) -> SNoLev v c= SNoLev u /\ SNoEq_ (SNoLev v) v u.
  apply mul_SNo_eq_3 x y Hx1 Hy1.
  let L' R'.
  assume HLR': SNoCutP L' R'.
  assume HL'E: forall u, u :e L' ->
               forall q:prop,
                  (forall w0 :e SNoL x, forall w1 :e SNoL y, u = w0 * y + x * w1 + - w0 * w1 -> q)
               -> (forall z0 :e SNoR x, forall z1 :e SNoR y, u = z0 * y + x * z1 + - z0 * z1 -> q)
               -> q.
  assume HL'I1: forall w0 :e SNoL x, forall w1 :e SNoL y, w0 * y + x * w1 + - w0 * w1 :e L'.
  assume HL'I2: forall z0 :e SNoR x, forall z1 :e SNoR y, z0 * y + x * z1 + - z0 * z1 :e L'.
  assume HR'E: forall u, u :e R' ->
               forall q:prop,
                    (forall w0 :e SNoL x, forall z1 :e SNoR y, u = w0 * y + x * z1 + - w0 * z1 -> q)
                 -> (forall z0 :e SNoR x, forall w1 :e SNoL y, u = z0 * y + x * w1 + - z0 * w1 -> q)
                 -> q.
  assume HR'I1: forall w0 :e SNoL x, forall z1 :e SNoR y, w0 * y + x * z1 + - w0 * z1 :e R'.
  assume HR'I2: forall z0 :e SNoR x, forall w1 :e SNoL y, z0 * y + x * w1 + - z0 * w1 :e R'.
  assume HLR'eq: x * y = SNoCut L' R'.
  rewrite HLR'eq.
  apply SNoCut_ext L' R' (LxLy' :\/: RxRy') (LxRy' :\/: RxLy').
  - exact HLR'.
  - exact L1.
  - prove forall w :e L', w < v.
    let w. assume Hw.
    apply HL'E w Hw.
    + let w0. assume Hw0: w0 :e SNoL x.
      let w1. assume Hw1: w1 :e SNoL y.
      assume Hwe. rewrite Hwe.
      prove w0 * y + x * w1 + - w0 * w1 < v.
      apply SNoL_E x Hx1 w0 Hw0.
      assume Hw0a Hw0b Hw0c.
      apply SNoL_E y Hy1 w1 Hw1.
      assume Hw1a Hw1b Hw1c.
      claim L2: exists w0' :e Lx, w0 <= w0'.
      { apply dneg.
        assume HC.
        claim L2a: SNoLev x c= SNoLev w0 /\ SNoEq_ (SNoLev x) x w0.
        { apply Hx5 w0 Hw0a.
          - prove forall w' :e Lx, w' < w0.
            let w'. assume Hw'.
            apply SNoLtLe_or w' w0 (HLRx1 w' Hw') Hw0a.
            + assume H. exact H.
            + assume H: w0 <= w'. prove False.
              apply HC. witness w'. apply andI.
              * exact Hw'.
              * prove w0 <= w'. exact H.
          - prove forall z' :e Rx, w0 < z'.
            let z'. assume Hz'.
            apply SNoLt_tra w0 x z' Hw0a Hx1 (HLRx2 z' Hz').
            + prove w0 < x. exact Hw0c.
            + prove x < z'. exact Hx4 z' Hz'.
        }
        apply L2a.
        assume Hxw0: SNoLev x c= SNoLev w0. assume _.
        apply In_irref (SNoLev w0).
        prove SNoLev w0 :e SNoLev w0.
        apply Hxw0. exact Hw0b.
      }
      claim L3: exists w1' :e Ly, w1 <= w1'.
      { apply dneg.
        assume HC.
        claim L3a: SNoLev y c= SNoLev w1 /\ SNoEq_ (SNoLev y) y w1.
        { apply Hy5 w1 Hw1a.
          - prove forall w' :e Ly, w' < w1.
            let w'. assume Hw'.
            apply SNoLtLe_or w' w1 (HLRy1 w' Hw') Hw1a.
            + assume H. exact H.
            + assume H: w1 <= w'. prove False.
              apply HC. witness w'. apply andI.
              * exact Hw'.
              * prove w1 <= w'. exact H.
          - prove forall z' :e Ry, w1 < z'.
            let z'. assume Hz'.
            apply SNoLt_tra w1 y z' Hw1a Hy1 (HLRy2 z' Hz').
            + prove w1 < y. exact Hw1c.
            + prove y < z'. exact Hy4 z' Hz'.
        }
        apply L3a.
        assume Hyw1: SNoLev y c= SNoLev w1. assume _.
        apply In_irref (SNoLev w1).
        prove SNoLev w1 :e SNoLev w1.
        apply Hyw1. exact Hw1b.
      }
      apply L2.
      let w0'. assume H. apply H.
      assume Hw0'1: w0' :e Lx.
      assume Hw0'2: w0 <= w0'.
      apply L3.
      let w1'. assume H. apply H.
      assume Hw1'1: w1' :e Ly.
      assume Hw1'2: w1 <= w1'.
      prove w0 * y + x * w1 + - w0 * w1 < v.
      apply SNoLeLt_tra (w0 * y + x * w1 + - w0 * w1)
                        (w0' * y + x * w1' + - w0' * w1')
                        v
                        (SNo_add_SNo_3 (w0 * y) (x * w1) (- w0 * w1)
                           (SNo_mul_SNo w0 y Hw0a Hy1)
                           (SNo_mul_SNo x w1 Hx1 Hw1a)
                           (SNo_minus_SNo (w0 * w1) (SNo_mul_SNo w0 w1 Hw0a Hw1a)))
                        (SNo_add_SNo_3 (w0' * y) (x * w1') (- w0' * w1')
                           (SNo_mul_SNo w0' y (HLRx1 w0' Hw0'1) Hy1)
                           (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                           (SNo_minus_SNo (w0' * w1') (SNo_mul_SNo w0' w1' (HLRx1 w0' Hw0'1) (HLRy1 w1' Hw1'1))))
                        Hv1.
      * { prove w0 * y + x * w1 + - w0 * w1 <= w0' * y + x * w1' + - w0' * w1'.
          apply add_SNo_minus_Le12b3 (w0 * y) (x * w1) (w0 * w1) (w0' * y) (x * w1') (w0' * w1')
                           (SNo_mul_SNo w0 y Hw0a Hy1)
                           (SNo_mul_SNo x w1 Hx1 Hw1a)
                           (SNo_mul_SNo w0 w1 Hw0a Hw1a)
                           (SNo_mul_SNo w0' y (HLRx1 w0' Hw0'1) Hy1)
                           (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                           (SNo_mul_SNo w0' w1' (HLRx1 w0' Hw0'1) (HLRy1 w1' Hw1'1)).
          prove w0 * y + x * w1 + w0' * w1' <= w0' * y + x * w1' + w0 * w1.
          apply SNoLe_tra (w0 * y + x * w1 + w0' * w1')
                          (w0 * y + x * w1' + w0' * w1)
                          (w0' * y + x * w1' + w0 * w1)
                          (SNo_add_SNo_3 (w0 * y) (x * w1) (w0' * w1')
                           (SNo_mul_SNo w0 y Hw0a Hy1)
                           (SNo_mul_SNo x w1 Hx1 Hw1a)
                           (SNo_mul_SNo w0' w1' (HLRx1 w0' Hw0'1) (HLRy1 w1' Hw1'1)))
                          (SNo_add_SNo_3 (w0 * y) (x * w1') (w0' * w1)
                           (SNo_mul_SNo w0 y Hw0a Hy1)
                           (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                           (SNo_mul_SNo w0' w1 (HLRx1 w0' Hw0'1) Hw1a))
                          (SNo_add_SNo_3 (w0' * y) (x * w1') (w0 * w1)
                           (SNo_mul_SNo w0' y (HLRx1 w0' Hw0'1) Hy1)
                           (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                           (SNo_mul_SNo w0 w1 Hw0a Hw1a)).
          - prove w0 * y + x * w1 + w0' * w1' <= w0 * y + x * w1' + w0' * w1.
            apply add_SNo_Le2 (w0 * y) (x * w1 + w0' * w1') (x * w1' + w0' * w1)
                              (SNo_mul_SNo w0 y Hw0a Hy1)
                              (SNo_add_SNo (x * w1) (w0' * w1')
                               (SNo_mul_SNo x w1 Hx1 Hw1a)
                               (SNo_mul_SNo w0' w1' (HLRx1 w0' Hw0'1) (HLRy1 w1' Hw1'1)))
                              (SNo_add_SNo (x * w1') (w0' * w1)
                               (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                               (SNo_mul_SNo w0' w1 (HLRx1 w0' Hw0'1) Hw1a)).
            prove x * w1 + w0' * w1' <= x * w1' + w0' * w1.
            rewrite add_SNo_com (x * w1) (w0' * w1')
                                (SNo_mul_SNo x w1 Hx1 Hw1a)
                                (SNo_mul_SNo w0' w1' (HLRx1 w0' Hw0'1) (HLRy1 w1' Hw1'1)).
            prove w0' * w1' + x * w1 <= x * w1' + w0' * w1.
            apply mul_SNo_Le x w1' w0' w1 Hx1 (HLRy1 w1' Hw1'1) (HLRx1 w0' Hw0'1) Hw1a.
            + prove w0' <= x. apply SNoLtLe. prove w0' < x. exact Hx3 w0' Hw0'1.
            + prove w1 <= w1'. exact Hw1'2.
          - prove w0 * y + x * w1' + w0' * w1 <= w0' * y + x * w1' + w0 * w1.
            rewrite add_SNo_com_3_0_1 (w0 * y) (x * w1') (w0' * w1)
                              (SNo_mul_SNo w0 y Hw0a Hy1)
                              (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                              (SNo_mul_SNo w0' w1 (HLRx1 w0' Hw0'1) Hw1a).
            rewrite add_SNo_com_3_0_1 (w0' * y) (x * w1') (w0 * w1)
                           (SNo_mul_SNo w0' y (HLRx1 w0' Hw0'1) Hy1)
                           (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                           (SNo_mul_SNo w0 w1 Hw0a Hw1a).
            apply add_SNo_Le2 (x * w1') (w0 * y + w0' * w1) (w0' * y + w0 * w1)
                              (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                              (SNo_add_SNo (w0 * y) (w0' * w1)
                                (SNo_mul_SNo w0 y Hw0a Hy1)
                                (SNo_mul_SNo w0' w1 (HLRx1 w0' Hw0'1) Hw1a))
                              (SNo_add_SNo (w0' * y) (w0 * w1)
                               (SNo_mul_SNo w0' y (HLRx1 w0' Hw0'1) Hy1)
                               (SNo_mul_SNo w0 w1 Hw0a Hw1a)).
            prove w0 * y + w0' * w1 <= w0' * y + w0 * w1.
            apply mul_SNo_Le w0' y w0 w1 (HLRx1 w0' Hw0'1) Hy1 Hw0a Hw1a.
            + prove w0 <= w0'. exact Hw0'2.
            + prove w1 <= y. apply SNoLtLe. exact Hw1c.
        }
      * { prove w0' * y + x * w1' + - w0' * w1' < v.
          apply Hv3.
          prove w0' * y + x * w1' + - w0' * w1' :e LxLy' :\/: RxRy'.
          apply binunionI1.
          apply LxLy'I.
          - exact Hw0'1.
          - exact Hw1'1.
        }
    + let z0. assume Hz0: z0 :e SNoR x.
      let z1. assume Hz1: z1 :e SNoR y.
      assume Hwe. rewrite Hwe.
      prove z0 * y + x * z1 + - z0 * z1 < v.
      apply SNoR_E x Hx1 z0 Hz0.
      assume Hz0a Hz0b Hz0c.
      apply SNoR_E y Hy1 z1 Hz1.
      assume Hz1a Hz1b Hz1c.
      claim L4: exists z0' :e Rx, z0' <= z0.
      { apply dneg.
        assume HC.
        claim L4a: SNoLev x c= SNoLev z0 /\ SNoEq_ (SNoLev x) x z0.
        { apply Hx5 z0 Hz0a.
          - prove forall w' :e Lx, w' < z0.
            let w'. assume Hw'.
            apply SNoLt_tra w' x z0 (HLRx1 w' Hw') Hx1 Hz0a.
            + prove w' < x. exact Hx3 w' Hw'.
            + prove x < z0. exact Hz0c.
          - prove forall z' :e Rx, z0 < z'.
            let z'. assume Hz'.
            apply SNoLtLe_or z0 z' Hz0a (HLRx2 z' Hz').
            + assume H. exact H.
            + assume H: z' <= z0. prove False.
              apply HC. witness z'. apply andI.
              * exact Hz'.
              * prove z' <= z0. exact H.
        }
        apply L4a.
        assume Hxz0: SNoLev x c= SNoLev z0. assume _.
        apply In_irref (SNoLev z0).
        prove SNoLev z0 :e SNoLev z0.
        apply Hxz0. exact Hz0b.
      }
      claim L5: exists z1' :e Ry, z1' <= z1.
      { apply dneg.
        assume HC.
        claim L5a: SNoLev y c= SNoLev z1 /\ SNoEq_ (SNoLev y) y z1.
        { apply Hy5 z1 Hz1a.
          - prove forall w' :e Ly, w' < z1.
            let w'. assume Hw'.
            apply SNoLt_tra w' y z1 (HLRy1 w' Hw') Hy1 Hz1a.
            + prove w' < y. exact Hy3 w' Hw'.
            + prove y < z1. exact Hz1c.
          - prove forall z' :e Ry, z1 < z'.
            let z'. assume Hz'.
            apply SNoLtLe_or z1 z' Hz1a (HLRy2 z' Hz').
            + assume H. exact H.
            + assume H: z' <= z1. prove False.
              apply HC. witness z'. apply andI.
              * exact Hz'.
              * prove z' <= z1. exact H.
        }
        apply L5a.
        assume Hyz1: SNoLev y c= SNoLev z1. assume _.
        apply In_irref (SNoLev z1).
        prove SNoLev z1 :e SNoLev z1.
        apply Hyz1. exact Hz1b.
      }
      apply L4.
      let z0'. assume H. apply H.
      assume Hz0'1: z0' :e Rx.
      assume Hz0'2: z0' <= z0.
      apply L5.
      let z1'. assume H. apply H.
      assume Hz1'1: z1' :e Ry.
      assume Hz1'2: z1' <= z1.
      prove z0 * y + x * z1 + - z0 * z1 < v.
      apply SNoLeLt_tra (z0 * y + x * z1 + - z0 * z1)
                        (z0' * y + x * z1' + - z0' * z1')
                        v
                        (SNo_add_SNo_3 (z0 * y) (x * z1) (- z0 * z1)
                           (SNo_mul_SNo z0 y Hz0a Hy1)
                           (SNo_mul_SNo x z1 Hx1 Hz1a)
                           (SNo_minus_SNo (z0 * z1) (SNo_mul_SNo z0 z1 Hz0a Hz1a)))
                        (SNo_add_SNo_3 (z0' * y) (x * z1') (- z0' * z1')
                           (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                           (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                           (SNo_minus_SNo (z0' * z1') (SNo_mul_SNo z0' z1' (HLRx2 z0' Hz0'1) (HLRy2 z1' Hz1'1))))
                        Hv1.
      * { prove z0 * y + x * z1 + - z0 * z1 <= z0' * y + x * z1' + - z0' * z1'.
          apply add_SNo_minus_Le12b3 (z0 * y) (x * z1) (z0 * z1) (z0' * y) (x * z1') (z0' * z1')
                           (SNo_mul_SNo z0 y Hz0a Hy1)
                           (SNo_mul_SNo x z1 Hx1 Hz1a)
                           (SNo_mul_SNo z0 z1 Hz0a Hz1a)
                           (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                           (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                           (SNo_mul_SNo z0' z1' (HLRx2 z0' Hz0'1) (HLRy2 z1' Hz1'1)).
          prove z0 * y + x * z1 + z0' * z1' <= z0' * y + x * z1' + z0 * z1.
          apply SNoLe_tra (z0 * y + x * z1 + z0' * z1')
                          (z0 * y + z0' * z1 + x * z1')
                          (z0' * y + x * z1' + z0 * z1)
                          (SNo_add_SNo_3 (z0 * y) (x * z1) (z0' * z1')
                           (SNo_mul_SNo z0 y Hz0a Hy1)
                           (SNo_mul_SNo x z1 Hx1 Hz1a)
                           (SNo_mul_SNo z0' z1' (HLRx2 z0' Hz0'1) (HLRy2 z1' Hz1'1)))
                          (SNo_add_SNo_3 (z0 * y) (z0' * z1) (x * z1')
                           (SNo_mul_SNo z0 y Hz0a Hy1)
                           (SNo_mul_SNo z0' z1 (HLRx2 z0' Hz0'1) Hz1a)
                           (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1)))
                          (SNo_add_SNo_3 (z0' * y) (x * z1') (z0 * z1)
                           (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                           (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                           (SNo_mul_SNo z0 z1 Hz0a Hz1a)).
          - prove z0 * y + x * z1 + z0' * z1' <= z0 * y + z0' * z1 + x * z1'.
            apply add_SNo_Le2 (z0 * y) (x * z1 + z0' * z1') (z0' * z1 + x * z1')
                              (SNo_mul_SNo z0 y Hz0a Hy1)
                              (SNo_add_SNo (x * z1) (z0' * z1')
                               (SNo_mul_SNo x z1 Hx1 Hz1a)
                               (SNo_mul_SNo z0' z1' (HLRx2 z0' Hz0'1) (HLRy2 z1' Hz1'1)))
                              (SNo_add_SNo (z0' * z1) (x * z1')
                               (SNo_mul_SNo z0' z1 (HLRx2 z0' Hz0'1) Hz1a)
                               (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))).
            prove x * z1 + z0' * z1' <= z0' * z1 + x * z1'.
            apply mul_SNo_Le z0' z1 x z1' (HLRx2 z0' Hz0'1) Hz1a Hx1 (HLRy2 z1' Hz1'1).
            + prove x <= z0'. apply SNoLtLe. prove x < z0'. exact Hx4 z0' Hz0'1.
            + prove z1' <= z1. exact Hz1'2.
          - prove z0 * y + z0' * z1 + x * z1' <= z0' * y + x * z1' + z0 * z1.
            rewrite add_SNo_rotate_3_1 (z0 * y) (z0' * z1) (x * z1')
                              (SNo_mul_SNo z0 y Hz0a Hy1)
                              (SNo_mul_SNo z0' z1 (HLRx2 z0' Hz0'1) Hz1a)
                              (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1)).
            rewrite add_SNo_com_3_0_1 (z0' * y) (x * z1') (z0 * z1)
                           (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                           (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                           (SNo_mul_SNo z0 z1 Hz0a Hz1a).
            prove x * z1' + z0 * y + z0' * z1 <= x * z1' + z0' * y + z0 * z1.
            apply add_SNo_Le2 (x * z1') (z0 * y + z0' * z1) (z0' * y + z0 * z1)
                              (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                              (SNo_add_SNo (z0 * y) (z0' * z1)
                                (SNo_mul_SNo z0 y Hz0a Hy1)
                                (SNo_mul_SNo z0' z1 (HLRx2 z0' Hz0'1) Hz1a))
                              (SNo_add_SNo (z0' * y) (z0 * z1)
                               (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                               (SNo_mul_SNo z0 z1 Hz0a Hz1a)).
            prove z0 * y + z0' * z1 <= z0' * y + z0 * z1.
            rewrite add_SNo_com (z0 * y) (z0' * z1) (SNo_mul_SNo z0 y Hz0a Hy1) (SNo_mul_SNo z0' z1 (HLRx2 z0' Hz0'1) Hz1a).
            rewrite add_SNo_com (z0' * y) (z0 * z1) (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1) (SNo_mul_SNo z0 z1 Hz0a Hz1a).
            apply mul_SNo_Le z0 z1 z0' y Hz0a Hz1a (HLRx2 z0' Hz0'1) Hy1.
            + prove z0' <= z0. exact Hz0'2.
            + prove y <= z1. apply SNoLtLe. exact Hz1c.
        }
      * { prove z0' * y + x * z1' + - z0' * z1' < v.
          apply Hv3.
          prove z0' * y + x * z1' + - z0' * z1' :e LxLy' :\/: RxRy'.
          apply binunionI2.
          apply RxRy'I.
          - exact Hz0'1.
          - exact Hz1'1.
        }
  - prove forall z :e R', v < z.
    let z. assume Hz.
    apply HR'E z Hz.
    + let w0. assume Hw0: w0 :e SNoL x.
      let z1. assume Hz1: z1 :e SNoR y.
      assume Hze. rewrite Hze.
      prove v < w0 * y + x * z1 + - w0 * z1.
      apply SNoL_E x Hx1 w0 Hw0.
      assume Hw0a Hw0b Hw0c.
      apply SNoR_E y Hy1 z1 Hz1.
      assume Hz1a Hz1b Hz1c.
      claim L6: exists w0' :e Lx, w0 <= w0'.
      { apply dneg.
        assume HC.
        claim L6a: SNoLev x c= SNoLev w0 /\ SNoEq_ (SNoLev x) x w0.
        { apply Hx5 w0 Hw0a.
          - prove forall w' :e Lx, w' < w0.
            let w'. assume Hw'.
            apply SNoLtLe_or w' w0 (HLRx1 w' Hw') Hw0a.
            + assume H. exact H.
            + assume H: w0 <= w'. prove False.
              apply HC. witness w'. apply andI.
              * exact Hw'.
              * prove w0 <= w'. exact H.
          - prove forall z' :e Rx, w0 < z'.
            let z'. assume Hz'.
            apply SNoLt_tra w0 x z' Hw0a Hx1 (HLRx2 z' Hz').
            + prove w0 < x. exact Hw0c.
            + prove x < z'. exact Hx4 z' Hz'.
        }
        apply L6a.
        assume Hxw0: SNoLev x c= SNoLev w0. assume _.
        apply In_irref (SNoLev w0).
        prove SNoLev w0 :e SNoLev w0.
        apply Hxw0. exact Hw0b.
      }
      claim L7: exists z1' :e Ry, z1' <= z1.
      { apply dneg.
        assume HC.
        claim L7a: SNoLev y c= SNoLev z1 /\ SNoEq_ (SNoLev y) y z1.
        { apply Hy5 z1 Hz1a.
          - prove forall w' :e Ly, w' < z1.
            let w'. assume Hw'.
            apply SNoLt_tra w' y z1 (HLRy1 w' Hw') Hy1 Hz1a.
            + prove w' < y. exact Hy3 w' Hw'.
            + prove y < z1. exact Hz1c.
          - prove forall z' :e Ry, z1 < z'.
            let z'. assume Hz'.
            apply SNoLtLe_or z1 z' Hz1a (HLRy2 z' Hz').
            + assume H. exact H.
            + assume H: z' <= z1. prove False.
              apply HC. witness z'. apply andI.
              * exact Hz'.
              * prove z' <= z1. exact H.
        }
        apply L7a.
        assume Hyz1: SNoLev y c= SNoLev z1. assume _.
        apply In_irref (SNoLev z1).
        prove SNoLev z1 :e SNoLev z1.
        apply Hyz1. exact Hz1b.
      }
      apply L6.
      let w0'. assume H. apply H.
      assume Hw0'1: w0' :e Lx.
      assume Hw0'2: w0 <= w0'.
      apply L7.
      let z1'. assume H. apply H.
      assume Hz1'1: z1' :e Ry.
      assume Hz1'2: z1' <= z1.
      prove v < w0 * y + x * z1 + - w0 * z1.
      apply SNoLtLe_tra v (w0' * y + x * z1' + - w0' * z1') (w0 * y + x * z1 + - w0 * z1)
                        Hv1
                        (SNo_add_SNo_3 (w0' * y) (x * z1') (- w0' * z1')
                                (SNo_mul_SNo w0' y (HLRx1 w0' Hw0'1) Hy1)
                                (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                                (SNo_minus_SNo (w0' * z1') (SNo_mul_SNo w0' z1' (HLRx1 w0' Hw0'1) (HLRy2 z1' Hz1'1))))
                        (SNo_add_SNo_3 (w0 * y) (x * z1) (- w0 * z1)
                                (SNo_mul_SNo w0 y Hw0a Hy1)
                                (SNo_mul_SNo x z1 Hx1 Hz1a)
                                (SNo_minus_SNo (w0 * z1) (SNo_mul_SNo w0 z1 Hw0a Hz1a))).
      * { prove v < w0' * y + x * z1' + - w0' * z1'.
          apply Hv4.
          prove w0' * y + x * z1' + - w0' * z1' :e LxRy' :\/: RxLy'.
          apply binunionI1.
          apply LxRy'I.
          - exact Hw0'1.
          - exact Hz1'1.
        }
      * { prove w0' * y + x * z1' + - w0' * z1' <= w0 * y + x * z1 + - w0 * z1.
          apply add_SNo_minus_Le12b3 (w0' * y) (x * z1') (w0' * z1') (w0 * y) (x * z1) (w0 * z1)
                           (SNo_mul_SNo w0' y (HLRx1 w0' Hw0'1) Hy1)
                           (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                           (SNo_mul_SNo w0' z1' (HLRx1 w0' Hw0'1) (HLRy2 z1' Hz1'1))
                           (SNo_mul_SNo w0 y Hw0a Hy1)
                           (SNo_mul_SNo x z1 Hx1 Hz1a)
                           (SNo_mul_SNo w0 z1 Hw0a Hz1a).
          prove w0' * y + x * z1' + w0 * z1 <= w0 * y + x * z1 + w0' * z1'.
          apply SNoLe_tra (w0' * y + x * z1' + w0 * z1)
                          (x * z1' + w0' * z1 + w0 * y)
                          (w0 * y + x * z1 + w0' * z1')
                          (SNo_add_SNo_3 (w0' * y) (x * z1') (w0 * z1)
                           (SNo_mul_SNo w0' y (HLRx1 w0' Hw0'1) Hy1)
                           (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                           (SNo_mul_SNo w0 z1 Hw0a Hz1a))
                          (SNo_add_SNo_3 (x * z1') (w0' * z1) (w0 * y)
                           (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                           (SNo_mul_SNo w0' z1 (HLRx1 w0' Hw0'1) Hz1a)
                           (SNo_mul_SNo w0 y Hw0a Hy1))
                          (SNo_add_SNo_3 (w0 * y) (x * z1) (w0' * z1')
                           (SNo_mul_SNo w0 y Hw0a Hy1)
                           (SNo_mul_SNo x z1 Hx1 Hz1a)
                           (SNo_mul_SNo w0' z1' (HLRx1 w0' Hw0'1) (HLRy2 z1' Hz1'1))).
          - prove w0' * y + x * z1' + w0 * z1 <= x * z1' + w0' * z1 + w0 * y.
            rewrite add_SNo_com_3_0_1 (w0' * y) (x * z1') (w0 * z1)
                           (SNo_mul_SNo w0' y (HLRx1 w0' Hw0'1) Hy1)
                           (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                           (SNo_mul_SNo w0 z1 Hw0a Hz1a).
            apply add_SNo_Le2 (x * z1') (w0' * y + w0 * z1) (w0' * z1 + w0 * y)
                              (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                              (SNo_add_SNo (w0' * y) (w0 * z1)
                               (SNo_mul_SNo w0' y (HLRx1 w0' Hw0'1) Hy1)
                               (SNo_mul_SNo w0 z1 Hw0a Hz1a))
                              (SNo_add_SNo (w0' * z1) (w0 * y)
                               (SNo_mul_SNo w0' z1 (HLRx1 w0' Hw0'1) Hz1a)
                               (SNo_mul_SNo w0 y Hw0a Hy1)).
            prove w0' * y + w0 * z1 <= w0' * z1 + w0 * y.
            rewrite add_SNo_com (w0' * y) (w0 * z1)
                                (SNo_mul_SNo w0' y (HLRx1 w0' Hw0'1) Hy1)
                                (SNo_mul_SNo w0 z1 Hw0a Hz1a).
            apply mul_SNo_Le w0' z1 w0 y (HLRx1 w0' Hw0'1) Hz1a Hw0a Hy1.
            + prove w0 <= w0'. exact Hw0'2.
            + prove y <= z1. apply SNoLtLe. prove y < z1. exact Hz1c.
          - prove x * z1' + w0' * z1 + w0 * y <= w0 * y + x * z1 + w0' * z1'.
            rewrite add_SNo_rotate_3_1 (x * z1') (w0' * z1) (w0 * y)
                              (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                              (SNo_mul_SNo w0' z1 (HLRx1 w0' Hw0'1) Hz1a)
                              (SNo_mul_SNo w0 y Hw0a Hy1).
            prove w0 * y + x * z1' + w0' * z1 <= w0 * y + x * z1 + w0' * z1'.
            apply add_SNo_Le2 (w0 * y) (x * z1' + w0' * z1) (x * z1 + w0' * z1')
                              (SNo_mul_SNo w0 y Hw0a Hy1)
                              (SNo_add_SNo (x * z1') (w0' * z1)
                               (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                               (SNo_mul_SNo w0' z1 (HLRx1 w0' Hw0'1) Hz1a))
                              (SNo_add_SNo (x * z1) (w0' * z1')
                               (SNo_mul_SNo x z1 Hx1 Hz1a)
                               (SNo_mul_SNo w0' z1' (HLRx1 w0' Hw0'1) (HLRy2 z1' Hz1'1))).
            prove x * z1' + w0' * z1 <= x * z1 + w0' * z1'.
            rewrite add_SNo_com (x * z1') (w0' * z1)
                                (SNo_mul_SNo x z1' Hx1 (HLRy2 z1' Hz1'1))
                                (SNo_mul_SNo w0' z1 (HLRx1 w0' Hw0'1) Hz1a).
            prove w0' * z1 + x * z1' <= x * z1 + w0' * z1'.
            apply mul_SNo_Le x z1 w0' z1' Hx1 Hz1a (HLRx1 w0' Hw0'1) (HLRy2 z1' Hz1'1).
            + prove w0' <= x. apply SNoLtLe. exact Hx3 w0' Hw0'1.
            + prove z1' <= z1. exact Hz1'2.
        }
    + let z0. assume Hz0: z0 :e SNoR x.
      let w1. assume Hw1: w1 :e SNoL y.
      assume Hze. rewrite Hze.
      prove v < z0 * y + x * w1 + - z0 * w1.
      apply SNoR_E x Hx1 z0 Hz0.
      assume Hz0a Hz0b Hz0c.
      apply SNoL_E y Hy1 w1 Hw1.
      assume Hw1a Hw1b Hw1c.
      claim L8: exists z0' :e Rx, z0' <= z0.
      { apply dneg.
        assume HC.
        claim L8a: SNoLev x c= SNoLev z0 /\ SNoEq_ (SNoLev x) x z0.
        { apply Hx5 z0 Hz0a.
          - prove forall w' :e Lx, w' < z0.
            let w'. assume Hw'.
            apply SNoLt_tra w' x z0 (HLRx1 w' Hw') Hx1 Hz0a.
            + prove w' < x. exact Hx3 w' Hw'.
            + prove x < z0. exact Hz0c.
          - prove forall z' :e Rx, z0 < z'.
            let z'. assume Hz'.
            apply SNoLtLe_or z0 z' Hz0a (HLRx2 z' Hz').
            + assume H. exact H.
            + assume H: z' <= z0. prove False.
              apply HC. witness z'. apply andI.
              * exact Hz'.
              * prove z' <= z0. exact H.
        }
        apply L8a.
        assume Hxz0: SNoLev x c= SNoLev z0. assume _.
        apply In_irref (SNoLev z0).
        prove SNoLev z0 :e SNoLev z0.
        apply Hxz0. exact Hz0b.
      }
      claim L9: exists w1' :e Ly, w1 <= w1'.
      { apply dneg.
        assume HC.
        claim L9a: SNoLev y c= SNoLev w1 /\ SNoEq_ (SNoLev y) y w1.
        { apply Hy5 w1 Hw1a.
          - prove forall w' :e Ly, w' < w1.
            let w'. assume Hw'.
            apply SNoLtLe_or w' w1 (HLRy1 w' Hw') Hw1a.
            + assume H. exact H.
            + assume H: w1 <= w'. prove False.
              apply HC. witness w'. apply andI.
              * exact Hw'.
              * prove w1 <= w'. exact H.
          - prove forall z' :e Ry, w1 < z'.
            let z'. assume Hz'.
            apply SNoLt_tra w1 y z' Hw1a Hy1 (HLRy2 z' Hz').
            + prove w1 < y. exact Hw1c.
            + prove y < z'. exact Hy4 z' Hz'.
        }
        apply L9a.
        assume Hyw1: SNoLev y c= SNoLev w1. assume _.
        apply In_irref (SNoLev w1).
        prove SNoLev w1 :e SNoLev w1.
        apply Hyw1. exact Hw1b.
      }
      apply L8.
      let z0'. assume H. apply H.
      assume Hz0'1: z0' :e Rx.
      assume Hz0'2: z0' <= z0.
      apply L9.
      let w1'. assume H. apply H.
      assume Hw1'1: w1' :e Ly.
      assume Hw1'2: w1 <= w1'.
      prove v < z0 * y + x * w1 + - z0 * w1.
      apply SNoLtLe_tra v (z0' * y + x * w1' + - z0' * w1') (z0 * y + x * w1 + - z0 * w1)
                        Hv1
                        (SNo_add_SNo_3 (z0' * y) (x * w1') (- z0' * w1')
                                (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                                (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                                (SNo_minus_SNo (z0' * w1') (SNo_mul_SNo z0' w1' (HLRx2 z0' Hz0'1) (HLRy1 w1' Hw1'1))))
                        (SNo_add_SNo_3 (z0 * y) (x * w1) (- z0 * w1)
                                (SNo_mul_SNo z0 y Hz0a Hy1)
                                (SNo_mul_SNo x w1 Hx1 Hw1a)
                                (SNo_minus_SNo (z0 * w1) (SNo_mul_SNo z0 w1 Hz0a Hw1a))).
      * { prove v < z0' * y + x * w1' + - z0' * w1'.
          apply Hv4.
          prove z0' * y + x * w1' + - z0' * w1' :e LxRy' :\/: RxLy'.
          apply binunionI2.
          apply RxLy'I.
          - exact Hz0'1.
          - exact Hw1'1.
        }
      * { prove z0' * y + x * w1' + - z0' * w1' <= z0 * y + x * w1 + - z0 * w1.
          apply add_SNo_minus_Le12b3 (z0' * y) (x * w1') (z0' * w1') (z0 * y) (x * w1) (z0 * w1)
                           (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                           (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                           (SNo_mul_SNo z0' w1' (HLRx2 z0' Hz0'1) (HLRy1 w1' Hw1'1))
                           (SNo_mul_SNo z0 y Hz0a Hy1)
                           (SNo_mul_SNo x w1 Hx1 Hw1a)
                           (SNo_mul_SNo z0 w1 Hz0a Hw1a).
          prove z0' * y + x * w1' + z0 * w1 <= z0 * y + x * w1 + z0' * w1'.
          apply SNoLe_tra (z0' * y + x * w1' + z0 * w1)
                          (z0' * y + x * w1 + z0 * w1')
                          (z0 * y + x * w1 + z0' * w1')
                          (SNo_add_SNo_3 (z0' * y) (x * w1') (z0 * w1)
                           (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                           (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                           (SNo_mul_SNo z0 w1 Hz0a Hw1a))
                          (SNo_add_SNo_3 (z0' * y) (x * w1) (z0 * w1')
                           (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                           (SNo_mul_SNo x w1 Hx1 Hw1a)
                           (SNo_mul_SNo z0 w1' Hz0a (HLRy1 w1' Hw1'1)))
                          (SNo_add_SNo_3 (z0 * y) (x * w1) (z0' * w1')
                           (SNo_mul_SNo z0 y Hz0a Hy1)
                           (SNo_mul_SNo x w1 Hx1 Hw1a)
                           (SNo_mul_SNo z0' w1' (HLRx2 z0' Hz0'1) (HLRy1 w1' Hw1'1))).
          - prove z0' * y + x * w1' + z0 * w1 <= z0' * y + x * w1 + z0 * w1'.
            apply add_SNo_Le2 (z0' * y) (x * w1' + z0 * w1) (x * w1 + z0 * w1')
                              (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                              (SNo_add_SNo (x * w1') (z0 * w1)
                               (SNo_mul_SNo x w1' Hx1 (HLRy1 w1' Hw1'1))
                               (SNo_mul_SNo z0 w1 Hz0a Hw1a))
                              (SNo_add_SNo (x * w1) (z0 * w1')
                               (SNo_mul_SNo x w1 Hx1 Hw1a)
                               (SNo_mul_SNo z0 w1' Hz0a (HLRy1 w1' Hw1'1))).
            prove x * w1' + z0 * w1 <= x * w1 + z0 * w1'.
            rewrite add_SNo_com (x * w1) (z0 * w1')
                                (SNo_mul_SNo x w1 Hx1 Hw1a)
                                (SNo_mul_SNo z0 w1' Hz0a (HLRy1 w1' Hw1'1)).
            apply mul_SNo_Le z0 w1' x w1 Hz0a (HLRy1 w1' Hw1'1) Hx1 Hw1a.
            + prove x <= z0. apply SNoLtLe. exact Hz0c.
            + prove w1 <= w1'. exact Hw1'2.
          - prove z0' * y + x * w1 + z0 * w1' <= z0 * y + x * w1 + z0' * w1'.
            rewrite add_SNo_com_3_0_1 (z0' * y) (x * w1) (z0 * w1')
                              (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                              (SNo_mul_SNo x w1 Hx1 Hw1a)
                              (SNo_mul_SNo z0 w1' Hz0a (HLRy1 w1' Hw1'1)).
            rewrite add_SNo_com_3_0_1 (z0 * y) (x * w1) (z0' * w1')
                              (SNo_mul_SNo z0 y Hz0a Hy1)
                              (SNo_mul_SNo x w1 Hx1 Hw1a)
                              (SNo_mul_SNo z0' w1' (HLRx2 z0' Hz0'1) (HLRy1 w1' Hw1'1)).
  
            prove x * w1 + z0' * y + z0 * w1' <= x * w1 + z0 * y + z0' * w1'.
            apply add_SNo_Le2 (x * w1) (z0' * y + z0 * w1') (z0 * y + z0' * w1')
                              (SNo_mul_SNo x w1 Hx1 Hw1a)
                              (SNo_add_SNo (z0' * y) (z0 * w1')
                               (SNo_mul_SNo z0' y (HLRx2 z0' Hz0'1) Hy1)
                               (SNo_mul_SNo z0 w1' Hz0a (HLRy1 w1' Hw1'1)))
                              (SNo_add_SNo (z0 * y) (z0' * w1')
                               (SNo_mul_SNo z0 y Hz0a Hy1)
                               (SNo_mul_SNo z0' w1' (HLRx2 z0' Hz0'1) (HLRy1 w1' Hw1'1))).
            prove z0' * y + z0 * w1' <= z0 * y + z0' * w1'.
            apply mul_SNo_Le z0 y z0' w1' Hz0a Hy1 (HLRx2 z0' Hz0'1) (HLRy1 w1' Hw1'1).
            + prove z0' <= z0. exact Hz0'2.
            + prove w1' <= y. apply SNoLtLe. exact Hy3 w1' Hw1'1.
        }
  - rewrite <- HLR'eq.
    prove forall w :e LxLy' :\/: RxRy', w < x * y.
    let w. apply binunionE'.
    + assume Hw: w :e LxLy'.
      apply LxLy'E w Hw.
      let w'. assume Hw': w' :e Lx.
      let w''. assume Hw'': w'' :e Ly.
      assume Hw'1: SNo w'.
      assume Hw''1: SNo w''.
      assume Hw'2: w' < x.
      assume Hw''2: w'' < y.
      assume Hwe. rewrite Hwe.
      prove w' * y + x * w'' + - w' * w'' < x * y.
      apply add_SNo_minus_Lt1b3 (w' * y) (x * w'') (w' * w'') (x * y)
                 (SNo_mul_SNo w' y Hw'1 Hy1)
                 (SNo_mul_SNo x w'' Hx1 Hw''1)
                 (SNo_mul_SNo w' w'' Hw'1 Hw''1)
                 (SNo_mul_SNo x y Hx1 Hy1).
      prove w' * y + x * w'' < x * y + w' * w''.
      exact mul_SNo_Lt x y w' w'' Hx1 Hy1 Hw'1 Hw''1 Hw'2 Hw''2.
    + assume Hw: w :e RxRy'.
      apply RxRy'E w Hw.
      let z. assume Hz: z :e Rx.
      let z'. assume Hz': z' :e Ry.
      assume Hz1: SNo z.
      assume Hz'1: SNo z'.
      assume Hz2: x < z.
      assume Hz'2: y < z'.
      assume Hwe. rewrite Hwe.
      prove z * y + x * z' + - z * z' < x * y.
      apply add_SNo_minus_Lt1b3 (z * y) (x * z') (z * z') (x * y)
                 (SNo_mul_SNo z y Hz1 Hy1)
                 (SNo_mul_SNo x z' Hx1 Hz'1)
                 (SNo_mul_SNo z z' Hz1 Hz'1)
                 (SNo_mul_SNo x y Hx1 Hy1).
      prove z * y + x * z' < x * y + z * z'.
      rewrite add_SNo_com (z * y) (x * z')
                 (SNo_mul_SNo z y Hz1 Hy1)
                 (SNo_mul_SNo x z' Hx1 Hz'1).
      rewrite add_SNo_com (x * y) (z * z')
                 (SNo_mul_SNo x y Hx1 Hy1)
                 (SNo_mul_SNo z z' Hz1 Hz'1).
      exact mul_SNo_Lt z z' x y Hz1 Hz'1 Hx1 Hy1 Hz2 Hz'2.
  - rewrite <- HLR'eq.
    prove forall z :e LxRy' :\/: RxLy', x * y < z.
    let z. apply binunionE'.
    + assume Hz: z :e LxRy'.
      apply LxRy'E z Hz.
      let w. assume Hw: w :e Lx.
      let z'. assume Hz': z' :e Ry.
      assume Hw1: SNo w.
      assume Hz'1: SNo z'.
      assume Hw2: w < x.
      assume Hz'2: y < z'.
      assume Hze. rewrite Hze.
      prove x * y < w * y + x * z' + - w * z'.
      apply add_SNo_minus_Lt2b3 (w * y) (x * z') (w * z') (x * y)
                 (SNo_mul_SNo w y Hw1 Hy1)
                 (SNo_mul_SNo x z' Hx1 Hz'1)
                 (SNo_mul_SNo w z' Hw1 Hz'1)
                 (SNo_mul_SNo x y Hx1 Hy1).
      prove x * y + w * z' < w * y + x * z'.
      rewrite add_SNo_com (x * y) (w * z')
                 (SNo_mul_SNo x y Hx1 Hy1)
                 (SNo_mul_SNo w z' Hw1 Hz'1).
      rewrite add_SNo_com (w * y) (x * z')
                 (SNo_mul_SNo w y Hw1 Hy1)
                 (SNo_mul_SNo x z' Hx1 Hz'1).
      prove w * z' + x * y < x * z' + w * y.
      exact mul_SNo_Lt x z' w y Hx1 Hz'1 Hw1 Hy1 Hw2 Hz'2.
    + assume Hz: z :e RxLy'.
      apply RxLy'E z Hz.
      let z'. assume Hz': z' :e Rx.
      let w. assume Hw: w :e Ly.
      assume Hz'1: SNo z'.
      assume Hw1: SNo w.
      assume Hz'2: x < z'.
      assume Hw2: w < y.
      assume Hze. rewrite Hze.
      prove x * y < z' * y + x * w + - z' * w.
      apply add_SNo_minus_Lt2b3 (z' * y) (x * w) (z' * w) (x * y)
                 (SNo_mul_SNo z' y Hz'1 Hy1)
                 (SNo_mul_SNo x w Hx1 Hw1)
                 (SNo_mul_SNo z' w Hz'1 Hw1)
                 (SNo_mul_SNo x y Hx1 Hy1).
      prove x * y + z' * w < z' * y + x * w.
      exact mul_SNo_Lt z' y x w Hz'1 Hy1 Hx1 Hw1 Hz'2 Hw2.
}
apply and3I.
- exact L1.
- exact Lxyeq.
- let q. assume Hq.
  apply Hq LxLy' RxRy' LxRy' RxLy'.
  + exact LxLy'E.
  + exact LxLy'I.
  + exact RxRy'E.
  + exact RxRy'I.
  + exact LxRy'E.
  + exact LxRy'I.
  + exact RxLy'E.
  + exact RxLy'I.
  + exact L1.
  + exact Lxyeq.
Qed.

Theorem mul_SNoCut_abs : forall Lx Rx Ly Ry x y,
    SNoCutP Lx Rx
 -> SNoCutP Ly Ry
 -> x = SNoCut Lx Rx
 -> y = SNoCut Ly Ry
 -> forall q:prop,
     (forall LxLy' RxRy' LxRy' RxLy',
         (forall u :e LxLy', forall p:prop, (forall w :e Lx, forall w' :e Ly, SNo w -> SNo w' -> w < x -> w' < y -> u = w * y + x * w' + - w * w' -> p) -> p)
      -> (forall w :e Lx, forall w' :e Ly, w * y + x * w' + - w * w' :e LxLy')
      -> (forall u :e RxRy', forall p:prop, (forall z :e Rx, forall z' :e Ry, SNo z -> SNo z' -> x < z -> y < z' -> u = z * y + x * z' + - z * z' -> p) -> p)
      -> (forall z :e Rx, forall z' :e Ry, z * y + x * z' + - z * z' :e RxRy')
      -> (forall u :e LxRy', forall p:prop, (forall w :e Lx, forall z :e Ry, SNo w -> SNo z -> w < x -> y < z -> u = w * y + x * z + - w * z -> p) -> p)
      -> (forall w :e Lx, forall z :e Ry, w * y + x * z + - w * z :e LxRy')
      -> (forall u :e RxLy', forall p:prop, (forall z :e Rx, forall w :e Ly, SNo z -> SNo w -> x < z -> w < y -> u = z * y + x * w + - z * w -> p) -> p)
      -> (forall z :e Rx, forall w :e Ly, z * y + x * w + - z * w :e RxLy')
      -> SNoCutP (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> x * y = SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> q)
    -> q.
let Lx Rx Ly Ry x y.
assume HLRx HLRy Hxe Hye.
apply mul_SNoCutP_lem Lx Rx Ly Ry x y HLRx HLRy Hxe Hye.
assume _ H. exact H.
Qed.

Theorem mul_SNo_SNoCut_SNoL_interpolate : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoL (x * y),
 (exists v :e Lx, exists w :e Ly, u + v * w <= v * y + x * w)
 \/
 (exists v :e Rx, exists w :e Ry, u + v * w <= v * y + x * w).
let Lx Rx Ly Ry. assume HLRx HLRy.
let x y. assume Hx Hy.
set P1 : set -> prop :=
  fun u => exists v :e Lx, exists w :e Ly, u + v * w <= v * y + x * w.
set P2 : set -> prop :=
  fun u => exists v :e Rx, exists w :e Ry, u + v * w <= v * y + x * w.
set P : set -> prop := fun u => P1 u \/ P2 u.
apply HLRx. assume H. apply H.
assume HLx HRx HLRx'.
apply HLRy. assume H. apply H.
assume HLy HRy HLRy'.
apply SNoCutP_SNoCut_impred Lx Rx HLRx.
rewrite <- Hx.
assume Hx1: SNo x.
assume Hx2: SNoLev x :e ordsucc ((\/_ x :e Lx, ordsucc (SNoLev x)) :\/: (\/_ y :e Rx, ordsucc (SNoLev y))).
assume Hx3: forall w :e Lx, w < x.
assume Hx4: forall z :e Rx, x < z.
assume Hx5: forall u, SNo u -> (forall w :e Lx, w < u) -> (forall z :e Rx, u < z) -> SNoLev x c= SNoLev u /\ SNoEq_ (SNoLev x) x u.
apply SNoCutP_SNoCut_impred Ly Ry HLRy.
rewrite <- Hy.
assume Hy1: SNo y.
assume Hy2: SNoLev y :e ordsucc ((\/_ y :e Ly, ordsucc (SNoLev y)) :\/: (\/_ y :e Ry, ordsucc (SNoLev y))).
assume Hy3: forall w :e Ly, w < y.
assume Hy4: forall z :e Ry, y < z.
assume Hy5: forall u, SNo u -> (forall w :e Ly, w < u) -> (forall z :e Ry, u < z) -> SNoLev y c= SNoLev u /\ SNoEq_ (SNoLev y) y u.
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Hx1 Hy1. }
claim LI: forall u, SNo u -> SNoLev u :e SNoLev (x * y) -> u < x * y -> P u.
{ apply SNoLev_ind.
  let u.
  assume Hu1: SNo u.
  assume IH: forall z :e SNoS_ (SNoLev u), SNoLev z :e SNoLev (x * y) -> z < x * y -> P z.
  assume Hu2: SNoLev u :e SNoLev (x * y).
  assume Hu3: u < x * y.
  apply dneg.
  assume HNC: ~P u.
  claim L1: forall v :e Lx, forall w :e Ly, v * y + x * w < u + v * w.
  { let v. assume Hv. let w. assume Hw.
    claim Lv1: SNo v.
    { exact HLx v Hv. }
    claim Lw1: SNo w.
    { exact HLy w Hw. }
    apply SNoLtLe_or (v * y + x * w) (u + v * w)
           (SNo_add_SNo (v * y) (x * w) (SNo_mul_SNo v y Lv1 Hy1) (SNo_mul_SNo x w Hx1 Lw1))
           (SNo_add_SNo u (v * w) Hu1 (SNo_mul_SNo v w Lv1 Lw1)).
    - assume H. exact H.
    - assume H. apply HNC. apply orIL.
      witness v. apply andI.
      + exact Hv.
      + witness w. apply andI.
        * exact Hw.
        * exact H.
  }
  claim L2: forall v :e Rx, forall w :e Ry, v * y + x * w < u + v * w.
  { let v. assume Hv. let w. assume Hw.
    claim Lv1: SNo v.
    { exact HRx v Hv. }
    claim Lw1: SNo w.
    { exact HRy w Hw. }
    apply SNoLtLe_or (v * y + x * w) (u + v * w)
           (SNo_add_SNo (v * y) (x * w) (SNo_mul_SNo v y Lv1 Hy1) (SNo_mul_SNo x w Hx1 Lw1))
           (SNo_add_SNo u (v * w) Hu1 (SNo_mul_SNo v w Lv1 Lw1)).
    - assume H. exact H.
    - assume H. apply HNC. apply orIR.
      witness v. apply andI.
      + exact Hv.
      + witness w. apply andI.
        * exact Hw.
        * exact H.
  }
  apply SNoLt_irref u.
  apply SNoLtLe_tra u (x * y) u Hu1 Lxy Hu1 Hu3.
  prove x * y <= u.
  apply mul_SNoCut_abs Lx Rx Ly Ry x y HLRx HLRy Hx Hy.
  let LxLy' RxRy' LxRy' RxLy'.
  assume LxLy'E LxLy'I RxRy'E RxRy'I LxRy'E LxRy'I RxLy'E RxLy'I.
  assume HSC: SNoCutP (LxLy' :\/: RxRy') (LxRy' :\/: RxLy').
  assume HE: x * y = SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy').
  rewrite HE.
  prove SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy') <= u.
  rewrite SNo_eta u Hu1.
  prove SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy') <= SNoCut (SNoL u) (SNoR u).
  apply SNoCut_Le (LxLy' :\/: RxRy') (LxRy' :\/: RxLy') (SNoL u) (SNoR u) HSC (SNoCutP_SNoL_SNoR u Hu1).
  - prove forall z :e LxLy' :\/: RxRy', z < SNoCut (SNoL u) (SNoR u).
    let z. rewrite <- SNo_eta u Hu1.
    apply binunionE'.
    + assume Hz: z :e LxLy'.
      apply LxLy'E z Hz.
      let w0. assume Hw0. let w1. assume Hw1.
      assume Hw0a Hw1a Hw0x Hw1y Hze. rewrite Hze.
      prove w0 * y + x * w1 + - w0 * w1 < u.
      apply add_SNo_minus_Lt1b3 (w0 * y) (x * w1) (w0 * w1) u
                     (SNo_mul_SNo w0 y Hw0a Hy1)
                     (SNo_mul_SNo x w1 Hx1 Hw1a)
                     (SNo_mul_SNo w0 w1 Hw0a Hw1a)
                     Hu1.
      prove w0 * y + x * w1 < u + w0 * w1.
      apply SNoLtLe_or (w0 * y + x * w1) (u + w0 * w1)
                       (SNo_add_SNo (w0 * y) (x * w1)
                        (SNo_mul_SNo w0 y Hw0a Hy1)
                        (SNo_mul_SNo x w1 Hx1 Hw1a))
                       (SNo_add_SNo u (w0 * w1) Hu1 (SNo_mul_SNo w0 w1 Hw0a Hw1a)).
      * assume H. exact H.
      * { assume H: u + w0 * w1 <= w0 * y + x * w1.
          apply HNC.
          prove P1 u \/ P2 u.
          apply orIL.
          prove exists v :e Lx, exists w :e Ly, u + v * w <= v * y + x * w.
          witness w0. apply andI.
          - exact Hw0.
          - witness w1. apply andI.
            + exact Hw1.
            + exact H.
        }
    + assume Hz: z :e RxRy'.
      apply RxRy'E z Hz.
      let z0. assume Hz0. let z1. assume Hz1.
      assume Hz0a Hz1a Hz0x Hz1y Hze. rewrite Hze.
      prove z0 * y + x * z1 + - z0 * z1 < u.
      apply add_SNo_minus_Lt1b3 (z0 * y) (x * z1) (z0 * z1) u
                     (SNo_mul_SNo z0 y Hz0a Hy1)
                     (SNo_mul_SNo x z1 Hx1 Hz1a)
                     (SNo_mul_SNo z0 z1 Hz0a Hz1a)
                     Hu1.
      prove z0 * y + x * z1 < u + z0 * z1.
      apply SNoLtLe_or (z0 * y + x * z1) (u + z0 * z1)
                       (SNo_add_SNo (z0 * y) (x * z1)
                        (SNo_mul_SNo z0 y Hz0a Hy1)
                        (SNo_mul_SNo x z1 Hx1 Hz1a))
                       (SNo_add_SNo u (z0 * z1) Hu1 (SNo_mul_SNo z0 z1 Hz0a Hz1a)).
      * assume H. exact H.
      * { assume H: u + z0 * z1 <= z0 * y + x * z1.
          apply HNC.
          prove P1 u \/ P2 u.
          apply orIR.
          prove exists v :e Rx, exists w :e Ry, u + v * w <= v * y + x * w.
          witness z0. apply andI.
          - exact Hz0.
          - witness z1. apply andI.
            + exact Hz1.
            + exact H.
        }
  - prove forall z :e SNoR u, SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy') < z.
    let z. assume Hz: z :e SNoR u.
    rewrite <- HE.
    prove x * y < z.
    apply SNoR_E u Hu1 z Hz.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev u.
    assume Hz3: u < z.
    apply SNoLt_trichotomy_or_impred z (x * y) Hz1 Lxy.
    + assume H1: z < x * y.
      claim LPz: P z.
      { apply IH z.
        - prove z :e SNoS_ (SNoLev u). apply SNoS_I2.
          + exact Hz1.
          + exact Hu1.
          + exact Hz2.
        - prove SNoLev z :e SNoLev (x * y).
          exact ordinal_TransSet (SNoLev (x * y)) (SNoLev_ordinal (x * y) Lxy)
                                 (SNoLev u) Hu2 (SNoLev z) Hz2.
        - prove z < x * y. exact H1.
      }
      apply LPz.
      * assume H2: P1 z. apply H2.
        let v. assume H2. apply H2.
        assume Hv: v :e Lx. assume H2. apply H2.
        let w. assume H2. apply H2.
        assume Hw: w :e Ly.
        assume Hvw: z + v * w <= v * y + x * w.
        claim Lv1: SNo v.
        { exact HLx v Hv. }
        claim Lw1: SNo w.
        { exact HLy w Hw. }
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Lv1 Lw1. }
        claim L3: z + v * w < u + v * w.
        { apply SNoLeLt_tra (z + v * w) (v * y + x * w) (u + v * w)
                       (SNo_add_SNo z (v * w) Hz1 Lvw)
                       (SNo_add_SNo (v * y) (x * w)
                                    (SNo_mul_SNo v y Lv1 Hy1)
                                    (SNo_mul_SNo x w Hx1 Lw1))
                       (SNo_add_SNo u (v * w) Hu1 Lvw)
                       Hvw.
          prove v * y + x * w < u + v * w.
          exact L1 v Hv w Hw.
        }
        claim L4: z < u.
        { exact add_SNo_Lt1_cancel z (v * w) u Hz1 Lvw Hu1 L3. }
        prove False.
        apply SNoLt_irref u.
        exact SNoLt_tra u z u Hu1 Hz1 Hu1 Hz3 L4.
      * assume H2: P2 z. apply H2.
        let v. assume H2. apply H2.
        assume Hv: v :e Rx. assume H2. apply H2.
        let w. assume H2. apply H2.
        assume Hw: w :e Ry.
        assume Hvw: z + v * w <= v * y + x * w.
        claim Lv1: SNo v.
        { exact HRx v Hv. }
        claim Lw1: SNo w.
        { exact HRy w Hw. }
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Lv1 Lw1. }
        claim L5: z + v * w < u + v * w.
        { apply SNoLeLt_tra (z + v * w) (v * y + x * w) (u + v * w)
                            (SNo_add_SNo z (v * w) Hz1 Lvw)
                            (SNo_add_SNo (v * y) (x * w)
                                         (SNo_mul_SNo v y Lv1 Hy1)
                                         (SNo_mul_SNo x w Hx1 Lw1))
                            (SNo_add_SNo u (v * w) Hu1 Lvw)
                            Hvw.
          prove v * y + x * w < u + v * w.
          exact L2 v Hv w Hw.
        }
        claim L6: z < u.
        { exact add_SNo_Lt1_cancel z (v * w) u Hz1 Lvw Hu1 L5. }
        prove False.
        apply SNoLt_irref u.
        exact SNoLt_tra u z u Hu1 Hz1 Hu1 Hz3 L6.
    + assume H1: z = x * y. apply In_no2cycle (SNoLev u) (SNoLev (x * y)) Hu2.
      prove SNoLev (x * y) :e SNoLev u. rewrite <- H1. exact Hz2.
    + assume H1: x * y < z. exact H1.
}
let u.
assume Hu: u :e SNoL (x * y).
apply SNoL_E (x * y) Lxy u Hu.
assume Hu1: SNo u.
assume Hu2: SNoLev u :e SNoLev (x * y).
assume Hu3: u < x * y.
exact LI u Hu1 Hu2 Hu3.
Qed.

Theorem mul_SNo_SNoCut_SNoL_interpolate_impred : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoL (x * y),
    forall p:prop,
        (forall v :e Lx, forall w :e Ly, u + v * w <= v * y + x * w -> p)
     -> (forall v :e Rx, forall w :e Ry, u + v * w <= v * y + x * w -> p)
     -> p.
let Lx Rx Ly Ry. assume HLRx HLRy.
let x y. assume Hx Hy. let u. assume Hu.
let p. assume Hp1 Hp2.
apply mul_SNo_SNoCut_SNoL_interpolate Lx Rx Ly Ry HLRx HLRy x y Hx Hy u Hu.
- assume H1. apply H1.
  let v. assume H1. apply H1.
  assume Hv. assume H1. apply H1.
  let w. assume H1. apply H1.
  assume Hw Hvw.
  exact Hp1 v Hv w Hw Hvw.
- assume H1. apply H1.
  let v. assume H1. apply H1.
  assume Hv. assume H1. apply H1.
  let w. assume H1. apply H1.
  assume Hw Hvw.
  exact Hp2 v Hv w Hw Hvw.
Qed.

Theorem mul_SNo_SNoCut_SNoR_interpolate : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoR (x * y),
 (exists v :e Lx, exists w :e Ry, v * y + x * w <= u + v * w)
 \/
 (exists v :e Rx, exists w :e Ly, v * y + x * w <= u + v * w).
let Lx Rx Ly Ry. assume HLRx HLRy.
let x y. assume Hx Hy.
set P1 : set -> prop :=
  fun u => exists v :e Lx, exists w :e Ry, v * y + x * w <= u + v * w.
set P2 : set -> prop :=
  fun u => exists v :e Rx, exists w :e Ly, v * y + x * w <= u + v * w.
set P : set -> prop := fun u => P1 u \/ P2 u.
apply HLRx. assume H. apply H.
assume HLx HRx HLRx'.
apply HLRy. assume H. apply H.
assume HLy HRy HLRy'.
apply SNoCutP_SNoCut_impred Lx Rx HLRx.
rewrite <- Hx.
assume Hx1: SNo x.
assume Hx2: SNoLev x :e ordsucc ((\/_ x :e Lx, ordsucc (SNoLev x)) :\/: (\/_ y :e Rx, ordsucc (SNoLev y))).
assume Hx3: forall w :e Lx, w < x.
assume Hx4: forall z :e Rx, x < z.
assume Hx5: forall u, SNo u -> (forall w :e Lx, w < u) -> (forall z :e Rx, u < z) -> SNoLev x c= SNoLev u /\ SNoEq_ (SNoLev x) x u.
apply SNoCutP_SNoCut_impred Ly Ry HLRy.
rewrite <- Hy.
assume Hy1: SNo y.
assume Hy2: SNoLev y :e ordsucc ((\/_ y :e Ly, ordsucc (SNoLev y)) :\/: (\/_ y :e Ry, ordsucc (SNoLev y))).
assume Hy3: forall w :e Ly, w < y.
assume Hy4: forall z :e Ry, y < z.
assume Hy5: forall u, SNo u -> (forall w :e Ly, w < u) -> (forall z :e Ry, u < z) -> SNoLev y c= SNoLev u /\ SNoEq_ (SNoLev y) y u.
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Hx1 Hy1. }
claim LI: forall u, SNo u -> SNoLev u :e SNoLev (x * y) -> x * y < u -> P u.
{ apply SNoLev_ind.
  let u.
  assume Hu1: SNo u.
  assume IH: forall z :e SNoS_ (SNoLev u), SNoLev z :e SNoLev (x * y) -> x * y < z -> P z.
  assume Hu2: SNoLev u :e SNoLev (x * y).
  assume Hu3: x * y < u.
  apply dneg.
  assume HNC: ~P u.
  claim L1: forall v :e Lx, forall w :e Ry, u + v * w < v * y + x * w.
  { let v. assume Hv. let w. assume Hw.
    claim Lv1: SNo v.
    { exact HLx v Hv. }
    claim Lw1: SNo w.
    { exact HRy w Hw. }
    apply SNoLtLe_or (u + v * w) (v * y + x * w)
           (SNo_add_SNo u (v * w) Hu1 (SNo_mul_SNo v w Lv1 Lw1))
           (SNo_add_SNo (v * y) (x * w) (SNo_mul_SNo v y Lv1 Hy1) (SNo_mul_SNo x w Hx1 Lw1)).
    - assume H. exact H.
    - assume H. apply HNC. apply orIL.
      witness v. apply andI.
      + exact Hv.
      + witness w. apply andI.
        * exact Hw.
        * exact H.
  }
  claim L2: forall v :e Rx, forall w :e Ly, u + v * w < v * y + x * w.
  { let v. assume Hv. let w. assume Hw.
    claim Lv1: SNo v.
    { exact HRx v Hv. }
    claim Lw1: SNo w.
    { exact HLy w Hw. }
    apply SNoLtLe_or (u + v * w) (v * y + x * w)
           (SNo_add_SNo u (v * w) Hu1 (SNo_mul_SNo v w Lv1 Lw1))
           (SNo_add_SNo (v * y) (x * w) (SNo_mul_SNo v y Lv1 Hy1) (SNo_mul_SNo x w Hx1 Lw1)).
    - assume H. exact H.
    - assume H. apply HNC. apply orIR.
      witness v. apply andI.
      + exact Hv.
      + witness w. apply andI.
        * exact Hw.
        * exact H.
  }
  apply SNoLt_irref (x * y).
  apply SNoLtLe_tra (x * y) u (x * y) Lxy Hu1 Lxy Hu3.
  prove u <= x * y.
  apply mul_SNoCut_abs Lx Rx Ly Ry x y HLRx HLRy Hx Hy.
  let LxLy' RxRy' LxRy' RxLy'.
  assume LxLy'E LxLy'I RxRy'E RxRy'I LxRy'E LxRy'I RxLy'E RxLy'I.
  assume HSC: SNoCutP (LxLy' :\/: RxRy') (LxRy' :\/: RxLy').
  assume HE: x * y = SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy').
  rewrite HE.
  prove u <= SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy').
  rewrite SNo_eta u Hu1.
  prove SNoCut (SNoL u) (SNoR u) <= SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy').
  apply SNoCut_Le (SNoL u) (SNoR u) (LxLy' :\/: RxRy') (LxRy' :\/: RxLy') (SNoCutP_SNoL_SNoR u Hu1) HSC.
  - prove forall z :e SNoL u, z < SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy').
    let z. assume Hz: z :e SNoL u.
    rewrite <- HE.
    prove z < x * y.
    apply SNoL_E u Hu1 z Hz.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev u.
    assume Hz3: z < u.
    apply SNoLt_trichotomy_or_impred (x * y) z Lxy Hz1.
    + assume H1: x * y < z.
      claim LPz: P z.
      { apply IH z.
        - prove z :e SNoS_ (SNoLev u). apply SNoS_I2.
          + exact Hz1.
          + exact Hu1.
          + exact Hz2.
        - prove SNoLev z :e SNoLev (x * y).
          exact ordinal_TransSet (SNoLev (x * y)) (SNoLev_ordinal (x * y) Lxy)
                                 (SNoLev u) Hu2 (SNoLev z) Hz2.
        - prove x * y < z. exact H1.
      }
      apply LPz.
      * assume H2: P1 z. apply H2.
        let v. assume H2. apply H2.
        assume Hv: v :e Lx. assume H2. apply H2.
        let w. assume H2. apply H2.
        assume Hw: w :e Ry.
        assume Hvw: v * y + x * w <= z + v * w.
        claim Lv1: SNo v.
        { exact HLx v Hv. }
        claim Lw1: SNo w.
        { exact HRy w Hw. }
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Lv1 Lw1. }
        claim L3: u + v * w < z + v * w.
        { apply SNoLtLe_tra (u + v * w) (v * y + x * w) (z + v * w)
                       (SNo_add_SNo u (v * w) Hu1 Lvw)
                       (SNo_add_SNo (v * y) (x * w)
                                    (SNo_mul_SNo v y Lv1 Hy1)
                                    (SNo_mul_SNo x w Hx1 Lw1))
                       (SNo_add_SNo z (v * w) Hz1 Lvw).
          - prove u + v * w < v * y + x * w.
            exact L1 v Hv w Hw.
          - exact Hvw.
        }
        claim L4: u < z.
        { exact add_SNo_Lt1_cancel u (v * w) z Hu1 Lvw Hz1 L3. }
        prove False.
        apply SNoLt_irref u.
        exact SNoLt_tra u z u Hu1 Hz1 Hu1 L4 Hz3.
      * assume H2: P2 z. apply H2.
        let v. assume H2. apply H2.
        assume Hv: v :e Rx. assume H2. apply H2.
        let w. assume H2. apply H2.
        assume Hw: w :e Ly.
        assume Hvw: v * y + x * w <= z + v * w.
        claim Lv1: SNo v.
        { exact HRx v Hv. }
        claim Lw1: SNo w.
        { exact HLy w Hw. }
        claim Lvw: SNo (v * w).
        { exact SNo_mul_SNo v w Lv1 Lw1. }
        claim L5: u + v * w < z + v * w.
        { apply SNoLtLe_tra (u + v * w) (v * y + x * w) (z + v * w)
                            (SNo_add_SNo u (v * w) Hu1 Lvw)
                            (SNo_add_SNo (v * y) (x * w)
                                         (SNo_mul_SNo v y Lv1 Hy1)
                                         (SNo_mul_SNo x w Hx1 Lw1))
                            (SNo_add_SNo z (v * w) Hz1 Lvw).
          - prove u + v * w < v * y + x * w.
            exact L2 v Hv w Hw.
          - exact Hvw.
        }
        claim L6: u < z.
        { exact add_SNo_Lt1_cancel u (v * w) z Hu1 Lvw Hz1 L5. }
        prove False.
        apply SNoLt_irref u.
        exact SNoLt_tra u z u Hu1 Hz1 Hu1 L6 Hz3.
    + assume H1: x * y = z. apply In_no2cycle (SNoLev u) (SNoLev (x * y)) Hu2.
      prove SNoLev (x * y) :e SNoLev u. rewrite H1. exact Hz2.
    + assume H1: z < x * y. exact H1.
  - prove forall z :e LxRy' :\/: RxLy', SNoCut (SNoL u) (SNoR u) < z.
    let z. rewrite <- SNo_eta u Hu1.
    apply binunionE'.
    + assume Hz: z :e LxRy'.
      apply LxRy'E z Hz.
      let w0. assume Hw0. let w1. assume Hw1.
      assume Hw0a Hw1a Hw0x Hw1y Hze. rewrite Hze.
      prove u < w0 * y + x * w1 + - w0 * w1.
      apply add_SNo_minus_Lt2b3 (w0 * y) (x * w1) (w0 * w1) u
                     (SNo_mul_SNo w0 y Hw0a Hy1)
                     (SNo_mul_SNo x w1 Hx1 Hw1a)
                     (SNo_mul_SNo w0 w1 Hw0a Hw1a)
                     Hu1.
      prove u + w0 * w1 < w0 * y + x * w1.
      apply SNoLtLe_or (u + w0 * w1) (w0 * y + x * w1)
                       (SNo_add_SNo u (w0 * w1) Hu1 (SNo_mul_SNo w0 w1 Hw0a Hw1a))
                       (SNo_add_SNo (w0 * y) (x * w1)
                        (SNo_mul_SNo w0 y Hw0a Hy1)
                        (SNo_mul_SNo x w1 Hx1 Hw1a)).
      * assume H. exact H.
      * { assume H: w0 * y + x * w1 <= u + w0 * w1.
          apply HNC.
          prove P1 u \/ P2 u.
          apply orIL.
          prove exists v :e Lx, exists w :e Ry, v * y + x * w <= u + v * w.
          witness w0. apply andI.
          - exact Hw0.
          - witness w1. apply andI.
            + exact Hw1.
            + exact H.
        }
    + assume Hz: z :e RxLy'.
      apply RxLy'E z Hz.
      let z0. assume Hz0. let z1. assume Hz1.
      assume Hz0a Hz1a Hz0x Hz1y Hze. rewrite Hze.
      prove u < z0 * y + x * z1 + - z0 * z1.
      apply add_SNo_minus_Lt2b3 (z0 * y) (x * z1) (z0 * z1) u
                     (SNo_mul_SNo z0 y Hz0a Hy1)
                     (SNo_mul_SNo x z1 Hx1 Hz1a)
                     (SNo_mul_SNo z0 z1 Hz0a Hz1a)
                     Hu1.
      prove u + z0 * z1 < z0 * y + x * z1.
      apply SNoLtLe_or (u + z0 * z1) (z0 * y + x * z1)
                       (SNo_add_SNo u (z0 * z1) Hu1 (SNo_mul_SNo z0 z1 Hz0a Hz1a))
                       (SNo_add_SNo (z0 * y) (x * z1)
                        (SNo_mul_SNo z0 y Hz0a Hy1)
                        (SNo_mul_SNo x z1 Hx1 Hz1a)).
      * assume H. exact H.
      * { assume H: z0 * y + x * z1 <= u + z0 * z1.
          apply HNC.
          prove P1 u \/ P2 u.
          apply orIR.
          prove exists v :e Rx, exists w :e Ly, v * y + x * w <= u + v * w.
          witness z0. apply andI.
          - exact Hz0.
          - witness z1. apply andI.
            + exact Hz1.
            + exact H.
        }
}
let u.
assume Hu: u :e SNoR (x * y).
apply SNoR_E (x * y) Lxy u Hu.
assume Hu1: SNo u.
assume Hu2: SNoLev u :e SNoLev (x * y).
assume Hu3: x * y < u.
exact LI u Hu1 Hu2 Hu3.
Qed.

Theorem mul_SNo_SNoCut_SNoR_interpolate_impred : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoR (x * y),
    forall p:prop,
        (forall v :e Lx, forall w :e Ry, v * y + x * w <= u + v * w -> p)
     -> (forall v :e Rx, forall w :e Ly, v * y + x * w <= u + v * w -> p)
     -> p.
let Lx Rx Ly Ry. assume HLRx HLRy.
let x y. assume Hx Hy. let u. assume Hu.
let p. assume Hp1 Hp2.
apply mul_SNo_SNoCut_SNoR_interpolate Lx Rx Ly Ry HLRx HLRy x y Hx Hy u Hu.
- assume H1. apply H1.
  let v. assume H1. apply H1.
  assume Hv. assume H1. apply H1.
  let w. assume H1. apply H1.
  assume Hw Hvw.
  exact Hp1 v Hv w Hw Hvw.
- assume H1. apply H1.
  let v. assume H1. apply H1.
  assume Hv. assume H1. apply H1.
  let w. assume H1. apply H1.
  assume Hw Hvw.
  exact Hp2 v Hv w Hw Hvw.
Qed.

Theorem nonpos_nonneg_0 : forall m n :e omega, m = - n -> m = 0 /\ n = 0.
let m. assume Hm.
let n. assume Hn Hmn.
apply nat_inv n (omega_nat_p n Hn).
- assume H1: n = 0. apply andI.
  + rewrite Hmn. rewrite H1. exact minus_SNo_0.
  + exact H1.
- assume H1. prove False.
  apply H1. let k. assume H. apply H.
  assume Hk: nat_p k.
  assume H1: n = ordsucc k.
  apply SNoLt_irref 0.
  prove 0 < 0.
  apply SNoLeLt_tra 0 m 0 SNo_0 (omega_SNo m Hm) SNo_0.
  + prove 0 <= m.
    apply ordinal_Subq_SNoLe 0 m ordinal_Empty (nat_p_ordinal m (omega_nat_p m Hm)).
    prove 0 c= m.
    apply Subq_Empty.
  + prove m < 0. rewrite Hmn.
    prove - n < 0.
    apply minus_SNo_Lt_contra1 0 n SNo_0 (omega_SNo n Hn).
    prove - 0 < n.
    rewrite minus_SNo_0.
    prove 0 < n.
    apply ordinal_In_SNoLt n (nat_p_ordinal n (omega_nat_p n Hn)).
    prove 0 :e n.
    rewrite H1.
    prove 0 :e ordsucc k.
    apply nat_0_in_ordsucc.
    exact Hk.
Qed.

Theorem mul_minus_SNo_distrR: forall x y, SNo x -> SNo y -> x * (- y) = - (x * y).
let x y.
assume Hx Hy.
transitivity (- y) * x,
             - (y * x).
- exact mul_SNo_com x (- y) Hx (SNo_minus_SNo y Hy).
- exact mul_SNo_minus_distrL y x Hy Hx.
- f_equal. exact mul_SNo_com y x Hy Hx.
Qed.

End SurrealMul.

Opaque mul_SNo.

Section Int.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Definition int : set := omega :\/: {- n|n :e omega}.

Theorem int_SNo_cases : forall p:set -> prop,
    (forall n :e omega, p n)
 -> (forall n :e omega, p (- n))
 -> forall x :e int, p x.
let p. assume Hp1 Hp2.
let x. assume Hx. prove p x.
apply binunionE omega {- n|n :e omega} x Hx.
- assume Hx: x :e omega. exact Hp1 x Hx.
- assume Hx. apply ReplE_impred omega minus_SNo x Hx.
  let n. assume Hn: n :e omega.
  assume Hxn: x = - n.
  rewrite Hxn. exact Hp2 n Hn.
Qed.

Theorem int_3_cases: forall n :e int, forall p:prop,
    (forall m :e omega, n = - ordsucc m -> p)
 -> (n = 0 -> p)
 -> (forall m :e omega, n = ordsucc m -> p)
 -> p.
apply int_SNo_cases.
- let m. assume Hm: m :e omega.
  let p. assume Hneg H0 Hpos.
  claim L1: forall k, nat_p k -> m = ordsucc k -> p.
  { let k. assume Hk HmSk.
    exact Hpos k (nat_p_omega k Hk) HmSk.
  }
  exact nat_inv_impred (fun k => m = k -> p) H0 L1 m (omega_nat_p m Hm) (fun q H => H).
- let m. assume Hm: m :e omega.
  let p.
  assume Hneg: forall k :e omega, - m = - ordsucc k -> p.
  assume H0: - m = 0 -> p.
  assume Hpos: forall k :e omega, - m = ordsucc k -> p.
  claim L2: m = 0 -> p.
  { assume Hm0. apply H0. rewrite Hm0. exact minus_SNo_0. }
  claim L3: forall k, nat_p k -> m = ordsucc k -> p.
  { let k. assume Hk HmSk.
    apply Hneg k (nat_p_omega k Hk).
    prove - m = - ordsucc k.
    f_equal. exact HmSk.
  }
  apply nat_inv_impred (fun k => m = k -> p) L2 L3 m (omega_nat_p m Hm) (fun q H => H).
Qed.

Theorem int_SNo : forall x :e int, SNo x.
apply int_SNo_cases.
- exact omega_SNo.
- let n. assume Hn. prove SNo (- n).
  apply SNo_minus_SNo.
  prove SNo n. exact omega_SNo n Hn.
Qed.

Theorem Subq_omega_int : omega c= int.
let n. assume Hn.
prove n :e omega :\/: {- k|k :e omega}.
apply binunionI1.
exact Hn.
Qed.

Theorem int_minus_SNo_omega : forall n :e omega, - n :e int.
let n. assume Hn.
prove - n :e omega :\/: {- k|k :e omega}.
apply binunionI2.
prove - n :e {- k|k :e omega}.
apply ReplI. exact Hn.
Qed.

Theorem int_add_SNo_lem: forall n :e omega, forall m, nat_p m -> - n + m :e int.
let n. assume Hn.
claim Lnn: nat_p n.
{ exact omega_nat_p n Hn. }
claim Lno: ordinal n.
{ exact nat_p_ordinal n Lnn. }
claim LnS: SNo n.
{ exact ordinal_SNo n Lno. }
apply nat_ind.
- prove - n + 0 :e int. rewrite add_SNo_0R (- n) (SNo_minus_SNo n LnS).
  prove - n :e int.
  apply int_minus_SNo_omega.
  exact Hn.
- let m. assume Hm: nat_p m.
  assume IHm: - n + m :e int.
  claim Lmo: ordinal m.
  { exact nat_p_ordinal m Hm. }
  claim LmS: SNo m.
  { exact ordinal_SNo m Lmo. }
  prove - n + ordsucc m :e int.
  rewrite ordinal_ordsucc_SNo_eq m Lmo.
  prove - n + (1 + m) :e int.
  rewrite add_SNo_com_3_0_1 (- n) 1 m (SNo_minus_SNo n LnS) SNo_1 LmS.
  prove 1 + (- n + m) :e int.
  claim L1: forall k :e omega, - n + m = k -> 1 + (- n + m) :e int.
  { let k. assume Hk He.
    rewrite He. prove 1 + k :e int.
    rewrite <- ordinal_ordsucc_SNo_eq k (nat_p_ordinal k (omega_nat_p k Hk)).
    prove ordsucc k :e int. apply Subq_omega_int. apply omega_ordsucc. exact Hk.    
  }
  claim L2: forall k :e omega, - n + m = - k -> 1 + (- n + m) :e int.
  { let k. assume Hk He. rewrite He.
    prove 1 + - k :e int.
    apply nat_inv k (omega_nat_p k Hk).
    - assume H1: k = 0. rewrite H1. rewrite minus_SNo_0.
      rewrite add_SNo_0R 1 SNo_1.
      prove 1 :e int.
      apply Subq_omega_int.
      prove 1 :e omega.
      exact nat_p_omega 1 nat_1.
    - assume H1. apply H1. let k'. assume H1. apply H1.
      assume H1: nat_p k'.
      assume H2: k = ordsucc k'.
      rewrite H2.
      prove 1 + - (ordsucc k') :e int.
      rewrite ordinal_ordsucc_SNo_eq k' (nat_p_ordinal k' H1).
      prove 1 + - (1 +  k') :e int.
      rewrite minus_add_SNo_distr 1 k' SNo_1 (ordinal_SNo k' (nat_p_ordinal k' H1)).
      prove 1 + - 1 +  - k' :e int.
      rewrite add_SNo_minus_L2' 1 (- k') SNo_1 (SNo_minus_SNo k' (ordinal_SNo k' (nat_p_ordinal k' H1))).
      prove - k' :e int. apply int_minus_SNo_omega. exact nat_p_omega k' H1.
  }
  apply int_SNo_cases (fun x => - n + m = x -> 1 + (- n + m) :e int) L1 L2 (- n + m) IHm.
  reflexivity.
Qed.

Theorem int_add_SNo: forall x y :e int, x + y :e int.
apply int_SNo_cases.
- let n. assume Hn: n :e omega.
  apply int_SNo_cases.
  + let m. assume Hm: m :e omega. apply Subq_omega_int.
    prove n + m :e omega. exact add_SNo_In_omega n Hn m Hm.
  + let m. assume Hm: m :e omega.
    prove n + - m :e int.
    rewrite add_SNo_com n (- m)
                        (ordinal_SNo n (nat_p_ordinal n (omega_nat_p n Hn)))
                        (SNo_minus_SNo m (ordinal_SNo m (nat_p_ordinal m (omega_nat_p m Hm)))).
    prove - m + n :e int.
    exact int_add_SNo_lem m Hm n (omega_nat_p n Hn).
- let n. assume Hn: n :e omega.
  apply int_SNo_cases.
  + let m. assume Hm: m :e omega.
    prove - n + m :e int.
    exact int_add_SNo_lem n Hn m (omega_nat_p m Hm).
  + let m. assume Hm: m :e omega.
    prove - n + - m :e int.
    claim Ln: SNo n.
    { exact ordinal_SNo n (nat_p_ordinal n (omega_nat_p n Hn)). }
    claim Lm: SNo m.
    { exact ordinal_SNo m (nat_p_ordinal m (omega_nat_p m Hm)). }
    rewrite <- minus_add_SNo_distr n m Ln Lm.
    apply int_minus_SNo_omega.
    prove n + m :e omega. exact add_SNo_In_omega n Hn m Hm.
Qed.

Theorem int_minus_SNo: forall x :e int, - x :e int.
apply int_SNo_cases.
- let n. assume Hn. prove - n :e int.
  apply int_minus_SNo_omega. exact Hn.
- let n. assume Hn. prove - - n :e int.
  rewrite minus_SNo_invol n (ordinal_SNo n (nat_p_ordinal n (omega_nat_p n Hn))).
  prove n :e int. apply Subq_omega_int. exact Hn.
Qed.

Theorem int_mul_SNo: forall x y :e int, x * y :e int.
apply int_SNo_cases.
- let n. assume Hn: n :e omega.
  claim Lnn: nat_p n.
  { exact omega_nat_p n Hn. }
  claim Lno: ordinal n.
  { exact nat_p_ordinal n Lnn. }
  claim LnS: SNo n.
  { exact ordinal_SNo n Lno. }
  apply int_SNo_cases.
  + let m. assume Hm: m :e omega. apply Subq_omega_int.
    prove n * m :e omega. exact mul_SNo_In_omega n Hn m Hm.
  + let m. assume Hm: m :e omega.
    claim Lmn: nat_p m.
    { exact omega_nat_p m Hm. }
    claim Lmo: ordinal m.
    { exact nat_p_ordinal m Lmn. }
    claim LmS: SNo m.
    { exact ordinal_SNo m Lmo. }
    prove n * (- m) :e int.
    rewrite mul_SNo_com n (- m) LnS (SNo_minus_SNo m LmS).
    prove (- m) * n :e int.
    rewrite mul_SNo_minus_distrL m n LmS LnS.
    prove - (m * n) :e int.
    apply int_minus_SNo.
    prove m * n :e int.
    apply Subq_omega_int.
    exact mul_SNo_In_omega m Hm n Hn.
- let n. assume Hn: n :e omega.
  claim Lnn: nat_p n.
  { exact omega_nat_p n Hn. }
  claim Lno: ordinal n.
  { exact nat_p_ordinal n Lnn. }
  claim LnS: SNo n.
  { exact ordinal_SNo n Lno. }
  apply int_SNo_cases.
  + let m. assume Hm: m :e omega.
    claim Lmn: nat_p m.
    { exact omega_nat_p m Hm. }
    claim Lmo: ordinal m.
    { exact nat_p_ordinal m Lmn. }
    claim LmS: SNo m.
    { exact ordinal_SNo m Lmo. }
    prove (- n) * m :e int.
    rewrite mul_SNo_minus_distrL n m LnS LmS.
    prove - (n * m) :e int.
    apply int_minus_SNo.
    prove n * m :e int.
    apply Subq_omega_int.
    exact mul_SNo_In_omega n Hn m Hm.
  + let m. assume Hm: m :e omega.
    claim Lmn: nat_p m.
    { exact omega_nat_p m Hm. }
    claim Lmo: ordinal m.
    { exact nat_p_ordinal m Lmn. }
    claim LmS: SNo m.
    { exact ordinal_SNo m Lmo. }
    prove (- n) * (- m) :e int.
    rewrite mul_SNo_minus_distrL n (- m) LnS (SNo_minus_SNo m LmS).
    prove - (n * (- m)) :e int.
    rewrite mul_SNo_com n (- m) LnS (SNo_minus_SNo m LmS).
    prove - ((- m) * n) :e int.
    rewrite mul_SNo_minus_distrL m n LmS LnS.
    prove - - (m * n) :e int.
    rewrite minus_SNo_invol (m * n) (SNo_mul_SNo m n LmS LnS).
    prove m * n :e int. apply Subq_omega_int.
    prove m * n :e omega. exact mul_SNo_In_omega m Hm n Hn.
Qed.

Theorem nonneg_int_nat_p: forall n :e int, 0 <= n -> nat_p n.
apply int_SNo_cases.
- let n.
  assume H1: n :e omega.
  assume H2: 0 <= n.
  prove nat_p n.
  exact omega_nat_p n H1.
- let n.
  assume H1: n :e omega.
  assume H2: 0 <= - n.
  prove nat_p (- n).
  claim LnS: SNo n.
  { exact omega_SNo n H1. }
  claim L1: n = 0.
  { apply SNoLe_antisym n 0 LnS SNo_0.
    - prove n <= 0.
      rewrite <- minus_SNo_invol n LnS.
      rewrite <- minus_SNo_0.
      prove - - n <= - 0.
      apply minus_SNo_Le_contra 0 (- n) SNo_0 (SNo_minus_SNo n LnS).
      prove 0 <= - n.
      exact H2.
    - prove 0 <= n.
      apply ordinal_Subq_SNoLe 0 n ordinal_Empty (nat_p_ordinal n (omega_nat_p n H1)).
      prove 0 c= n.
      apply Subq_Empty.
  }
  rewrite L1. rewrite minus_SNo_0.
  exact nat_0.
Qed.

End Int.

Section BezoutAndGCD.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Theorem quotient_remainder_nat: forall n :e omega :\: {0}, forall m, nat_p m -> exists q :e omega, exists r :e n, m = q * n + r.
let n. assume Hn.
apply setminusE omega {0} n Hn.
assume Hn1: n :e omega.
assume Hn2: n /:e {0}.
claim LnN: nat_p n.
{ apply omega_nat_p. exact Hn1. }
claim Lno: ordinal n.
{ apply nat_p_ordinal. exact LnN. }
claim L0n: 0 :e n.
{ apply ordinal_In_Or_Subq 0 n ordinal_Empty Lno.
  - assume H1: 0 :e n. exact H1.
  - assume H1: n c= 0. prove False.
    apply Hn2.
    prove n :e {0}.
    rewrite Empty_Subq_eq n H1.
    apply SingI.
}
apply nat_ind.
- prove exists q :e omega, exists r :e n, 0 = q * n + r.
  witness 0. apply andI.
  + apply nat_p_omega. exact nat_0.
  + witness 0. apply andI.
    * exact L0n.
    * prove 0 = 0 * n + 0.
      rewrite mul_nat_0L n LnN.
      symmetry.
      exact add_nat_0R 0.
- let m. assume Hm.
  assume IHm: exists q :e omega, exists r :e n, m = q * n + r.
  prove exists q :e omega, exists r :e n, ordsucc m = q * n + r.
  apply IHm.
  let q. assume H. apply H.
  assume Hq: q :e omega. assume H. apply H.
  let r. assume H. apply H.
  assume Hr: r :e n.
  assume H1: m = q * n + r.
  claim LqN: nat_p q.
  { exact omega_nat_p q Hq. }
  claim LrN: nat_p r.
  { exact nat_p_trans n LnN r Hr. }
  apply ordinal_trichotomy_or_impred (ordsucc r) n (ordinal_ordsucc r (nat_p_ordinal r LrN)) Lno.
  + assume H2: ordsucc r :e n.
    witness q. apply andI.
    * exact Hq.
    * { witness (ordsucc r). apply andI.
        - exact H2.
        - prove ordsucc m = q * n + ordsucc r.
          rewrite add_nat_SR (q * n) r LrN.
          f_equal.
          exact H1.
      }
  + assume H2: ordsucc r = n.
    witness (ordsucc q). apply andI.
    * apply omega_ordsucc. exact Hq.
    * { witness 0. apply andI.
        - exact L0n.
        - prove ordsucc m = ordsucc q * n + 0.
          rewrite add_nat_0R (ordsucc q * n).
          prove ordsucc m = ordsucc q * n.
          rewrite mul_nat_SL q LqN n LnN.
          prove ordsucc m = q * n + n.
          rewrite <- H2 at 2.
          prove ordsucc m = q * n + ordsucc r.
          rewrite add_nat_SR (q * n) r LrN.
          f_equal.
          exact H1.
      }
  + assume H2: n :e ordsucc r. prove False.
    apply In_irref n.
    apply ordinal_ordsucc_In_Subq n Lno r Hr.
    exact H2.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
Infix <= 490 := SNoLe.

Theorem mul_SNo_nonpos_nonneg: forall x y, SNo x -> SNo y -> x <= 0 -> 0 <= y -> x * y <= 0.
let x y. assume Hx Hy Hxnp Hynn.
apply SNoLeE 0 y SNo_0 Hy Hynn.
- assume H1: 0 < y.
  exact mul_SNo_nonpos_pos x y Hx Hy Hxnp H1.
- assume H1: 0 = y. rewrite <- H1.
  prove x * 0 <= 0.
  rewrite mul_SNo_zeroR x Hx.
  apply SNoLe_ref.
Qed.

Theorem ordinal_0_In_ordsucc: forall alpha, ordinal alpha -> 0 :e ordsucc alpha.
let alpha. assume Ha.
apply ordinal_In_Or_Subq 0 (ordsucc alpha) ordinal_Empty (ordinal_ordsucc alpha Ha).
- assume H1: 0 :e ordsucc alpha. exact H1.
- assume H1: ordsucc alpha c= 0. prove False.
  apply EmptyE alpha.
  prove alpha :e 0. apply H1. apply ordsuccI2.
Qed.

Theorem ordinal_ordsucc_pos: forall alpha, ordinal alpha -> 0 < ordsucc alpha.
let alpha. assume Ha.
apply ordinal_In_SNoLt (ordsucc alpha) (ordinal_ordsucc alpha Ha) 0.
prove 0 :e ordsucc alpha.
exact ordinal_0_In_ordsucc alpha Ha.
Qed.

Theorem quotient_remainder_int: forall n :e omega :\: {0}, forall m :e int, exists q :e int, exists r :e n, m = q * n + r.
let n. assume Hn.
apply setminusE omega {0} n Hn.
assume Hn1: n :e omega.
assume Hn2: n /:e {0}.
claim LnN: nat_p n.
{ apply omega_nat_p. exact Hn1. }
claim Lno: ordinal n.
{ apply nat_p_ordinal. exact LnN. }
claim L0n: 0 :e n.
{ apply ordinal_In_Or_Subq 0 n ordinal_Empty Lno.
  - assume H1: 0 :e n. exact H1.
  - assume H1: n c= 0. prove False.
    apply Hn2.
    prove n :e {0}.
    rewrite Empty_Subq_eq n H1.
    apply SingI.
}
apply int_SNo_cases.
- let m. assume Hm: m :e omega.
  apply quotient_remainder_nat n Hn m (omega_nat_p m Hm).
  let q. assume H. apply H.
  assume Hq: q :e omega. assume H. apply H.
  let r. assume H. apply H.
  assume Hr: r :e n.
  assume H1: m = add_nat (mul_nat q n) r.
  claim LqN: nat_p q.
  { exact omega_nat_p q Hq. }
  claim LrN: nat_p r.
  { exact nat_p_trans n LnN r Hr. }
  claim L1: m = q * n + r.
  { transitivity mul_nat q n + r.
    - prove m = mul_nat q n + r.
      rewrite H1.
      exact add_nat_add_SNo (mul_nat q n) (nat_p_omega (mul_nat q n) (mul_nat_p q LqN n LnN)) r (nat_p_omega r LrN).
    - prove mul_nat q n + r = q * n + r.
      f_equal.
      exact mul_nat_mul_SNo q Hq n Hn1.
  }
  witness q. apply andI.
  - prove q :e int. apply Subq_omega_int. exact Hq.
  - witness r. apply andI.
    + exact Hr.
    + prove m = q * n + r. exact L1.
- let m. assume Hm: m :e omega.
  prove exists q :e int, exists r :e n, - m = q * n + r.
  apply quotient_remainder_nat n Hn m (omega_nat_p m Hm).
  let q. assume H. apply H.
  assume Hq: q :e omega. assume H. apply H.
  let r. assume H. apply H.
  assume Hr: r :e n.
  assume H1: m = add_nat (mul_nat q n) r.
  claim LqN: nat_p q.
  { exact omega_nat_p q Hq. }
  claim LqS: SNo q.
  { apply nat_p_SNo. exact LqN. }
  claim LrN: nat_p r.
  { exact nat_p_trans n LnN r Hr. }
  claim LrS: SNo r.
  { apply nat_p_SNo. exact LrN. }
  claim LnS: SNo n.
  { apply nat_p_SNo. exact LnN. }
  claim LqnS: SNo (q * n).
  { exact SNo_mul_SNo q n LqS LnS. }
  claim L2: m = q * n + r.
  { transitivity mul_nat q n + r.
    - prove m = mul_nat q n + r.
      rewrite H1.
      exact add_nat_add_SNo (mul_nat q n) (nat_p_omega (mul_nat q n) (mul_nat_p q LqN n LnN)) r (nat_p_omega r LrN).
    - prove mul_nat q n + r = q * n + r.
      f_equal.
      exact mul_nat_mul_SNo q Hq n Hn1.
  }
  claim L3: 0 <= r.
  { apply omega_nonneg. apply nat_p_omega. exact LrN. }
  apply SNoLeE 0 r SNo_0 LrS L3.
  + assume H2: 0 < r.
    claim L4: n + - r :e n.
    { apply ordinal_SNoLt_In.
      - prove ordinal (n + - r).
        apply nat_p_ordinal.
        prove nat_p (n + - r).
        apply nonneg_int_nat_p.
        + prove n + - r :e int.
          apply int_add_SNo.
          * apply Subq_omega_int. exact Hn1.
          * apply int_minus_SNo. apply Subq_omega_int. apply nat_p_omega. exact LrN.
        + prove 0 <= n + - r.
          apply add_SNo_minus_Le2b n r 0 LnS LrS SNo_0.
          prove 0 + r <= n.
          rewrite add_SNo_0L r LrS.
          apply SNoLtLe.
          prove r < n.
          exact ordinal_In_SNoLt n Lno r Hr.
      - prove ordinal n. exact Lno.
      - prove n + - r < n.
        apply add_SNo_minus_Lt1b n r n LnS LrS LnS.
        prove n < n + r.
        rewrite <- add_SNo_0R n LnS at 1.
        prove n + 0 < n + r.
        exact add_SNo_Lt2 n 0 r LnS SNo_0 LrS H2.
    }
    witness (- q + - 1). apply andI.
    * { apply int_add_SNo.
        - apply int_minus_SNo_omega. exact Hq.
        - apply int_minus_SNo_omega. apply nat_p_omega. exact nat_1.
      }
    * { witness (n + - r). apply andI.
        - exact L4.
        - prove - m = (- q + - 1) * n + (n + - r).
          rewrite mul_SNo_distrR (- q) (- 1) n (SNo_minus_SNo q LqS) (SNo_minus_SNo 1 SNo_1) LnS.
          prove - m = ((- q) * n + (- 1) * n) + (n + - r).
          rewrite mul_SNo_minus_distrL 1 n SNo_1 LnS.
          rewrite mul_SNo_minus_distrL q n LqS LnS.
          prove - m = (- q * n + - 1 * n) + (n + - r).
          rewrite mul_SNo_oneL n LnS.
          prove - m = (- q * n + - n) + (n + - r).
          rewrite <- add_SNo_assoc (- q * n) (- n) (n + - r) (SNo_minus_SNo (q * n) LqnS) (SNo_minus_SNo n LnS) (SNo_add_SNo n (- r) LnS (SNo_minus_SNo r LrS)).
          prove - m = - q * n + - n + n + - r.
          rewrite add_SNo_minus_L2 n (- r) LnS (SNo_minus_SNo r LrS).
          prove - m = - q * n + - r.
          rewrite <- minus_add_SNo_distr (q * n) r LqnS LrS.
          f_equal.
          exact L2.
      }
  + assume H2: 0 = r.
    witness (- q). apply andI.
    * prove - q :e int. apply int_minus_SNo_omega. exact Hq.
    * { witness 0. apply andI.
        - exact L0n.
        - prove - m = (- q) * n + 0.
          rewrite mul_SNo_minus_distrL q n LqS LnS.
          prove - m = - (q * n) + 0.
          rewrite L2.
          prove - (q * n + r) = - (q * n) + 0.
          rewrite <- H2.
          prove - (q * n + 0) = - (q * n) + 0.
          rewrite add_SNo_0R (q * n) LqnS.
          symmetry.
          exact add_SNo_0R (- q * n) (SNo_minus_SNo (q * n) LqnS).
      }
Qed.

Definition divides_int : set -> set -> prop := fun m n => m :e int /\ n :e int /\ exists k :e int, m * k = n.

Theorem divides_int_ref: forall n :e int, divides_int n n.
let n. assume Hn: n :e int.
prove n :e int /\ n :e int /\ exists k :e int, n * k = n.
apply and3I.
- exact Hn.
- exact Hn.
- witness 1. apply andI.
  + prove 1 :e int.
    apply Subq_omega_int.
    apply nat_p_omega.
    exact nat_1.
  + prove n * 1 = n.
    exact mul_SNo_oneR n (int_SNo n Hn).
Qed.

Theorem divides_int_0: forall n :e int, divides_int n 0.
let n. assume Hn: n :e int.
claim L0i: 0 :e int.
{ apply Subq_omega_int.
  apply nat_p_omega.
  exact nat_0.
}
prove n :e int /\ 0 :e int /\ exists k :e int, n * k = 0.
apply and3I.
- exact Hn.
- prove 0 :e int. exact L0i.
- witness 0. apply andI.
  + prove 0 :e int. exact L0i.
  + prove n * 0 = 0.
    exact mul_SNo_zeroR n (int_SNo n Hn).
Qed.

Theorem divides_int_add_SNo: forall m n k, divides_int m n -> divides_int m k -> divides_int m (n + k).
let m n k.
assume H1: divides_int m n.
assume H2: divides_int m k.
apply H1. assume H. apply H.
assume Hm: m :e int.
assume Hn: n :e int.
assume H. apply H.
let n'. assume H. apply H.
assume Hn': n' :e int.
assume H3: m * n' = n.
apply H2. assume H. apply H.
assume _.
assume Hk: k :e int.
assume H. apply H.
let k'. assume H. apply H.
assume Hk': k' :e int.
assume H4: m * k' = k.
prove m :e int /\ n + k :e int /\ exists l :e int, m * l = n + k.
apply and3I.
- exact Hm.
- apply int_add_SNo.
  + exact Hn.
  + exact Hk.
- witness n' + k'. apply andI.
  + prove n' + k' :e int.
    apply int_add_SNo.
    * exact Hn'.
    * exact Hk'.
  + prove m * (n' + k') = n + k.
    rewrite mul_SNo_distrL m n' k' (int_SNo m Hm) (int_SNo n' Hn') (int_SNo k' Hk').
    prove m * n' + m * k' = n + k.
    f_equal.
    * exact H3.
    * exact H4.
Qed.

Theorem divides_int_mul_SNo: forall m n m' n', divides_int m m' -> divides_int n n' -> divides_int (m * n) (m' * n').
let m n m' n'.
assume H1: divides_int m m'.
assume H2: divides_int n n'.
apply H1. assume H. apply H.
assume Hm: m :e int.
assume Hm': m' :e int.
assume H. apply H.
let k. assume H. apply H.
assume Hk: k :e int.
assume H3: m * k = m'.
apply H2. assume H. apply H.
assume Hn: n :e int.
assume Hn': n' :e int.
assume H. apply H.
let l. assume H. apply H.
assume Hl: l :e int.
assume H4: n * l = n'.
prove m * n :e int /\ m' * n' :e int /\ exists q :e int, (m * n) * q = m' * n'.
apply and3I.
- apply int_mul_SNo.
  + exact Hm.
  + exact Hn.
- apply int_mul_SNo.
  + exact Hm'.
  + exact Hn'.
- witness k * l. apply andI.
  + apply int_mul_SNo.
    * exact Hk.
    * exact Hl.
  + prove (m * n) * (k * l) = m' * n'.
    rewrite mul_SNo_com_4_inner_mid m n k l (int_SNo m Hm) (int_SNo n Hn) (int_SNo k Hk) (int_SNo l Hl).
    prove (m * k) * (n * l) = m' * n'.
    f_equal.
    * exact H3.
    * exact H4.
Qed.

Theorem divides_nat_divides_int: forall m n, divides_nat m n -> divides_int m n.
let m n.
assume H1: divides_nat m n.
apply H1. assume H. apply H.
assume Hm: m :e omega.
assume Hn: n :e omega.
assume H. apply H.
let k. assume H. apply H.
assume Hk: k :e omega.
assume H2: mul_nat m k = n.
prove m :e int /\ n :e int /\ exists k :e int, m * k = n.
apply and3I.
- apply Subq_omega_int. exact Hm.
- apply Subq_omega_int. exact Hn.
- witness k. apply andI.
  + apply Subq_omega_int. exact Hk.
  + prove m * k = n.
    rewrite <- mul_nat_mul_SNo m Hm k Hk.
    prove mul_nat m k = n.
    exact H2.
Qed.

Theorem divides_int_divides_nat: forall m n :e omega, divides_int m n -> divides_nat m n.
let m. assume Hm.
let n. assume Hn.
assume H. apply H.
assume _.
assume Hmn: exists k :e int, m * k = n.
prove m :e omega /\ n :e omega /\ exists k :e omega, mul_nat m k = n.
apply and3I.
- exact Hm.
- exact Hn.
- apply Hmn. let k. assume H. apply H.
  assume Hk: k :e int.
  assume H1: m * k = n.
  apply binunionE omega {- n|n :e omega} k Hk.
  + assume H2: k :e omega.
    witness k. apply andI.
    * exact H2.
    * prove mul_nat m k = n.
      rewrite mul_nat_mul_SNo m Hm k H2.
      exact H1.
  + assume H2: k :e {- n|n :e omega}.
    apply xm (n = 0).
    * { assume H3: n = 0.
        claim L0: 0 :e omega.
        { apply nat_p_omega. exact nat_0. }
        witness 0. apply andI.
        - exact L0.
        - rewrite mul_nat_mul_SNo m Hm 0 L0. rewrite H3.
          prove m * 0 = 0.
          rewrite <- mul_nat_mul_SNo m Hm 0 (nat_p_omega 0 nat_0).
          apply mul_nat_0R.
      }
    * { assume H3: n <> 0.
        prove False.
        apply ReplE_impred omega minus_SNo k H2.
        let j. assume Hj: j :e omega.
        prove k <> - j.
        assume H4: k = - j.
        claim L1: m * (- j) = n.
        { rewrite <- H4. exact H1. }
        claim L2: n = - (m * j).
        { symmetry. rewrite <- mul_minus_SNo_distrR m j (omega_SNo m Hm) (omega_SNo j Hj). exact L1. }
        apply H3.
        claim Lmj: m * j :e omega.
        { apply mul_SNo_In_omega.
          - exact Hm.
          - exact Hj.
        }
        prove n = 0.
        apply nonpos_nonneg_0 n Hn (m * j) Lmj L2.
        assume H _. exact H.
      }
Qed.

Theorem divides_int_minus_SNo: forall m n, divides_int m n -> divides_int m (- n).
let m n.
assume H1: divides_int m n.
apply H1. assume H. apply H.
assume Hm: m :e int.
assume Hn: n :e int.
assume H. apply H.
let k. assume H. apply H.
assume Hk: k :e int.
assume H2: m * k = n.
prove m :e int /\ - n :e int /\ exists k :e int, m * k = - n.
apply and3I.
- exact Hm.
- apply int_minus_SNo. exact Hn.
- witness - k.
  apply andI.
  + apply int_minus_SNo. exact Hk.
  + prove m * (- k) = - n.
    rewrite mul_SNo_minus_distrR m k (int_SNo m Hm) (int_SNo k Hk).
    prove - m * k = - n.
    f_equal.
    exact H2.
Qed.

Theorem divides_int_mul_SNo_L: forall m n, forall k :e int, divides_int m n -> divides_int m (n * k).
let m n k.
assume Hk: k :e int.
assume H1: divides_int m n.
apply H1. assume H. apply H.
assume Hm: m :e int.
assume Hn: n :e int.
assume H. apply H.
let l. assume H. apply H.
assume Hl: l :e int.
assume H2: m * l = n.
prove m :e int /\ n * k :e int /\ exists l :e int, m * l = n * k.
apply and3I.
- exact Hm.
- apply int_mul_SNo.
  + exact Hn.
  + exact Hk.
- prove exists l :e int, m * l = n * k.
  witness l * k. apply andI.
  + prove l * k :e int.
    apply int_mul_SNo.
    * exact Hl.
    * exact Hk.
  + prove m * (l * k) = n * k.
    rewrite mul_SNo_assoc m l k (int_SNo m Hm) (int_SNo l Hl) (int_SNo k Hk).
    prove (m * l) * k = n * k.
    f_equal.
    exact H2.
Qed.

Theorem divides_int_mul_SNo_R: forall m n, forall k :e int, divides_int m n -> divides_int m (k * n).
let m n k.
assume Hk: k :e int.
assume H1: divides_int m n.
apply H1. assume H. apply H.
assume Hm: m :e int.
assume Hn: n :e int.
assume _.
rewrite mul_SNo_com k n (int_SNo k Hk) (int_SNo n Hn).
prove divides_int m (n * k).
exact divides_int_mul_SNo_L m n k Hk H1.
Qed.

Theorem divides_int_1: forall n :e int, divides_int 1 n.
let n. assume Hn: n :e int.
prove 1 :e int /\ n :e int /\ exists k :e int, 1 * k = n.
apply and3I.
- apply Subq_omega_int. apply nat_p_omega. exact nat_1.
- exact Hn.
- witness n. apply andI.
  + exact Hn.
  + prove 1 * n = n.
    exact mul_SNo_oneL n (int_SNo n Hn).
Qed.

Theorem divides_int_pos_Le: forall m n, divides_int m n -> 0 < n -> m <= n.
let m n. assume H1 H2.
apply H1. assume H _. apply H.
assume HmZ: m :e int.
assume HnZ: n :e int.
claim LnS: SNo n.
{ apply int_SNo. exact HnZ. }
claim L1: forall m :e int, divides_int m n -> m <= n.
{ apply int_SNo_cases.
  - let m. assume Hm: m :e omega.
    assume H3: divides_int m n.
    apply H3. assume _.
    assume H. apply H.
    let k. assume H. apply H.
    assume Hk: k :e int.
    assume H4: m * k = n.
    prove m <= n.
    claim LmS: SNo m.
    { apply omega_SNo. exact Hm. }
    claim LkS: SNo k.
    { apply int_SNo. exact Hk. }
    prove m <= n.
    rewrite <- H4.
    prove m <= m * k.
    rewrite <- mul_SNo_oneR m LmS at 1.
    prove m * 1 <= m * k.
    claim L0m: 0 <= m.
    { apply omega_nonneg. exact Hm. }
    apply nonneg_mul_SNo_Le m 1 k LmS.
    + prove 0 <= m. exact L0m.
    + exact SNo_1.
    + prove SNo k. exact LkS.
    + prove 1 <= k.
      apply SNoLtLe_or k 1 LkS SNo_1.
      * assume H5: k < 1. prove False.
        claim Lk0: k <= 0.
        { apply SNoLtLe_or 0 k SNo_0 LkS.
          - assume H6: 0 < k. prove False.
            claim LkN: nat_p k.
            { apply nonneg_int_nat_p k Hk. apply SNoLtLe. exact H6. }
            apply SNoLt_irref k.
            prove k < k.
            apply SNoLtLe_tra k 1 k LkS SNo_1 LkS H5.
            prove 1 <= k.
            apply ordinal_Subq_SNoLe 1 k (ordinal_ordsucc 0 ordinal_Empty) (nat_p_ordinal k LkN).
            prove 1 c= k.
            apply ordinal_ordsucc_In_Subq k (nat_p_ordinal k LkN) 0.
            prove 0 :e k.
            apply ordinal_SNoLt_In 0 k ordinal_Empty (nat_p_ordinal k LkN).
            prove 0 < k.
            exact H6.
          - assume H6: k <= 0. exact H6.
        }
        claim Lmk0: m * k <= 0.
        { rewrite mul_SNo_com m k LmS LkS.
          apply mul_SNo_nonpos_nonneg k m LkS LmS.
          - prove k <= 0. exact Lk0.
          - prove 0 <= m. exact L0m.
        }
        apply SNoLt_irref n.
        prove n < n.
        rewrite <- H4 at 1.
        prove m * k < n.
        exact SNoLeLt_tra (m * k) 0 n (SNo_mul_SNo m k LmS LkS) SNo_0 LnS Lmk0 H2.
      * assume H5: 1 <= k. exact H5.
  - let m. assume Hm: m :e omega.
    assume H3: divides_int (- m) n.
    claim LmS: SNo m.
    { apply omega_SNo. exact Hm. }
    prove - m <= n.
    apply SNoLe_tra (- m) 0 n (SNo_minus_SNo m LmS) SNo_0 LnS.
    + prove - m <= 0.
      rewrite <- minus_SNo_0.
      apply minus_SNo_Le_contra 0 m SNo_0 LmS.
      prove 0 <= m.
      apply omega_nonneg. exact Hm.
    + prove 0 <= n.
      apply SNoLtLe.
      exact H2.
}
exact L1 m HmZ H1.
Qed.

Definition gcd_reln : set -> set -> set -> prop := fun m n d => divides_int d m /\ divides_int d n /\ forall d', divides_int d' m -> divides_int d' n -> d' <= d.

Theorem gcd_reln_uniq: forall a b c d, gcd_reln a b c -> gcd_reln a b d -> c = d.
let a b c d.
assume H. apply H. assume H. apply H.
assume Hca: divides_int c a.
assume Hcb: divides_int c b.
assume Hcg: forall d', divides_int d' a -> divides_int d' b -> d' <= c.
assume H. apply H. assume H. apply H.
assume Hda: divides_int d a.
assume Hdb: divides_int d b.
assume Hdg: forall d', divides_int d' a -> divides_int d' b -> d' <= d.
apply Hca. assume H _. apply H.
assume Hc: c :e int.
assume _.
apply Hda. assume H _. apply H.
assume Hd: d :e int.
assume _.
apply SNoLe_antisym c d (int_SNo c Hc) (int_SNo d Hd).
- prove c <= d.
  apply Hdg.
  + prove divides_int c a. exact Hca.
  + prove divides_int c b. exact Hcb.
- prove d <= c.
  apply Hcg.
  + prove divides_int d a. exact Hda.
  + prove divides_int d b. exact Hdb.
Qed.

Definition int_lin_comb : set -> set -> set -> prop := fun a b c => a :e int /\ b :e int /\ c :e int /\ exists m n :e int, m * a + n * b = c.

Theorem int_lin_comb_I: forall a b c :e int, (exists m n :e int, m * a + n * b = c) -> int_lin_comb a b c.
let a. assume Ha. let b. assume Hb. let c. assume Hc.
assume H1.
prove a :e int /\ b :e int /\ c :e int /\ exists m n :e int, m * a + n * b = c.
apply and4I.
- exact Ha.
- exact Hb.
- exact Hc.
- exact H1.
Qed.

Theorem int_lin_comb_E: forall a b c, int_lin_comb a b c ->
  forall p:prop,
       (a :e int -> b :e int -> c :e int -> forall m n :e int, m * a + n * b = c -> p)
    -> p.
let a b c. assume H. let p. assume Hp.
apply H. assume H. apply H. assume H. apply H.
assume Ha Hb Hc H.
apply H.
let m. assume H. apply H.
assume Hm. assume H. apply H.
let n. assume H. apply H.
assume Hn.
assume H1: m * a + n * b = c.
exact Hp Ha Hb Hc m Hm n Hn H1.
Qed.

Theorem int_lin_comb_E1: forall a b c, int_lin_comb a b c -> a :e int.
let a b c. assume H. apply int_lin_comb_E a b c H.
assume Ha _ _. let m. assume _. let n. assume _ _.
exact Ha.
Qed.

Theorem int_lin_comb_E2: forall a b c, int_lin_comb a b c -> b :e int.
let a b c. assume H. apply int_lin_comb_E a b c H.
assume _ Hb _. let m. assume _. let n. assume _ _.
exact Hb.
Qed.

Theorem int_lin_comb_E3: forall a b c, int_lin_comb a b c -> c :e int.
let a b c. assume H. apply int_lin_comb_E a b c H.
assume _ _ Hc. let m. assume _. let n. assume _ _.
exact Hc.
Qed.

Theorem int_lin_comb_E4: forall a b c, int_lin_comb a b c ->
  forall p:prop,
       (forall m n :e int, m * a + n * b = c -> p)
    -> p.
let a b c. assume H. let p. assume Hp. apply int_lin_comb_E a b c H.
assume _ _ _. let m. assume Hm. let n. assume Hn H1.
exact Hp m Hm n Hn H1.
Qed.

Theorem least_pos_int_lin_comb_ex: forall a b :e int, ~(a = 0 /\ b = 0) -> exists c, int_lin_comb a b c /\ 0 < c /\ forall c', int_lin_comb a b c' -> 0 < c' -> c <= c'.
let a. assume Ha. let b. assume Hb.
assume H1: ~(a = 0 /\ b = 0).
claim LaS: SNo a.
{ exact int_SNo a Ha. }
claim LbS: SNo b.
{ exact int_SNo b Hb. }
set p : set -> prop := fun c => int_lin_comb a b c /\ 0 < c.
claim L1: exists c, ordinal c /\ p c.
{ apply int_3_cases a Ha.
  - let a'. assume Ha': a' :e omega.
    assume Haa': a = - ordsucc a'.
    claim La'N: nat_p a'.
    { apply omega_nat_p. exact Ha'. }
    claim La': ordinal a'.
    { apply nat_p_ordinal. exact La'N. }
    claim LSa'S: SNo (ordsucc a').
    { apply nat_p_SNo. apply nat_ordsucc. exact La'N. }
    witness ordsucc a'.
    apply andI.
    + prove ordinal (ordsucc a'). apply ordinal_ordsucc. exact La'.
    + prove int_lin_comb a b (ordsucc a') /\ 0 < ordsucc a'.
      apply andI.
      * { prove int_lin_comb a b (ordsucc a').
          apply int_lin_comb_I.
          - exact Ha.
          - exact Hb.
          - prove ordsucc a' :e int.
            apply Subq_omega_int.
            apply omega_ordsucc.
            exact Ha'.
          - prove exists m n :e int, m * a + n * b = ordsucc a'.
            witness (- 1). apply andI.
            + prove - 1 :e int. apply int_minus_SNo_omega. apply nat_p_omega. exact nat_1.
            + witness 0. apply andI.
              * prove 0 :e int. apply Subq_omega_int. apply nat_p_omega. exact nat_0.
              * prove (- 1) * a + 0 * b = ordsucc a'.
                rewrite mul_SNo_zeroL b LbS.
                prove (- 1) * a + 0 = ordsucc a'.
                rewrite mul_SNo_minus_distrL 1 a SNo_1 LaS.
                prove - 1 * a + 0 = ordsucc a'.
                rewrite mul_SNo_oneL a LaS.
                prove - a + 0 = ordsucc a'.
                rewrite Haa'.
                prove - - ordsucc a' + 0 = ordsucc a'.
                rewrite minus_SNo_invol (ordsucc a') LSa'S.
                exact add_SNo_0R (ordsucc a') LSa'S.
        }
      * prove 0 < ordsucc a'.
        exact ordinal_ordsucc_pos a' La'.
  - assume H2: a = 0.
    apply int_3_cases b Hb.
    + let b'. assume Hb': b' :e omega.
      assume Hbb': b = - ordsucc b'.
      claim Lb'N: nat_p b'.
      { apply omega_nat_p. exact Hb'. }
      claim Lb': ordinal b'.
      { apply nat_p_ordinal. exact Lb'N. }
      claim LSb'S: SNo (ordsucc b').
      { apply nat_p_SNo. apply nat_ordsucc. exact Lb'N. }
      witness ordsucc b'.
      apply andI.
      * prove ordinal (ordsucc b'). apply ordinal_ordsucc. exact Lb'.
      * { prove int_lin_comb a b (ordsucc b') /\ 0 < ordsucc b'.
          apply andI.
          - prove int_lin_comb a b (ordsucc b').
            apply int_lin_comb_I.
            + exact Ha.
            + exact Hb.
            + prove ordsucc b' :e int.
              apply Subq_omega_int.
              apply omega_ordsucc.
              exact Hb'.
            + prove exists m n :e int, m * a + n * b = ordsucc b'.
              witness 0. apply andI.
              * prove 0 :e int. apply Subq_omega_int. apply nat_p_omega. exact nat_0.
              * { witness (- 1). apply andI.
                  - prove - 1 :e int. apply int_minus_SNo_omega. apply nat_p_omega. exact nat_1.
                  - prove 0 * a + (- 1) * b = ordsucc b'.
                    rewrite mul_SNo_zeroL a LaS.
                    prove 0 + (- 1) * b = ordsucc b'.
                    rewrite mul_SNo_minus_distrL 1 b SNo_1 LbS.
                    prove 0 + - 1 * b = ordsucc b'.
                    rewrite mul_SNo_oneL b LbS.
                    prove 0 + - b = ordsucc b'.
                    rewrite Hbb'.
                    prove 0 + - - ordsucc b' = ordsucc b'.
                    rewrite minus_SNo_invol (ordsucc b') LSb'S.
                    exact add_SNo_0L (ordsucc b') LSb'S.
                }
          - prove 0 < ordsucc b'.
            exact ordinal_ordsucc_pos b' Lb'.
        }
    + assume H3: b = 0. prove False. apply H1. apply andI.
      * exact H2.
      * exact H3.
    + let b'. assume Hb': b' :e omega.
      assume Hbb': b = ordsucc b'.
      claim Lb': ordinal b'.
      { apply nat_p_ordinal. apply omega_nat_p. exact Hb'. }
      witness ordsucc b'.
      apply andI.
      * prove ordinal (ordsucc b'). apply ordinal_ordsucc. exact Lb'.
      * { prove int_lin_comb a b (ordsucc b') /\ 0 < ordsucc b'.
          apply andI.
          - prove int_lin_comb a b (ordsucc b').
            apply int_lin_comb_I.
            + exact Ha.
            + exact Hb.
            + prove ordsucc b' :e int.
              apply Subq_omega_int.
              apply omega_ordsucc.
              exact Hb'.
            + prove exists m n :e int, m * a + n * b = ordsucc b'.
              witness 0. apply andI.
              * prove 0 :e int. apply Subq_omega_int. apply nat_p_omega. exact nat_0.
              * { witness 1. apply andI.
                  - prove 1 :e int. apply Subq_omega_int. apply nat_p_omega. exact nat_1.
                  - prove 0 * a + 1 * b = ordsucc b'.
                    rewrite <- Hbb'.
                    rewrite mul_SNo_zeroL a LaS.
                    rewrite mul_SNo_oneL b LbS.
                    prove 0 + b = b.
                    exact add_SNo_0L b LbS.
                }
          - prove 0 < ordsucc b'.
            exact ordinal_ordsucc_pos b' Lb'.
        }
  - let a'. assume Ha': a' :e omega.
    assume Haa': a = ordsucc a'.
    claim La': ordinal a'.
    { apply nat_p_ordinal. apply omega_nat_p. exact Ha'. }
    witness ordsucc a'.
    apply andI.
    + prove ordinal (ordsucc a'). apply ordinal_ordsucc. exact La'.
    + prove int_lin_comb a b (ordsucc a') /\ 0 < ordsucc a'.
      apply andI.
      * { prove int_lin_comb a b (ordsucc a').
          apply int_lin_comb_I.
          - exact Ha.
          - exact Hb.
          - prove ordsucc a' :e int.
            apply Subq_omega_int.
            apply omega_ordsucc.
            exact Ha'.
          - prove exists m n :e int, m * a + n * b = ordsucc a'.
            witness 1. apply andI.
            + prove 1 :e int. apply Subq_omega_int. apply nat_p_omega. exact nat_1.
            + witness 0. apply andI.
              * prove 0 :e int. apply Subq_omega_int. apply nat_p_omega. exact nat_0.
              * prove 1 * a + 0 * b = ordsucc a'.
                rewrite <- Haa'.
                rewrite mul_SNo_zeroL b LbS.
                rewrite mul_SNo_oneL a LaS.
                prove a + 0 = a.
                exact add_SNo_0R a LaS.
        }
      * prove 0 < ordsucc a'.
        exact ordinal_ordsucc_pos a' La'.
}
claim L2: exists c, ordinal c /\ p c /\ forall beta :e c, ~p beta.
{ exact least_ordinal_ex p L1. }
apply L2.
let c. assume H. apply H. assume H. apply H.
assume Hco: ordinal c.
assume Hc1: int_lin_comb a b c /\ 0 < c.
assume Hc2: forall beta :e c, ~p beta.
claim LcS: SNo c.
{ exact ordinal_SNo c Hco. }
witness c.
apply andI.
- exact Hc1.
- let c'.
  assume Hc'1: int_lin_comb a b c'.
  assume Hc'2: 0 < c'.
  prove c <= c'.
  claim Lc'Z: c' :e int.
  { exact int_lin_comb_E3 a b c' Hc'1. }
  claim Lc'S: SNo c'.
  { exact int_SNo c' Lc'Z. }
  apply SNoLtLe_or c' c Lc'S LcS.
  + assume H2: c' < c. prove False.
    claim Lc'N: nat_p c'.
    { apply nonneg_int_nat_p c' Lc'Z.
      prove 0 <= c'.
      apply SNoLtLe.
      prove 0 < c'.
      exact Hc'2.
    }
    claim L3: c' :e c.
    { exact ordinal_SNoLt_In c' c (nat_p_ordinal c' Lc'N) Hco H2. }
    apply Hc2 c' L3.
    prove p c'.
    prove int_lin_comb a b c' /\ 0 < c'.
    apply andI.
    * exact Hc'1.
    * exact Hc'2.
  + assume H2: c <= c'. exact H2.
Qed.

Theorem int_lin_comb_sym: forall a b d,
     int_lin_comb a b d
  -> int_lin_comb b a d.
let a b d.
assume H1. apply int_lin_comb_E a b d H1.
assume Ha Hb Hd.
let m. assume Hm. let n. assume Hn.
assume H2: m * a + n * b = d.
apply int_lin_comb_I b Hb a Ha d Hd.
prove exists n m :e int, n * b + m * a = d.
witness n. apply andI.
- exact Hn.
- witness m. apply andI.
  + exact Hm.
  + prove n * b + m * a = d.
    rewrite add_SNo_com (n * b) (m * a)
                        (SNo_mul_SNo n b (int_SNo n Hn) (int_SNo b Hb))
                        (SNo_mul_SNo m a (int_SNo m Hm) (int_SNo a Ha)).
    exact H2.
Qed.
  
Theorem least_pos_int_lin_comb_divides_int: forall a b d,
     int_lin_comb a b d
  -> 0 < d
  -> (forall c, int_lin_comb a b c -> 0 < c -> d <= c)
  -> divides_int d a.
let a b d.
assume Hd1: int_lin_comb a b d.
assume Hd2: 0 < d.
assume Hd3: forall c, int_lin_comb a b c -> 0 < c -> d <= c.
apply int_lin_comb_E a b d Hd1.
assume Ha: a :e int.
assume Hb: b :e int.
assume HdZ: d :e int.
let m. assume Hm: m :e int.
let n. assume Hn: n :e int.
assume H2: m * a + n * b = d.
claim LaS: SNo a.
{ exact int_SNo a Ha. }
claim LbS: SNo b.
{ exact int_SNo b Hb. }
claim LmS: SNo m.
{ exact int_SNo m Hm. }
claim LnS: SNo n.
{ exact int_SNo n Hn. }
claim LdN: nat_p d.
{ apply nonneg_int_nat_p d HdZ.
  prove 0 <= d.
  apply SNoLtLe.
  exact Hd2.
}
claim Ld1: d :e omega :\: {0}.
{ apply setminusI.
  - prove d :e omega.
    apply nat_p_omega.
    exact LdN.
  - assume H3: d :e {0}.
    apply SNoLt_irref 0.
    prove 0 < 0.
    rewrite <- SingE 0 d H3 at 2.
    exact Hd2.
}
claim LdS: SNo d.
{ exact nat_p_SNo d LdN. }
apply quotient_remainder_int d Ld1 a Ha.
let q. assume H. apply H.
assume Hq: q :e int. assume H. apply H.
let r. assume H. apply H.
assume Hr: r :e d.
assume H1: a = q * d + r.
claim LqS: SNo q.
{ apply int_SNo. exact Hq. }
claim LmqS: SNo (- q).
{ apply SNo_minus_SNo q LqS. }
claim LrN: nat_p r.
{ exact nat_p_trans d LdN r Hr. }
claim Lrnn: 0 <= r.
{ apply omega_nonneg. apply nat_p_omega. exact LrN. }
claim Lrd: r < d.
{ apply ordinal_In_SNoLt d (nat_p_ordinal d LdN) r Hr. }
claim LqdS: SNo (q * d).
{ exact SNo_mul_SNo q d LqS LdS. }
claim LrS: SNo r.
{ exact nat_p_SNo r LrN. }
claim L1: r = (1 + - q * m) * a + (- q * n) * b.
{ transitivity a + - q * d,
               a + (- q) * (m * a + n * b).
  - prove r = a + - q * d.
    rewrite add_SNo_com a (- q * d) LaS (SNo_minus_SNo (q * d) LqdS).
    prove r = - q * d + a.
    rewrite H1.
    prove r = - q * d + q * d + r.
    symmetry.
    exact add_SNo_minus_L2 (q * d) r LqdS LrS.
  - prove a + - q * d = a + (- q) * (m * a + n * b).
    f_equal.
    prove - q * d = (- q) * (m * a + n * b).
    rewrite <- mul_SNo_minus_distrL q d LqS LdS.
    prove (- q) * d = (- q) * (m * a + n * b).
    f_equal.
    prove d = m * a + n * b.
    symmetry.
    exact H2.
  - prove a + (- q) * (m * a + n * b) = (1 + - q * m) * a + (- q * n) * b.
    rewrite mul_SNo_distrL (- q) (m * a) (n * b)
                           LmqS
                           (SNo_mul_SNo m a LmS LaS)
                           (SNo_mul_SNo n b LnS LbS).
    prove a + ((- q) * (m * a)) + ((- q) * (n * b)) = (1 + - q * m) * a + (- q * n) * b.
    rewrite add_SNo_assoc a ((- q) * (m * a)) ((- q) * (n * b))
                          LaS
                          (SNo_mul_SNo (- q) (m * a) LmqS (SNo_mul_SNo m a LmS LaS))
                          (SNo_mul_SNo (- q) (n * b) LmqS (SNo_mul_SNo n b LnS LbS)).
    prove (a + (- q) * (m * a)) + (- q) * (n * b) = (1 + - q * m) * a + (- q * n) * b.
    f_equal.
    + prove a + (- q) * (m * a) = (1 + - q * m) * a.
      rewrite <- mul_SNo_minus_distrL q m LqS LmS.
      prove a + (- q) * (m * a) = (1 + (- q) * m) * a.
      rewrite mul_SNo_distrR 1 ((- q) * m) a SNo_1 (SNo_mul_SNo (- q) m LmqS LmS) LaS.
      prove a + (- q) * (m * a) = 1 * a + ((- q) * m) * a.
      f_equal.
      * prove a = 1 * a. symmetry. exact mul_SNo_oneL a LaS.
      * prove (- q) * (m * a) = ((- q) * m) * a.
        exact mul_SNo_assoc (- q) m a LmqS LmS LaS.
    + prove (- q) * (n * b) = (- q * n) * b.
      rewrite <- mul_SNo_minus_distrL q n LqS LnS.
      exact mul_SNo_assoc (- q) n b LmqS LnS LbS.
}
claim L2: int_lin_comb a b r.
{ prove a :e int /\ b :e int /\ r :e int /\ exists m n :e int, m * a + n * b = r.
  apply and4I.
  - exact Ha.
  - exact Hb.
  - apply Subq_omega_int. apply nat_p_omega. exact LrN.
  - prove exists m n :e int, m * a + n * b = r.
    witness (1 + - q * m). apply andI.
    + prove 1 + - q * m :e int.
      apply int_add_SNo.
      * apply Subq_omega_int. apply nat_p_omega. exact nat_1.
      * { apply int_minus_SNo. apply int_mul_SNo.
          - exact Hq.
          - exact Hm.
        }
    + witness (- q * n). apply andI.
      * { prove - q * n :e int.
          apply int_minus_SNo. apply int_mul_SNo.
          - exact Hq.
          - exact Hn.
        }
      * symmetry. exact L1.
}
claim L3: r = 0.
{ apply SNoLeE 0 r SNo_0 LrS Lrnn.
  - assume H2: 0 < r. prove False.
    apply SNoLt_irref r.
    prove r < r.
    apply SNoLtLe_tra r d r LrS LdS LrS Lrd.
    prove d <= r.
    apply Hd3.
    + prove int_lin_comb a b r. exact L2.
    + prove 0 < r. exact H2.
  - assume H2: 0 = r. symmetry. exact H2.
}
prove divides_int d a.
prove d :e int /\ a :e int /\ exists k :e int, d * k = a.
apply and3I.
- exact HdZ.
- exact Ha.
- witness q. apply andI.
  + exact Hq.
  + prove d * q = a.
    rewrite H1.
    prove d * q = q * d + r.
    rewrite L3.
    rewrite add_SNo_0R (q * d) LqdS.
    prove d * q = q * d.
    exact mul_SNo_com d q LdS LqS.
Qed.

Theorem least_pos_int_lin_comb_gcd: forall a b d,
     int_lin_comb a b d
  -> 0 < d
  -> (forall c, int_lin_comb a b c -> 0 < c -> d <= c)
  -> gcd_reln a b d.
let a b d.
assume Hd1: int_lin_comb a b d.
assume Hd2: 0 < d.
assume Hd3: forall c, int_lin_comb a b c -> 0 < c -> d <= c.
apply int_lin_comb_E a b d Hd1.
assume Ha: a :e int.
assume Hb: b :e int.
assume HdZ: d :e int.
let m. assume Hm: m :e int.
let n. assume Hn: n :e int.
assume H2: m * a + n * b = d.
claim LdN: nat_p d.
{ apply nonneg_int_nat_p d HdZ.
  prove 0 <= d.
  apply SNoLtLe.
  exact Hd2.
}
claim Ld1: d :e omega :\: {0}.
{ apply setminusI.
  - prove d :e omega.
    apply nat_p_omega.
    exact LdN.
  - assume H3: d :e {0}.
    apply SNoLt_irref 0.
    prove 0 < 0.
    rewrite <- SingE 0 d H3 at 2.
    exact Hd2.
}
claim LdS: SNo d.
{ exact nat_p_SNo d LdN. }
claim Lda: divides_int d a.
{ apply least_pos_int_lin_comb_divides_int a b d.
  - exact Hd1.
  - exact Hd2.
  - exact Hd3.
}
claim Ldb: divides_int d b.
{ apply least_pos_int_lin_comb_divides_int b a d.
  - apply int_lin_comb_sym. exact Hd1.
  - exact Hd2.
  - let c.
    assume H2: int_lin_comb b a c.
    assume H3: 0 < c.
    prove d <= c.
    apply Hd3 c.
    + prove int_lin_comb a b c.
      apply int_lin_comb_sym. exact H2.
    + exact H3.
}
prove divides_int d a /\ divides_int d b /\ forall d', divides_int d' a -> divides_int d' b -> d' <= d.
apply and3I.
- exact Lda.
- exact Ldb.
- let d'.
  assume Hd'a: divides_int d' a.
  assume Hd'b: divides_int d' b.
  prove d' <= d.
  claim Ld'd: divides_int d' d.
  { rewrite <- H2.
    prove divides_int d' (m * a + n * b).
    apply divides_int_add_SNo.
    - prove divides_int d' (m * a).
      apply divides_int_mul_SNo_R.
      + exact Hm.
      + exact Hd'a.
    - prove divides_int d' (n * b).
      apply divides_int_mul_SNo_R.
      + exact Hn.
      + exact Hd'b.
  }
  apply divides_int_pos_Le.
  + exact Ld'd.
  + exact Hd2.
Qed.

Theorem BezoutThm: forall a b :e int, ~(a = 0 /\ b = 0) ->
  forall d, gcd_reln a b d <-> int_lin_comb a b d /\ 0 < d /\ forall d', int_lin_comb a b d' -> 0 < d' -> d <= d'.
let a. assume Ha. let b. assume Hb.
assume H1: ~(a = 0 /\ b = 0).
let d.
apply iffI.
- assume H3: gcd_reln a b d.
  prove int_lin_comb a b d
     /\ 0 < d
     /\ forall d', int_lin_comb a b d' -> 0 < d' -> d <= d'.
  apply least_pos_int_lin_comb_ex a Ha b Hb H1.
  let d'.
  assume Hd': int_lin_comb a b d' /\ 0 < d' /\ forall c, int_lin_comb a b c -> 0 < c -> d' <= c.
  apply Hd'. assume H. apply H.
  assume Hd'1: int_lin_comb a b d'.
  assume Hd'2: 0 < d'.
  assume Hd'3: forall c, int_lin_comb a b c -> 0 < c -> d' <= c.
  claim Ld'g: gcd_reln a b d'.
  { exact least_pos_int_lin_comb_gcd a b d' Hd'1 Hd'2 Hd'3. }
  claim Ldd': d = d'.
  { exact gcd_reln_uniq a b d d' H3 Ld'g. }
  rewrite Ldd'.
  exact Hd'.
- assume H. apply H. assume H. apply H.
  assume Hd1: int_lin_comb a b d.
  assume Hd2: 0 < d.
  assume Hd3: forall d', int_lin_comb a b d' -> 0 < d' -> d <= d'.
  prove gcd_reln a b d.
  exact least_pos_int_lin_comb_gcd a b d Hd1 Hd2 Hd3.
Qed.

Theorem gcd_id: forall m :e omega :\: {0}, gcd_reln m m m.
let m. assume Hm.
apply setminusE omega {0} m Hm.
assume Hm1: m :e omega.
assume Hm2: m /:e {0}.
claim LmN: nat_p m.
{ apply omega_nat_p. exact Hm1. }
claim Lmo: ordinal m.
{ apply nat_p_ordinal. exact LmN. }
claim LmZ: m :e int.
{ apply Subq_omega_int. exact Hm1. }
claim LmS: SNo m.
{ exact int_SNo m LmZ. }
claim Lmpos: 0 < m.
{ apply SNoLeE 0 m SNo_0 LmS (omega_nonneg m Hm1).
  - assume H1: 0 < m. exact H1.
  - assume H1: 0 = m. prove False.
    apply Hm2.
    prove m :e {0}.
    rewrite <- H1.
    apply SingI.
}
prove divides_int m m /\ divides_int m m /\ forall d', divides_int d' m -> divides_int d' m -> d' <= m.
apply and3I.
- prove divides_int m m.
  apply divides_int_ref.
  prove m :e int.
  exact LmZ.
- prove divides_int m m.
  apply divides_int_ref.
  exact LmZ.
- let d'.
  assume H1: divides_int d' m.
  assume _.
  prove d' <= m.
  apply H1. assume H. apply H.
  assume Hd': d' :e int.
  assume Hm: m :e int.
  assume H. apply H.
  let k. assume H. apply H.
  assume Hk: k :e int.
  assume Hd'km: d' * k = m.
  prove d' <= m.
  claim Ld'S: SNo d'.
  { apply int_SNo. exact Hd'. }
  claim LkS: SNo k.
  { apply int_SNo. exact Hk. }
  apply SNoLtLe_or 0 d' SNo_0 Ld'S.
  + assume H1: 0 < d'.
    apply SNoLtLe_or k 0 LkS SNo_0.
    * { assume H2: k < 0. prove False.
        apply SNoLt_irref m.
        prove m < m.
        apply SNoLt_tra m 0 m LmS SNo_0 LmS.
        - prove m < 0.
          rewrite <- Hd'km.
          exact mul_SNo_pos_neg d' k Ld'S LkS H1 H2.
        - exact Lmpos.
      }
    * { assume H2: 0 <= k.
        claim LkN: nat_p k.
        { exact nonneg_int_nat_p k Hk H2. }
        claim Ld'N: nat_p d'.
        { apply nonneg_int_nat_p d' Hd'.
          prove 0 <= d'.
          apply SNoLtLe.
          exact H1.
        }
        apply mul_nat_0_or_Subq d' Ld'N k LkN.
        - assume H3: k = 0. prove False.
          apply SNoLt_irref m.
          prove m < m.
          rewrite <- Hd'km at 1.
          rewrite H3.
          prove d' * 0 < m.
          rewrite mul_SNo_zeroR d' Ld'S.
          prove 0 < m.
          exact Lmpos.
        - assume H3: d' c= mul_nat d' k.
          prove d' <= m.
          rewrite <- Hd'km.
          rewrite <- mul_nat_mul_SNo d' (nat_p_omega d' Ld'N) k (nat_p_omega k LkN).
          prove d' <= mul_nat d' k.
          apply ordinal_Subq_SNoLe.
          + prove ordinal d'. apply nat_p_ordinal. exact Ld'N.
          + prove ordinal (mul_nat d' k).
            apply nat_p_ordinal.
            apply mul_nat_p.
            * exact Ld'N.
            * exact LkN.
          + prove d' c= mul_nat d' k. exact H3.
      }
  + assume H1: d' <= 0.
    apply SNoLe_tra d' 0 m Ld'S SNo_0 LmS H1.
    prove 0 <= m.
    apply SNoLtLe.
    exact Lmpos.
Qed.

Theorem gcd_0: forall m :e omega :\: {0}, gcd_reln 0 m m.
let m. assume Hm.
apply setminusE omega {0} m Hm.
assume Hm1: m :e omega.
assume Hm2: m /:e {0}.
claim LmZ: m :e int.
{ apply Subq_omega_int. exact Hm1. }
apply gcd_id m Hm. assume H. apply H.
assume _.
assume H1: divides_int m m.
assume H2: forall d', divides_int d' m -> divides_int d' m -> d' <= m.
prove divides_int m 0 /\ divides_int m m /\ forall d', divides_int d' 0 -> divides_int d' m -> d' <= m.
apply and3I.
- prove divides_int m 0.
  apply divides_int_0.
  prove m :e int.
  exact LmZ.
- prove divides_int m m. exact H1.
- let d'.
  assume H3: divides_int d' 0.
  assume H4: divides_int d' m.
  prove d' <= m.
  apply H2.
  + exact H4.
  + exact H4.
Qed.

Theorem gcd_sym: forall m n d, gcd_reln m n d -> gcd_reln n m d.
let m n d.
assume H. apply H. assume H. apply H.
assume H1: divides_int d m.
assume H2: divides_int d n.
assume H3: forall d', divides_int d' m -> divides_int d' n -> d' <= d.
prove divides_int d n /\ divides_int d m /\ forall d', divides_int d' n -> divides_int d' m -> d' <= d.
apply and3I.
- exact H2.
- exact H1.
- let d'. assume H4 H5. apply H3.
  + exact H5.
  + exact H4.
Qed.

Theorem gcd_minus: forall m n d, gcd_reln m n d -> gcd_reln m (- n) d.
let m n d.
assume H. apply H. assume H. apply H.
assume H1: divides_int d m.
assume H2: divides_int d n.
assume H3: forall d', divides_int d' m -> divides_int d' n -> d' <= d.
prove divides_int d m /\ divides_int d (- n) /\ forall d', divides_int d' m -> divides_int d' (- n) -> d' <= d.
apply H2. assume H _. apply H. assume _.
assume Hn: n :e int.
apply and3I.
- exact H1.
- prove divides_int d (- n).
  apply divides_int_minus_SNo.
  exact H2.
- let d'. assume H4 H5. apply H3.
  + exact H4.
  + prove divides_int d' n.
    rewrite <- minus_SNo_invol n (int_SNo n Hn).
    prove divides_int d' (- - n).
    apply divides_int_minus_SNo.
    exact H5.
Qed.

Theorem euclidean_algorithm_prop_1: forall m n d, n :e int -> gcd_reln m (n + - m) d -> gcd_reln m n d.
let m n d.
assume Hn: n :e int.
assume H1: gcd_reln m (n + - m) d.
apply H1. assume H. apply H.
assume H2: divides_int d m.
assume H3: divides_int d (n + - m).
assume H4: forall d', divides_int d' m -> divides_int d' (n + - m) -> d' <= d.
apply H2. assume H _. apply H. assume _.
assume Hm: m :e int.
claim LnS: SNo n.
{ exact int_SNo n Hn. }
claim LmS: SNo m.
{ exact int_SNo m Hm. }
prove divides_int d m /\ divides_int d n /\ forall d', divides_int d' m -> divides_int d' n -> d' <= d.
apply and3I.
- exact H2.
- prove divides_int d n.
  rewrite <- add_SNo_minus_R2' n m LnS LmS.
  prove divides_int d ((n + - m) + m).
  apply divides_int_add_SNo.
  + exact H3.
  + exact H2.
- let d'.
  assume H5: divides_int d' m.
  assume H6: divides_int d' n.
  prove d' <= d.
  apply H4.
  + exact H5.
  + prove divides_int d' (n + - m).
    apply divides_int_add_SNo.
    * exact H6.
    * apply divides_int_minus_SNo.
      exact H5.
Qed.

Theorem euclidean_algorithm:
     (forall m :e omega :\: {0}, gcd_reln m m m)
  /\ (forall m :e omega :\: {0}, gcd_reln 0 m m)
  /\ (forall m :e omega :\: {0}, gcd_reln m 0 m)
  /\ (forall m n :e omega, m < n
          -> forall d, gcd_reln m (n + - m) d
                    -> gcd_reln m n d)
  /\ (forall m n :e omega, n < m
          -> forall d, gcd_reln n m d
                    -> gcd_reln m n d)
  /\ (forall m :e omega, forall n :e int, n < 0
          -> forall d, gcd_reln m (- n) d
                    -> gcd_reln m n d)
  /\ (forall m n :e int, m < 0
          -> forall d, gcd_reln (- m) n d
                    -> gcd_reln m n d).
apply and7I.
- exact gcd_id.
- exact gcd_0.
- let m. assume Hm. apply gcd_sym. exact gcd_0 m Hm.
- let m. assume Hm. let n. assume Hn Hmn.
  let d.
  prove gcd_reln m (n + - m) d -> gcd_reln m n d.
  exact euclidean_algorithm_prop_1 m n d (Subq_omega_int n Hn).
- let m. assume Hm. let n. assume Hn Hnm.
  let d.
  prove gcd_reln n m d -> gcd_reln m n d.
  exact gcd_sym n m d.
- let m. assume Hm. let n. assume Hn Hnneg.
  let d.
  prove gcd_reln m (- n) d -> gcd_reln m n d.
  rewrite <- minus_SNo_invol n (int_SNo n Hn) at 2.
  prove gcd_reln m (- n) d -> gcd_reln m (- - n) d.
  exact gcd_minus m (- n) d.
- let m. assume Hm. let n. assume Hn Hmneg.
  let d.
  prove gcd_reln (- m) n d -> gcd_reln m n d.
  assume H1: gcd_reln (- m) n d.
  prove gcd_reln m n d.
  apply gcd_sym.
  prove gcd_reln n m d.
  rewrite <- minus_SNo_invol m (int_SNo m Hm).
  apply gcd_minus.
  apply gcd_sym.
  exact H1.
Qed.

Theorem Euclid_lemma: forall p, prime_nat p -> forall a b :e int, divides_int p (a * b) -> divides_int p a \/ divides_int p b.
let p. assume Hp.
let a. assume Ha.
let b. assume Hb.
apply Hp. assume H. apply H.
assume Hp1: p :e omega.
assume Hp2: 1 :e p.
assume Hp3: forall k :e omega, divides_nat k p -> k = 1 \/ k = p.
assume H1: divides_int p (a * b).
claim LaS: SNo a.
{ exact int_SNo a Ha. }
claim LbS: SNo b.
{ exact int_SNo b Hb. }
claim LpZ: p :e int.
{ apply Subq_omega_int. exact Hp1. }
apply xm (divides_int p a).
- assume H2: divides_int p a. apply orIL. exact H2.
- assume H2: ~divides_int p a. apply orIR.
  prove divides_int p b.
  claim L1: gcd_reln p a 1.
  { prove divides_int 1 p /\ divides_int 1 a /\ forall d, divides_int d p -> divides_int d a -> d <= 1.
    apply and3I.
    - exact divides_int_1 p LpZ.
    - exact divides_int_1 a Ha.
    - let d.
      assume Hdp: divides_int d p.
      assume Hda: divides_int d a.
      prove d <= 1.
      apply Hdp. assume H _. apply H.
      assume HdZ: d :e int.
      assume _.
      claim LdS: SNo d.
      { exact int_SNo d HdZ. }
      apply SNoLtLe_or d 0 LdS SNo_0.
      + assume H3: d < 0.
        prove d <= 1.
	apply SNoLtLe.
        prove d < 1.
        apply SNoLt_tra d 0 1 LdS SNo_0 SNo_1.
	* exact H3.
	* exact SNoLt_0_1.
      + assume H3: 0 <= d.
        claim LdN: d :e omega.
	{ apply nat_p_omega. exact nonneg_int_nat_p d HdZ H3. }
        claim Ldp: divides_nat d p.
        { apply divides_int_divides_nat.
          - prove d :e omega. exact LdN.
          - prove p :e omega. exact Hp1.
          - exact Hdp.
        }
	apply Hp3 d LdN Ldp.
	* assume H4: d = 1.
	  rewrite H4.
	  apply SNoLe_ref.
	* assume H4: d = p.
	  apply H2.
	  prove divides_int p a.
	  rewrite <- H4.
	  prove divides_int d a.
	  exact Hda.
  }
  claim L2: ~(p = 0 /\ a = 0).
  { assume H3. apply H3.
    assume H4: p = 0.
    assume _.
    apply In_no2cycle 0 1 In_0_1.
    prove 1 :e 0.
    rewrite <- H4 at 2.
    prove 1 :e p.
    exact Hp2.
  }
  apply BezoutThm p LpZ a Ha L2 1.
  assume HBezout1: gcd_reln p a 1 ->
        int_lin_comb p a 1
     /\ 0 < 1
     /\ forall d, int_lin_comb p a d -> 0 < d -> 1 <= d.
  assume _.
  apply HBezout1 L1. assume H. apply H.
  assume H3: int_lin_comb p a 1.
  assume _.
  assume H4: forall d, int_lin_comb p a d -> 0 < d -> 1 <= d.
  apply int_lin_comb_E4 p a 1 H3.
  let m. assume Hm: m :e int.
  let n. assume Hn: n :e int.
  assume H5: m * p + n * a = 1.
  claim LnS: SNo n.
  { exact int_SNo n Hn. }
  claim L3: b * m * p + b * n * a = b.
  { rewrite <- mul_SNo_distrL b (m * p) (n * a) LbS (SNo_mul_SNo m p (int_SNo m Hm) (int_SNo p LpZ)) (SNo_mul_SNo n a LnS LaS).
    prove b * (m * p + n * a) = b.
    rewrite H5.
    exact mul_SNo_oneR b LbS.
  }
  prove divides_int p b.
  rewrite <- L3.
  prove divides_int p (b * m * p + b * n * a).
  apply divides_int_add_SNo.
  + prove divides_int p (b * m * p).
    apply divides_int_mul_SNo_R p (m * p) b Hb.
    prove divides_int p (m * p).
    apply divides_int_mul_SNo_R p p m Hm.
    prove divides_int p p.
    exact divides_int_ref p LpZ.
  + prove divides_int p (b * n * a).
    rewrite <- mul_SNo_rotate_3_1 n a b LnS LaS LbS.
    prove divides_int p (n * a * b).
    apply divides_int_mul_SNo_R p (a * b) n Hn.
    prove divides_int p (a * b).
    exact H1.
Qed.

End BezoutAndGCD.

Section PrimeFactorization.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
Infix <= 490 := SNoLe.

Theorem prime_not_divides_int_1: forall p, prime_nat p -> ~divides_int p 1.
let p. assume Hp.
assume H1: divides_int p 1.
apply Hp. assume H. apply H.
assume Hp1: p :e omega.
assume Hp2: 1 :e p.
assume _.
claim LpN: nat_p p.
{ exact omega_nat_p p Hp1. }
claim Lpo: ordinal p.
{ exact nat_p_ordinal p LpN. }
claim LpS: SNo p.
{ exact nat_p_SNo p LpN. }
apply SNoLt_irref 1.
prove 1 < 1.
apply SNoLtLe_tra 1 p 1 SNo_1 LpS SNo_1.
- prove 1 < p.
  apply ordinal_In_SNoLt p Lpo 1.
  prove 1 :e p.
  exact Hp2.
- prove p <= 1.
  exact divides_int_pos_Le p 1 H1 SNoLt_0_1.
Qed.

Definition Pi_SNo : (set -> set) -> set -> set := fun f n =>
  nat_primrec 1 (fun i r => r * f i) n.

Theorem Pi_SNo_0: forall f:set -> set, Pi_SNo f 0 = 1.
let f.
exact nat_primrec_0 1 (fun i r => r * f i).
Qed.

Theorem Pi_SNo_S: forall f:set -> set, forall n, nat_p n -> Pi_SNo f (ordsucc n) = Pi_SNo f n * f n.
let f n. assume Hn.
prove Pi_SNo f (ordsucc n) = Pi_SNo f n * f n.
exact nat_primrec_S 1 (fun i r => r * f i) n Hn.
Qed.

Theorem Pi_SNo_In_omega: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, f i :e omega)
  -> Pi_SNo f n :e omega.
let f.
apply nat_ind.
- assume _. rewrite Pi_SNo_0. apply nat_p_omega. exact nat_1.
- let n. assume Hn: nat_p n.
  assume IHn: (forall i :e n, f i :e omega) -> Pi_SNo f n :e omega.
  assume Hf: forall i :e ordsucc n, f i :e omega.
  prove Pi_SNo f (ordsucc n) :e omega.
  rewrite Pi_SNo_S f n Hn.
  prove Pi_SNo f n * f n :e omega.
  apply mul_SNo_In_omega.
  + apply IHn.
    let i. assume Hi: i :e n.
    prove f i :e omega.
    apply Hf.
    prove i :e ordsucc n.
    apply ordsuccI1. exact Hi.
  + prove f n :e omega.
    apply Hf.
    prove n :e ordsucc n. apply ordsuccI2.
Qed.

Theorem Pi_SNo_In_int: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, f i :e int)
  -> Pi_SNo f n :e int.
let f.
apply nat_ind.
- assume _. rewrite Pi_SNo_0. apply Subq_omega_int. apply nat_p_omega. exact nat_1.
- let n. assume Hn: nat_p n.
  assume IHn: (forall i :e n, f i :e int) -> Pi_SNo f n :e int.
  assume Hf: forall i :e ordsucc n, f i :e int.
  prove Pi_SNo f (ordsucc n) :e int.
  rewrite Pi_SNo_S f n Hn.
  prove Pi_SNo f n * f n :e int.
  apply int_mul_SNo.
  + apply IHn.
    let i. assume Hi: i :e n.
    prove f i :e int.
    apply Hf.
    prove i :e ordsucc n.
    apply ordsuccI1. exact Hi.
  + prove f n :e int.
    apply Hf.
    prove n :e ordsucc n. apply ordsuccI2.
Qed.

Theorem divides_int_prime_nat_eq: forall p q, prime_nat p -> prime_nat q -> divides_int p q -> p = q.
let p q.
assume Hp Hq Hpq.
apply Hp. assume H. apply H.
assume HpN: p :e omega.
assume H1p: 1 :e p.
assume Hpp: forall k :e omega, divides_nat k p -> k = 1 \/ k = p.
apply Hq. assume H. apply H.
assume HqN: q :e omega.
assume H1q: 1 :e q.
assume Hqp: forall k :e omega, divides_nat k q -> k = 1 \/ k = q.
claim L1: divides_nat p q.
{ apply divides_int_divides_nat.
  - exact HpN.
  - exact HqN.
  - exact Hpq.
}
apply Hqp p HpN L1.
- assume H1: p = 1. prove False.
  apply In_irref p.
  rewrite H1 at 1.
  exact H1p.
- assume H1: p = q. exact H1.
Qed.

Theorem Euclid_lemma_Pi_SNo: forall f:set->set,
  forall p, prime_nat p ->
  forall n, nat_p n ->
      (forall i :e n, f i :e int)
   -> divides_int p (Pi_SNo f n)
   -> exists i :e n, divides_int p (f i).
let f p.
assume Hp: prime_nat p.
apply nat_ind.
- assume _.
  rewrite Pi_SNo_0.
  assume H1: divides_int p 1.
  prove False.
  exact prime_not_divides_int_1 p Hp H1.
- let n.
  assume Hn: nat_p n.
  assume IHn: (forall i :e n, f i :e int)
   -> divides_int p (Pi_SNo f n)
   -> exists i :e n, divides_int p (f i).
  assume H1: forall i :e ordsucc n, f i :e int.
  rewrite Pi_SNo_S f n Hn.
  assume H2: divides_int p (Pi_SNo f n * f n).
  claim L1: forall i :e n, f i :e int.
  { let i. assume Hi. apply H1. apply ordsuccI1. exact Hi. }
  claim L2: f n :e int.
  { apply H1. apply ordsuccI2. }
  apply Euclid_lemma p Hp (Pi_SNo f n) (Pi_SNo_In_int f n Hn L1) (f n) L2 H2.
  - assume H3: divides_int p (Pi_SNo f n).
    apply IHn L1 H3.
    let i. assume H. apply H.
    assume Hi: i :e n.
    assume H4: divides_int p (f i).
    witness i. apply andI.
    + prove i :e ordsucc n. apply ordsuccI1. exact Hi.
    + exact H4.
  - assume H3: divides_int p (f n).
    witness n. apply andI.
    + prove n :e ordsucc n. apply ordsuccI2.
    + exact H3.
Qed.

Theorem divides_nat_mul_SNo_R: forall m n :e omega, divides_nat m (m * n).
let m. assume Hm. let n. assume Hn.
prove m :e omega /\ m * n :e omega /\ exists k :e omega, mul_nat m k = m * n.
apply and3I.
- exact Hm.
- apply mul_SNo_In_omega.
  + exact Hm.
  + exact Hn.
- witness n. apply andI.
  + exact Hn.
  + prove mul_nat m n = m * n.
    exact mul_nat_mul_SNo m Hm n Hn.
Qed.

Theorem divides_nat_mul_SNo_L: forall m n :e omega, divides_nat n (m * n).
let m. assume Hm. let n. assume Hn.
rewrite mul_SNo_com m n (omega_SNo m Hm) (omega_SNo n Hn).
prove divides_nat n (n * m).
exact divides_nat_mul_SNo_R n Hn m Hm.
Qed.

Theorem Pi_SNo_divides: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, f i :e omega)
   -> (forall i :e n, divides_nat (f i) (Pi_SNo f n)).
let f.
apply nat_ind.
- assume _. let i. assume Hi: i :e 0. prove False. exact EmptyE i Hi.
- let n. assume Hn: nat_p n.
  assume IHn: (forall i :e n, f i :e omega)
           -> (forall i :e n, divides_nat (f i) (Pi_SNo f n)).
  assume Hf: forall i :e ordsucc n, f i :e omega.
  claim L1: forall i :e n, f i :e omega.
  { let i. assume Hi. apply Hf. apply ordsuccI1. exact Hi. }
  claim L2: Pi_SNo f n :e omega.
  { exact Pi_SNo_In_omega f n Hn L1. }
  claim L3: f n :e omega.
  { apply Hf. apply ordsuccI2. }
  let i. assume Hi: i :e ordsucc n.
  rewrite Pi_SNo_S f n Hn.
  prove divides_nat (f i) (Pi_SNo f n * f n).
  apply ordsuccE n i Hi.
  + assume H1: i :e n.
    apply divides_nat_tra (f i) (Pi_SNo f n).
    * prove divides_nat (f i) (Pi_SNo f n).
      exact IHn L1 i H1.
    * prove divides_nat (Pi_SNo f n) (Pi_SNo f n * f n).
      exact divides_nat_mul_SNo_R (Pi_SNo f n) L2 (f n) L3.
  + assume H1: i = n. rewrite H1.
    prove divides_nat (f n) (Pi_SNo f n * f n).
    exact divides_nat_mul_SNo_L (Pi_SNo f n) L2 (f n) L3.
Qed.

Definition nonincrfinseq : (set -> prop) -> set -> (set -> set) -> prop := fun A n f => forall i :e n, A (f i) /\ forall j :e i, f i <= f j.

Theorem Pi_SNo_eq: forall f g:set->set,
  forall m, nat_p m
   -> (forall i :e m, f i = g i)
   -> Pi_SNo f m = Pi_SNo g m.
let f g.
apply nat_ind.
- assume _. rewrite Pi_SNo_0 g. exact Pi_SNo_0 f.
- let m. assume Hm.
  assume IHm: (forall i :e m, f i = g i) -> Pi_SNo f m = Pi_SNo g m.
  assume H1: forall i :e ordsucc m, f i = g i.
  claim L1: forall i :e m, f i = g i.
  { let i. assume Hi. apply H1. apply ordsuccI1. exact Hi. }
  claim L2: f m = g m.
  { apply H1. apply ordsuccI2. }
  prove Pi_SNo f (ordsucc m) = Pi_SNo g (ordsucc m).
  rewrite Pi_SNo_S f m Hm.
  rewrite Pi_SNo_S g m Hm.
  prove Pi_SNo f m * f m = Pi_SNo g m * g m.
  f_equal.
  + exact IHm L1.
  + exact L2.
Qed.

Theorem prime_factorization_ex_uniq: forall n, nat_p n -> 0 :e n ->
  exists k :e omega, exists f:set -> set, nonincrfinseq prime_nat k f /\ Pi_SNo f k = n
    /\ forall k' :e omega, forall f':set -> set, nonincrfinseq prime_nat k' f' -> Pi_SNo f' k' = n
         -> k' = k /\ forall i :e k, f' i = f i.
apply nat_complete_ind.
let n.
assume Hn: nat_p n.
assume IH: forall m :e n, 0 :e m ->
  exists k :e omega, exists f:set -> set, nonincrfinseq prime_nat k f /\ Pi_SNo f k = m
    /\ forall k' :e omega, forall f':set -> set, nonincrfinseq prime_nat k' f' -> Pi_SNo f' k' = m
         -> k' = k /\ forall i :e k, f' i = f i.
assume H1: 0 :e n.
claim Ln: n :e omega.
{ exact nat_p_omega n Hn. }
apply xm (n = 1).
- assume H2: n = 1.
  set f : set -> set := fun i => 0.
  prove exists k :e omega, exists f:set -> set, nonincrfinseq prime_nat k f /\ Pi_SNo f k = n
          /\ forall k' :e omega, forall f':set -> set, nonincrfinseq prime_nat k' f' -> Pi_SNo f' k' = n
              -> k' = k /\ forall i :e k, f' i = f i.
  witness 0. apply andI.
  + prove 0 :e omega. exact nat_p_omega 0 nat_0.
  + witness f.
    apply and3I.
    * let i. assume Hi: i :e 0. prove False. exact EmptyE i Hi.
    * prove Pi_SNo f 0 = n.
      rewrite Pi_SNo_0 f.
      symmetry.
      exact H2.
    * { let k'. assume Hk': k' :e omega.
        let f'.
	assume Hf': nonincrfinseq prime_nat k' f'.
        assume H3: Pi_SNo f' k' = n.
	claim Lf'1: forall i :e k', prime_nat (f' i).
	{ let i. assume Hi: i :e k'.
	  apply Hf' i Hi.
	  assume H4: prime_nat (f' i).
	  assume _.
	  exact H4.
	}
	claim Lf'2: forall i :e k', f' i :e omega.
	{ let i. assume Hi: i :e k'.
	  apply Lf'1 i Hi.
	  assume H. apply H.
	  assume H4: f' i :e omega.
	  assume _ _.
	  exact H4.
	}
	apply andI.
	- prove k' = 0.
	  apply Empty_eq.
	  let i. assume Hi: i :e k'.
	  prove False.
          claim Lf'i1: prime_nat (f' i).
	  { exact Lf'1 i Hi. }
	  claim Lf'i2: f' i :e omega.
	  { exact Lf'2 i Hi. }
	  apply SNoLt_irref n.
	  prove n < n.
	  rewrite H2 at 1.
	  prove 1 < n.
	  apply SNoLtLe_tra 1 (f' i) n SNo_1.
	  + prove SNo (f' i).
	    exact omega_SNo (f' i) Lf'i2.
	  + prove SNo n. apply nat_p_SNo. exact Hn.
	  + prove 1 < f' i.
	    apply Lf'i1. assume H. apply H.
	    assume _.
	    assume H4: 1 :e f' i.
	    assume _.
	    prove 1 < f' i.
	    exact ordinal_In_SNoLt (f' i) (nat_p_ordinal (f' i) (omega_nat_p (f' i) Lf'i2)) 1 H4.
	  + prove f' i <= n.
	    apply divides_int_pos_Le (f' i) n.
	    * prove divides_int (f' i) n.
	      apply divides_nat_divides_int.
	      prove divides_nat (f' i) n.
	      rewrite <- H3.
	      prove divides_nat (f' i) (Pi_SNo f' k').
	      exact Pi_SNo_divides f' k' (omega_nat_p k' Hk') Lf'2 i Hi.
	    * prove 0 < n.
	      rewrite H2.
	      exact SNoLt_0_1.
	- let i. assume Hi: i :e 0.
	  prove False.
	  exact EmptyE i Hi.
      }
- assume H2: n <> 1.
  claim LnS: SNo n.
  { exact nat_p_SNo n Hn. }
  claim Lno: ordinal n.
  { exact nat_p_ordinal n Hn. }
  claim L1: 1 :e n.
  { apply ordinal_In_Or_Subq 1 n (nat_p_ordinal 1 nat_1) Lno.
    - assume H3: 1 :e n. exact H3.
    - assume H3: n c= 1. prove False.
      apply H2.
      apply set_ext.
      + exact H3.
      + prove 1 c= n.
        let i. assume Hi: i :e 1.
	apply cases_1 i Hi.
	prove 0 :e n.
	exact H1.
  }
  claim L2: exists p, ordinal p /\ (prime_nat p /\ divides_nat p n) /\ forall q :e p, ~(prime_nat q /\ divides_nat q n).
  { apply least_ordinal_ex.
    prove exists p, ordinal p /\ (prime_nat p /\ divides_nat p n).
    apply prime_nat_divisor_ex n Hn L1.
    let p. assume H. apply H.
    assume H3: prime_nat p.
    assume H4: divides_nat p n.
    witness p.
    apply andI.
    - prove ordinal p.
      apply H3. assume H _. apply H.
      assume H5: p :e omega.
      assume _.
      exact nat_p_ordinal p (omega_nat_p p H5).
    - apply andI.
      + exact H3.
      + exact H4.
  }
  apply L2.
  let p. assume H. apply H. assume H. apply H.
  assume Hpo: ordinal p. assume H. apply H.
  assume Hpp: prime_nat p.
  assume Hpn: divides_nat p n.
  assume Hpleast: forall q :e p, ~(prime_nat q /\ divides_nat q n).
  apply Hpp. assume H _. apply H.
  assume HpN: p :e omega.
  assume H1p: 1 :e p.
  apply Hpn. assume _ H. apply H.
  let m. assume H. apply H.
  assume Hm: m :e omega.
  rewrite mul_nat_mul_SNo p HpN m Hm.
  assume Hpm: p * m = n.
  claim LmS: SNo m.
  { exact omega_SNo m Hm. }
  claim LmN: nat_p m.
  { exact omega_nat_p m Hm. }
  claim Lmo: ordinal m.
  { exact nat_p_ordinal m LmN. }
  claim LpS: SNo p.
  { exact omega_SNo p HpN. }
  claim LpN: nat_p p.
  { exact omega_nat_p p HpN. }
  claim Lpo: ordinal p.
  { exact nat_p_ordinal p LpN. }
  claim Lmp: m * p = n.
  { rewrite mul_SNo_com m p LmS LpS. exact Hpm. }
  claim L1p: 1 < p.
  { apply ordinal_In_SNoLt p Hpo 1.
    prove 1 :e p.
    exact H1p.
  }
  claim Lmpos: 0 < m.
  { apply SNoLeE 0 m SNo_0 LmS (omega_nonneg m Hm).
    - assume H3: 0 < m. exact H3.
    - assume H3: 0 = m. prove False.
      claim Ln0: n = 0.
      { rewrite <- Hpm.
        prove p * m = 0.
	rewrite <- H3.
	exact mul_SNo_zeroR p LpS.
      }
      apply In_irref n.
      prove n :e n.
      rewrite Ln0 at 1.
      exact H1.
  }
  claim L3: m < n.
  { rewrite <- Lmp.
    prove m < m * p.
    rewrite <- mul_SNo_oneR m LmS at 1.
    prove m * 1 < m * p.
    apply pos_mul_SNo_Lt m 1 p LmS Lmpos SNo_1 LpS L1p.
  }
  claim L4: m :e n.
  { exact ordinal_SNoLt_In m n Lmo Lno L3. }
  claim L5: 0 :e m.
  { exact ordinal_SNoLt_In 0 m ordinal_Empty Lmo Lmpos. }
  apply IH m L4 L5.
  let k. assume H. apply H.
  assume Hk: k :e omega. assume H. apply H.
  let f. assume H. apply H. assume H. apply H.
  assume Hf: nonincrfinseq prime_nat k f.
  assume Hfkm: Pi_SNo f k = m.
  assume Huniq: forall k' :e omega, forall f':set -> set, nonincrfinseq prime_nat k' f' -> Pi_SNo f' k' = m
                 -> k' = k /\ forall i :e k, f' i = f i.
  claim LkN: nat_p k.
  { exact omega_nat_p k Hk. }
  claim Lf1: forall i :e k, prime_nat (f i).
  { let i. assume Hi: i :e k.
    apply Hf i Hi.
    assume H3: prime_nat (f i).
    assume _.
    exact H3.
  }
  claim Lf2: forall i :e k, f i :e omega.
  { let i. assume Hi: i :e k.
    apply Lf1 i Hi.
    assume H. apply H.
    assume H3: f i :e omega.
    assume _ _.
    exact H3.
  }
  claim Lg: exists g:set->set, g k = p /\ forall i :e k, g i = f i.
  { set g : set -> set := fun i => if i :e k then f i else p.
    witness g. apply andI.
    - prove g k = p.
      exact If_i_0 (k :e k) (f k) p (In_irref k).
    - let i. assume Hi: i :e k.
      prove g i = f i.
      exact If_i_1 (i :e k) (f i) p Hi.
  }
  apply Lg.
  let g. assume H. apply H.
  assume Hgk: g k = p.
  assume Hgi: forall i :e k, g i = f i.
  prove exists k :e omega, exists f:set -> set, nonincrfinseq prime_nat k f /\ Pi_SNo f k = n
    /\ forall k' :e omega, forall f':set -> set, nonincrfinseq prime_nat k' f' -> Pi_SNo f' k' = n
         -> k' = k /\ forall i :e k, f' i = f i.
  witness (ordsucc k). apply andI.
  + prove ordsucc k :e omega. apply omega_ordsucc. exact Hk.
  + witness g. apply and3I.
    * { prove nonincrfinseq prime_nat (ordsucc k) g.
        let i. assume Hi: i :e ordsucc k.
	apply ordsuccE k i Hi.
	- assume H3: i :e k.
	  prove prime_nat (g i) /\ forall j :e i, g i <= g j.
	  rewrite Hgi i H3.
	  prove prime_nat (f i) /\ forall j :e i, f i <= g j.
	  apply Hf i H3.
	  assume H4: prime_nat (f i).
	  assume H5: forall j :e i, f i <= f j.
	  apply andI.
	  + exact H4.
	  + let j. assume Hj: j :e i.
	    prove f i <= g j.
	    claim Lj: j :e k.
	    { exact nat_trans k LkN i H3 j Hj. }
	    rewrite Hgi j Lj.
	    exact H5 j Hj.
	- assume H3: i = k.
	  prove prime_nat (g i) /\ forall j :e i, g i <= g j.
	  rewrite H3. rewrite Hgk.
	  prove prime_nat p /\ forall j :e k, p <= g j.
	  apply andI.
	  + exact Hpp.
	  + let j. assume Hj: j :e k.
	    rewrite Hgi j Hj.
	    prove p <= f j.
	    claim LfjN: nat_p (f j).
	    { exact omega_nat_p (f j) (Lf2 j Hj). }
	    claim LfjS: SNo (f j).
	    { exact nat_p_SNo (f j) LfjN. }
	    claim Lfjo: ordinal (f j).
	    { exact nat_p_ordinal (f j) LfjN. }
            apply SNoLtLe_or (f j) p LfjS LpS.
	    * { assume H4: f j < p.
	        prove False.
		apply Hpleast (f j).
		- prove f j :e p.
		  apply ordinal_SNoLt_In (f j) p Lfjo Lpo.
		  prove f j < p.
		  exact H4.
		- apply andI.
		  + prove prime_nat (f j). exact Lf1 j Hj.
		  + prove divides_nat (f j) n.
		    apply divides_nat_tra (f j) m n.
		    * prove divides_nat (f j) m.
		      rewrite <- Hfkm.
		      prove divides_nat (f j) (Pi_SNo f k).
                      exact Pi_SNo_divides f k LkN Lf2 j Hj.
		    * prove divides_nat m n.
		      rewrite <- Lmp.
		      prove divides_nat m (m * p).
		      exact divides_nat_mul_SNo_R m Hm p HpN.
              }
	    * assume H4: p <= f j. exact H4.
      }
    * { prove Pi_SNo g (ordsucc k) = n.
        rewrite Pi_SNo_S g k LkN.
        prove Pi_SNo g k * g k = n.
        rewrite <- Lmp.
        prove Pi_SNo g k * g k = m * p.
	f_equal.
	- prove Pi_SNo g k = m.
	  rewrite Pi_SNo_eq g f k LkN Hgi.
	  prove Pi_SNo f k = m.
	  exact Hfkm.
	- prove g k = p. exact Hgk.
      }
    * { prove forall k' :e omega, forall g':set -> set, nonincrfinseq prime_nat k' g' -> Pi_SNo g' k' = n
                -> k' = ordsucc k /\ forall i :e ordsucc k, g' i = g i.
        let k'. assume Hk': k' :e omega.
	let g'.
	assume Hg': nonincrfinseq prime_nat k' g'.
	assume Hg'k': Pi_SNo g' k' = n.
	claim Lg'1: forall i :e k', prime_nat (g' i).
	{ let i. assume Hi: i :e k'.
	  apply Hg' i Hi.
	  assume H4: prime_nat (g' i).
	  assume _.
	  exact H4.
	}
	claim Lg'2: forall i :e k', g' i :e omega.
	{ let i. assume Hi: i :e k'.
	  apply Lg'1 i Hi.
	  assume H. apply H.
	  assume H4: g' i :e omega.
	  assume _ _.
	  exact H4.
	}
	prove k' = ordsucc k /\ forall i :e ordsucc k, g' i = g i.
	claim Lk'N: nat_p k'.
	{ exact omega_nat_p k' Hk'. }
	apply nat_inv k' Lk'N.
	- assume Hk': k' = 0.
	  prove False.
	  apply H2.
	  prove n = 1.
	  rewrite <- Hg'k'.
	  rewrite Hk'.
	  apply Pi_SNo_0.
	- assume H. apply H.
	  let k''. assume H. apply H.
	  assume Hk'': nat_p k''.
	  assume Hk'k'': k' = ordsucc k''.
	  claim L6: nonincrfinseq prime_nat k'' g'.
	  { let i. assume Hi: i :e k''.
	    prove prime_nat (g' i) /\ forall j :e i, g' i <= g' j.
	    claim Li: i :e k'.
	    { rewrite Hk'k''. apply ordsuccI1. exact Hi. }
	    exact Hg' i Li.
	  }
	  claim LPg'k''N: Pi_SNo g' k'' :e omega.
	  { apply Pi_SNo_In_omega g' k'' Hk''.
	    let i. assume Hi: i :e k''.
	    claim Li: i :e k'.
	    { rewrite Hk'k''. apply ordsuccI1. exact Hi. }
	    exact Lg'2 i Li.
	  }
	  claim LPg'k''S: SNo (Pi_SNo g' k'').
	  { exact omega_SNo (Pi_SNo g' k'') LPg'k''N. }
	  claim L7: g' k'' = p.
	  { claim L7a: prime_nat (g' k'') /\ forall j :e k'', g' k'' <= g' j.
	    { apply Hg' k''.
	      prove k'' :e k'.
	      rewrite Hk'k''. apply ordsuccI2.
	    }
	    apply L7a.
	    assume Hg'k''P: prime_nat (g' k'').
	    assume Hg'k''minimal: forall j :e k'', g' k'' <= g' j.
	    apply Hg'k''P. assume H _. apply H.
	    assume H4: g' k'' :e omega.
	    assume H5: 1 :e g' k''.
	    claim Lg'k''N: nat_p (g' k'').
	    { exact omega_nat_p (g' k'') H4. }
	    claim Lg'k''o: ordinal (g' k'').
	    { exact nat_p_ordinal (g' k'') Lg'k''N. }
	    claim Lg'k''S: SNo (g' k'').
	    { exact nat_p_SNo (g' k'') Lg'k''N. }
	    claim L7b: divides_nat (g' k'') n.
	    { rewrite <- Hg'k'.
	      prove divides_nat (g' k'') (Pi_SNo g' k').
	      rewrite Hk'k''.
	      rewrite Pi_SNo_S g' k'' Hk''.
	      prove divides_nat (g' k'') (Pi_SNo g' k'' * g' k'').
	      apply divides_nat_mul_SNo_L.
	      - exact LPg'k''N.
	      - exact H4.
	    }
	    claim L7c: divides_int p (Pi_SNo g' k').
	    { apply Hg'k' (fun u v => divides_int p v).
	      prove divides_int p n.
	      apply divides_nat_divides_int.
	      exact Hpn.
	    }
	    claim L7d: divides_int p (Pi_SNo g' k'') \/ divides_int p (g' k'').
	    { apply Euclid_lemma p Hpp.
	      - prove Pi_SNo g' k'' :e int.
	        apply Subq_omega_int.
		exact LPg'k''N.
	      - prove g' k'' :e int.
	        apply Subq_omega_int.
		exact H4.
	      - prove divides_int p (Pi_SNo g' k'' * g' k'').
	        rewrite <- Pi_SNo_S g' k'' Hk''.
		prove divides_int p (Pi_SNo g' (ordsucc k'')).
		rewrite <- Hk'k''.
		exact L7c.
	    }
	    claim L7e: forall i :e k'', g' i :e int.
	    { let i. assume Hi.
	      apply Subq_omega_int.
	      apply Lg'2.
	      prove i :e k'.
	      rewrite Hk'k''.
	      apply ordsuccI1.
	      exact Hi.
	    }
	    apply L7d.
	    - assume H6: divides_int p (Pi_SNo g' k'').
              prove g' k'' = p.
	      apply SNoLt_trichotomy_or_impred (g' k'') p Lg'k''S LpS.
	      + assume H7: g' k'' < p.
	        prove False.
	        apply Hpleast (g' k'').
	        * prove g' k'' :e p.
	          exact ordinal_SNoLt_In (g' k'') p Lg'k''o Lpo H7.
	        * { prove prime_nat (g' k'') /\ divides_nat (g' k'') n.
		    apply andI.
		    - exact Hg'k''P.
		    - exact L7b.
		  }
	      + assume H7: g' k'' = p. exact H7.
	      + assume H7: p < g' k''.
	        prove False.
		apply Euclid_lemma_Pi_SNo g' p Hpp k'' Hk'' L7e H6.
		let j. assume H. apply H.
		assume Hj: j :e k''.
		assume H8: divides_int p (g' j).
		claim L7f: prime_nat (g' j).
		{ apply Lg'1. rewrite Hk'k''. apply ordsuccI1. exact Hj. }
		claim L7g: p = g' j.
		{ exact divides_int_prime_nat_eq p (g' j) Hpp L7f H8. }
	        apply SNoLt_irref p.
	        prove p < p.
                apply SNoLtLe_tra p (g' k'') p LpS Lg'k''S LpS H7.
	        prove g' k'' <= p.
		rewrite L7g.
	        prove g' k'' <= g' j.
	        apply Hg'k''minimal.
	        prove j :e k''.
                exact Hj.
	    - assume H6: divides_int p (g' k'').
	      prove g' k'' = p.
	      symmetry.
	      apply divides_int_prime_nat_eq p (g' k'') Hpp.
	      + prove prime_nat (g' k''). apply Lg'1. rewrite Hk'k''. apply ordsuccI2.
	      + prove divides_int p (g' k''). exact H6.
	  }
	  claim L8: Pi_SNo g' k'' = m.
	  { apply mul_SNo_nonzero_cancel p (Pi_SNo g' k'') m.
	    - prove SNo p. exact LpS.
	    - prove p <> 0.
	      assume H4: p = 0.
	      apply SNoLt_irref 0.
	      prove 0 < 0.
	      rewrite <- H4 at 2.
	      prove 0 < p.
	      exact SNoLt_tra 0 1 p SNo_0 SNo_1 LpS SNoLt_0_1 L1p.
	    - prove SNo (Pi_SNo g' k'').
	      exact LPg'k''S.
	    - prove SNo m. exact LmS.
	    - prove p * Pi_SNo g' k'' = p * m.
	      rewrite Hpm.
	      prove p * Pi_SNo g' k'' = n.
	      rewrite <- Hg'k'.
	      prove p * Pi_SNo g' k'' = Pi_SNo g' k'.
	      rewrite Hk'k''.
	      prove p * Pi_SNo g' k'' = Pi_SNo g' (ordsucc k'').
	      rewrite Pi_SNo_S g' k'' Hk''.
	      prove p * Pi_SNo g' k'' = Pi_SNo g' k'' * g' k''.
	      rewrite L7.
	      prove p * Pi_SNo g' k'' = Pi_SNo g' k'' * p.
	      exact mul_SNo_com p (Pi_SNo g' k'') LpS LPg'k''S.
	  }
	  apply Huniq k'' (nat_p_omega k'' Hk'') g' L6 L8.
	  assume H3: k'' = k.
	  assume H4: forall i :e k, g' i = f i.
	  prove k' = ordsucc k /\ forall i :e ordsucc k, g' i = g i.
	  apply andI.
	  + prove k' = ordsucc k. rewrite Hk'k''. f_equal. exact H3.
	  + let i. assume Hi: i :e ordsucc k.
	    apply ordsuccE k i Hi.
	    * assume H5: i :e k.
	      prove g' i = g i.
	      rewrite Hgi i H5.
	      prove g' i = f i.
	      exact H4 i H5.
	    * assume H5: i = k.
	      prove g' i = g i.
	      rewrite H5.
	      rewrite Hgk.
	      prove g' k = p.
	      rewrite <- H3.
	      exact L7.
      }
Qed.

End PrimeFactorization.

Section SurrealExp.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Definition exp_SNo_nat : set->set->set := fun n m:set => nat_primrec 1 (fun _ r => n * r) m.
Infix ^ 342 right := exp_SNo_nat.

Theorem exp_SNo_nat_0 : forall x, SNo x -> x ^ 0 = 1.
let x. assume Hx.
exact nat_primrec_0 1 (fun _ r => x * r).
Qed.

Theorem exp_SNo_nat_S : forall x, SNo x -> forall n, nat_p n -> x ^ (ordsucc n) = x * x ^ n.
let x. assume Hx. let n. assume Hn.
exact nat_primrec_S 1 (fun _ r => x * r) n Hn.
Qed.

Theorem exp_SNo_nat_1: forall x, SNo x -> x ^ 1 = x.
let x. assume Hx.
rewrite exp_SNo_nat_S x Hx 0 nat_0.
prove x * x ^ 0 = x.
rewrite exp_SNo_nat_0 x Hx.
prove x * 1 = x.
exact mul_SNo_oneR x Hx.
Qed.

Theorem SNo_exp_SNo_nat : forall x, SNo x -> forall n, nat_p n -> SNo (x ^ n).
let x. assume Hx. apply nat_ind.
- prove SNo (x ^ 0). rewrite exp_SNo_nat_0 x Hx. exact SNo_1.
- let n. assume Hn. assume IHn: SNo (x ^ n).
  prove SNo (x ^ (ordsucc n)).
  rewrite exp_SNo_nat_S x Hx n Hn.
  prove SNo (x * x ^ n).
  exact SNo_mul_SNo x (x ^ n) Hx IHn.
Qed.

Theorem nat_exp_SNo_nat : forall x, nat_p x -> forall n, nat_p n -> nat_p (x ^ n).
let x. assume Hx.
claim Lx: SNo x.
{ exact nat_p_SNo x Hx. }
apply nat_ind.
- prove nat_p (x ^ 0). rewrite exp_SNo_nat_0 x Lx. exact nat_1.
- let n. assume Hn. assume IHn: nat_p (x ^ n).
  prove nat_p (x ^ (ordsucc n)).
  rewrite exp_SNo_nat_S x Lx n Hn.
  prove nat_p (x * x ^ n).
  rewrite <- mul_nat_mul_SNo x (nat_p_omega x Hx) (x ^ n) (nat_p_omega (x ^ n) IHn).
  prove nat_p (mul_nat x (x ^ n)).
  exact mul_nat_p x Hx (x ^ n) IHn.
Qed.

Theorem eps_ordsucc_half_add : forall n, nat_p n -> eps_ (ordsucc n) + eps_ (ordsucc n) = eps_ n.
apply nat_complete_ind.
let n. assume Hn.
assume IH: forall m :e n, eps_ (ordsucc m) + eps_ (ordsucc m) = eps_ m.
claim Ln: n :e omega.
{ exact nat_p_omega n Hn. }
rewrite eps_SNoCut n Ln.
set x := eps_ (ordsucc n).
claim Lx: SNo x.
{ exact SNo_eps_ (ordsucc n) (omega_ordsucc n Ln). }
claim Lx2: 0 < x.
{ exact SNo_eps_pos (ordsucc n) (omega_ordsucc n Ln). }
rewrite add_SNo_eq x Lx x Lx.
prove SNoCut ({w + x|w :e SNoL x} :\/: {x + w|w :e SNoL x})
             ({z + x|z :e SNoR x} :\/: {x + z|z :e SNoR x})
    = SNoCut {0} {eps_ m|m :e n}.
apply SNoCut_ext ({w + x|w :e SNoL x} :\/: {x + w|w :e SNoL x})
                 ({z + x|z :e SNoR x} :\/: {x + z|z :e SNoR x})
                 {0} {eps_ m|m :e n}
                 (add_SNo_SNoCutP x x Lx Lx)
                 (eps_SNoCutP n Ln).
- claim L1: forall w :e SNoL x, w + x < eps_ n /\ x + w < eps_ n.
  { let w. assume Hw: w :e SNoL x.
    apply SNoL_E x Lx w Hw.
    assume Hw1: SNo w.
    rewrite SNoLev_eps_ (ordsucc n) (omega_ordsucc n Ln).
    assume Hw2: SNoLev w :e ordsucc (ordsucc n).
    assume Hw3: w < x.
    claim Lw0: w <= 0.
    { apply SNoLtLe_or 0 w SNo_0 Hw1.
      - assume H1: 0 < w. prove False.
        apply SNoLt_irref w.
        prove w < w.
        apply SNoLt_tra w x w Hw1 Lx Hw1 Hw3.
        prove x < w.
        apply SNo_pos_eps_Lt (ordsucc n) (nat_ordsucc n Hn) w.
        + prove w :e SNoS_ (ordsucc (ordsucc n)).
          apply SNoS_I (ordsucc (ordsucc n)) (nat_p_ordinal (ordsucc (ordsucc n)) (nat_ordsucc (ordsucc n) (nat_ordsucc n Hn))) w (SNoLev w) Hw2.
          prove SNo_ (SNoLev w) w.
          exact SNoLev_ w Hw1.
        + prove 0 < w. exact H1.
      - assume H1: w <= 0. exact H1.
    }
    claim L1a: w + x < eps_ n.
    { apply SNoLeLt_tra (w + x) (0 + x) (eps_ n).
      - exact SNo_add_SNo w x Hw1 Lx.
      - exact SNo_add_SNo 0 x SNo_0 Lx.
      - exact SNo_eps_ n Ln.
      - prove w + x <= 0 + x.
        exact add_SNo_Le1 w x 0 Hw1 Lx SNo_0 Lw0.
      - prove 0 + x < eps_ n.
        rewrite add_SNo_0L x Lx.
        prove eps_ (ordsucc n) < eps_ n.
        exact SNo_eps_decr (ordsucc n) (omega_ordsucc n Ln) n (ordsuccI2 n). 
    }
    apply andI.
    - exact L1a.
    - rewrite add_SNo_com x w Lx Hw1. exact L1a.
  }    
  let w'. assume Hw': w' :e {w + x|w :e SNoL x} :\/: {x + w|w :e SNoL x}.
  prove w' < SNoCut {0} {eps_ m|m :e n}.
  rewrite <- eps_SNoCut n Ln.
  prove w' < eps_ n.
  apply binunionE {w + x|w :e SNoL x} {x + w|w :e SNoL x} w' Hw'.
  + assume Hw': w' :e {w + x|w :e SNoL x}.
    apply ReplE_impred (SNoL x) (fun w => w + x) w' Hw'.
    let w. assume Hw1: w :e SNoL x. assume Hw2: w' = w + x.
    rewrite Hw2.
    exact andEL (w + x < eps_ n) (x + w < eps_ n) (L1 w Hw1).
  + assume Hw': w' :e {x + w|w :e SNoL x}.
    apply ReplE_impred (SNoL x) (fun w => x + w) w' Hw'.
    let w. assume Hw1: w :e SNoL x. assume Hw2: w' = x + w.
    rewrite Hw2.
    exact andER (w + x < eps_ n) (x + w < eps_ n) (L1 w Hw1).
- claim L2: forall z :e SNoR x, eps_ n < z + x /\ eps_ n < x + z.
  { let z. assume Hz: z :e SNoR x.
    apply SNoR_E x Lx z Hz.
    assume Hz1: SNo z.
    rewrite SNoLev_eps_ (ordsucc n) (omega_ordsucc n Ln).
    assume Hz2: SNoLev z :e ordsucc (ordsucc n).
    assume Hz3: x < z.
    claim L2a: eps_ n < z + x.
    { apply SNoLeLt_tra (eps_ n) z (z + x) (SNo_eps_ n Ln) Hz1.
      - exact SNo_add_SNo z x Hz1 Lx.
      - prove eps_ n <= z.
        apply SNo_pos_eps_Le n Hn z.
        + prove z :e SNoS_ (ordsucc (ordsucc n)).
          apply SNoS_I (ordsucc (ordsucc n)) (nat_p_ordinal (ordsucc (ordsucc n)) (nat_ordsucc (ordsucc n) (nat_ordsucc n Hn))) z (SNoLev z) Hz2.
          prove SNo_ (SNoLev z) z.
          exact SNoLev_ z Hz1.
        + prove 0 < z.
          apply SNoLt_tra 0 x z SNo_0 Lx Hz1.
          * prove 0 < x. exact SNo_eps_pos (ordsucc n) (omega_ordsucc n Ln).
          * prove x < z. exact Hz3.
      - prove z < z + x.
        rewrite <- add_SNo_0R z Hz1 at 1.
        prove z + 0 < z + x.
        apply add_SNo_Lt2 z 0 x Hz1 SNo_0 Lx.
        prove 0 < x. exact SNo_eps_pos (ordsucc n) (omega_ordsucc n Ln).
    }
    apply andI.
    - exact L2a.
    - rewrite add_SNo_com x z Lx Hz1. exact L2a.
  }
  let z'. assume Hz': z' :e {z + x|z :e SNoR x} :\/: {x + z|z :e SNoR x}.
  prove SNoCut {0} {eps_ m|m :e n} < z'.
  rewrite <- eps_SNoCut n Ln.
  prove eps_ n < z'.
  apply binunionE {z + x|z :e SNoR x} {x + z|z :e SNoR x} z' Hz'.
  + assume Hz': z' :e {z + x|z :e SNoR x}.
    apply ReplE_impred (SNoR x) (fun z => z + x) z' Hz'.
    let z. assume Hz1: z :e SNoR x. assume Hz2: z' = z + x.
    rewrite Hz2.
    prove eps_ n < z + x.
    exact andEL (eps_ n < z + x) (eps_ n < x + z) (L2 z Hz1).
  + assume Hz': z' :e {x + z|z :e SNoR x}.
    apply ReplE_impred (SNoR x) (fun z => x + z) z' Hz'.
    let z. assume Hz1: z :e SNoR x. assume Hz2: z' = x + z.
    rewrite Hz2.
    prove eps_ n < x + z.
    exact andER (eps_ n < z + x) (eps_ n < x + z) (L2 z Hz1).
- let w. assume Hw: w :e {0}.
  prove w < SNoCut ({w + x|w :e SNoL x} :\/: {x + w|w :e SNoL x})
                   ({z + x|z :e SNoR x} :\/: {x + z|z :e SNoR x}).
  rewrite SingE 0 w Hw.
  prove 0 < SNoCut ({w + x|w :e SNoL x} :\/: {x + w|w :e SNoL x})
                   ({z + x|z :e SNoR x} :\/: {x + z|z :e SNoR x}).
  rewrite <- add_SNo_eq x Lx x Lx.
  prove 0 < x + x.
  rewrite <- add_SNo_0L 0 SNo_0.
  prove 0 + 0 < x + x.
  exact add_SNo_Lt3 0 0 x x SNo_0 SNo_0 Lx Lx Lx2 Lx2.
- let z. assume Hz: z :e {eps_ m|m :e n}.
  prove SNoCut ({w + x|w :e SNoL x} :\/: {x + w|w :e SNoL x})
               ({z + x|z :e SNoR x} :\/: {x + z|z :e SNoR x})
      < z.
  rewrite <- add_SNo_eq x Lx x Lx.
  prove x + x < z.
  apply ReplE_impred n eps_ z Hz.
  let m. assume Hm1: m :e n. assume Hm2: z = eps_ m.
  rewrite Hm2.
  prove x + x < eps_ m.
  rewrite <- IH m Hm1.
  prove x + x < eps_ (ordsucc m) + eps_ (ordsucc m).
  set y := eps_ (ordsucc m).
  prove x + x < y + y.
  claim Lm: m :e omega.
  { apply nat_p_omega. exact nat_p_trans n Hn m Hm1. }
  claim Ly: SNo y.
  { exact SNo_eps_ (ordsucc m) (omega_ordsucc m Lm). }
  claim Lxy: x < y.
  { apply SNo_eps_decr (ordsucc n) (omega_ordsucc n Ln) (ordsucc m).
    prove ordsucc m :e ordsucc n.
    apply ordinal_ordsucc_In.
    - prove ordinal n. exact nat_p_ordinal n Hn.
    - exact Hm1.
  }
  exact add_SNo_Lt3 x x y y Lx Lx Ly Ly Lxy Lxy.
Qed.

Theorem eps_1_half_eq1 : eps_ 1 + eps_ 1 = 1.
transitivity eps_ 0.
- exact eps_ordsucc_half_add 0 nat_0.
- exact eps_0_1.
Qed.

Theorem eps_1_half_eq2 : 2 * eps_ 1 = 1.
rewrite <- add_SNo_1_1_2.
prove (1 + 1) * eps_ 1 = 1.
rewrite mul_SNo_distrR 1 1 (eps_ 1) SNo_1 SNo_1 SNo_eps_1.
prove 1 * eps_ 1 + 1 * eps_ 1 = 1.
rewrite mul_SNo_oneL (eps_ 1) SNo_eps_1.
exact eps_1_half_eq1.
Qed.

Theorem double_eps_1 : forall x y z, SNo x -> SNo y -> SNo z -> x + x = y + z -> x = eps_ 1 * (y + z).
let x y z. assume Hx Hy Hz H1.
claim Lyz: SNo (y + z).
{ exact SNo_add_SNo y z Hy Hz. }
apply mul_SNo_nonzero_cancel 2 x (eps_ 1 * (y + z)) SNo_2 neq_2_0 Hx (SNo_mul_SNo (eps_ 1) (y + z) (SNo_eps_ 1 (nat_p_omega 1 nat_1)) Lyz).
prove 2 * x = 2 * eps_ 1 * (y + z).
rewrite mul_SNo_assoc 2 (eps_ 1) (y + z) SNo_2 (SNo_eps_ 1 (nat_p_omega 1 nat_1)) Lyz.
prove 2 * x = (2 * eps_ 1) * (y + z).
rewrite eps_1_half_eq2.
prove 2 * x = 1 * (y + z).
rewrite mul_SNo_oneL (y + z) Lyz.
prove 2 * x = y + z.
rewrite <- add_SNo_1_1_2.
prove (1 + 1) * x = y + z.
rewrite mul_SNo_distrR 1 1 x SNo_1 SNo_1 Hx.
prove 1 * x + 1 * x = y + z.
rewrite mul_SNo_oneL x Hx.
prove x + x = y + z.
exact H1.
Qed.

Theorem exp_SNo_1_bd: forall x, SNo x -> 1 <= x -> forall n, nat_p n -> 1 <= x ^ n.
let x. assume Hx Hx1.
apply nat_ind.
- prove 1 <= x ^ 0. rewrite exp_SNo_nat_0 x Hx. apply SNoLe_ref.
- let n. assume Hn.
  assume IHn: 1 <= x ^ n.
  claim Lxn: SNo (x ^ n).
  { exact SNo_exp_SNo_nat x Hx n Hn. }
  prove 1 <= x ^ (ordsucc n).
  rewrite exp_SNo_nat_S x Hx n Hn.
  prove 1 <= x * x ^ n.
  rewrite <- mul_SNo_oneL 1 SNo_1.
  prove 1 * 1 <= x * x ^ n.
  apply nonneg_mul_SNo_Le2 1 1 x (x ^ n) SNo_1 SNo_1 Hx Lxn.
  + prove 0 <= 1. apply SNoLtLe. exact SNoLt_0_1.
  + prove 0 <= 1. apply SNoLtLe. exact SNoLt_0_1.
  + prove 1 <= x. exact Hx1.
  + prove 1 <= x ^ n. exact IHn.
Qed.

Theorem exp_SNo_2_bd: forall n, nat_p n -> n < 2 ^ n.
apply nat_ind.
- prove 0 < 2 ^ 0. rewrite exp_SNo_nat_0 2 SNo_2. exact SNoLt_0_1.
- let n. assume Hn.
  assume IHn: n < 2 ^ n.
  claim Ln: SNo n.
  { exact nat_p_SNo n Hn. }
  claim L2n: SNo (2 ^ n).
  { exact SNo_exp_SNo_nat 2 SNo_2 n Hn. }
  prove ordsucc n < 2 ^ (ordsucc n).
  rewrite exp_SNo_nat_S 2 SNo_2 n Hn.
  prove ordsucc n < 2 * 2 ^ n.
  rewrite <- add_SNo_1_ordsucc n (nat_p_omega n Hn).
  prove n + 1 < 2 * 2 ^ n.
  rewrite <- add_SNo_1_1_2 at 1.
  prove n + 1 < (1 + 1) * 2 ^ n.
  rewrite mul_SNo_distrR 1 1 (2 ^ n) SNo_1 SNo_1 L2n.
  prove n + 1 < 1 * 2 ^ n + 1 * 2 ^ n.
  rewrite mul_SNo_oneL (2 ^ n) L2n.
  prove n + 1 < 2 ^ n + 2 ^ n.
  apply SNoLtLe_tra (n + 1) (2 ^ n + 1) (2 ^ n + 2 ^ n)
                    (SNo_add_SNo n 1 Ln SNo_1)
                    (SNo_add_SNo (2 ^ n) 1 L2n SNo_1)
                    (SNo_add_SNo (2 ^ n) (2 ^ n) L2n L2n).
  + prove n + 1 < 2 ^ n + 1.
    exact add_SNo_Lt1 n 1 (2 ^ n) Ln SNo_1 L2n IHn.
  + prove 2 ^ n + 1 <= 2 ^ n + 2 ^ n.
    apply add_SNo_Le2 (2 ^ n) 1 (2 ^ n) L2n SNo_1 L2n.
    prove 1 <= 2 ^ n.
    apply exp_SNo_1_bd 2 SNo_2.
    * prove 1 <= 2. apply SNoLtLe. exact SNoLt_1_2.
    * exact Hn.
Qed.

Theorem mul_SNo_eps_power_2: forall n, nat_p n -> eps_ n * 2 ^ n = 1.
apply nat_ind.
- prove eps_ 0 * 2 ^ 0 = 1.
  rewrite eps_0_1. rewrite exp_SNo_nat_0 2 SNo_2.
  prove 1 * 1 = 1. exact mul_SNo_oneR 1 SNo_1.
- let n. assume Hn.
  assume IHn: eps_ n * 2 ^ n = 1.
  prove eps_ (ordsucc n) * 2 ^ (ordsucc n) = 1.
  rewrite exp_SNo_nat_S 2 SNo_2 n Hn.
  prove eps_ (ordsucc n) * (2 * 2 ^ n) = 1.
  claim LeSn: SNo (eps_ (ordsucc n)).
  { exact SNo_eps_ (ordsucc n) (nat_p_omega (ordsucc n) (nat_ordsucc n Hn)). }
  rewrite mul_SNo_assoc (eps_ (ordsucc n)) 2 (2 ^ n) LeSn SNo_2 (SNo_exp_SNo_nat 2 SNo_2 n Hn).
  prove (eps_ (ordsucc n) * 2) * 2 ^ n = 1.
  rewrite <- add_SNo_1_1_2 at 1.
  prove (eps_ (ordsucc n) * (1 + 1)) * 2 ^ n = 1.
  rewrite mul_SNo_distrL (eps_ (ordsucc n)) 1 1 LeSn SNo_1 SNo_1.
  prove ((eps_ (ordsucc n) * 1) + (eps_ (ordsucc n) * 1)) * 2 ^ n = 1.
  rewrite mul_SNo_oneR (eps_ (ordsucc n)) LeSn.
  prove (eps_ (ordsucc n) + eps_ (ordsucc n)) * 2 ^ n = 1.
  rewrite eps_ordsucc_half_add n Hn.
  prove eps_ n * 2 ^ n = 1.
  exact IHn.
Qed.

Theorem eps_bd_1 : forall n :e omega, eps_ n <= 1.
let n. assume Hn.
prove eps_ n <= 1.
rewrite <- mul_SNo_oneR (eps_ n) (SNo_eps_ n Hn).
prove eps_ n * 1 <= 1.
rewrite <- mul_SNo_eps_power_2 n (omega_nat_p n Hn) at 2.
prove eps_ n * 1 <= eps_ n * 2 ^ n.
apply nonneg_mul_SNo_Le (eps_ n) 1 (2 ^ n) (SNo_eps_ n Hn).
- prove 0 <= eps_ n. apply SNoLtLe. exact SNo_eps_pos n Hn.
- exact SNo_1.
- prove SNo (2 ^ n). apply SNo_exp_SNo_nat.
  + exact SNo_2.
  + prove nat_p n. exact omega_nat_p n Hn.
- prove 1 <= 2 ^ n. apply exp_SNo_1_bd 2 SNo_2.
  + prove 1 <= 2. apply SNoLtLe. exact SNoLt_1_2.
  + prove nat_p n. exact omega_nat_p n Hn.
Qed.

Theorem mul_SNo_eps_power_2': forall n, nat_p n -> 2 ^ n * eps_ n = 1.
let n. assume Hn.
transitivity eps_ n * 2 ^ n.
- apply mul_SNo_com.
  + exact SNo_exp_SNo_nat 2 SNo_2 n Hn.
  + exact SNo_eps_ n (nat_p_omega n Hn).
- exact mul_SNo_eps_power_2 n Hn.
Qed.

Theorem exp_SNo_nat_mul_add : forall x, SNo x -> forall m, nat_p m -> forall n, nat_p n -> x ^ m * x ^ n = x ^ (m + n).
let x. assume Hx. let m. assume Hm.
claim Lm: SNo m.
{ exact nat_p_SNo m Hm. }
apply nat_ind.
- prove x ^ m * x ^ 0 = x ^ (m + 0).
  rewrite exp_SNo_nat_0 x Hx.
  rewrite add_SNo_0R m Lm.
  exact mul_SNo_oneR (x ^ m) (SNo_exp_SNo_nat x Hx m Hm).
- let n. assume Hn: nat_p n.
  assume IHn: x ^ m * x ^ n = x ^ (m + n).
  prove x ^ m * x ^ (ordsucc n) = x ^ (m + ordsucc n).
  rewrite exp_SNo_nat_S x Hx n Hn.
  prove x ^ m * (x * x ^ n) = x ^ (m + ordsucc n).
  rewrite <- add_nat_add_SNo m (nat_p_omega m Hm) (ordsucc n) (omega_ordsucc n (nat_p_omega n Hn)).
  prove x ^ m * (x * x ^ n) = x ^ (add_nat m (ordsucc n)).
  rewrite add_nat_SR m n Hn.
  prove x ^ m * (x * x ^ n) = x ^ (ordsucc (add_nat m n)).
  rewrite exp_SNo_nat_S x Hx (add_nat m n) (add_nat_p m Hm n Hn).
  prove x ^ m * (x * x ^ n) = x * x ^ (add_nat m n).
  rewrite add_nat_add_SNo m (nat_p_omega m Hm) n (nat_p_omega n Hn).
  prove x ^ m * (x * x ^ n) = x * x ^ (m + n).
  rewrite <- IHn.
  prove x ^ m * (x * x ^ n) = x * (x ^ m * x ^ n).
  rewrite mul_SNo_assoc (x ^ m) x (x ^ n) (SNo_exp_SNo_nat x Hx m Hm) Hx (SNo_exp_SNo_nat x Hx n Hn).
  prove (x ^ m * x) * x ^ n = x * (x ^ m * x ^ n).
  rewrite mul_SNo_com (x ^ m) x (SNo_exp_SNo_nat x Hx m Hm) Hx.
  prove (x * x ^ m) * x ^ n = x * (x ^ m * x ^ n).
  symmetry.
  exact mul_SNo_assoc x (x ^ m) (x ^ n) Hx (SNo_exp_SNo_nat x Hx m Hm) (SNo_exp_SNo_nat x Hx n Hn).
Qed.

Theorem exp_SNo_nat_mul_add' : forall x, SNo x -> forall m n :e omega, x ^ m * x ^ n = x ^ (m + n).
let x. assume Hx. let m. assume Hm. let n. assume Hn.
exact exp_SNo_nat_mul_add x Hx m (omega_nat_p m Hm) n (omega_nat_p n Hn).
Qed.

Theorem exp_SNo_nat_pos : forall x, SNo x -> 0 < x -> forall n, nat_p n -> 0 < x ^ n.
let x. assume Hx Hxpos.
apply nat_ind.
- prove 0 < x ^ 0. rewrite exp_SNo_nat_0 x Hx. prove 0 < 1. exact SNoLt_0_1.
- let n. assume Hn: nat_p n.
  assume IHn: 0 < x ^ n.
  prove 0 < x ^ (ordsucc n).
  rewrite exp_SNo_nat_S x Hx n Hn.
  prove 0 < x * x ^ n.
  rewrite <- mul_SNo_zeroR x Hx.
  prove x * 0 < x * x ^ n.
  exact pos_mul_SNo_Lt x 0 (x ^ n) Hx Hxpos SNo_0 (SNo_exp_SNo_nat x Hx n Hn) IHn.
Qed.

Theorem mul_SNo_eps_eps_add_SNo: forall m n :e omega, eps_ m * eps_ n = eps_ (m + n).
let m. assume Hm. let n. assume Hn.
claim Lmn1: m + n :e omega.
{ exact add_SNo_In_omega m Hm n Hn. }
claim Lmn2: nat_p (m + n).
{ exact omega_nat_p (m + n) Lmn1. }
claim Lem: SNo (eps_ m).
{ exact SNo_eps_ m Hm. }
claim Len: SNo (eps_ n).
{ exact SNo_eps_ n Hn. }
claim Lemen: SNo (eps_ m * eps_ n).
{ exact SNo_mul_SNo (eps_ m) (eps_ n) Lem Len. }
claim Lemn: SNo (eps_ (m + n)).
{ exact SNo_eps_ (m + n) Lmn1. }
claim L2m: SNo (2 ^ m).
{ exact SNo_exp_SNo_nat 2 SNo_2 m (omega_nat_p m Hm). }
claim L2n: SNo (2 ^ n).
{ exact SNo_exp_SNo_nat 2 SNo_2 n (omega_nat_p n Hn). }
apply mul_SNo_nonzero_cancel (2 ^ (m + n)).
- prove SNo (2 ^ (m + n)).
  exact SNo_exp_SNo_nat 2 SNo_2 (m + n) Lmn2.
- prove 2 ^ (m + n) <> 0.
  assume H1: 2 ^ (m + n) = 0.
  apply SNoLt_irref 0.
  prove 0 < 0. rewrite <- H1 at 2.
  prove 0 < 2 ^ (m + n).
  exact exp_SNo_nat_pos 2 SNo_2 SNoLt_0_2 (m + n) Lmn2.
- prove SNo (eps_ m * eps_ n). exact Lemen.
- prove SNo (eps_ (m + n)). exact Lemn.
- prove 2 ^ (m + n) * (eps_ m * eps_ n) = 2 ^ (m + n) * eps_ (m + n).
  transitivity (2 ^ m * 2 ^ n) * (eps_ m * eps_ n),
               2 ^ m * (2 ^ n * (eps_ m * eps_ n)),
               2 ^ m * eps_ m,
               1.
  + f_equal. symmetry. exact exp_SNo_nat_mul_add' 2 SNo_2 m Hm n Hn.
  + symmetry.
    exact mul_SNo_assoc (2 ^ m) (2 ^ n) (eps_ m * eps_ n) L2m L2n (SNo_mul_SNo (eps_ m) (eps_ n) Lem Len).
  + f_equal.
    prove 2 ^ n * (eps_ m * eps_ n) = eps_ m.
    transitivity (2 ^ n * eps_ n) * eps_ m, 1 * eps_ m.
    * rewrite mul_SNo_com (eps_ m) (eps_ n) Lem Len.
      exact mul_SNo_assoc (2 ^ n) (eps_ n) (eps_ m) L2n Len Lem.
    * f_equal. exact mul_SNo_eps_power_2' n (omega_nat_p n Hn).
    * exact mul_SNo_oneL (eps_ m) Lem.
  + prove 2 ^ m * eps_ m = 1. exact mul_SNo_eps_power_2' m (omega_nat_p m Hm).
  + symmetry.
    prove 2 ^ (m + n) * eps_ (m + n) = 1.
    exact mul_SNo_eps_power_2' (m + n) Lmn2.
Qed.

Theorem SNoS_omega_Lev_equip : forall n, nat_p n -> equip {x :e SNoS_ omega|SNoLev x = n} (2 ^ n).
apply nat_ind.
- prove equip {x :e SNoS_ omega|SNoLev x = 0} (2 ^ 0).
  rewrite exp_SNo_nat_0 2 SNo_2.
  prove equip {x :e SNoS_ omega|SNoLev x = 0} 1.
  apply equip_sym.
  prove exists f:set -> set, bij 1 {x :e SNoS_ omega|SNoLev x = 0} f.
  set f := fun i:set => 0.
  witness f.
  apply bijI.
  + let i. assume Hi: i :e 1.
    prove 0 :e {x :e SNoS_ omega|SNoLev x = 0}.
    apply SepI.
    * prove 0 :e SNoS_ omega.
      apply SNoS_I omega omega_ordinal 0 0 (nat_p_omega 0 nat_0).
      prove SNo_ 0 0. exact ordinal_SNo_ 0 ordinal_Empty.
    * prove SNoLev 0 = 0. exact SNoLev_0.
  + let i. assume Hi: i :e 1. let j. assume Hj: j :e 1.
    assume Hij: 0 = 0.
    prove i = j.
    apply cases_1 i Hi. apply cases_1 j Hj.
    prove 0 = 0. exact Hij. (** smaller proof than reflexivity, so use it **)
  + let x. assume Hx: x :e {x :e SNoS_ omega|SNoLev x = 0}.
    apply SepE (SNoS_ omega) (fun x => SNoLev x = 0) x Hx.
    assume Hx1: x :e SNoS_ omega.
    assume Hx2: SNoLev x = 0.
    apply SNoS_E2 omega omega_ordinal x Hx1.
    assume Hx1a: SNoLev x :e omega.
    assume Hx1b: ordinal (SNoLev x).
    assume Hx1c: SNo x.
    assume Hx1d: SNo_ (SNoLev x) x.
    claim L1: x = 0.
    { symmetry. apply SNo_eq 0 x SNo_0 Hx1c.
      - prove SNoLev 0 = SNoLev x. rewrite SNoLev_0. symmetry. exact Hx2.
      - prove SNoEq_ (SNoLev 0) 0 x. rewrite SNoLev_0.
        let alpha. assume Ha: alpha :e 0. prove False. exact EmptyE alpha Ha.
    }
    witness 0. apply andI.
    * exact In_0_1.
    * prove 0 = x. symmetry. exact L1.
- let n. assume Hn.
  assume IHn: equip {x :e SNoS_ omega|SNoLev x = n} (2 ^ n).
  prove equip {x :e SNoS_ omega|SNoLev x = ordsucc n} (2 ^ ordsucc n).
  rewrite exp_SNo_nat_S 2 SNo_2 n Hn.
  prove equip {x :e SNoS_ omega|SNoLev x = ordsucc n} (2 * 2 ^ n).
  rewrite <- add_SNo_1_1_2 at 1.
  prove equip {x :e SNoS_ omega|SNoLev x = ordsucc n} ((1 + 1) * 2 ^ n).
  rewrite mul_SNo_distrR 1 1 (2 ^ n) SNo_1 SNo_1 (SNo_exp_SNo_nat 2 SNo_2 n Hn).
  rewrite mul_SNo_oneL (2 ^ n) (SNo_exp_SNo_nat 2 SNo_2 n Hn).
  prove equip {x :e SNoS_ omega|SNoLev x = ordsucc n} (2 ^ n + 2 ^ n).
  claim L2n1: nat_p (2 ^ n).
  { exact nat_exp_SNo_nat 2 nat_2 n Hn. }
  claim L2n2: ordinal (2 ^ n).
  { apply nat_p_ordinal. exact L2n1. }
  claim L2n3: SNo (2 ^ n).
  { apply ordinal_SNo. exact L2n2. }
  claim L2n2n1: nat_p (2 ^ n + 2 ^ n).
  { apply omega_nat_p. apply add_SNo_In_omega.
    - apply nat_p_omega. exact L2n1.
    - apply nat_p_omega. exact L2n1.
  }
  claim L2n2n2: ordinal (2 ^ n + 2 ^ n).
  { apply nat_p_ordinal. exact L2n2n1. }
  claim L2n2n3: SNo (2 ^ n + 2 ^ n).
  { apply ordinal_SNo. exact L2n2n2. }
  claim L2npLt2n2n: forall m, SNo m -> m < 2 ^ n -> 2 ^ n + m < 2 ^ n + 2 ^ n.
  { let m. assume Hm H1.
    exact add_SNo_Lt2 (2 ^ n) m (2 ^ n) L2n3 Hm L2n3 H1.
  }
  claim L2nLt2n2n: 2 ^ n < 2 ^ n + 2 ^ n.
  { rewrite <- add_SNo_0R (2 ^ n) L2n3 at 1.
    prove 2 ^ n + 0 < 2 ^ n + 2 ^ n.
    apply L2npLt2n2n 0 SNo_0.
    prove 0 < 2 ^ n.
    exact exp_SNo_nat_pos 2 SNo_2 SNoLt_0_2 n Hn.
  }
  apply IHn.
  let f.
  assume Hf: bij {x :e SNoS_ omega|SNoLev x = n} (2 ^ n) f.
  apply bijE {x :e SNoS_ omega|SNoLev x = n} (2 ^ n) f Hf.
  assume Hf1: forall u :e {x :e SNoS_ omega|SNoLev x = n}, f u :e (2 ^ n).
  assume Hf2: forall u v :e {x :e SNoS_ omega|SNoLev x = n}, f u = f v -> u = v.
  assume Hf3: forall w :e 2 ^ n, exists u :e {x :e SNoS_ omega|SNoLev x = n}, f u = w.
  claim L2: forall x :e {x :e SNoS_ omega|SNoLev x = ordsucc n},
     forall p:prop,
          (SNo x
        -> SNoLev x = ordsucc n
        -> (x :/\: SNoElts_ n) :e {x :e SNoS_ omega|SNoLev x = n}
        -> SNo (x :/\: SNoElts_ n)
        -> SNoLev (x :/\: SNoElts_ n) = n
        -> p)
       -> p.
  { let x. assume Hx.
    apply SepE (SNoS_ omega) (fun x => SNoLev x = ordsucc n) x Hx.
    assume Hx HxSn.
    apply SNoS_E2 omega omega_ordinal x Hx.
    assume Hx1: SNoLev x :e omega.
    assume Hx2: ordinal (SNoLev x).
    assume Hx3: SNo x.
    assume Hx4: SNo_ (SNoLev x) x.
    let p. assume Hp.
    claim L2a: n :e SNoLev x.
    { rewrite HxSn. apply ordsuccI2. }
    claim L2b: SNoLev (x :/\: SNoElts_ n) = n.
    { exact restr_SNoLev x Hx3 n L2a. }
    apply Hp.
    - exact Hx3.
    - exact HxSn.
    - apply SepI.
      + prove (x :/\: SNoElts_ n) :e SNoS_ omega.
        apply SNoS_I omega omega_ordinal (x :/\: SNoElts_ n) n (nat_p_omega n Hn).
        prove SNo_ n (x :/\: SNoElts_ n).
        exact restr_SNo_ x Hx3 n L2a.
      + prove SNoLev (x :/\: SNoElts_ n) = n. exact L2b.
    - exact restr_SNo x Hx3 n L2a.
    - exact L2b.
  }
  claim Lf: forall u :e {x :e SNoS_ omega|SNoLev x = ordsucc n},
              forall p:prop,
                  (nat_p (f (u :/\: SNoElts_ n))
                -> ordinal (f (u :/\: SNoElts_ n))
                -> SNo (f (u :/\: SNoElts_ n))
                -> f (u :/\: SNoElts_ n) < 2 ^ n
                -> p)
               -> p.
  { let u. assume Hu. let p. assume Hp.
    apply L2 u Hu.
    assume Hu0a: SNo u.
    assume Hu0b: SNoLev u = ordsucc n.
    assume Hu1: (u :/\: SNoElts_ n) :e {x :e SNoS_ omega|SNoLev x = n}.
    assume Hu2: SNo (u :/\: SNoElts_ n).
    assume Hu3: SNoLev (u :/\: SNoElts_ n) = n.
    claim Lf1a: f (u :/\: SNoElts_ n) :e 2 ^ n.
    { exact Hf1 (u :/\: SNoElts_ n) Hu1. }
    claim Lf1b: nat_p (f (u :/\: SNoElts_ n)).
    { exact nat_p_trans (2 ^ n) L2n1 (f (u :/\: SNoElts_ n)) Lf1a. }
    claim Lf1c: ordinal (f (u :/\: SNoElts_ n)).
    { exact nat_p_ordinal (f (u :/\: SNoElts_ n)) Lf1b. }
    apply Hp.
    - exact Lf1b.
    - exact Lf1c.
    - apply ordinal_SNo. exact Lf1c.
    - apply ordinal_In_SNoLt.
      + prove ordinal (2 ^ n). exact L2n2.
      + prove f (u :/\: SNoElts_ n) :e 2 ^ n. exact Lf1a.
  }
  claim Lg: exists g:set -> set, (forall x, n :e x -> g x = f (x :/\: SNoElts_ n)) /\ (forall x, n /:e x -> g x = 2 ^ n + f (x :/\: SNoElts_ n)).
  { witness (fun x => if n :e x then f (x :/\: SNoElts_ n) else 2 ^ n + f (x :/\: SNoElts_ n)).
    apply andI.
    - let x. assume H1: n :e x.
      exact If_i_1 (n :e x) (f (x :/\: SNoElts_ n)) (2 ^ n + f (x :/\: SNoElts_ n)) H1.
    - let x. assume H1: n /:e x.
      exact If_i_0 (n :e x) (f (x :/\: SNoElts_ n)) (2 ^ n + f (x :/\: SNoElts_ n)) H1.
  }
  apply Lg. let g. assume H. apply H.
  assume Hg1: forall x, n :e x -> g x = f (x :/\: SNoElts_ n).
  assume Hg2: forall x, n /:e x -> g x = 2 ^ n + f (x :/\: SNoElts_ n).
  prove exists g:set -> set, bij {x :e SNoS_ omega|SNoLev x = ordsucc n} (2 ^ n + 2 ^ n) g.
  witness g. apply bijI.
  + let u. assume Hu: u :e {x :e SNoS_ omega|SNoLev x = ordsucc n}.
    prove g u :e 2 ^ n + 2 ^ n.
    apply L2 u Hu.
    assume Hu0a: SNo u.
    assume Hu0b: SNoLev u = ordsucc n.
    assume Hu1: (u :/\: SNoElts_ n) :e {x :e SNoS_ omega|SNoLev x = n}.
    assume Hu2: SNo (u :/\: SNoElts_ n).
    assume Hu3: SNoLev (u :/\: SNoElts_ n) = n.
    apply Lf u Hu.
    assume Lfu1: nat_p (f (u :/\: SNoElts_ n)).
    assume Lfu2: ordinal (f (u :/\: SNoElts_ n)).
    assume Lfu3: SNo (f (u :/\: SNoElts_ n)).
    assume Lfu4: f (u :/\: SNoElts_ n) < 2 ^ n.
    apply xm (n :e u).
    * assume H1: n :e u. rewrite Hg1 u H1.
      prove f (u :/\: SNoElts_ n) :e 2 ^ n + 2 ^ n.
      apply ordinal_SNoLt_In (f (u :/\: SNoElts_ n)) (2 ^ n + 2 ^ n) Lfu2 L2n2n2.
      prove f (u :/\: SNoElts_ n) < 2 ^ n + 2 ^ n.
      exact SNoLt_tra (f (u :/\: SNoElts_ n)) (2 ^ n) (2 ^ n + 2 ^ n) Lfu3 L2n3 L2n2n3 Lfu4 L2nLt2n2n.
    * assume H1: n /:e u. rewrite Hg2 u H1.
      prove 2 ^ n + f (u :/\: SNoElts_ n) :e 2 ^ n + 2 ^ n.
      apply ordinal_SNoLt_In (2 ^ n + f (u :/\: SNoElts_ n)) (2 ^ n + 2 ^ n)
                             (add_SNo_ordinal_ordinal (2 ^ n) L2n2 (f (u :/\: SNoElts_ n)) Lfu2)
                             L2n2n2.
      prove 2 ^ n + f (u :/\: SNoElts_ n) < 2 ^ n + 2 ^ n.
      exact L2npLt2n2n (f (u :/\: SNoElts_ n)) Lfu3 Lfu4.
  + let u. assume Hu: u :e {x :e SNoS_ omega|SNoLev x = ordsucc n}.
    let v. assume Hv: v :e {x :e SNoS_ omega|SNoLev x = ordsucc n}.
    apply L2 u Hu.
    assume Hu0a: SNo u.
    assume Hu0b: SNoLev u = ordsucc n.
    assume Hu1: (u :/\: SNoElts_ n) :e {x :e SNoS_ omega|SNoLev x = n}.
    assume Hu2: SNo (u :/\: SNoElts_ n).
    assume Hu3: SNoLev (u :/\: SNoElts_ n) = n.
    apply Lf u Hu.
    assume Lfu1: nat_p (f (u :/\: SNoElts_ n)).
    assume Lfu2: ordinal (f (u :/\: SNoElts_ n)).
    assume Lfu3: SNo (f (u :/\: SNoElts_ n)).
    assume Lfu4: f (u :/\: SNoElts_ n) < 2 ^ n.
    apply L2 v Hv.
    assume Hv0a: SNo v.
    assume Hv0b: SNoLev v = ordsucc n.
    assume Hv1: (v :/\: SNoElts_ n) :e {x :e SNoS_ omega|SNoLev x = n}.
    assume Hv2: SNo (v :/\: SNoElts_ n).
    assume Hv3: SNoLev (v :/\: SNoElts_ n) = n.
    apply Lf v Hv.
    assume Lfv1: nat_p (f (v :/\: SNoElts_ n)).
    assume Lfv2: ordinal (f (v :/\: SNoElts_ n)).
    assume Lfv3: SNo (f (v :/\: SNoElts_ n)).
    assume Lfv4: f (v :/\: SNoElts_ n) < 2 ^ n.
    claim LnLu: n :e SNoLev u.
    { rewrite Hu0b. apply ordsuccI2. }
    claim LnLv: n :e SNoLev v.
    { rewrite Hv0b. apply ordsuccI2. }
    apply xm (n :e u).
    * { assume H1: n :e u. rewrite Hg1 u H1.
        apply xm (n :e v).
        - assume H2: n :e v. rewrite Hg1 v H2.
          assume Hguv: f (u :/\: SNoElts_ n) = f (v :/\: SNoElts_ n).
          prove u = v.
          claim Luv: u :/\: SNoElts_ n = v :/\: SNoElts_ n.
          { exact Hf2 (u :/\: SNoElts_ n) Hu1 (v :/\: SNoElts_ n) Hv1 Hguv. }
          apply SNo_eq u v Hu0a Hv0a.
          + prove SNoLev u = SNoLev v. rewrite Hv0b. exact Hu0b.
          + prove SNoEq_ (SNoLev u) u v.
            rewrite Hu0b.
            prove SNoEq_ (ordsucc n) u v.
            let i. assume Hi: i :e ordsucc n.
            apply ordsuccE n i Hi.
            * { assume H3: i :e n.
                prove i :e u <-> i :e v.
                apply iff_trans (i :e u) (i :e u :/\: SNoElts_ n) (i :e v).
                - prove i :e u <-> i :e u :/\: SNoElts_ n.
                  apply iff_sym.
                  exact restr_SNoEq u ?? n LnLu i H3.
                - prove i :e u :/\: SNoElts_ n <-> i :e v.
                  rewrite Luv.
                  prove i :e v :/\: SNoElts_ n <-> i :e v.
                  exact restr_SNoEq v ?? n LnLv i H3.
              }
            * { assume H3: i = n. rewrite H3. apply iffI.
                - assume _. exact H2.
                - assume _. exact H1.
              }
        - assume H2: n /:e v. rewrite Hg2 v H2.
          assume Hguv: f (u :/\: SNoElts_ n) = 2 ^ n + f (v :/\: SNoElts_ n).
          prove False.
          apply SNoLt_irref (2 ^ n).
          prove 2 ^ n < 2 ^ n.
          apply SNoLeLt_tra (2 ^ n) (2 ^ n + f (v :/\: SNoElts_ n)) (2 ^ n)
                            L2n3
                            (SNo_add_SNo (2 ^ n) (f (v :/\: SNoElts_ n)) L2n3 Lfv3)
                            L2n3.
          + prove 2 ^ n <= 2 ^ n + f (v :/\: SNoElts_ n).
            rewrite <- add_SNo_0R (2 ^ n) L2n3 at 1.
            prove 2 ^ n + 0 <= 2 ^ n + f (v :/\: SNoElts_ n).
            apply add_SNo_Le2 (2 ^ n) 0 (f (v :/\: SNoElts_ n)) L2n3 SNo_0 Lfv3.
            prove 0 <= f (v :/\: SNoElts_ n).
            exact omega_nonneg (f (v :/\: SNoElts_ n)) (nat_p_omega (f (v :/\: SNoElts_ n)) Lfv1).
          + prove 2 ^ n + f (v :/\: SNoElts_ n) < 2 ^ n.
            rewrite <- Hguv. exact Lfu4.
      }
    * { assume H1: n /:e u. rewrite Hg2 u H1.
        apply xm (n :e v).
        - assume H2: n :e v. rewrite Hg1 v H2.
          assume Hguv: 2 ^ n + f (u :/\: SNoElts_ n) = f (v :/\: SNoElts_ n).
          prove False.
          apply SNoLt_irref (2 ^ n).
          prove 2 ^ n < 2 ^ n.
          apply SNoLeLt_tra (2 ^ n) (2 ^ n + f (u :/\: SNoElts_ n)) (2 ^ n)
                            L2n3
                            (SNo_add_SNo (2 ^ n) (f (u :/\: SNoElts_ n)) L2n3 Lfu3)
                            L2n3.
          + prove 2 ^ n <= 2 ^ n + f (u :/\: SNoElts_ n).
            rewrite <- add_SNo_0R (2 ^ n) L2n3 at 1.
            prove 2 ^ n + 0 <= 2 ^ n + f (u :/\: SNoElts_ n).
            apply add_SNo_Le2 (2 ^ n) 0 (f (u :/\: SNoElts_ n)) L2n3 SNo_0 Lfu3.
            prove 0 <= f (u :/\: SNoElts_ n).
            exact omega_nonneg (f (u :/\: SNoElts_ n)) (nat_p_omega (f (u :/\: SNoElts_ n)) Lfu1).
          + prove 2 ^ n + f (u :/\: SNoElts_ n) < 2 ^ n.
            rewrite Hguv. exact Lfv4.
        - assume H2: n /:e v. rewrite Hg2 v H2.
          assume Hguv: 2 ^ n + f (u :/\: SNoElts_ n) = 2 ^ n + f (v :/\: SNoElts_ n).
          prove u = v.
          claim Luv: u :/\: SNoElts_ n = v :/\: SNoElts_ n.
          { apply Hf2 (u :/\: SNoElts_ n) Hu1 (v :/\: SNoElts_ n) Hv1.
            prove f (u :/\: SNoElts_ n) = f (v :/\: SNoElts_ n).
            exact add_SNo_cancel_L (2 ^ n) (f (u :/\: SNoElts_ n)) (f (v :/\: SNoElts_ n)) L2n3 Lfu3 Lfv3 Hguv.
          }
          apply SNo_eq u v Hu0a Hv0a.
          + prove SNoLev u = SNoLev v. rewrite Hv0b. exact Hu0b.
          + prove SNoEq_ (SNoLev u) u v.
            rewrite Hu0b.
            prove SNoEq_ (ordsucc n) u v.
            let i. assume Hi: i :e ordsucc n.
            apply ordsuccE n i Hi.
            * { assume H3: i :e n.
                prove i :e u <-> i :e v.
                apply iff_trans (i :e u) (i :e u :/\: SNoElts_ n) (i :e v).
                - prove i :e u <-> i :e u :/\: SNoElts_ n.
                  apply iff_sym.
                  exact restr_SNoEq u ?? n LnLu i H3.
                - prove i :e u :/\: SNoElts_ n <-> i :e v.
                  rewrite Luv.
                  prove i :e v :/\: SNoElts_ n <-> i :e v.
                  exact restr_SNoEq v ?? n LnLv i H3.
              }
            * { assume H3: i = n. rewrite H3. apply iffI.
                - assume H4: n :e u. prove False. exact H1 H4.
                - assume H4: n :e v. prove False. exact H2 H4.
              }
      }
  + prove forall m :e 2 ^ n + 2 ^ n, exists u :e {x :e SNoS_ omega|SNoLev x = ordsucc n}, g u = m.
    let m. assume Hm: m :e 2 ^ n + 2 ^ n.
    claim Lm1: nat_p m.
    { exact nat_p_trans (2 ^ n + 2 ^ n) L2n2n1 m Hm. }
    claim Lm2: SNo m.
    { exact nat_p_SNo m Lm1. }
    apply add_SNo_omega_In_cases m (2 ^ n) (nat_p_omega (2 ^ n) L2n1) (2 ^ n) L2n1 Hm.
    * { assume H1: m :e 2 ^ n.
        apply Hf3 m H1.
        let u. assume H. apply H.
        assume Hu1: u :e {x :e SNoS_ omega|SNoLev x = n}.
        assume Hu2: f u = m.
        apply SepE (SNoS_ omega) (fun x => SNoLev x = n) u Hu1.
        assume Hu3: u :e SNoS_ omega.
        assume Hu4: SNoLev u = n.
        apply SNoS_E2 omega omega_ordinal u Hu3.
        assume Hu3a Hu3b Hu3c Hu3d.
        claim Lu1: SNo (SNo_extend1 u).
        { exact SNo_extend1_SNo u ??. }
        claim Lu2: SNoLev (SNo_extend1 u) = ordsucc n.
        { rewrite <- Hu4. exact SNo_extend1_SNoLev u ??. }
        claim Lu3: n :e SNo_extend1 u.
        { rewrite <- Hu4. exact SNo_extend1_In u ??. }
        witness (SNo_extend1 u). apply andI.
        - prove SNo_extend1 u :e {x :e SNoS_ omega|SNoLev x = ordsucc n}.
          apply SepI.
          + apply SNoS_I omega omega_ordinal (SNo_extend1 u) (ordsucc n).
            * prove ordsucc n :e omega. apply omega_ordsucc. exact nat_p_omega n Hn.
            * prove SNo_ (ordsucc n) (SNo_extend1 u).
              rewrite <- Hu4.
              prove SNo_ (ordsucc (SNoLev u)) (SNo_extend1 u).
              exact SNo_extend1_SNo_ u ??.
          + prove SNoLev (SNo_extend1 u) = ordsucc n. exact Lu2.
        - prove g (SNo_extend1 u) = m.
          rewrite Hg1 (SNo_extend1 u) Lu3.
          prove f (SNo_extend1 u :/\: SNoElts_ n) = m.
          rewrite <- Hu4.
          prove f (SNo_extend1 u :/\: SNoElts_ (SNoLev u)) = m.
          rewrite <- SNo_extend1_restr_eq u Hu3c.
          exact Hu2.
      }
    * { assume H1: m + - 2 ^ n :e 2 ^ n.
        apply Hf3 (m + - 2 ^ n) H1.
        let u. assume H. apply H.
        assume Hu1: u :e {x :e SNoS_ omega|SNoLev x = n}.
        assume Hu2: f u = m + - 2 ^ n.
        apply SepE (SNoS_ omega) (fun x => SNoLev x = n) u Hu1.
        assume Hu3: u :e SNoS_ omega.
        assume Hu4: SNoLev u = n.
        apply SNoS_E2 omega omega_ordinal u Hu3.
        assume Hu3a Hu3b Hu3c Hu3d.
        claim Lu1: SNo (SNo_extend0 u).
        { exact SNo_extend0_SNo u ??. }
        claim Lu2: SNoLev (SNo_extend0 u) = ordsucc n.
        { rewrite <- Hu4. exact SNo_extend0_SNoLev u ??. }
        claim Lu3: n /:e SNo_extend0 u.
        { rewrite <- Hu4. exact SNo_extend0_nIn u ??. }
        witness (SNo_extend0 u). apply andI.
        - prove SNo_extend0 u :e {x :e SNoS_ omega|SNoLev x = ordsucc n}.
          apply SepI.
          + apply SNoS_I omega omega_ordinal (SNo_extend0 u) (ordsucc n).
            * prove ordsucc n :e omega. apply omega_ordsucc. exact nat_p_omega n Hn.
            * prove SNo_ (ordsucc n) (SNo_extend0 u).
              rewrite <- Hu4.
              prove SNo_ (ordsucc (SNoLev u)) (SNo_extend0 u).
              exact SNo_extend0_SNo_ u ??.
          + prove SNoLev (SNo_extend0 u) = ordsucc n. exact Lu2.
        - prove g (SNo_extend0 u) = m.
          rewrite Hg2 (SNo_extend0 u) Lu3.
          prove 2 ^ n + f (SNo_extend0 u :/\: SNoElts_ n) = m.
          rewrite <- Hu4 at 2.
          prove 2 ^ n + f (SNo_extend0 u :/\: SNoElts_ (SNoLev u)) = m.
          rewrite <- SNo_extend0_restr_eq u Hu3c.
          prove 2 ^ n + f u = m.
          rewrite Hu2.
          prove 2 ^ n + (m + - 2 ^ n) = m.
          rewrite add_SNo_com (2 ^ n) (m + - 2 ^ n) L2n3 (SNo_add_SNo m (- 2 ^ n) Lm2 (SNo_minus_SNo (2 ^ n) L2n3)).
          prove (m + - 2 ^ n) + 2 ^ n = m.
          rewrite <- add_SNo_assoc m (- 2 ^ n) (2 ^ n) Lm2 (SNo_minus_SNo (2 ^ n) L2n3) L2n3.
          prove m + (- 2 ^ n + 2 ^ n) = m.
          rewrite add_SNo_minus_SNo_linv (2 ^ n) L2n3.
          prove m + 0 = m.
          exact add_SNo_0R m Lm2.
      }
Qed.

Theorem SNoS_finite : forall n :e omega, finite (SNoS_ n).
let n. assume Hn.
claim Ln: nat_p n.
{ exact omega_nat_p n Hn. }
claim Ln2: ordinal n.
{ exact nat_p_ordinal n Ln. }
claim L1: SNoS_ n = \/_ i :e n, {x :e SNoS_ omega|SNoLev x = i}.
{ apply set_ext.
  - let x. assume Hx.
    apply SNoS_E2 n Ln2 x Hx.
    assume Hx1: SNoLev x :e n.
    assume Hx2: ordinal (SNoLev x).
    assume Hx3: SNo x.
    assume Hx4: SNo_ (SNoLev x) x.
    apply famunionI n (fun i => {x :e SNoS_ omega|SNoLev x = i}) (SNoLev x) x Hx1.
    prove x :e {x' :e SNoS_ omega|SNoLev x' = SNoLev x}.
    apply SepI.
    + prove x :e SNoS_ omega.
      apply SNoS_Subq n omega Ln2 omega_ordinal.
      * prove n c= omega. exact omega_TransSet n Hn.
      * exact Hx.
    + prove SNoLev x = SNoLev x. reflexivity.
  - let x. assume Hx.
    apply famunionE_impred n (fun i => {x :e SNoS_ omega|SNoLev x = i}) x Hx.
    let i. assume Hi: i :e n.
    assume H1.
    apply SepE (SNoS_ omega) (fun x => SNoLev x = i) x H1.
    assume Hxa: x :e SNoS_ omega.
    assume Hxb: SNoLev x = i.
    prove x :e SNoS_ n.
    apply SNoS_E2 omega omega_ordinal x Hxa.
    assume Hx1: SNoLev x :e omega.
    assume Hx2: ordinal (SNoLev x).
    assume Hx3: SNo x.
    assume Hx4: SNo_ (SNoLev x) x.
    apply SNoS_I n Ln2 x (SNoLev x).
    - prove SNoLev x :e n. rewrite Hxb. exact Hi.
    - prove SNo_ (SNoLev x) x. exact Hx4.
}
rewrite L1.
prove finite (\/_ i :e n, {x :e SNoS_ omega|SNoLev x = i}).
apply famunion_nat_finite (fun i => {x :e SNoS_ omega|SNoLev x = i}) n Ln.
let i. assume Hi: i :e n.
prove finite {x :e SNoS_ omega|SNoLev x = i}.
prove exists m :e omega, equip {x :e SNoS_ omega|SNoLev x = i} m.
witness 2 ^ i.
apply andI.
- prove 2 ^ i :e omega. apply nat_p_omega.
  exact nat_exp_SNo_nat 2 nat_2 i (nat_p_trans n Ln i Hi).
- exact SNoS_omega_Lev_equip i (nat_p_trans n Ln i Hi).
Qed.

Theorem SNoS_omega_SNoL_finite : forall x :e SNoS_ omega, finite (SNoL x).
let x. assume Hx.
apply SNoS_E2 omega omega_ordinal x Hx.
assume Hx1: SNoLev x :e omega.
assume Hx2: ordinal (SNoLev x).
assume Hx3: SNo x.
assume Hx4: SNo_ (SNoLev x) x.
apply Subq_finite (SNoS_ (SNoLev x)).
- prove finite (SNoS_ (SNoLev x)).
  exact SNoS_finite (SNoLev x) Hx1.
- prove SNoL x c= SNoS_ (SNoLev x).
  let y. assume Hy.
  apply SNoL_E x Hx3 y Hy.
  assume Hy1 Hy2 Hy3.
  prove y :e SNoS_ (SNoLev x).
  apply SNoS_I2 y x ?? ??.
  prove SNoLev y :e SNoLev x.
  exact Hy2.  
Qed.

Theorem SNoS_omega_SNoR_finite : forall x :e SNoS_ omega, finite (SNoR x).
let x. assume Hx.
apply SNoS_E2 omega omega_ordinal x Hx.
assume Hx1: SNoLev x :e omega.
assume Hx2: ordinal (SNoLev x).
assume Hx3: SNo x.
assume Hx4: SNo_ (SNoLev x) x.
apply Subq_finite (SNoS_ (SNoLev x)).
- prove finite (SNoS_ (SNoLev x)).
  exact SNoS_finite (SNoLev x) Hx1.
- prove SNoR x c= SNoS_ (SNoLev x).
  let y. assume Hy.
  apply SNoR_E x Hx3 y Hy.
  assume Hy1 Hy2 Hy3.
  prove y :e SNoS_ (SNoLev x).
  apply SNoS_I2 y x ?? ??.
  prove SNoLev y :e SNoLev x.
  exact Hy2.  
Qed.

End SurrealExp.

Opaque exp_SNo_nat.

Section SNoMaxMin.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Definition SNo_max_of : set -> set -> prop := fun X x => x :e X /\ SNo x /\ forall y :e X, SNo y -> y <= x.
Definition SNo_min_of : set -> set -> prop := fun X x => x :e X /\ SNo x /\ forall y :e X, SNo y -> x <= y.

Theorem minus_SNo_max_min : forall X y, (forall x :e X, SNo x) -> SNo_max_of X y -> SNo_min_of {- x|x :e X} (- y).
let X y. assume HX H1.
apply H1. assume H. apply H.
assume H1a: y :e X.
assume H1b: SNo y.
assume H1c: forall z :e X, SNo z -> z <= y.
prove - y :e {- x|x :e X} /\ SNo (- y) /\ (forall z :e {- x|x :e X}, SNo z -> - y <= z).
apply and3I.
- apply ReplI. exact H1a.
- exact SNo_minus_SNo y H1b.
- let z. assume Hz1: z :e {- x|x :e X}.
  assume Hz2: SNo z.
  apply ReplE_impred X (fun x => - x) z Hz1.
  let x. assume Hx: x :e X.
  assume Hze: z = - x.
  rewrite Hze.
  prove - y <= - x.
  apply minus_SNo_Le_contra x y (HX x Hx) H1b.
  prove x <= y. exact H1c x Hx (HX x Hx).
Qed.

Theorem minus_SNo_max_min' : forall X y, (forall x :e X, SNo x) -> SNo_max_of {- x|x :e X} y -> SNo_min_of X (- y).
let X y. assume HX H1.
claim L1: {- z|z :e {- x|x :e X}} = X.
{ apply Repl_invol_eq SNo minus_SNo.
  - prove forall x, SNo x -> - - x = x. exact minus_SNo_invol.
  - prove forall x :e X, SNo x. exact HX.
}
claim L2: forall z :e {- x|x :e X}, SNo z.
{ let z. assume Hz.
  apply ReplE_impred X (fun x => - x) z Hz.
  let x. assume Hx: x :e X.
  assume Hzx: z = - x.
  rewrite Hzx. apply SNo_minus_SNo.
  prove SNo x. exact HX x Hx.
}
rewrite <- L1.
exact minus_SNo_max_min {- x|x :e X} y L2 H1.
Qed.

Theorem minus_SNo_min_max : forall X y, (forall x :e X, SNo x) -> SNo_min_of X y -> SNo_max_of {- x|x :e X} (- y).
let X y. assume HX H1.
apply H1. assume H. apply H.
assume H1a: y :e X.
assume H1b: SNo y.
assume H1c: forall z :e X, SNo z -> y <= z.
prove - y :e {- x|x :e X} /\ SNo (- y) /\ (forall z :e {- x|x :e X}, SNo z -> z <= - y).
apply and3I.
- apply ReplI. exact H1a.
- exact SNo_minus_SNo y H1b.
- let z. assume Hz1: z :e {- x|x :e X}.
  assume Hz2: SNo z.
  apply ReplE_impred X (fun x => - x) z Hz1.
  let x. assume Hx: x :e X.
  assume Hze: z = - x.
  rewrite Hze.
  prove -x <= - y.
  apply minus_SNo_Le_contra y x H1b (HX x Hx).
  prove y <= x. exact H1c x Hx (HX x Hx).
Qed.

Theorem double_SNo_max_1 : forall x y, SNo x -> SNo_max_of (SNoL x) y -> forall z, SNo z -> x < z -> y + z < x + x -> exists w :e SNoR z, y + w = x + x.
let x y. assume Hx Hy.
apply Hy. assume H. apply H.
assume Hy1: y :e SNoL x.
assume Hy2: SNo y.
assume Hy3: forall w :e SNoL x, SNo w -> w <= y.
apply SNoL_E x Hx y Hy1.
assume Hy1a.
assume Hy1b: SNoLev y :e SNoLev x.
assume Hy1c: y < x.
apply SNoLev_ind.
let z. assume Hz: SNo z.
assume IH: forall w :e SNoS_ (SNoLev z), x < w -> y + w < x + x -> exists u :e SNoR w, y + u = x + x.
assume H1: x < z.
assume H2: y + z < x + x.
prove exists w :e SNoR z, y + w = x + x.
claim Lxx: SNo (x + x).
{ exact SNo_add_SNo x x Hx Hx. }
claim Lyz: SNo (y + z).
{ exact SNo_add_SNo y z Hy2 Hz. }
claim L1: forall w :e SNoR y, w + z <= x + x -> False.
{ let w. assume Hw.
  assume H3: w + z <= x + x.
  apply SNoR_E y Hy2 w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev y.
  assume Hw3: y < w.
  apply SNoLt_irref (x + x).
  prove x + x < x + x.
  apply SNoLtLe_tra (x + x) (w + z) (x + x) Lxx (SNo_add_SNo w z Hw1 Hz) Lxx.
  - prove x + x < w + z.
    apply add_SNo_Lt3b x x w z Hx Hx Hw1 Hz.
    + prove x <= w.
      apply SNoLtLe_or w x Hw1 Hx.
      * assume H4: w < x.
        claim L1a: w :e SNoL x.
        { apply SNoL_I x Hx w Hw1.
          - prove SNoLev w :e SNoLev x.
            exact ordinal_TransSet (SNoLev x) (SNoLev_ordinal x Hx) (SNoLev y) Hy1b (SNoLev w) Hw2.
          - prove w < x. exact H4.
        }
        apply SNoLt_irref y.
        prove y < y.
        apply SNoLtLe_tra y w y Hy2 Hw1 Hy2 Hw3.
        prove w <= y.
        exact Hy3 w L1a Hw1.
      * assume H4: x <= w. exact H4.
    + prove x < z. exact H1.
  - prove w + z <= x + x. exact H3.
}
claim L2: forall w :e SNoL x, y + z <= w + x -> False.
{ let w. assume Hw.
  assume H3: y + z <= w + x.
  apply SNoL_E x Hx w Hw.
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e SNoLev x.
  assume Hw3: w < x.
  apply SNoLt_irref (w + x).
  prove w + x < w + x.
  apply SNoLtLe_tra (w + x) (w + z) (w + x)
                    (SNo_add_SNo w x Hw1 Hx)
                    (SNo_add_SNo w z Hw1 Hz)
                    (SNo_add_SNo w x Hw1 Hx).
  - prove w + x < w + z.
    apply add_SNo_Lt2 w x z Hw1 Hx Hz.
    prove x < z. exact H1.
  - prove w + z <= w + x.
    apply SNoLe_tra (w + z) (y + z) (w + x)
                    (SNo_add_SNo w z Hw1 Hz)
                    Lyz
                    (SNo_add_SNo w x Hw1 Hx).
    + prove w + z <= y + z.
      apply add_SNo_Le1 w z y Hw1 Hz Hy2.
      prove w <= y.
      exact Hy3 w Hw Hw1.
    + prove y + z <= w + x. exact H3.
}
claim L3: forall w :e SNoR z, y + w < x + x -> exists w :e SNoR z, y + w = x + x.
{ let w.
  assume Hw: w :e SNoR z.
  assume H4: y + w < x + x.
  apply SNoR_E z Hz w Hw.
  assume Hw1: SNo w.
  assume Hw2.
  assume Hw3: z < w.
  claim LIH: exists u :e SNoR w, y + u = x + x.
  { apply IH w (SNoR_SNoS_ z w Hw).
    - prove x < w. exact SNoLt_tra x z w Hx Hz Hw1 H1 Hw3.
    - prove y + w < x + x. exact H4.
  }
  apply LIH.
  let u. assume H. apply H.
  assume Hu1: u :e SNoR w.
  assume Hu2: y + u = x + x.
  apply SNoR_E w Hw1 u Hu1.
  assume Hu1a Hu1b Hu1c.
  witness u. apply andI.
  - prove u :e SNoR z.
    apply SNoR_I z Hz u Hu1a.
    + prove SNoLev u :e SNoLev z.
      exact ordinal_TransSet (SNoLev z) (SNoLev_ordinal z Hz) (SNoLev w) Hw2 (SNoLev u) Hu1b.
    + prove z < u. exact SNoLt_tra z w u Hz Hw1 Hu1a Hw3 Hu1c.
  - exact Hu2.
}
apply SNoLt_SNoL_or_SNoR_impred (y + z) (x + x) Lyz Lxx H2.
- let u.
  assume Hu1: u :e SNoL (x + x).
  assume Hu2: u :e SNoR (y + z).
  apply SNoL_E (x + x) Lxx u Hu1.
  assume Hu1a: SNo u.
  assume Hu1b.
  assume Hu1c: u < x + x.
  apply add_SNo_SNoR_interpolate y z Hy2 Hz u Hu2.
  + assume H. apply H.
    let w. assume H. apply H.
    assume Hw: w :e SNoR y.
    assume H4: w + z <= u.
    apply SNoR_E y Hy2 w Hw.
    assume Hw1: SNo w.
    assume Hw2.
    assume Hw3: y < w.
    prove False.
    apply L1 w Hw.
    prove w + z <= x + x.
    apply SNoLtLe.
    prove w + z < x + x.
    apply SNoLeLt_tra (w + z) u (x + x) (SNo_add_SNo w z Hw1 Hz) Hu1a Lxx H4.
    prove u < x + x.
    exact Hu1c.
  + assume H. apply H.
    let w. assume H. apply H.
    assume Hw: w :e SNoR z.
    assume H4: y + w <= u.
    apply SNoR_E z Hz w Hw.
    assume Hw1: SNo w.
    assume Hw2.
    assume Hw3: z < w.
    apply L3 w Hw.
    prove y + w < x + x.
    apply SNoLeLt_tra (y + w) u (x + x) (SNo_add_SNo y w Hy2 Hw1) Hu1a Lxx H4.
    prove u < x + x.
    exact Hu1c.
- assume H3: y + z :e SNoL (x + x). prove False.
  apply add_SNo_SNoL_interpolate x x Hx Hx (y + z) H3.
  + assume H. apply H.
    let w. assume H. apply H.
    assume Hw: w :e SNoL x.
    assume H4: y + z <= w + x.
    exact L2 w Hw H4.
  + assume H. apply H.
    let w. assume H. apply H.
    assume Hw: w :e SNoL x.
    assume H4: y + z <= x + w.
    apply SNoL_E x Hx w Hw.
    assume Hw1 Hw2 Hw3.
    apply L2 w Hw.
    prove y + z <= w + x.
    rewrite add_SNo_com w x Hw1 Hx.
    prove y + z <= x + w.
    exact H4.
- assume H3: x + x :e SNoR (y + z).
  apply add_SNo_SNoR_interpolate y z Hy2 Hz (x + x) H3.
  + assume H. apply H.
    let w. assume H. apply H.
    assume Hw: w :e SNoR y.
    assume H4: w + z <= x + x.
    prove False.
    exact L1 w Hw H4.
  + assume H. apply H.
    let w. assume H. apply H.
    assume Hw: w :e SNoR z.
    assume H4: y + w <= x + x.
    apply SNoR_E z Hz w Hw.
    assume Hw1: SNo w.
    assume Hw2: SNoLev w :e SNoLev z.
    assume Hw3: z < w.
    apply SNoLtLe_or (y + w) (x + x) (SNo_add_SNo y w Hy2 Hw1) Lxx.
    * assume H5: y + w < x + x.
      prove exists w :e SNoR z, y + w = x + x.
      apply L3 w Hw.
      prove y + w < x + x.
      exact H5.
    * { assume H5: x + x <= y + w.
        prove exists w :e SNoR z, y + w = x + x.
        witness w. apply andI.
        - exact Hw.
        - apply SNoLe_antisym (y + w) (x + x) (SNo_add_SNo y w Hy2 Hw1) Lxx.
          + exact H4.
          + exact H5.
      }
Qed.

Theorem double_SNo_min_1 : forall x y, SNo x -> SNo_min_of (SNoR x) y -> forall z, SNo z -> z < x -> x + x < y + z -> exists w :e SNoL z, y + w = x + x.
let x y. assume Hx Hy.
apply Hy. assume H. apply H.
assume Hy1: y :e SNoR x.
assume Hy2: SNo y.
assume Hy3: forall w :e SNoR x, SNo w -> y <= w.
apply SNoR_E x Hx y Hy1.
assume Hy1a.
assume Hy1b: SNoLev y :e SNoLev x.
assume Hy1c: x < y.
let z. assume Hz: SNo z.
assume H1: z < x.
assume H2: x + x < y + z.
claim Lmx: SNo (- x).
{ exact SNo_minus_SNo x Hx. }
claim Lmy: SNo (- y).
{ exact SNo_minus_SNo y Hy2. }
claim Lmz: SNo (- z).
{ exact SNo_minus_SNo z Hz. }
claim Lxx: SNo (x + x).
{ exact SNo_add_SNo x x Hx Hx. }
claim Lyz: SNo (y + z).
{ exact SNo_add_SNo y z Hy2 Hz. }
claim L1: SNo_max_of (SNoL (- x)) (- y).
{ rewrite SNoL_minus_SNoR x Hx.
  prove SNo_max_of {- w|w :e SNoR x} (- y).
  apply minus_SNo_min_max.
  - prove forall w :e SNoR x, SNo w.
    let w. assume Hw.
    apply SNoR_E x Hx w Hw.
    assume Hw1 _ _. exact Hw1.
  - prove SNo_min_of (SNoR x) y. exact Hy.
}
claim L2: - x < - z.
{ exact minus_SNo_Lt_contra z x Hz Hx H1. }
claim L3: - y + - z < - x + - x.
{ rewrite <- minus_add_SNo_distr y z Hy2 Hz.
  rewrite <- minus_add_SNo_distr x x Hx Hx.
  exact minus_SNo_Lt_contra (x + x) (y + z) Lxx Lyz H2.
}
apply double_SNo_max_1 (- x) (- y) Lmx L1 (- z) Lmz L2 L3.
let w. assume H. apply H.
assume Hw: w :e SNoR (- z).
rewrite <- minus_add_SNo_distr x x Hx Hx.
assume H3: - y + w = - (x + x).
apply SNoR_E (- z) Lmz w Hw.
assume Hw1: SNo w.
assume Hw2: SNoLev w :e SNoLev (- z).
assume Hw3: - z < w.
claim Lmw: SNo (- w).
{ exact SNo_minus_SNo w Hw1. }
witness (- w). apply andI.
- prove - w :e SNoL z.
  rewrite <- minus_SNo_invol z Hz.
  prove - w :e SNoL (- - z).
  rewrite SNoL_minus_SNoR (- z) Lmz.
  prove - w :e {- w|w :e SNoR (- z)}.
  apply ReplI.
  exact Hw.
- prove y + - w = x + x.
  rewrite <- minus_SNo_invol (x + x) Lxx.
  prove y + - w = - - (x + x).
  rewrite <- H3.
  prove y + - w = - (- y + w).
  rewrite minus_add_SNo_distr (- y) w Lmy Hw1.
  prove y + - w = - - y + - w.
  rewrite minus_SNo_invol y Hy2.
  reflexivity.
Qed.

Theorem finite_max_exists : forall X, (forall x :e X, SNo x) -> finite X -> X <> 0 -> exists x, SNo_max_of X x.
claim L1: forall n, nat_p n -> forall X, (forall x :e X, SNo x) -> equip X (ordsucc n) -> exists x, SNo_max_of X x.
{ apply nat_ind.
  - let X. assume HX.
    assume H1: equip X 1.
    apply equip_sym X 1 H1.
    let f. assume Hf: bij 1 X f.
    apply bijE 1 X f Hf. assume Hf1 Hf2 Hf3.
    witness f 0.
    prove SNo_max_of X (f 0).
    prove f 0 :e X /\ SNo (f 0) /\ forall y :e X, SNo y -> y <= f 0.
    claim Lf0X: f 0 :e X.
    { exact Hf1 0 In_0_1. }
    apply and3I.
    + prove f 0 :e X. exact Lf0X.
    + exact HX (f 0) Lf0X.
    + let y. assume Hy: y :e X. assume Hy2: SNo y.
      apply Hf3 y Hy.
      let i. assume H. apply H.
      assume Hi: i :e 1.
      assume Hyi: f i = y.
      prove y <= f 0.
      rewrite <- Hyi.
      apply cases_1 i Hi.
      prove f 0 <= f 0. apply SNoLe_ref.
  - let n. assume Hn.
    assume IHn: forall X, (forall x :e X, SNo x) -> equip X (ordsucc n) -> exists x, SNo_max_of X x.
    let X. assume HX.
    assume H1: equip X (ordsucc (ordsucc n)).
    apply equip_sym X (ordsucc (ordsucc n)) H1.
    let f. assume Hf: bij (ordsucc (ordsucc n)) X f.
    apply bijE (ordsucc (ordsucc n)) X f Hf. assume Hf1 Hf2 Hf3.
    set X' := {f i|i :e ordsucc n}.
    claim LX'1: X' c= X.
    { let w. assume Hw: w :e X'.
      apply ReplE_impred (ordsucc n) f w Hw.
      let i. assume Hi: i :e ordsucc n.
      assume Hwi: w = f i. rewrite Hwi.
      prove f i :e X.
      apply Hf1 i.
      apply ordsuccI1. exact Hi.
    }
    claim LX'2: equip X' (ordsucc n).
    { apply equip_sym.
      prove exists f:set -> set, bij (ordsucc n) X' f.
      witness f.
      apply bijI.
      - let i. assume Hi: i :e ordsucc n.
        prove f i :e X'. apply ReplI. exact Hi.
      - let i. assume Hi. let j. assume Hj.
        assume Hij: f i = f j.
        apply Hf2.
        + prove i :e ordsucc (ordsucc n). apply ordsuccI1. exact Hi.
        + prove j :e ordsucc (ordsucc n). apply ordsuccI1. exact Hj.
        + exact Hij.
      - let w. assume Hw: w :e X'.
        apply ReplE_impred (ordsucc n) f w Hw.
        let i. assume Hi: i :e ordsucc n.
        assume Hwi: w = f i.
        witness i. apply andI.
        + exact Hi.
        + symmetry. exact Hwi.
    }
    apply IHn X' (fun x' Hx' => HX x' (LX'1 x' Hx')) LX'2.
    let z. assume H. apply H. assume H. apply H.
    assume Hz1: z :e X'.
    assume Hz2: SNo z.
    assume Hz3: forall y :e X', SNo y -> y <= z.
    claim Lfn1: f (ordsucc n) :e X.
    { apply Hf1 (ordsucc n). apply ordsuccI2. }
    claim Lfn1': SNo (f (ordsucc n)).
    { apply HX (f (ordsucc n)) Lfn1. }
    apply SNoLtLe_or z (f (ordsucc n)) Hz2 Lfn1'.
    + assume H2: z < f (ordsucc n).
      witness (f (ordsucc n)).
      prove f (ordsucc n) :e X /\ SNo (f (ordsucc n)) /\ forall y :e X, SNo y -> y <= f (ordsucc n).
      apply and3I.
      * exact Lfn1.
      * exact Lfn1'.
      * { let y. assume Hy Hy2.
          apply Hf3 y Hy.
          let i. assume H. apply H.
          assume Hi: i :e ordsucc (ordsucc n).
          assume Hyi: f i = y.
          apply ordsuccE (ordsucc n) i Hi.
          - assume H3: i :e ordsucc n.
            prove y <= f (ordsucc n).
            apply SNoLe_tra y z (f (ordsucc n)) Hy2 Hz2 Lfn1'.
            + prove y <= z. apply Hz3 y.
              * prove y :e X'. rewrite <- Hyi. prove f i :e X'. apply ReplI. exact H3.
              * exact Hy2.
            + prove z <= f (ordsucc n). apply SNoLtLe. exact H2.
          - assume H3: i = ordsucc n.
            rewrite <- Hyi. rewrite H3.
            prove f (ordsucc n) <= f (ordsucc n).
            apply SNoLe_ref.
        }
    + assume H2: f (ordsucc n) <= z.
      witness z.
      prove z :e X /\ SNo z /\ forall y :e X, SNo y -> y <= z.
      apply and3I.
      * exact LX'1 z Hz1.
      * exact Hz2.
      * { let y. assume Hy Hy2.
          apply Hf3 y Hy.
          let i. assume H. apply H.
          assume Hi: i :e ordsucc (ordsucc n).
          assume Hyi: f i = y.
          apply ordsuccE (ordsucc n) i Hi.
          - assume H3: i :e ordsucc n.
            prove y <= z.
            apply Hz3 y.
            + prove y :e X'. rewrite <- Hyi. prove f i :e X'. apply ReplI. exact H3.
            + exact Hy2.
          - assume H3: i = ordsucc n.
            rewrite <- Hyi. rewrite H3.
            prove f (ordsucc n) <= z. exact H2.
        }
}
let X. assume HX.
assume H1: finite X. apply H1.
let n. assume H. apply H.
assume Hn: n :e omega.
apply nat_inv n (omega_nat_p n Hn).
- assume Hn0: n = 0.
  rewrite Hn0.
  assume H2: equip X 0.
  assume H3: X <> 0.
  prove False.
  apply H2. let f. assume Hf: bij X 0 f.
  apply bijE X 0 f Hf.
  assume Hf1 _ _.
  apply H3. apply Empty_eq.
  let x. assume Hx.
  apply EmptyE (f x).
  exact Hf1 x Hx.
- assume H. apply H.
  let m. assume H. apply H.
  assume Hm: nat_p m.
  assume Hnm: n = ordsucc m.
  rewrite Hnm.
  assume H2: equip X (ordsucc m).
  assume _.
  exact L1 m Hm X HX H2.
Qed.

Theorem finite_min_exists : forall X, (forall x :e X, SNo x) -> finite X -> X <> 0 -> exists x, SNo_min_of X x.
let X.
assume HX: forall x :e X, SNo x.
assume H1: finite X.
assume H2: X <> 0.
set X' := {- x|x :e X}.
claim L1: forall z :e X', SNo z.
{ let z. assume Hz.
  apply ReplE_impred X (fun x => - x) z Hz.
  let x. assume Hx: x :e X.
  assume Hzx: z = - x.
  rewrite Hzx. apply SNo_minus_SNo.
  prove SNo x. exact HX x Hx.
}
claim L2: finite X'.
{ apply H1.
  let n. assume H. apply H.
  assume Hn: n :e omega.
  assume H3: equip X n.
  prove exists n :e omega, equip X' n.
  witness n. apply andI.
  - exact Hn.
  - prove equip X' n.
    apply equip_tra X' X n.
    + prove equip X' X. apply equip_sym.
      prove equip X X'.
      prove exists f : set -> set, bij X X' f.
      witness minus_SNo.
      apply bijI.
      * let x. assume Hx: x :e X.
        prove - x :e X'. apply ReplI. exact Hx.
      * { let x. assume Hx. let x'. assume Hx'.
          assume Hxx': - x = - x'.
          prove x = x'.
          transitivity - - x, - - x'.
          - symmetry. exact minus_SNo_invol x (HX x Hx).
          - f_equal. exact Hxx'.
          - exact minus_SNo_invol x' (HX x' Hx').
        }
      * { let w. assume Hw: w :e X'.
          apply ReplE_impred X (fun x => - x) w Hw.
          let x. assume Hx.
          assume Hwx: w = - x.
          prove exists u :e X, - u = w.
          witness x.
          apply andI.
          - exact Hx.
          - symmetry. exact Hwx.
        }
    + prove equip X n. exact H3.
}
claim L3: X' <> 0.
{ assume H1: X' = 0.
  apply H2. prove X = 0.
  apply Empty_eq.
  let x. assume Hx: x :e X.
  apply EmptyE (- x).
  prove - x :e 0.
  rewrite <- H1. apply ReplI. exact Hx.
}
apply finite_max_exists X' L1 L2 L3.
let y.
assume Hy: SNo_max_of X' y.
witness (- y).
prove SNo_min_of X (- y).
exact minus_SNo_max_min' X y HX Hy.
Qed.

Theorem SNoS_omega_SNoL_max_exists : forall x :e SNoS_ omega, SNoL x = 0 \/ exists y, SNo_max_of (SNoL x) y.
let x. assume Hx.
apply xm (SNoL x = 0).
- assume H1: SNoL x = 0. apply orIL. exact H1.
- assume H1: SNoL x <> 0. apply orIR.
  claim L1: forall y :e SNoL x, SNo y.
  { let y. assume Hy.
    apply SNoS_E2 omega omega_ordinal x Hx.
    assume _ _ Hx3 _.
    apply SNoL_E x Hx3 y Hy.
    assume H _ _. exact H.
  }
  exact finite_max_exists (SNoL x) L1 (SNoS_omega_SNoL_finite x Hx) H1.
Qed.

Theorem SNoS_omega_SNoR_min_exists : forall x :e SNoS_ omega, SNoR x = 0 \/ exists y, SNo_min_of (SNoR x) y.
let x. assume Hx.
apply xm (SNoR x = 0).
- assume H1: SNoR x = 0. apply orIL. exact H1.
- assume H1: SNoR x <> 0. apply orIR.
  claim L1: forall y :e SNoR x, SNo y.
  { let y. assume Hy.
    apply SNoS_E2 omega omega_ordinal x Hx.
    assume _ _ Hx3 _.
    apply SNoR_E x Hx3 y Hy.
    assume H _ _. exact H.
  }
  exact finite_min_exists (SNoR x) L1 (SNoS_omega_SNoR_finite x Hx) H1.
Qed.

End SNoMaxMin.

Section DiadicRationals.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.

Theorem nonneg_diadic_rational_p_SNoS_omega: forall k :e omega, forall n, nat_p n -> eps_ k * n :e SNoS_ omega.
let k. assume Hk.
claim Lek: SNo (eps_ k).
{ exact SNo_eps_ k Hk. }
claim Lek2: eps_ k :e SNoS_ omega.
{ exact SNo_eps_SNoS_omega k Hk. }
apply nat_ind.
- prove eps_ k * 0 :e SNoS_ omega. rewrite mul_SNo_zeroR (eps_ k) Lek.
  prove 0 :e SNoS_ omega.
  exact omega_SNoS_omega 0 (nat_p_omega 0 nat_0).
- let n. assume Hn.
  assume IHn: eps_ k * n :e SNoS_ omega.
  prove eps_ k * ordsucc n :e SNoS_ omega.
  rewrite <- add_SNo_1_ordsucc n (nat_p_omega n Hn).
  prove eps_ k * (n + 1) :e SNoS_ omega.
  rewrite mul_SNo_distrL (eps_ k) n 1 Lek (omega_SNo n (nat_p_omega n Hn)) (omega_SNo 1 (nat_p_omega 1 nat_1)).
  prove eps_ k * n + eps_ k * 1 :e SNoS_ omega.
  rewrite mul_SNo_oneR (eps_ k) Lek.
  prove eps_ k * n + eps_ k :e SNoS_ omega.
  apply add_SNo_SNoS_omega.
  + exact IHn.
  + exact SNo_eps_SNoS_omega k Hk.
Qed.

Definition diadic_rational_p : set -> prop := fun x => exists k :e omega, exists m :e int, x = eps_ k * m.

Theorem diadic_rational_p_SNoS_omega: forall x, diadic_rational_p x -> x :e SNoS_ omega.
let x. 
assume H. apply H.
let k. assume H. apply H.
assume Hk: k :e omega. assume H. apply H.
let m.  assume H. apply H.
assume Hm: m :e int.
assume Hxkm: x = eps_ k * m.
rewrite Hxkm.
prove eps_ k * m :e SNoS_ omega.
claim L1: forall n :e omega, eps_ k * n :e SNoS_ omega.
{ let n. assume Hn: n :e omega.
  prove eps_ k * n :e SNoS_ omega.
  exact nonneg_diadic_rational_p_SNoS_omega k Hk n (omega_nat_p n Hn).
}
claim L2: forall n :e omega, eps_ k * (- n) :e SNoS_ omega.
{ let n. assume Hn: n :e omega.
  prove eps_ k * (- n) :e SNoS_ omega.
  rewrite mul_SNo_minus_distrR (eps_ k) n (SNo_eps_ k Hk) (omega_SNo n Hn).
  apply minus_SNo_SNoS_omega.
  exact nonneg_diadic_rational_p_SNoS_omega k Hk n (omega_nat_p n Hn).
}
exact int_SNo_cases (fun m => eps_ k * m :e SNoS_ omega) L1 L2 m Hm.
Qed.

Theorem int_diadic_rational_p : forall m :e int, diadic_rational_p m.
let m. assume Hm.
prove exists k :e omega, exists m' :e int, m = eps_ k * m'.
witness 0. apply andI.
- exact nat_p_omega 0 nat_0.
- witness m. apply andI.
  + exact Hm.
  + prove m = eps_ 0 * m.
    rewrite eps_0_1. symmetry. exact mul_SNo_oneL m (int_SNo m Hm).
Qed.

Theorem omega_diadic_rational_p : forall m :e omega, diadic_rational_p m.
let m. assume Hm. apply int_diadic_rational_p.
apply Subq_omega_int. exact Hm.
Qed.

Theorem eps_diadic_rational_p : forall k :e omega, diadic_rational_p (eps_ k).
let k. assume Hk.
prove exists k' :e omega, exists m :e int, eps_ k = eps_ k' * m.
witness k. apply andI.
- exact Hk.
- witness 1. apply andI.
  + apply Subq_omega_int. exact nat_p_omega 1 nat_1.
  + prove eps_ k = eps_ k * 1.
    symmetry.
    exact mul_SNo_oneR (eps_ k) (SNo_eps_ k Hk).
Qed.

Theorem minus_SNo_diadic_rational_p : forall x, diadic_rational_p x -> diadic_rational_p (- x).
let x. assume H. apply H.
let k. assume H. apply H.
assume Hk: k :e omega.
claim Lek: SNo (eps_ k).
{ exact SNo_eps_ k Hk. }
assume H. apply H.
let m. assume H. apply H.
assume Hm: m :e int.
assume Hxkm: x = eps_ k * m.
claim Lm: SNo m.
{ exact int_SNo m Hm. }
claim Lekm: SNo (eps_ k * m).
{ exact SNo_mul_SNo (eps_ k) m Lek Lm. }
prove exists k' :e omega, exists m' :e int, - x = eps_ k' * m'.
witness k. apply andI.
- exact Hk.
- witness (- m). apply andI.
  + apply int_minus_SNo. exact Hm.
  + prove - x = eps_ k * (- m).
    rewrite mul_SNo_minus_distrR (eps_ k) m (SNo_eps_ k Hk) Lm.
    prove - x = - eps_ k * m.
    f_equal.
    exact Hxkm.
Qed.

Theorem mul_SNo_diadic_rational_p : forall x y, diadic_rational_p x -> diadic_rational_p y -> diadic_rational_p (x * y).
let x y. assume Hx. apply Hx.
let k. assume H. apply H.
assume Hk: k :e omega.
claim Lek: SNo (eps_ k).
{ exact SNo_eps_ k Hk. }
assume H. apply H.
let m. assume H. apply H.
assume Hm: m :e int.
assume Hxkm: x = eps_ k * m.
claim Lm: SNo m.
{ exact int_SNo m Hm. }
claim Lekm: SNo (eps_ k * m).
{ exact SNo_mul_SNo (eps_ k) m Lek Lm. }
assume Hy. apply Hy.
let l. assume H. apply H.
assume Hl: l :e omega.
claim Lel: SNo (eps_ l).
{ exact SNo_eps_ l Hl. }
assume H. apply H.
let n. assume H. apply H.
assume Hn: n :e int.
claim Ln: SNo n.
{ exact int_SNo n Hn. }
claim Leln: SNo (eps_ l * n).
{ exact SNo_mul_SNo (eps_ l) n Lel Ln. }
assume Hyln: y = eps_ l * n.
prove exists k' :e omega, exists m' :e int, x * y = eps_ k' * m'.
witness (k + l). apply andI.
- exact add_SNo_In_omega k Hk l Hl.
- witness (m * n). apply andI.
  + exact int_mul_SNo m Hm n Hn.
  + prove x * y = eps_ (k + l) * (m * n).
    rewrite <- mul_SNo_eps_eps_add_SNo k Hk l Hl.
    prove x * y = (eps_ k * eps_ l) * (m * n).
    rewrite mul_SNo_com_4_inner_mid (eps_ k) (eps_ l) m n Lek Lel Lm Ln.
    prove x * y = (eps_ k * m) * (eps_ l * n).
    f_equal.
    * exact Hxkm.
    * exact Hyln.
Qed.

Theorem add_SNo_diadic_rational_p : forall x y, diadic_rational_p x -> diadic_rational_p y -> diadic_rational_p (x + y).
let x y. assume Hx. apply Hx.
let k. assume H. apply H.
assume Hk: k :e omega.
claim Lek: SNo (eps_ k).
{ exact SNo_eps_ k Hk. }
assume H. apply H.
let m. assume H. apply H.
assume Hm: m :e int.
assume Hxkm: x = eps_ k * m.
claim Lm: SNo m.
{ exact int_SNo m Hm. }
claim Lekm: SNo (eps_ k * m).
{ exact SNo_mul_SNo (eps_ k) m Lek Lm. }
assume Hy. apply Hy.
let l. assume H. apply H.
assume Hl: l :e omega.
claim Lel: SNo (eps_ l).
{ exact SNo_eps_ l Hl. }
assume H. apply H.
let n. assume H. apply H.
assume Hn: n :e int.
assume Hyln: y = eps_ l * n.
claim Ln: SNo n.
{ exact int_SNo n Hn. }
claim Leln: SNo (eps_ l * n).
{ exact SNo_mul_SNo (eps_ l) n Lel Ln. }
prove exists k' :e omega, exists m' :e int, x + y = eps_ k' * m'.
witness (k + l). apply andI.
- prove k + l :e omega. exact add_SNo_In_omega k Hk l Hl.
- witness (2 ^ l * m + 2 ^ k * n).
  claim L2l: 2 ^ l :e int.
  { apply Subq_omega_int. apply nat_p_omega.
    exact nat_exp_SNo_nat 2 nat_2 l (omega_nat_p l Hl).
  }
  claim L2lm: 2 ^ l * m :e int.
  { apply int_mul_SNo.
    - exact L2l.
    - exact Hm.
  }
  claim L2k: 2 ^ k :e int.
  { apply Subq_omega_int. apply nat_p_omega.
    exact nat_exp_SNo_nat 2 nat_2 k (omega_nat_p k Hk).
  }
  claim L2kn: 2 ^ k * n :e int.
  { apply int_mul_SNo.
    - exact L2k.
    - exact Hn.
  }
  apply andI.
  + prove 2 ^ l * m + 2 ^ k * n :e int.
    apply int_add_SNo.
    * exact L2lm.
    * exact L2kn.
  + prove x + y = eps_ (k + l) * (2 ^ l * m + 2 ^ k * n).
    rewrite <- mul_SNo_eps_eps_add_SNo k Hk l Hl.
    prove x + y = (eps_ k * eps_ l) * (2 ^ l * m + 2 ^ k * n).
    rewrite mul_SNo_distrL (eps_ k * eps_ l) (2 ^ l * m) (2 ^ k * n) (SNo_mul_SNo (eps_ k) (eps_ l) Lek Lel) (int_SNo (2 ^ l * m) L2lm) (int_SNo (2 ^ k * n) L2kn).
    prove x + y = (eps_ k * eps_ l) * 2 ^ l * m + (eps_ k * eps_ l) * 2 ^ k * n.
    f_equal.
    * prove x = (eps_ k * eps_ l) * 2 ^ l * m.
      rewrite <- mul_SNo_assoc (eps_ k) (eps_ l) (2 ^ l * m) Lek Lel (int_SNo (2 ^ l * m) L2lm).
      prove x = eps_ k * eps_ l * 2 ^ l * m.
      rewrite mul_SNo_assoc (eps_ l) (2 ^ l) m Lel (int_SNo (2 ^ l) L2l) (int_SNo m Hm).
      prove x = eps_ k * (eps_ l * 2 ^ l) * m.
      rewrite mul_SNo_eps_power_2 l (omega_nat_p l Hl).
      prove x = eps_ k * 1 * m.
      rewrite mul_SNo_oneL m (int_SNo m Hm).
      prove x = eps_ k * m. exact Hxkm.
    * prove y = (eps_ k * eps_ l) * (2 ^ k * n).
      rewrite mul_SNo_com_4_inner_mid (eps_ k) (eps_ l) (2 ^ k) n Lek Lel (int_SNo (2 ^ k) L2k) (int_SNo n Hn).
      prove y = (eps_ k * 2 ^ k) * (eps_ l * n).
      rewrite mul_SNo_eps_power_2 k (omega_nat_p k Hk).
      prove y = 1 * (eps_ l * n).
      rewrite mul_SNo_oneL (eps_ l * n) Leln.
      exact Hyln.
Qed.

Theorem SNoS_omega_diadic_rational_p_lem: forall n, nat_p n -> forall x, SNo x -> SNoLev x = n -> diadic_rational_p x.
apply nat_complete_ind.
let n. assume Hn.
assume IH: forall m :e n, forall x, SNo x -> SNoLev x = m -> diadic_rational_p x.
let x.
assume Hx: SNo x.
assume Hxn: SNoLev x = n.
prove diadic_rational_p x.
apply dneg.
assume HC: ~diadic_rational_p x.
prove False.
claim LxSo: x :e SNoS_ omega.
{ apply SNoS_I omega omega_ordinal x (SNoLev x).
  - prove SNoLev x :e omega. rewrite Hxn. exact nat_p_omega n Hn.
  - prove SNo_ (SNoLev x) x. apply SNoLev_. exact Hx.
}
claim L1: exists y, SNo_max_of (SNoL x) y.
{ apply SNoS_omega_SNoL_max_exists x LxSo.
  - assume H1: SNoL x = 0. (** x must be - n, so it is a diadic rational **)
    claim L1a: ordinal (- x).
    { apply SNo_max_ordinal (- x) (SNo_minus_SNo x Hx).
      let w.
      rewrite minus_SNo_Lev x Hx.
      assume Hw: w :e SNoS_ (SNoLev x).
      prove w < - x.
      apply SNoS_E2 (SNoLev x) (SNoLev_ordinal x Hx) w Hw.
      assume Hw1 Hw2 Hw3 Hw4.
      apply SNoLt_trichotomy_or_impred w (- x) ?? (SNo_minus_SNo x Hx).
      - assume H2: w < - x. exact H2.
      - assume H2: w = - x. prove False. apply In_irref (SNoLev w).
        rewrite H2 at 2. rewrite minus_SNo_Lev x Hx.
        exact ??.
      - assume H2: - x < w. prove False.
        apply EmptyE (- w).
        prove - w :e 0.
        rewrite <- H1.
        prove - w :e SNoL x.
        apply SNoL_I x Hx (- w) (SNo_minus_SNo w ??).
        + prove SNoLev (- w) :e SNoLev x. rewrite minus_SNo_Lev w ??. exact ??.
        + prove - w < x. exact minus_SNo_Lt_contra1 x w Hx ?? ??.
    }
    claim L1b: - x = n.
    { rewrite <- Hxn. prove - x = SNoLev x. symmetry.
      rewrite <- minus_SNo_Lev x ??.
      exact ordinal_SNoLev (- x) L1a.
    }
    prove False.
    apply HC.
    prove diadic_rational_p x.
    rewrite <- minus_SNo_invol x ??.
    prove diadic_rational_p (- - x).
    apply minus_SNo_diadic_rational_p.
    prove diadic_rational_p (- x).
    rewrite L1b.
    prove diadic_rational_p n.
    apply omega_diadic_rational_p.
    exact nat_p_omega n Hn.
  - assume H1. exact H1.
}
claim L2: exists z, SNo_min_of (SNoR x) z.
{ apply SNoS_omega_SNoR_min_exists x LxSo.
  - assume H1: SNoR x = 0. (** x must be n, so it is a diadic rational **)
    claim L2a: ordinal x.
    { apply SNo_max_ordinal x Hx.
      let w. assume Hw: w :e SNoS_ (SNoLev x).
      prove w < x.
      apply SNoS_E2 (SNoLev x) (SNoLev_ordinal x ??) w Hw.
      assume Hw1 Hw2 Hw3 Hw4.
      apply SNoLt_trichotomy_or_impred w x ?? ??.
      - assume H2: w < x. exact H2.
      - assume H2: w = x. prove False. apply In_irref (SNoLev x).
        rewrite <- H2 at 1. exact ??.
      - assume H2: x < w. prove False.
        apply EmptyE w.
        prove w :e 0.
        rewrite <- H1.
        prove w :e SNoR x.
        apply SNoR_I x ?? w ?? ?? ??.
    }
    claim L2b: x = n.
    { rewrite <- Hxn. prove x = SNoLev x. symmetry. exact ordinal_SNoLev x L2a. }
    prove False.
    apply HC.
    prove diadic_rational_p x.
    apply omega_diadic_rational_p.
    prove x :e omega. rewrite L2b. exact nat_p_omega n Hn.
  - assume H1. exact H1.
}
apply L1.
let y.
assume Hy: SNo_max_of (SNoL x) y.
apply Hy. assume H. apply H.
assume Hy1: y :e SNoL x.
assume Hy2: SNo y.
assume Hy3: forall w :e SNoL x, SNo w -> w <= y.
apply SNoL_E x Hx y Hy1.
assume _ Hy1b Hy1c.
apply L2.
let z.
assume Hz: SNo_min_of (SNoR x) z.
apply Hz. assume H. apply H.
assume Hz1: z :e SNoR x.
assume Hz2: SNo z.
assume Hz3: forall w :e SNoR x, SNo w -> z <= w.
apply SNoR_E x Hx z Hz1.
assume _ Hz1b Hz1c.
claim Lxx: SNo (x + x).
{ exact SNo_add_SNo x x Hx Hx. }
claim Lyz: SNo (y + z).
{ exact SNo_add_SNo y z Hy2 Hz2. }
claim Ldry: diadic_rational_p y.
{ apply IH (SNoLev y).
  - prove SNoLev y :e n. rewrite <- Hxn.
    prove SNoLev y :e SNoLev x.
    exact Hy1b.
  - prove SNo y. exact Hy2.
  - prove SNoLev y = SNoLev y. reflexivity.
}
claim Ldrz: diadic_rational_p z.
{ apply IH (SNoLev z).
  - prove SNoLev z :e n. rewrite <- Hxn.
    prove SNoLev z :e SNoLev x.
    exact Hz1b.
  - prove SNo z. exact Hz2.
  - prove SNoLev z = SNoLev z. reflexivity.
}
apply SNoLt_trichotomy_or_impred (x + x) (y + z) Lxx Lyz.
- rewrite add_SNo_com y z Hy2 Hz2.
  assume H1: x + x < z + y.
  apply double_SNo_min_1 x z Hx Hz y Hy2 Hy1c H1.
  let w. assume H. apply H.
  assume Hw: w :e SNoL y.
  assume H2: z + w = x + x.
  apply SNoL_E y Hy2 w Hw.
  assume Hw1 Hw2 Hw3.
  claim Ldrw: diadic_rational_p w.
  { apply IH (SNoLev w).
    - prove SNoLev w :e n.
      apply ordinal_TransSet n (nat_p_ordinal n Hn) (SNoLev y).
      + prove SNoLev y :e n. rewrite <- Hxn.
        exact Hy1b.
      + prove SNoLev w :e SNoLev y. exact Hw2.
    - prove SNo w. exact Hw1.
    - prove SNoLev w = SNoLev w. reflexivity.
  }
  claim Lxe: x = eps_ 1 * (z + w).
  { apply double_eps_1 x z w Hx Hz2 Hw1.
    symmetry. exact H2.
  }
  apply HC.
  prove diadic_rational_p x.
  rewrite Lxe.
  apply mul_SNo_diadic_rational_p.
  + prove diadic_rational_p (eps_ 1).
    exact eps_diadic_rational_p 1 (nat_p_omega 1 nat_1).
  + prove diadic_rational_p (z + w).
    apply add_SNo_diadic_rational_p.
    * prove diadic_rational_p z. exact Ldrz.
    * prove diadic_rational_p w. exact Ldrw.
- assume H1: x + x = y + z.
  claim Lxe: x = eps_ 1 * (y + z).
  { exact double_eps_1 x y z Hx Hy2 Hz2 H1. }
  apply HC.
  prove diadic_rational_p x.
  rewrite Lxe.
  apply mul_SNo_diadic_rational_p.
  + prove diadic_rational_p (eps_ 1).
    exact eps_diadic_rational_p 1 (nat_p_omega 1 nat_1).
  + prove diadic_rational_p (y + z).
    apply add_SNo_diadic_rational_p.
    * prove diadic_rational_p y. exact Ldry.
    * prove diadic_rational_p z. exact Ldrz.
- assume H1: y + z < x + x.
  apply double_SNo_max_1 x y Hx Hy z Hz2 Hz1c H1.
  let w. assume H. apply H.
  assume Hw: w :e SNoR z.
  assume H2: y + w = x + x.
  apply SNoR_E z Hz2 w Hw.
  assume Hw1 Hw2 Hw3.
  claim Ldrw: diadic_rational_p w.
  { apply IH (SNoLev w).
    - prove SNoLev w :e n.
      apply ordinal_TransSet n (nat_p_ordinal n Hn) (SNoLev z).
      + prove SNoLev z :e n. rewrite <- Hxn.
        exact Hz1b.
      + prove SNoLev w :e SNoLev z. exact Hw2.
    - prove SNo w. exact Hw1.
    - prove SNoLev w = SNoLev w. reflexivity.
  }
  claim Lxe: x = eps_ 1 * (y + w).
  { apply double_eps_1 x y w Hx Hy2 Hw1.
    symmetry. exact H2.
  }
  apply HC.
  prove diadic_rational_p x.
  rewrite Lxe.
  apply mul_SNo_diadic_rational_p.
  + prove diadic_rational_p (eps_ 1).
    exact eps_diadic_rational_p 1 (nat_p_omega 1 nat_1).
  + prove diadic_rational_p (y + w).
    apply add_SNo_diadic_rational_p.
    * prove diadic_rational_p y. exact Ldry.
    * prove diadic_rational_p w. exact Ldrw.
Qed.

Theorem SNoS_omega_diadic_rational_p: forall x :e SNoS_ omega, diadic_rational_p x.
let x. assume Hx: x :e SNoS_ omega.
apply SNoS_E2 omega omega_ordinal x Hx.
assume Hx1: SNoLev x :e omega.
assume Hx2: ordinal (SNoLev x).
assume Hx3: SNo x.
assume Hx4: SNo_ (SNoLev x) x.
apply SNoS_omega_diadic_rational_p_lem (SNoLev x).
- prove nat_p (SNoLev x). exact omega_nat_p (SNoLev x) Hx1.
- prove SNo x. exact Hx3.
- prove SNoLev x = SNoLev x. reflexivity.
Qed.

Theorem mul_SNo_SNoS_omega : forall x y :e SNoS_ omega, x * y :e SNoS_ omega.
let x. assume Hx. let y. assume Hy.
apply diadic_rational_p_SNoS_omega.
apply mul_SNo_diadic_rational_p.
- apply SNoS_omega_diadic_rational_p. exact Hx.
- apply SNoS_omega_diadic_rational_p. exact Hy.
Qed.

End DiadicRationals.

Opaque int.

Section SurrealDiv.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.
Definition SNoL_pos : set -> set := fun x => {w :e SNoL x|0 < w}.

Theorem SNo_recip_pos_pos: forall x xi, SNo x -> SNo xi -> 0 < x -> x * xi = 1 -> 0 < xi.
let x xi. assume Hx Hxi Hxpos Hxxi.
apply SNoLt_trichotomy_or_impred 0 xi SNo_0 Hxi.
- assume H1. exact H1.
- assume H1: 0 = xi. prove False.
  apply neq_0_1.
  prove 0 = 1.
  rewrite <- Hxxi.
  prove 0 = x * xi.
  rewrite <- H1.
  prove 0 = x * 0.
  symmetry. exact mul_SNo_zeroR x Hx.
- assume H1: xi < 0. prove False.
  apply SNoLt_irref 0.
  prove 0 < 0.
  apply SNoLt_tra 0 1 0 SNo_0 SNo_1 SNo_0 SNoLt_0_1.
  prove 1 < 0.
  rewrite <- Hxxi.
  prove x * xi < 0.
  exact mul_SNo_pos_neg x xi Hx Hxi Hxpos H1.
Qed.

Theorem SNo_recip_lem1: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoL_pos x -> SNo x'i -> x' * x'i = 1 -> SNo y -> x * y < 1 -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> 1 < x * y'.
let x x' x'i y y'.
assume Hx Hxpos Hx' Hx'i Hx'x'i Hy Hxy1 Hy' Hy'y.
apply SepE (SNoL x) (fun w => 0 < w) x' Hx'.
assume Hx'L: x' :e SNoL x.
assume Hx'pos: 0 < x'.
apply SNoL_E x Hx x' Hx'L.
assume Hx'1: SNo x'.
assume Hx'2: SNoLev x' :e SNoLev x.
assume Hx'3: x' < x.
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Hx Hy. }
claim Lxy': SNo (x * y').
{ exact SNo_mul_SNo x y' Hx Hy'. }
claim L1: 0 < 1 + - x * y.
{ apply add_SNo_minus_Lt2b 1 (x * y) 0 SNo_1 Lxy SNo_0.
  prove 0 + x * y < 1.
  rewrite add_SNo_0L (x * y) Lxy.
  prove x * y < 1.
  exact Hxy1.
}
claim L2: (x' + - x) * x'i < 0.
{ apply mul_SNo_neg_pos (x' + - x) x'i (SNo_add_SNo x' (- x) Hx'1 (SNo_minus_SNo x Hx)) Hx'i.
  - prove x' + - x < 0.
    apply add_SNo_minus_Lt1b x' x 0 Hx'1 Hx SNo_0.
    prove x' < 0 + x.
    rewrite add_SNo_0L x Hx.
    exact Hx'3.
  - prove 0 < x'i.
    exact SNo_recip_pos_pos x' x'i Hx'1 Hx'i Hx'pos Hx'x'i.
}
claim L3: 1 + - x * y' < 0.
{ rewrite Hy'y.
  prove (1 + - x * y) * (x' + - x) * x'i < 0.
  apply mul_SNo_pos_neg (1 + - x * y) ((x' + - x) * x'i)
                        (SNo_add_SNo 1 (- x * y) SNo_1 (SNo_minus_SNo (x * y) Lxy))
                        (SNo_mul_SNo (x' + - x) x'i (SNo_add_SNo x' (- x) Hx'1 (SNo_minus_SNo x Hx)) Hx'i).
  - exact L1.
  - exact L2.
}
prove 1 < x * y'.
rewrite <- add_SNo_0L (x * y') Lxy'.
prove 1 < 0 + x * y'.
exact add_SNo_minus_Lt1 1 (x * y') 0 SNo_1 Lxy' SNo_0 L3.
Qed.

Theorem SNo_recip_lem2: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoL_pos x -> SNo x'i -> x' * x'i = 1 -> SNo y -> 1 < x * y -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> x * y' < 1.
let x x' x'i y y'.
assume Hx Hxpos Hx' Hx'i Hx'x'i Hy Hxy1 Hy' Hy'y.
apply SepE (SNoL x) (fun w => 0 < w) x' Hx'.
assume Hx'L: x' :e SNoL x.
assume Hx'pos: 0 < x'.
apply SNoL_E x Hx x' Hx'L.
assume Hx'1: SNo x'.
assume Hx'2: SNoLev x' :e SNoLev x.
assume Hx'3: x' < x.
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Hx Hy. }
claim Lxy': SNo (x * y').
{ exact SNo_mul_SNo x y' Hx Hy'. }
claim L1: 1 + - x * y < 0.
{ apply add_SNo_minus_Lt1b 1 (x * y) 0 SNo_1 Lxy SNo_0.
  prove 1 < 0 + x * y.
  rewrite add_SNo_0L (x * y) Lxy.
  prove 1 < x * y.
  exact Hxy1.
}
claim L2: (x' + - x) * x'i < 0.
{ apply mul_SNo_neg_pos (x' + - x) x'i (SNo_add_SNo x' (- x) Hx'1 (SNo_minus_SNo x Hx)) Hx'i.
  - prove x' + - x < 0.
    apply add_SNo_minus_Lt1b x' x 0 Hx'1 Hx SNo_0.
    prove x' < 0 + x.
    rewrite add_SNo_0L x Hx.
    exact Hx'3.
  - prove 0 < x'i.
    exact SNo_recip_pos_pos x' x'i Hx'1 Hx'i Hx'pos Hx'x'i.
}
claim L3: 0 < 1 + - x * y'.
{ rewrite Hy'y.
  prove 0 < (1 + - x * y) * (x' + - x) * x'i.
  apply mul_SNo_neg_neg (1 + - x * y) ((x' + - x) * x'i)
                        (SNo_add_SNo 1 (- x * y) SNo_1 (SNo_minus_SNo (x * y) Lxy))
                        (SNo_mul_SNo (x' + - x) x'i (SNo_add_SNo x' (- x) Hx'1 (SNo_minus_SNo x Hx)) Hx'i).
  - exact L1.
  - exact L2.
}
prove x * y' < 1.
rewrite <- add_SNo_0L (x * y') Lxy'.
prove 0 + x * y' < 1.
exact add_SNo_minus_Lt2 1 (x * y') 0 SNo_1 Lxy' SNo_0 L3.
Qed.

Theorem SNo_recip_lem3: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoR x -> SNo x'i -> x' * x'i = 1 -> SNo y -> x * y < 1 -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> x * y' < 1.
let x x' x'i y y'.
assume Hx Hxpos Hx' Hx'i Hx'x'i Hy Hxy1 Hy' Hy'y.
apply SNoR_E x Hx x' Hx'.
assume Hx'1: SNo x'.
assume Hx'2: SNoLev x' :e SNoLev x.
assume Hx'3: x < x'.
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Hx Hy. }
claim Lxy': SNo (x * y').
{ exact SNo_mul_SNo x y' Hx Hy'. }
claim Lx'pos: 0 < x'.
{ exact SNoLt_tra 0 x x' SNo_0 Hx Hx'1 Hxpos Hx'3. }
claim L1: 0 < 1 + - x * y.
{ apply add_SNo_minus_Lt2b 1 (x * y) 0 SNo_1 Lxy SNo_0.
  prove 0 + x * y < 1.
  rewrite add_SNo_0L (x * y) Lxy.
  prove x * y < 1.
  exact Hxy1.
}
claim L2: 0 < (x' + - x) * x'i.
{ apply mul_SNo_pos_pos (x' + - x) x'i (SNo_add_SNo x' (- x) Hx'1 (SNo_minus_SNo x Hx)) Hx'i.
  - prove 0 < x' + - x.
    apply add_SNo_minus_Lt2b x' x 0 Hx'1 Hx SNo_0.
    prove 0 + x < x'.
    rewrite add_SNo_0L x Hx.
    exact Hx'3.
  - prove 0 < x'i.
    exact SNo_recip_pos_pos x' x'i Hx'1 Hx'i Lx'pos Hx'x'i.
}
claim L3: 0 < 1 + - x * y'.
{ rewrite Hy'y.
  prove 0 < (1 + - x * y) * (x' + - x) * x'i.
  apply mul_SNo_pos_pos (1 + - x * y) ((x' + - x) * x'i)
                        (SNo_add_SNo 1 (- x * y) SNo_1 (SNo_minus_SNo (x * y) Lxy))
                        (SNo_mul_SNo (x' + - x) x'i (SNo_add_SNo x' (- x) Hx'1 (SNo_minus_SNo x Hx)) Hx'i).
  - exact L1.
  - exact L2.
}
prove x * y' < 1.
rewrite <- add_SNo_0L (x * y') Lxy'.
prove 0 + x * y' < 1.
exact add_SNo_minus_Lt2 1 (x * y') 0 SNo_1 Lxy' SNo_0 L3.
Qed.

Theorem SNo_recip_lem4: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoR x -> SNo x'i -> x' * x'i = 1 -> SNo y -> 1 < x * y -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> 1 < x * y'.
let x x' x'i y y'.
assume Hx Hxpos Hx' Hx'i Hx'x'i Hy Hxy1 Hy' Hy'y.
apply SNoR_E x Hx x' Hx'.
assume Hx'1: SNo x'.
assume Hx'2: SNoLev x' :e SNoLev x.
assume Hx'3: x < x'.
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Hx Hy. }
claim Lxy': SNo (x * y').
{ exact SNo_mul_SNo x y' Hx Hy'. }
claim Lx'pos: 0 < x'.
{ exact SNoLt_tra 0 x x' SNo_0 Hx Hx'1 Hxpos Hx'3. }
claim L1: 1 + - x * y < 0.
{ apply add_SNo_minus_Lt1b 1 (x * y) 0 SNo_1 Lxy SNo_0.
  prove 1 < 0 + x * y.
  rewrite add_SNo_0L (x * y) Lxy.
  prove 1 < x * y.
  exact Hxy1.
}
claim L2: 0 < (x' + - x) * x'i.
{ apply mul_SNo_pos_pos (x' + - x) x'i (SNo_add_SNo x' (- x) Hx'1 (SNo_minus_SNo x Hx)) Hx'i.
  - prove 0 < x' + - x.
    apply add_SNo_minus_Lt2b x' x 0 Hx'1 Hx SNo_0.
    prove 0 + x < x'.
    rewrite add_SNo_0L x Hx.
    exact Hx'3.
  - prove 0 < x'i.
    exact SNo_recip_pos_pos x' x'i Hx'1 Hx'i Lx'pos Hx'x'i.
}
claim L3: 1 + - x * y' < 0.
{ rewrite Hy'y.
  prove (1 + - x * y) * (x' + - x) * x'i < 0.
  apply mul_SNo_neg_pos (1 + - x * y) ((x' + - x) * x'i)
                        (SNo_add_SNo 1 (- x * y) SNo_1 (SNo_minus_SNo (x * y) Lxy))
                        (SNo_mul_SNo (x' + - x) x'i (SNo_add_SNo x' (- x) Hx'1 (SNo_minus_SNo x Hx)) Hx'i).
  - exact L1.
  - exact L2.
}
prove 1 < x * y'.
rewrite <- add_SNo_0L (x * y') Lxy'.
prove 1 < 0 + x * y'.
exact add_SNo_minus_Lt1 1 (x * y') 0 SNo_1 Lxy' SNo_0 L3.
Qed.

Definition SNo_recipauxset : set -> set -> set -> (set -> set) -> set := fun Y x X g => \/_ y :e Y, {(1 + (x' + - x) * y) * g x'|x' :e X}.

Theorem SNo_recipauxset_I: forall Y x X, forall g:set -> set,
 forall y :e Y, forall x' :e X, (1 + (x' + - x) * y) * g x' :e SNo_recipauxset Y x X g.
let Y x X g y. assume Hy. let x'. assume Hx'.
prove (1 + (x' + - x) * y) * g x' :e \/_ y :e Y, {(1 + (x' + - x) * y) * g x'|x' :e X}.
apply famunionI Y (fun y => {(1 + (x' + - x) * y) * g x'|x' :e X}) y ((1 + (x' + - x) * y) * g x') Hy.
prove (1 + (x' + - x) * y) * g x' :e {(1 + (x' + - x) * y) * g x'|x' :e X}.
exact ReplI X (fun x' => (1 + (x' + - x) * y) * g x') x' Hx'.
Qed.

Theorem SNo_recipauxset_E : forall Y x X, forall g:set -> set, forall z :e SNo_recipauxset Y x X g, forall p:prop, (forall y :e Y, forall x' :e X, z = (1 + (x' + - x) * y) * g x' -> p) -> p.
let Y x X g z. assume Hz.
let p. assume H1.
apply famunionE_impred Y (fun y => {(1 + (x' + - x) * y) * g x'|x' :e X}) z Hz.
let y. assume Hy.
assume H2: z :e {(1 + (x' + - x) * y) * g x'|x' :e X}.
apply ReplE_impred X (fun x' => (1 + (x' + - x) * y) * g x') z H2.
let x'. assume Hx': x' :e X.
assume H3: z = (1 + (x' + - x) * y) * g x'.
exact H1 y Hy x' Hx' H3.
Qed.

Theorem SNo_recipauxset_ext: forall Y x X, forall g h:set -> set, (forall x' :e X, g x' = h x') -> SNo_recipauxset Y x X g = SNo_recipauxset Y x X h.
let Y x X g h.
assume Hgh.
prove (\/_ y :e Y, {(1 + (x' + - x) * y) * g x'|x' :e X})
    = (\/_ y :e Y, {(1 + (x' + - x) * y) * h x'|x' :e X}).
apply famunion_ext.
let y. assume Hy.
apply ReplEq_ext X (fun x' => (1 + (x' + - x) * y) * g x')
                   (fun x' => (1 + (x' + - x) * y) * h x').
let x'. assume Hx'.
prove (1 + (x' + - x) * y) * g x' = (1 + (x' + - x) * y) * h x'.
f_equal. exact Hgh x' Hx'.
Qed.

Definition SNo_recipaux : set -> (set -> set) -> set -> set :=
 fun x g =>
  nat_primrec ({0},0)
   (fun k p => (p 0 :\/: SNo_recipauxset (p 0) x (SNoR x) g
                    :\/: SNo_recipauxset (p 1) x (SNoL_pos x) g,
                p 1 :\/: SNo_recipauxset (p 0) x (SNoL_pos x) g
                    :\/: SNo_recipauxset (p 1) x (SNoR x) g)).

Theorem SNo_recipaux_0: forall x, forall g:set -> set, SNo_recipaux x g 0 = ({0},0).
let x g.
exact nat_primrec_0 ({0},0)
   (fun k p => (p 0 :\/: SNo_recipauxset (p 0) x (SNoR x) g
                    :\/: SNo_recipauxset (p 1) x (SNoL_pos x) g,
                p 1 :\/: SNo_recipauxset (p 0) x (SNoL_pos x) g
                    :\/: SNo_recipauxset (p 1) x (SNoR x) g)).
Qed.

Theorem SNo_recipaux_S: forall x, forall g:set -> set, forall n, nat_p n ->
   SNo_recipaux x g (ordsucc n)
 = (SNo_recipaux x g n 0 :\/: SNo_recipauxset (SNo_recipaux x g n 0) x (SNoR x) g
        :\/: SNo_recipauxset (SNo_recipaux x g n 1) x (SNoL_pos x) g,
    SNo_recipaux x g n 1 :\/: SNo_recipauxset (SNo_recipaux x g n 0) x (SNoL_pos x) g
        :\/: SNo_recipauxset (SNo_recipaux x g n 1) x (SNoR x) g).
let x g n. assume Hn.
exact nat_primrec_S ({0},0)
   (fun k p => (p 0 :\/: SNo_recipauxset (p 0) x (SNoR x) g
                    :\/: SNo_recipauxset (p 1) x (SNoL_pos x) g,
                p 1 :\/: SNo_recipauxset (p 0) x (SNoL_pos x) g
                    :\/: SNo_recipauxset (p 1) x (SNoR x) g)) n Hn.
Qed.

Theorem SNo_recipaux_lem1: forall x, SNo x -> 0 < x ->
 forall g:set -> set,
    (forall x' :e SNoS_ (SNoLev x), 0 < x' -> SNo (g x') /\ x' * g x' = 1)
 -> forall k, nat_p k ->
         (forall y :e SNo_recipaux x g k 0, SNo y /\ x * y < 1)
      /\ (forall y :e SNo_recipaux x g k 1, SNo y /\ 1 < x * y).
let x. assume Hx Hxpos.
let g. assume Hg.
set r := SNo_recipaux x g.
claim L1: forall x' :e SNoS_ (SNoLev x), 0 < x' -> forall y y', SNo y -> y' = (1 + (x' + - x) * y) * g x' -> SNo y'.
{ let x'. assume Hx' Hx'pos. let y y'. assume Hy Hy'.
  apply SNoS_E2 (SNoLev x) (SNoLev_ordinal x Hx) x' Hx'. assume _ _ Hx'1 _.
  rewrite Hy'.
  apply SNo_mul_SNo.
  - apply SNo_add_SNo.
    + exact SNo_1.
    + apply SNo_mul_SNo.
      * { apply SNo_add_SNo.
          - exact Hx'1.
          - apply SNo_minus_SNo. exact Hx.
         }
       * exact Hy.
  - apply Hg x' Hx' Hx'pos. assume H _. exact H.
}
claim L2: forall x' :e SNoS_ (SNoLev x), 0 < x' -> forall y y', SNo y -> y' = (1 + (x' + - x) * y) * g x' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * g x'.
{ let x'. assume Hx' Hx'pos. let y y'. assume Hy Hy'.
  apply SNoS_E2 (SNoLev x) (SNoLev_ordinal x Hx) x' Hx'. assume _ _ Hx'1 _.
  prove 1 + - x * y' = (1 + - x * y) * (x' + - x) * g x'.
  apply Hg x' Hx' Hx'pos. assume Hgx'1 Hgx'2.
  rewrite mul_SNo_distrR x' (- x) (g x') Hx'1 (SNo_minus_SNo x Hx) Hgx'1.
  prove 1 + - x * y' = (1 + - x * y) * (x' * g x' + (- x) * g x').
  rewrite Hgx'2.
  prove 1 + - x * y' = (1 + - x * y) * (1 + (- x) * g x').
  rewrite SNo_foil 1 (- x * y) 1 ((- x) * g x') SNo_1 (SNo_minus_SNo (x * y) (SNo_mul_SNo x y Hx Hy)) SNo_1 (SNo_mul_SNo (- x) (g x') (SNo_minus_SNo x Hx) Hgx'1).
  prove 1 + - x * y' = 1 * 1 + 1 * (- x) * g x' + (- x * y) * 1 + (- x * y) * (- x) * g x'.
  rewrite mul_SNo_oneL 1 SNo_1.
  rewrite mul_SNo_oneL ((- x) * g x') (SNo_mul_SNo (- x) (g x') (SNo_minus_SNo x Hx) Hgx'1).
  rewrite mul_SNo_oneR (- x * y) (SNo_minus_SNo (x * y) (SNo_mul_SNo x y Hx Hy)).
  prove 1 + - x * y' = 1 + (- x) * g x' + - x * y + (- x * y) * (- x) * g x'.
  f_equal.
  prove - x * y' = (- x) * g x' + - x * y + (- x * y) * (- x) * g x'.
  rewrite Hy'.
  prove - x * ((1 + (x' + - x) * y) * g x') = (- x) * g x' + - x * y + (- x * y) * (- x) * g x'.
  rewrite mul_SNo_distrR 1 ((x' + - x) * y) (g x') SNo_1 (SNo_mul_SNo (x' + - x) y (SNo_add_SNo x' (- x) Hx'1 (SNo_minus_SNo x Hx)) Hy) Hgx'1.
  prove - x * (1 * g x' + ((x' + - x) * y) * g x') = (- x) * g x' + - x * y + (- x * y) * (- x) * g x'.
  rewrite mul_SNo_oneL (g x') Hgx'1.
  prove - x * (g x' + ((x' + - x) * y) * g x') = (- x) * g x' + - x * y + (- x * y) * (- x) * g x'.
  rewrite <- mul_SNo_minus_distrL x (g x' + ((x' + - x) * y) * g x') Hx (SNo_add_SNo (g x') (((x' + - x) * y) * g x') Hgx'1 (SNo_mul_SNo ((x' + - x) * y) (g x') (SNo_mul_SNo (x' + - x) y (SNo_add_SNo x' (- x) Hx'1 (SNo_minus_SNo x Hx)) Hy) Hgx'1)).
  prove (- x) * (g x' + ((x' + - x) * y) * g x') = (- x) * g x' + - x * y + (- x * y) * (- x) * g x'.
  rewrite mul_SNo_distrL (- x) (g x') (((x' + - x) * y) * g x') (SNo_minus_SNo x Hx) Hgx'1 (SNo_mul_SNo ((x' + - x) * y) (g x') (SNo_mul_SNo (x' + - x) y (SNo_add_SNo x' (- x) Hx'1 (SNo_minus_SNo x Hx)) Hy) Hgx'1).
  prove (- x) * g x' + (- x) * (((x' + - x) * y) * g x') = (- x) * g x' + - x * y + (- x * y) * (- x) * g x'.
  f_equal.
  prove (- x) * (((x' + - x) * y) * g x') = - x * y + (- x * y) * (- x) * g x'.
  rewrite mul_SNo_distrR x' (- x) y Hx'1 (SNo_minus_SNo x Hx) Hy.
  prove (- x) * ((x' * y + (- x) * y) * g x') = - x * y + (- x * y) * (- x) * g x'.
  rewrite mul_SNo_distrR (x' * y) ((- x) * y) (g x') (SNo_mul_SNo x' y Hx'1 Hy) (SNo_mul_SNo (- x) y (SNo_minus_SNo x Hx) Hy) Hgx'1.
  prove (- x) * ((x' * y) * g x' + ((- x) * y) * g x') = - x * y + (- x * y) * (- x) * g x'.
  rewrite mul_SNo_com x' y Hx'1 Hy.
  rewrite <- mul_SNo_assoc y x' (g x') Hy Hx'1 Hgx'1.
  rewrite Hgx'2.
  rewrite mul_SNo_oneR y Hy.
  prove (- x) * (y + ((- x) * y) * g x') = - x * y + (- x * y) * (- x) * g x'.
  rewrite mul_SNo_distrL (- x) y (((- x) * y) * g x') (SNo_minus_SNo x Hx) Hy (SNo_mul_SNo ((- x) * y) (g x') (SNo_mul_SNo (- x) y (SNo_minus_SNo x Hx) Hy) Hgx'1).
  prove (- x) * y + (- x) * ((- x) * y) * g x' = - x * y + (- x * y) * (- x) * g x'.
  rewrite mul_SNo_minus_distrL x y Hx Hy at 1.
  prove - x * y + (- x) * ((- x) * y) * g x' = - x * y + (- x * y) * (- x) * g x'.
  f_equal.
  prove (- x) * ((- x) * y) * g x' = (- x * y) * (- x) * g x'.
  rewrite mul_SNo_assoc (- x) ((- x) * y) (g x') (SNo_minus_SNo x Hx) (SNo_mul_SNo (- x) y (SNo_minus_SNo x Hx) Hy) Hgx'1.
  rewrite mul_SNo_assoc (- x * y) (- x) (g x') (SNo_minus_SNo (x * y) (SNo_mul_SNo x y Hx Hy)) (SNo_minus_SNo x Hx) Hgx'1.
  f_equal.
  prove (- x) * ((- x) * y) = (- x * y) * (- x).
  rewrite mul_SNo_com (- x) y (SNo_minus_SNo x Hx) Hy.
  prove (- x) * (y * (- x)) = (- x * y) * (- x).
  rewrite <- mul_SNo_minus_distrL x y Hx Hy.
  prove (- x) * (y * (- x)) = ((- x) * y) * (- x).
  exact mul_SNo_assoc (- x) y (- x) (SNo_minus_SNo x Hx) Hy (SNo_minus_SNo x Hx).
}
apply nat_ind.
- apply andI.
  + let y.
    prove y :e r 0 0 -> SNo y /\ x * y < 1.
    rewrite SNo_recipaux_0.
    rewrite tuple_2_0_eq.
    prove y :e {0} -> SNo y /\ x * y < 1.
    assume H1: y :e {0}.
    rewrite SingE 0 y H1.
    apply andI.
    * exact SNo_0.
    * prove x * 0 < 1.
      rewrite mul_SNo_zeroR x Hx.
      exact SNoLt_0_1.
  + let y.
    prove y :e r 0 1 -> SNo y /\ 1 < x * y.
    rewrite SNo_recipaux_0.
    prove y :e ({0},0) 1 -> SNo y /\ 1 < x * y.
    rewrite tuple_2_1_eq.
    prove y :e 0 -> SNo y /\ 1 < x * y.
    assume H1: y :e 0.
    prove False. exact EmptyE y H1.
- let k.
  assume Hk: nat_p k.
  assume IH. apply IH.
  assume IH1: forall y :e r k 0, SNo y /\ x * y < 1.
  assume IH2: forall y :e r k 1, SNo y /\ 1 < x * y.
  apply andI.
  + let y'.
    prove y' :e r (ordsucc k) 0 -> SNo y' /\ x * y' < 1.
    rewrite SNo_recipaux_S.
    * { prove y' :e (r k 0 :\/: SNo_recipauxset (r k 0) x (SNoR x) g
                           :\/: SNo_recipauxset (r k 1) x (SNoL_pos x) g,
                     r k 1 :\/: SNo_recipauxset (r k 0) x (SNoL_pos x) g
                           :\/: SNo_recipauxset (r k 1) x (SNoR x) g) 0
              -> SNo y' /\ x * y' < 1.
        rewrite tuple_2_0_eq.
        prove y' :e r k 0 :\/: SNo_recipauxset (r k 0) x (SNoR x) g
                          :\/: SNo_recipauxset (r k 1) x (SNoL_pos x) g
           -> SNo y' /\ x * y' < 1.
        assume H1.
        apply binunionE (r k 0 :\/: SNo_recipauxset (r k 0) x (SNoR x) g) (SNo_recipauxset (r k 1) x (SNoL_pos x) g) y' H1.
        - assume H1.
          apply binunionE (r k 0) (SNo_recipauxset (r k 0) x (SNoR x) g) y' H1.
          + exact IH1 y'.
          + assume H1.
            apply SNo_recipauxset_E (r k 0) x (SNoR x) g y' H1.
            let y. assume Hy: y :e r k 0.
            let x'. assume Hx': x' :e SNoR x.
            assume H2: y' = (1 + (x' + - x) * y) * g x'.
            apply SNoR_E x Hx x' Hx'.
            assume Hx'1 Hx'2 Hx'3.
            claim Lx': x' :e SNoS_ (SNoLev x).
            { apply SNoS_I2 x' x Hx'1 Hx Hx'2. }
            claim Lx'pos: 0 < x'.
            { exact SNoLt_tra 0 x x' SNo_0 Hx Hx'1 Hxpos Hx'3. }
            apply IH1 y Hy.
            assume Hy1: SNo y.
            assume Hxy1: x * y < 1.
            apply Hg x' Lx' Lx'pos.
            assume Hgx'1: SNo (g x').
            assume Hgx'2: x' * g x' = 1.
            claim Ly': SNo y'.
            { exact L1 x' Lx' Lx'pos y y' Hy1 H2. }
            apply andI.
            * exact Ly'.
            * apply SNo_recip_lem3 x x' (g x') y y' Hx Hxpos Hx' Hgx'1 Hgx'2 Hy1 Hxy1 Ly'.
              prove 1 + - x * y' = (1 + - x * y) * (x' + - x) * g x'.
              exact L2 x' Lx' Lx'pos y y' Hy1 H2.
        - assume H1.
          apply SNo_recipauxset_E (r k 1) x (SNoL_pos x) g y' H1.
          let y. assume Hy: y :e r k 1.
          let x'. assume Hx': x' :e SNoL_pos x.
          assume H2: y' = (1 + (x' + - x) * y) * g x'.
          apply SepE (SNoL x) (fun w => 0 < w) x' Hx'.
          assume Hx'0: x' :e SNoL x.
          assume Hx'pos: 0 < x'.
          apply SNoL_E x Hx x' Hx'0.
          assume Hx'1 Hx'2 Hx'3.
          claim Lx': x' :e SNoS_ (SNoLev x).
          { apply SNoS_I2 x' x Hx'1 Hx Hx'2. }
          apply IH2 y Hy.
          assume Hy1: SNo y.
          assume Hxy1: 1 < x * y.
          apply Hg x' Lx' Hx'pos.
          assume Hgx'1: SNo (g x').
          assume Hgx'2: x' * g x' = 1.
          claim Ly': SNo y'.
          { exact L1 x' Lx' Hx'pos y y' Hy1 H2. }
          apply andI.
          + exact Ly'.
          + apply SNo_recip_lem2 x x' (g x') y y' Hx Hxpos Hx' Hgx'1 Hgx'2 Hy1 Hxy1 Ly'.
            prove 1 + - x * y' = (1 + - x * y) * (x' + - x) * g x'.
            exact L2 x' Lx' Hx'pos y y' Hy1 H2.
      }
    * exact Hk.
  + let y'.
    prove y' :e r (ordsucc k) 1 -> SNo y' /\ 1 < x * y'.
    rewrite SNo_recipaux_S.
    * { prove y' :e (r k 0 :\/: SNo_recipauxset (r k 0) x (SNoR x) g
                           :\/: SNo_recipauxset (r k 1) x (SNoL_pos x) g,
                     r k 1 :\/: SNo_recipauxset (r k 0) x (SNoL_pos x) g
                           :\/: SNo_recipauxset (r k 1) x (SNoR x) g) 1
            -> SNo y' /\ 1 < x * y'.
        rewrite tuple_2_1_eq.
        prove y' :e r k 1 :\/: SNo_recipauxset (r k 0) x (SNoL_pos x) g
                          :\/: SNo_recipauxset (r k 1) x (SNoR x) g
              -> SNo y' /\ 1 < x * y'.
         assume H1.
         apply binunionE (r k 1 :\/: SNo_recipauxset (r k 0) x (SNoL_pos x) g) (SNo_recipauxset (r k 1) x (SNoR x) g) y' H1.
         - assume H1. apply binunionE (r k 1) (SNo_recipauxset (r k 0) x (SNoL_pos x) g) y' H1.
           + exact IH2 y'.
           + assume H1.
            apply SNo_recipauxset_E (r k 0) x (SNoL_pos x) g y' H1.
            let y. assume Hy: y :e r k 0.
            let x'. assume Hx': x' :e SNoL_pos x.
            assume H2: y' = (1 + (x' + - x) * y) * g x'.
            apply SepE (SNoL x) (fun w => 0 < w) x' Hx'.
            assume Hx'0: x' :e SNoL x.
            assume Hx'pos: 0 < x'.
            apply SNoL_E x Hx x' Hx'0.
            assume Hx'1 Hx'2 Hx'3.
            claim Lx': x' :e SNoS_ (SNoLev x).
            { apply SNoS_I2 x' x Hx'1 Hx Hx'2. }
            apply IH1 y Hy.
            assume Hy1: SNo y.
            assume Hxy1: x * y < 1.
            apply Hg x' Lx' Hx'pos.
            assume Hgx'1: SNo (g x').
            assume Hgx'2: x' * g x' = 1.
            claim Ly': SNo y'.
            { exact L1 x' Lx' Hx'pos y y' Hy1 H2. }
            apply andI.
            * exact Ly'.
            * apply SNo_recip_lem1 x x' (g x') y y' Hx Hxpos Hx' Hgx'1 Hgx'2 Hy1 Hxy1 Ly'.
              prove 1 + - x * y' = (1 + - x * y) * (x' + - x) * g x'.
              exact L2 x' Lx' Hx'pos y y' Hy1 H2.
         - assume H1.
          apply SNo_recipauxset_E (r k 1) x (SNoR x) g y' H1.
          let y. assume Hy: y :e r k 1.
          let x'. assume Hx': x' :e SNoR x.
          assume H2: y' = (1 + (x' + - x) * y) * g x'.
          apply SNoR_E x Hx x' Hx'.
          assume Hx'1 Hx'2 Hx'3.
          claim Lx': x' :e SNoS_ (SNoLev x).
          { apply SNoS_I2 x' x Hx'1 Hx Hx'2. }
          claim Lx'pos: 0 < x'.
          { exact SNoLt_tra 0 x x' SNo_0 Hx Hx'1 Hxpos Hx'3. }
          apply IH2 y Hy.
          assume Hy1: SNo y.
          assume Hxy1: 1 < x * y.
          apply Hg x' Lx' Lx'pos.
          assume Hgx'1: SNo (g x').
          assume Hgx'2: x' * g x' = 1.
          claim Ly': SNo y'.
          { exact L1 x' Lx' Lx'pos y y' Hy1 H2. }
          apply andI.
          + exact Ly'.
          + apply SNo_recip_lem4 x x' (g x') y y' Hx Hxpos Hx' Hgx'1 Hgx'2 Hy1 Hxy1 Ly'.
            prove 1 + - x * y' = (1 + - x * y) * (x' + - x) * g x'.
            exact L2 x' Lx' Lx'pos y y' Hy1 H2.
      }
    * exact Hk.
Qed.

Theorem SNo_recipaux_lem2: forall x, SNo x -> 0 < x ->
 forall g:set -> set,
    (forall x' :e SNoS_ (SNoLev x), 0 < x' -> SNo (g x') /\ x' * g x' = 1)
 -> SNoCutP (\/_ k :e omega, SNo_recipaux x g k 0) (\/_ k :e omega, SNo_recipaux x g k 1).
let x. assume Hx Hxpos.
let g. assume Hg.
set L := \/_ k :e omega, SNo_recipaux x g k 0.
set R := \/_ k :e omega, SNo_recipaux x g k 1.
prove (forall x :e L, SNo x)
   /\ (forall y :e R, SNo y)
   /\ (forall x :e L, forall y :e R, x < y).
claim L1: forall k, nat_p k ->
              (forall y :e SNo_recipaux x g k 0, SNo y /\ x * y < 1)
           /\ (forall y :e SNo_recipaux x g k 1, SNo y /\ 1 < x * y).
{ exact SNo_recipaux_lem1 x Hx Hxpos g Hg. }
apply and3I.
- let y. assume Hy.
  apply famunionE_impred omega (fun k => SNo_recipaux x g k 0) y Hy.
  let k. assume Hk.
  assume H1: y :e SNo_recipaux x g k 0.
  apply L1 k (omega_nat_p k Hk).
  assume H2 _.
  apply H2 y H1. assume H3 _. exact H3.
- let y. assume Hy.
  apply famunionE_impred omega (fun k => SNo_recipaux x g k 1) y Hy.
  let k. assume Hk.
  assume H1: y :e SNo_recipaux x g k 1.
  apply L1 k (omega_nat_p k Hk).
  assume _ H2.
  apply H2 y H1. assume H3 _. exact H3.
- let w. assume Hw. let z. assume Hz.
  apply famunionE_impred omega (fun k => SNo_recipaux x g k 0) w Hw.
  let k. assume Hk.
  assume H1: w :e SNo_recipaux x g k 0.
  apply L1 k (omega_nat_p k Hk).
  assume H2 _.
  apply H2 w H1.
  assume H3: SNo w.
  assume H4: x * w < 1.
  apply famunionE_impred omega (fun k => SNo_recipaux x g k 1) z Hz.
  let k'. assume Hk'.
  assume H5: z :e SNo_recipaux x g k' 1.
  apply L1 k' (omega_nat_p k' Hk').
  assume _ H6.
  apply H6 z H5.
  assume H7: SNo z.
  assume H8: 1 < x * z.
  prove w < z.
  apply SNoLtLe_or w z H3 H7.
  + assume H9: w < z. exact H9.
  + assume H9: z <= w. prove False.
    apply SNoLt_irref 1.
    prove 1 < 1.
    apply SNoLt_tra 1 (x * z) 1 SNo_1 (SNo_mul_SNo x z Hx H7) SNo_1 H8.
    prove x * z < 1.
    apply SNoLeLt_tra (x * z) (x * w) 1 (SNo_mul_SNo x z Hx H7) (SNo_mul_SNo x w Hx H3) SNo_1.
    * prove x * z <= x * w.
      apply nonneg_mul_SNo_Le x z w Hx (SNoLtLe 0 x Hxpos) H7 H3 H9.
    * prove x * w < 1. exact H4.
Qed.

Theorem SNo_recipaux_ext: forall x, SNo x -> forall g h:set -> set, (forall x' :e SNoS_ (SNoLev x), g x' = h x') -> forall k, nat_p k -> SNo_recipaux x g k = SNo_recipaux x h k.
let x. assume Hx. let g h.
assume Hgh.
apply nat_ind.
- prove SNo_recipaux x g 0 = SNo_recipaux x h 0.
  rewrite SNo_recipaux_0 x h.
  exact SNo_recipaux_0 x g.
- let k.
  assume Hk: nat_p k.
  assume IH: SNo_recipaux x g k = SNo_recipaux x h k.
  prove SNo_recipaux x g (ordsucc k) = SNo_recipaux x h (ordsucc k).
  rewrite SNo_recipaux_S x g k Hk.
  rewrite SNo_recipaux_S x h k Hk.
  prove (SNo_recipaux x g k 0 :\/: SNo_recipauxset (SNo_recipaux x g k 0) x (SNoR x) g
                    :\/: SNo_recipauxset (SNo_recipaux x g k 1) x (SNoL_pos x) g,
         SNo_recipaux x g k 1 :\/: SNo_recipauxset (SNo_recipaux x g k 0) x (SNoL_pos x) g
                    :\/: SNo_recipauxset (SNo_recipaux x g k 1) x (SNoR x) g)
      = (SNo_recipaux x h k 0 :\/: SNo_recipauxset (SNo_recipaux x h k 0) x (SNoR x) h
                    :\/: SNo_recipauxset (SNo_recipaux x h k 1) x (SNoL_pos x) h,
         SNo_recipaux x h k 1 :\/: SNo_recipauxset (SNo_recipaux x h k 0) x (SNoL_pos x) h
                    :\/: SNo_recipauxset (SNo_recipaux x h k 1) x (SNoR x) h).
  rewrite IH.
  prove (SNo_recipaux x h k 0 :\/: SNo_recipauxset (SNo_recipaux x h k 0) x (SNoR x) g
                    :\/: SNo_recipauxset (SNo_recipaux x h k 1) x (SNoL_pos x) g,
         SNo_recipaux x h k 1 :\/: SNo_recipauxset (SNo_recipaux x h k 0) x (SNoL_pos x) g
                    :\/: SNo_recipauxset (SNo_recipaux x h k 1) x (SNoR x) g)
      = (SNo_recipaux x h k 0 :\/: SNo_recipauxset (SNo_recipaux x h k 0) x (SNoR x) h
                    :\/: SNo_recipauxset (SNo_recipaux x h k 1) x (SNoL_pos x) h,
         SNo_recipaux x h k 1 :\/: SNo_recipauxset (SNo_recipaux x h k 0) x (SNoL_pos x) h
                    :\/: SNo_recipauxset (SNo_recipaux x h k 1) x (SNoR x) h).
  claim L1: SNo_recipaux x h k 0 :\/: SNo_recipauxset (SNo_recipaux x h k 0) x (SNoR x) g
                    :\/: SNo_recipauxset (SNo_recipaux x h k 1) x (SNoL_pos x) g
          = SNo_recipaux x h k 0 :\/: SNo_recipauxset (SNo_recipaux x h k 0) x (SNoR x) h
                    :\/: SNo_recipauxset (SNo_recipaux x h k 1) x (SNoL_pos x) h.
  { f_equal.
    - f_equal.
      prove SNo_recipauxset (SNo_recipaux x h k 0) x (SNoR x) g
          = SNo_recipauxset (SNo_recipaux x h k 0) x (SNoR x) h.
      apply SNo_recipauxset_ext.
      let w. assume Hw: w :e SNoR x.
      prove g w = h w.
      apply SNoR_E x Hx w Hw.
      assume Hw1 Hw2 Hw3.
      apply Hgh.
      prove w :e SNoS_ (SNoLev x).
      exact SNoS_I2 w x Hw1 Hx Hw2.
    - prove SNo_recipauxset (SNo_recipaux x h k 1) x (SNoL_pos x) g
          = SNo_recipauxset (SNo_recipaux x h k 1) x (SNoL_pos x) h.
      apply SNo_recipauxset_ext.
      let w. assume Hw: w :e SNoL_pos x.
      prove g w = h w.
      apply SNoL_E x Hx w (SepE1 (SNoL x) (fun w => 0 < w) w Hw).
      assume Hw1 Hw2 Hw3.
      apply Hgh.
      prove w :e SNoS_ (SNoLev x).
      exact SNoS_I2 w x Hw1 Hx Hw2.
  }
  claim L2: SNo_recipaux x h k 1 :\/: SNo_recipauxset (SNo_recipaux x h k 0) x (SNoL_pos x) g
                    :\/: SNo_recipauxset (SNo_recipaux x h k 1) x (SNoR x) g
          = SNo_recipaux x h k 1 :\/: SNo_recipauxset (SNo_recipaux x h k 0) x (SNoL_pos x) h
                    :\/: SNo_recipauxset (SNo_recipaux x h k 1) x (SNoR x) h.
  { f_equal.
    - f_equal.
      prove SNo_recipauxset (SNo_recipaux x h k 0) x (SNoL_pos x) g
          = SNo_recipauxset (SNo_recipaux x h k 0) x (SNoL_pos x) h.
      apply SNo_recipauxset_ext.
      let w. assume Hw: w :e SNoL_pos x.
      prove g w = h w.
      apply SNoL_E x Hx w (SepE1 (SNoL x) (fun w => 0 < w) w Hw).
      assume Hw1 Hw2 Hw3.
      apply Hgh.
      prove w :e SNoS_ (SNoLev x).
      exact SNoS_I2 w x Hw1 Hx Hw2.
    - prove SNo_recipauxset (SNo_recipaux x h k 1) x (SNoR x) g
          = SNo_recipauxset (SNo_recipaux x h k 1) x (SNoR x) h.
      apply SNo_recipauxset_ext.
      let w. assume Hw: w :e SNoR x.
      prove g w = h w.
      apply SNoR_E x Hx w Hw.
      assume Hw1 Hw2 Hw3.
      apply Hgh.
      prove w :e SNoS_ (SNoLev x).
      exact SNoS_I2 w x Hw1 Hx Hw2.
  }
  rewrite L1. rewrite L2.
  reflexivity.
Qed.

Section recip_SNo_pos.
Let G : set -> (set -> set) -> set := fun x g => SNoCut (\/_ k :e omega, SNo_recipaux x g k 0) (\/_ k :e omega, SNo_recipaux x g k 1).
Definition recip_SNo_pos : set -> set := SNo_rec_i G.

Theorem recip_SNo_pos_eq: forall x, SNo x -> recip_SNo_pos x = G x recip_SNo_pos.
apply SNo_rec_i_eq G.
let x. assume Hx.
let g h. assume Hgh.
prove SNoCut (\/_ k :e omega, SNo_recipaux x g k 0) (\/_ k :e omega, SNo_recipaux x g k 1)
    = SNoCut (\/_ k :e omega, SNo_recipaux x h k 0) (\/_ k :e omega, SNo_recipaux x h k 1).
f_equal.
- apply famunion_ext.
  let k. assume Hk.
  prove SNo_recipaux x g k 0 = SNo_recipaux x h k 0.
  f_equal.
  apply SNo_recipaux_ext x Hx g h.
  + prove forall w :e SNoS_ (SNoLev x), g w = h w.
    exact Hgh.
  + exact omega_nat_p k Hk.
- apply famunion_ext.
  let k. assume Hk.
  prove SNo_recipaux x g k 1 = SNo_recipaux x h k 1.
  f_equal.
  apply SNo_recipaux_ext x Hx g h.
  + prove forall w :e SNoS_ (SNoLev x), g w = h w.
    exact Hgh.
  + exact omega_nat_p k Hk.
Qed.

Theorem recip_SNo_pos_prop1: forall x, SNo x -> 0 < x -> SNo (recip_SNo_pos x) /\ x * recip_SNo_pos x = 1.
apply SNoLev_ind.
let x. assume Hx: SNo x.
assume IH: forall w :e SNoS_ (SNoLev x), 0 < w -> SNo (recip_SNo_pos w) /\ w * recip_SNo_pos w = 1.
assume Hxpos: 0 < x.
prove SNo (recip_SNo_pos x) /\ x * recip_SNo_pos x = 1.
rewrite recip_SNo_pos_eq x Hx.
prove SNo (G x recip_SNo_pos) /\ x * G x recip_SNo_pos = 1.
set L := \/_ k :e omega, SNo_recipaux x recip_SNo_pos k 0.
set R := \/_ k :e omega, SNo_recipaux x recip_SNo_pos k 1.
claim L1: forall k, nat_p k ->
              (forall y :e SNo_recipaux x recip_SNo_pos k 0, SNo y /\ x * y < 1)
           /\ (forall y :e SNo_recipaux x recip_SNo_pos k 1, SNo y /\ 1 < x * y).
{ exact SNo_recipaux_lem1 x Hx Hxpos recip_SNo_pos IH. }
claim L1L: forall w :e L, x * w < 1.
{ let w. assume Hw.
  apply famunionE_impred omega (fun k => SNo_recipaux x recip_SNo_pos k 0) w Hw.
  let k. assume Hk: k :e omega.
  assume H1: w :e SNo_recipaux x recip_SNo_pos k 0.
  apply L1 k (omega_nat_p k Hk).
  assume H2 _.
  apply H2 w H1.
  assume _ H3. exact H3.
}
claim L1R: forall z :e R, 1 < x * z.
{ let z. assume Hz.
  apply famunionE_impred omega (fun k => SNo_recipaux x recip_SNo_pos k 1) z Hz.
  let k. assume Hk: k :e omega.
  assume H1: z :e SNo_recipaux x recip_SNo_pos k 1.
  apply L1 k (omega_nat_p k Hk).
  assume _ H2.
  apply H2 z H1.
  assume _ H3. exact H3.
}
claim L2: SNoCutP L R.
{ exact SNo_recipaux_lem2 x Hx Hxpos recip_SNo_pos IH. }
apply L2.
assume HLHR. apply HLHR.
assume HL: forall w :e L, SNo w.
assume HR: forall z :e R, SNo z.
assume HLR: forall w :e L, forall z :e R, w < z.
set y := SNoCut L R.
apply SNoCutP_SNoCut_impred L R L2.
assume H1: SNo y.
assume H2: SNoLev y :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume H3: forall w :e L, w < y.
assume H4: forall z :e R, y < z.
assume H5: forall u, SNo u -> (forall w :e L, w < u) -> (forall z :e R, u < z) -> SNoLev y c= SNoLev u /\ SNoEq_ (SNoLev y) y u.
claim L3: SNo (x * y).
{ exact SNo_mul_SNo x y Hx H1. }
claim L4: 0 < y.
{ apply H3.
  prove 0 :e L.
  apply famunionI omega (fun k => SNo_recipaux x recip_SNo_pos k 0) 0.
  - prove 0 :e omega. apply nat_p_omega. exact nat_0.
  - prove 0 :e SNo_recipaux x recip_SNo_pos 0 0.
    rewrite SNo_recipaux_0.
    prove 0 :e ({0},0) 0.
    rewrite tuple_2_0_eq. apply SingI.
}
claim L5: 0 < x * y.
{ exact mul_SNo_pos_pos x y Hx H1 Hxpos L4. }
claim L6: forall w :e SNoL y, exists w' :e L, w <= w'.
{ exact SNoL_SNoCutP_ex L R L2. }
claim L7: forall z :e SNoR y, exists z' :e R, z' <= z.
{ exact SNoR_SNoCutP_ex L R L2. }
apply andI.
- prove SNo y. exact H1.
- prove x * y = 1.
  apply dneg.
  assume HC: x * y <> 1.
  apply SNoLt_trichotomy_or_impred (x * y) 1 L3 SNo_1.
  + assume H6: x * y < 1.
    claim L8: 1 :e SNoR (x * y).
    { apply SNoR_I.
      - exact L3.
      - exact SNo_1.
      - prove SNoLev 1 :e SNoLev (x * y).
        rewrite ordinal_SNoLev 1 ordinal_1.
        prove 1 :e SNoLev (x * y).
        apply ordinal_In_Or_Subq 1 (SNoLev (x * y)) ordinal_1 (SNoLev_ordinal (x * y) L3).
        + assume H7: 1 :e SNoLev (x * y). exact H7.
        + assume H7: SNoLev (x * y) c= 1. prove False.
          apply HC.
          prove x * y = 1.
          exact pos_low_eq_one (x * y) L3 L5 H7.
      - exact H6.
    }
    claim L9: forall v w w', SNo v -> SNo w -> SNo w' -> v :e SNoS_ (SNoLev x) -> 0 < v -> v * y + x * w <= 1 + v * w -> (1 + (v + - x) * w') * recip_SNo_pos v :e L -> (- v + x) * w' <= (- v + x) * w -> False.
    { let v w w'. assume Hv1 Hw1 Hw' HvS Hvpos H7 Hw'' H8.
      set w'' := (1 + (v + - x) * w') * recip_SNo_pos v.
      claim Lw''1: SNo w''.
      { exact HL w'' Hw''. }
      apply SNoLt_irref 1.
      prove 1 < 1.
      apply SNoLtLe_tra 1 (1 + v * (y + - w'')) 1 SNo_1 (SNo_add_SNo 1 (v * (y + - w'')) SNo_1 (SNo_mul_SNo v (y + - w'') Hv1 (SNo_add_SNo y (- w'') H1 (SNo_minus_SNo w'' Lw''1)))) SNo_1.
      - prove 1 < 1 + v * (y + - w'').
        rewrite <- add_SNo_0R 1 SNo_1 at 1.
        prove 1 + 0 < 1 + v * (y + - w'').
        apply add_SNo_Lt2 1 0 (v * (y + - w'')) SNo_1 SNo_0 (SNo_mul_SNo v (y + - w'') Hv1 (SNo_add_SNo y (- w'') H1 (SNo_minus_SNo w'' Lw''1))).
        prove 0 < v * (y + - w'').
        apply mul_SNo_pos_pos v (y + - w'') Hv1 (SNo_add_SNo y (- w'') H1 (SNo_minus_SNo w'' Lw''1)) Hvpos.
        prove 0 < y + - w''.
        apply SNoLt_minus_pos w'' y Lw''1 H1.
        prove w'' < y.
        exact H3 w'' Hw''.
      - prove 1 + v * (y + - w'') <= 1.
        rewrite mul_SNo_distrL v y (- w'') Hv1 H1 (SNo_minus_SNo w'' Lw''1).
        prove 1 + v * y + v * (- w'') <= 1.
        rewrite mul_SNo_minus_distrR v w'' Hv1 Lw''1.
        prove 1 + v * y + - v * w'' <= 1.
        prove 1 + v * y + - v * (1 + (v + - x) * w') * recip_SNo_pos v <= 1.
        apply IH v HvS Hvpos.
        assume Hrv1: SNo (recip_SNo_pos v).
        assume Hrv2: v * recip_SNo_pos v = 1.
        rewrite mul_SNo_com (1 + (v + - x) * w') (recip_SNo_pos v)
                            (SNo_add_SNo 1 ((v + - x) * w') SNo_1 (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw'))
                            Hrv1.
        prove 1 + v * y + - v * recip_SNo_pos v * (1 + (v + - x) * w') <= 1.
        rewrite mul_SNo_assoc v (recip_SNo_pos v) (1 + (v + - x) * w')
                              Hv1 Hrv1
                              (SNo_add_SNo 1 ((v + - x) * w') SNo_1 (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw')).
        prove 1 + v * y + - (v * recip_SNo_pos v) * (1 + (v + - x) * w') <= 1.
        rewrite Hrv2.
        prove 1 + v * y + - 1 * (1 + (v + - x) * w') <= 1.
        rewrite mul_SNo_oneL (1 + (v + - x) * w')
                             (SNo_add_SNo 1 ((v + - x) * w') SNo_1 (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw')).
        prove 1 + v * y + - (1 + (v + - x) * w') <= 1.
        rewrite minus_add_SNo_distr 1 ((v + - x) * w') SNo_1 (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw').
        prove 1 + v * y + - 1 + - (v + - x) * w' <= 1.
        rewrite <- add_SNo_rotate_3_1 (- 1) (- (v + - x) * w') (v * y)
                                      (SNo_minus_SNo 1 SNo_1)
                                      (SNo_minus_SNo ((v + - x) * w') (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw'))
                                      (SNo_mul_SNo v y Hv1 H1).
        prove 1 + - 1 + - (v + - x) * w' + v * y <= 1.
        rewrite add_SNo_minus_SNo_prop2 1 (- (v + - x) * w' + v * y) SNo_1
                         (SNo_add_SNo (- (v + - x) * w') (v * y)
                                      (SNo_minus_SNo ((v + - x) * w') (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw'))
                                      (SNo_mul_SNo v y Hv1 H1)).
        prove - (v + - x) * w' + v * y <= 1.
        rewrite <- mul_SNo_minus_distrL (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw'.
        prove (- (v + - x)) * w' + v * y <= 1.
        rewrite minus_add_SNo_distr v (- x) Hv1 (SNo_minus_SNo x Hx).
        rewrite minus_SNo_invol x Hx.
        prove (- v + x) * w' + v * y <= 1.
        apply SNoLe_tra ((- v + x) * w' + v * y) ((- v + x) * w + v * y) 1
                        (SNo_add_SNo ((- v + x) * w') (v * y)
                         (SNo_mul_SNo (- v + x) w' (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx) Hw')
                         (SNo_mul_SNo v y Hv1 H1))
                        (SNo_add_SNo ((- v + x) * w) (v * y)
                         (SNo_mul_SNo (- v + x) w (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx) Hw1)
                         (SNo_mul_SNo v y Hv1 H1))
                        SNo_1.
        + prove (- v + x) * w' + v * y <= (- v + x) * w + v * y.
          apply add_SNo_Le1 ((- v + x) * w') (v * y) ((- v + x) * w)
                            (SNo_mul_SNo (- v + x) w' (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx) Hw')
                            (SNo_mul_SNo v y Hv1 H1)
                            (SNo_mul_SNo (- v + x) w (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx) Hw1).
          prove (- v + x) * w' <= (- v + x) * w.
          exact H8.
        + prove (- v + x) * w + v * y <= 1.
          rewrite mul_SNo_distrR (- v) x w (SNo_minus_SNo v Hv1) Hx Hw1.
          prove ((- v) * w + x * w) + v * y <= 1.
          rewrite mul_SNo_minus_distrL v w Hv1 Hw1.
          prove (- v * w + x * w) + v * y <= 1.
          rewrite <- add_SNo_assoc (- v * w) (x * w) (v * y)
                                  (SNo_minus_SNo (v * w) (SNo_mul_SNo v w Hv1 Hw1))
                                   (SNo_mul_SNo x w Hx Hw1)
                                   (SNo_mul_SNo v y Hv1 H1).
          prove - v * w + x * w + v * y <= 1.
          rewrite add_SNo_com (- v * w) (x * w + v * y)
                                   (SNo_minus_SNo (v * w) (SNo_mul_SNo v w Hv1 Hw1))
                                   (SNo_add_SNo (x * w) (v * y)
                                    (SNo_mul_SNo x w Hx Hw1)
                                    (SNo_mul_SNo v y Hv1 H1)).
          apply add_SNo_minus_Le2 1 (- v * w) (x * w + v * y) SNo_1
                                   (SNo_minus_SNo (v * w) (SNo_mul_SNo v w Hv1 Hw1))
                                   (SNo_add_SNo (x * w) (v * y)
                                    (SNo_mul_SNo x w Hx Hw1)
                                    (SNo_mul_SNo v y Hv1 H1)).
          prove x * w + v * y <= 1 + - - v * w.
          rewrite minus_SNo_invol (v * w) (SNo_mul_SNo v w Hv1 Hw1).
          prove x * w + v * y <= 1 + v * w.
          rewrite add_SNo_com (x * w) (v * y) (SNo_mul_SNo x w Hx Hw1) (SNo_mul_SNo v y Hv1 H1).
          prove v * y + x * w <= 1 + v * w.
          exact H7.
    }
    apply mul_SNo_SNoR_interpolate_impred x y Hx H1 1 L8.
    * { let v. assume Hv: v :e SNoL x.
        let w. assume Hw: w :e SNoR y.
        assume H7: v * y + x * w <= 1 + v * w.
        apply SNoL_E x Hx v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev x.
        assume Hv3: v < x.
        apply SNoR_E y H1 w Hw.
        assume Hw1: SNo w.
        assume Hw2: SNoLev w :e SNoLev y.
        assume Hw3: y < w.
        claim LvS: v :e SNoS_ (SNoLev x).
        { exact SNoS_I2 v x Hv1 Hx Hv2. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        apply L7 w Hw.
        let w'. assume Hw'. apply Hw'.
        assume Hw'1: w' :e R.
        assume Hw'2: w' <= w.
        claim Lw': SNo w'.
        { exact HR w' Hw'1. }
        claim Lxw': SNo (x * w').
        { exact SNo_mul_SNo x w' Hx Lw'. }
        claim Lvpos: 0 < v.
        { apply SNoLtLe_or 0 v SNo_0 Hv1.
          - assume H8: 0 < v. exact H8.
          - assume H8: v <= 0. prove False.
            apply SNoLt_irref 1.
            prove 1 < 1.
            apply SNoLtLe_tra 1 (x * w') 1 SNo_1 Lxw' SNo_1.
            + prove 1 < x * w'.
              exact L1R w' Hw'1.
            + prove x * w' <= 1.
              apply SNoLe_tra (x * w') (x * w) 1 Lxw' Lxw SNo_1.
              * prove x * w' <= x * w.
                exact nonneg_mul_SNo_Le x w' w Hx (SNoLtLe 0 x Hxpos) Lw' Hw1 Hw'2.  
              * { prove x * w <= 1.
                  apply SNoLe_tra (x * w) (v * (y + - w) + x * w) 1 Lxw (SNo_add_SNo (v * (y + - w)) (x * w) (SNo_mul_SNo v (y + - w) Hv1 (SNo_add_SNo y (- w) H1 (SNo_minus_SNo w Hw1))) Lxw) SNo_1.
                  - prove x * w <= v * (y + - w) + x * w.
                    rewrite <- add_SNo_0L (x * w) Lxw at 1.
                    prove 0 + x * w <= v * (y + - w) + x * w.
                    apply add_SNo_Le1 0 (x * w) (v * (y + - w)) SNo_0 Lxw (SNo_mul_SNo v (y + - w) Hv1 (SNo_add_SNo y (- w) H1 (SNo_minus_SNo w Hw1))).
                    prove 0 <= v * (y + - w).
                    apply mul_SNo_nonpos_neg v (y + - w) Hv1 (SNo_add_SNo y (- w) H1 (SNo_minus_SNo w Hw1)) H8.
                    prove y + - w < 0.
                    apply add_SNo_minus_Lt1b y w 0 H1 Hw1 SNo_0.
                    prove y < 0 + w.
                    rewrite add_SNo_0L w Hw1.
                    prove y < w.
                    exact Hw3.
                  - prove v * (y + - w) + x * w <= 1.
                    rewrite mul_SNo_distrL v y (- w) Hv1 H1 (SNo_minus_SNo w Hw1).
                    prove (v * y + v * (- w)) + x * w <= 1.
                    rewrite add_SNo_com_3b_1_2 (v * y) (v * (- w)) (x * w) (SNo_mul_SNo v y Hv1 H1) (SNo_mul_SNo v (- w) Hv1 (SNo_minus_SNo w Hw1)) Lxw.
                    prove (v * y + x * w) + v * (- w) <= 1.
                    apply add_SNo_minus_Le2 1 (v * (- w)) (v * y + x * w) SNo_1 (SNo_mul_SNo v (- w) Hv1 (SNo_minus_SNo w Hw1)) (SNo_add_SNo (v * y) (x * w) (SNo_mul_SNo v y Hv1 H1) Lxw).
                    prove v * y + x * w <= 1 + - v * (- w).
                    rewrite mul_SNo_minus_distrR v w Hv1 Hw1.
                    rewrite minus_SNo_invol (v * w) (SNo_mul_SNo v w Hv1 Hw1).
                    exact H7.
                }
        }
        set w'' := (1 + (v + - x) * w') * recip_SNo_pos v.
        claim Lw'': w'' :e L.
        { apply famunionE_impred omega (fun k => SNo_recipaux x recip_SNo_pos k 1) w' Hw'1.
          let k. assume Hk: k :e omega.
          assume H9: w' :e SNo_recipaux x recip_SNo_pos k 1.
          apply famunionI omega (fun k => SNo_recipaux x recip_SNo_pos k 0) (ordsucc k) w'' (omega_ordsucc k Hk).
          prove w'' :e SNo_recipaux x recip_SNo_pos (ordsucc k) 0.
          rewrite SNo_recipaux_S x recip_SNo_pos k (omega_nat_p k Hk).
          rewrite tuple_2_0_eq.
          prove w'' :e SNo_recipaux x recip_SNo_pos k 0 :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 0) x (SNoR x) recip_SNo_pos
                           :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 1) x (SNoL_pos x) recip_SNo_pos.
          apply binunionI2.
          prove w'' :e SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 1) x (SNoL_pos x) recip_SNo_pos.
          apply SNo_recipauxset_I (SNo_recipaux x recip_SNo_pos k 1) x (SNoL_pos x) recip_SNo_pos.
          - prove w' :e SNo_recipaux x recip_SNo_pos k 1.
            exact H9.
          - prove v :e SNoL_pos x.
            prove v :e {w :e SNoL x|0 < w}.
            apply SepI.
            + exact Hv.
            + prove 0 < v. exact Lvpos.
        }
        apply L9 v w w' Hv1 Hw1 Lw' LvS Lvpos H7 Lw''.
        prove (- v + x) * w' <= (- v + x) * w.
        apply nonneg_mul_SNo_Le (- v + x) w' w (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx).
        - prove 0 <= - v + x.
          rewrite add_SNo_com (- v) x (SNo_minus_SNo v Hv1) Hx.
          prove 0 <= x + - v.
          apply add_SNo_minus_Le2b x v 0 Hx Hv1 SNo_0.
          prove 0 + v <= x.
          rewrite add_SNo_0L v Hv1.
          apply SNoLtLe. exact Hv3.
        - exact Lw'.
        - exact Hw1.
        - exact Hw'2.
      }
    * { let v. assume Hv: v :e SNoR x.
        let w. assume Hw: w :e SNoL y.
        assume H7: v * y + x * w <= 1 + v * w.
        apply SNoR_E x Hx v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev x.
        assume Hv3: x < v.
        apply SNoL_E y H1 w Hw.
        assume Hw1: SNo w.
        assume Hw2: SNoLev w :e SNoLev y.
        assume Hw3: w < y.
        claim LvS: v :e SNoS_ (SNoLev x).
        { exact SNoS_I2 v x Hv1 Hx Hv2. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        apply L6 w Hw.
        let w'. assume Hw'. apply Hw'.
        assume Hw'1: w' :e L.
        assume Hw'2: w <= w'.
        claim Lw': SNo w'.
        { exact HL w' Hw'1. }
        claim Lxw': SNo (x * w').
        { exact SNo_mul_SNo x w' Hx Lw'. }
        claim Lvpos: 0 < v.
        { exact SNoLt_tra 0 x v SNo_0 Hx Hv1 Hxpos Hv3. }
        set w'' := (1 + (v + - x) * w') * recip_SNo_pos v.
        claim Lw'': w'' :e L.
        { apply famunionE_impred omega (fun k => SNo_recipaux x recip_SNo_pos k 0) w' Hw'1.
          let k. assume Hk: k :e omega.
          assume H9: w' :e SNo_recipaux x recip_SNo_pos k 0.
          apply famunionI omega (fun k => SNo_recipaux x recip_SNo_pos k 0) (ordsucc k) w'' (omega_ordsucc k Hk).
          prove w'' :e SNo_recipaux x recip_SNo_pos (ordsucc k) 0.
          rewrite SNo_recipaux_S x recip_SNo_pos k (omega_nat_p k Hk).
          rewrite tuple_2_0_eq.
          prove w'' :e SNo_recipaux x recip_SNo_pos k 0 :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 0) x (SNoR x) recip_SNo_pos
                           :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 1) x (SNoL_pos x) recip_SNo_pos.
          apply binunionI1. apply binunionI2.
          prove w'' :e SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 0) x (SNoR x) recip_SNo_pos.
          apply SNo_recipauxset_I (SNo_recipaux x recip_SNo_pos k 0) x (SNoR x) recip_SNo_pos.
          - prove w' :e SNo_recipaux x recip_SNo_pos k 0.
            exact H9.
          - prove v :e SNoR x. exact Hv.
        }
        apply L9 v w w' Hv1 Hw1 Lw' LvS Lvpos H7 Lw''.
        prove (- v + x) * w' <= (- v + x) * w.
        apply nonpos_mul_SNo_Le (- v + x) w' w (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx).
        - prove - v + x <= 0.
          rewrite add_SNo_com (- v) x (SNo_minus_SNo v Hv1) Hx.
          prove x + - v <= 0.
          apply add_SNo_minus_Le2 0 (- v) x SNo_0 (SNo_minus_SNo v Hv1) Hx.
          rewrite minus_SNo_invol v Hv1.
          prove x <= 0 + v.
          rewrite add_SNo_0L v Hv1.
          apply SNoLtLe. exact Hv3.
        - exact Lw'.
        - exact Hw1.
        - exact Hw'2.
      }
  + assume H6: x * y = 1. apply HC. exact H6.
  + assume H6: 1 < x * y.
    claim L10: 1 :e SNoL (x * y).
    { apply SNoL_I.
      - exact L3.
      - exact SNo_1.
      - prove SNoLev 1 :e SNoLev (x * y).
        rewrite ordinal_SNoLev 1 ordinal_1.
        prove 1 :e SNoLev (x * y).
        apply ordinal_In_Or_Subq 1 (SNoLev (x * y)) ordinal_1 (SNoLev_ordinal (x * y) L3).
        + assume H7: 1 :e SNoLev (x * y). exact H7.
        + assume H7: SNoLev (x * y) c= 1. prove False.
          apply HC.
          prove x * y = 1.
          exact pos_low_eq_one (x * y) L3 L5 H7.
      - exact H6.
    }
    claim L11: forall v w w', SNo v -> SNo w -> SNo w' -> v :e SNoS_ (SNoLev x) -> 0 < v -> 1 + v * w <= v * y + x * w -> (1 + (v + - x) * w') * recip_SNo_pos v :e R -> (- v + x) * w <= (- v + x) * w' -> False.
    { let v w w'. assume Hv1 Hw1 Hw' HvS Hvpos H7 Hw'' H8.
      set w'' := (1 + (v + - x) * w') * recip_SNo_pos v.
      claim Lw''1: SNo w''.
      { exact HR w'' Hw''. }
      apply SNoLt_irref 1.
      prove 1 < 1.
      apply SNoLeLt_tra 1 (1 + v * (y + - w'')) 1 SNo_1 (SNo_add_SNo 1 (v * (y + - w'')) SNo_1 (SNo_mul_SNo v (y + - w'') Hv1 (SNo_add_SNo y (- w'') H1 (SNo_minus_SNo w'' Lw''1)))) SNo_1.
      - prove 1 <= 1 + v * (y + - w'').
        rewrite mul_SNo_distrL v y (- w'') Hv1 H1 (SNo_minus_SNo w'' Lw''1).
        prove 1 <= 1 + v * y + v * (- w'').
        rewrite mul_SNo_minus_distrR v w'' Hv1 Lw''1.
        prove 1 <= 1 + v * y + - v * w''.
        prove 1 <= 1 + v * y + - v * (1 + (v + - x) * w') * recip_SNo_pos v.
        apply IH v HvS Hvpos.
        assume Hrv1: SNo (recip_SNo_pos v).
        assume Hrv2: v * recip_SNo_pos v = 1.
        rewrite mul_SNo_com (1 + (v + - x) * w') (recip_SNo_pos v)
                            (SNo_add_SNo 1 ((v + - x) * w') SNo_1 (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw'))
                            Hrv1.
        prove 1 <= 1 + v * y + - v * recip_SNo_pos v * (1 + (v + - x) * w').
        rewrite mul_SNo_assoc v (recip_SNo_pos v) (1 + (v + - x) * w')
                              Hv1 Hrv1
                              (SNo_add_SNo 1 ((v + - x) * w') SNo_1 (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw')).
        prove 1 <= 1 + v * y + - (v * recip_SNo_pos v) * (1 + (v + - x) * w').
        rewrite Hrv2.
        prove 1 <= 1 + v * y + - 1 * (1 + (v + - x) * w').
        rewrite mul_SNo_oneL (1 + (v + - x) * w')
                             (SNo_add_SNo 1 ((v + - x) * w') SNo_1 (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw')).
        prove 1 <= 1 + v * y + - (1 + (v + - x) * w').
        rewrite minus_add_SNo_distr 1 ((v + - x) * w') SNo_1 (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw').
        prove 1 <= 1 + v * y + - 1 + - (v + - x) * w'.
        rewrite <- add_SNo_rotate_3_1 (- 1) (- (v + - x) * w') (v * y)
                                      (SNo_minus_SNo 1 SNo_1)
                                      (SNo_minus_SNo ((v + - x) * w') (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw'))
                                      (SNo_mul_SNo v y Hv1 H1).
        prove 1 <= 1 + - 1 + - (v + - x) * w' + v * y.
        rewrite add_SNo_minus_SNo_prop2 1 (- (v + - x) * w' + v * y) SNo_1
                         (SNo_add_SNo (- (v + - x) * w') (v * y)
                                      (SNo_minus_SNo ((v + - x) * w') (SNo_mul_SNo (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw'))
                                      (SNo_mul_SNo v y Hv1 H1)).
        prove 1 <= - (v + - x) * w' + v * y.
        rewrite <- mul_SNo_minus_distrL (v + - x) w' (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx)) Hw'.
        prove 1 <= (- (v + - x)) * w' + v * y.
        rewrite minus_add_SNo_distr v (- x) Hv1 (SNo_minus_SNo x Hx).
        rewrite minus_SNo_invol x Hx.
        prove 1 <= (- v + x) * w' + v * y.
        apply SNoLe_tra 1 ((- v + x) * w + v * y) ((- v + x) * w' + v * y) SNo_1
                        (SNo_add_SNo ((- v + x) * w) (v * y)
                         (SNo_mul_SNo (- v + x) w (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx) Hw1)
                         (SNo_mul_SNo v y Hv1 H1))
                        (SNo_add_SNo ((- v + x) * w') (v * y)
                         (SNo_mul_SNo (- v + x) w' (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx) Hw')
                         (SNo_mul_SNo v y Hv1 H1)).
        + prove 1 <= (- v + x) * w + v * y.
          rewrite mul_SNo_distrR (- v) x w (SNo_minus_SNo v Hv1) Hx Hw1.
          prove 1 <= ((- v) * w + x * w) + v * y.
          rewrite mul_SNo_minus_distrL v w Hv1 Hw1.
          prove 1 <= (- v * w + x * w) + v * y.
          rewrite <- add_SNo_assoc (- v * w) (x * w) (v * y)
                                  (SNo_minus_SNo (v * w) (SNo_mul_SNo v w Hv1 Hw1))
                                   (SNo_mul_SNo x w Hx Hw1)
                                   (SNo_mul_SNo v y Hv1 H1).
          prove 1 <= - v * w + x * w + v * y.
          rewrite add_SNo_com (- v * w) (x * w + v * y)
                                   (SNo_minus_SNo (v * w) (SNo_mul_SNo v w Hv1 Hw1))
                                   (SNo_add_SNo (x * w) (v * y)
                                    (SNo_mul_SNo x w Hx Hw1)
                                    (SNo_mul_SNo v y Hv1 H1)).
          prove 1 <= (x * w + v * y) + - v * w.
          apply add_SNo_minus_Le2b (x * w + v * y) (v * w) 1
                                   (SNo_add_SNo (x * w) (v * y)
                                    (SNo_mul_SNo x w Hx Hw1)
                                    (SNo_mul_SNo v y Hv1 H1))
                                   (SNo_mul_SNo v w Hv1 Hw1)
                                   SNo_1.
          prove 1 + v * w <= x * w + v * y.
          rewrite add_SNo_com (x * w) (v * y) (SNo_mul_SNo x w Hx Hw1) (SNo_mul_SNo v y Hv1 H1).
          prove 1 + v * w <= v * y + x * w.
          exact H7.
        + prove (- v + x) * w + v * y <= (- v + x) * w' + v * y.
          apply add_SNo_Le1 ((- v + x) * w) (v * y) ((- v + x) * w')
                            (SNo_mul_SNo (- v + x) w (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx) Hw1)
                            (SNo_mul_SNo v y Hv1 H1)
                            (SNo_mul_SNo (- v + x) w' (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx) Hw').
          prove (- v + x) * w <= (- v + x) * w'.
          exact H8.
      - prove 1 + v * (y + - w'') < 1.
        rewrite <- add_SNo_0R 1 SNo_1 at 4.
        prove 1 + v * (y + - w'') < 1 + 0.
        apply add_SNo_Lt2 1 (v * (y + - w'')) 0 SNo_1 (SNo_mul_SNo v (y + - w'') Hv1 (SNo_add_SNo y (- w'') H1 (SNo_minus_SNo w'' Lw''1))) SNo_0.
        prove v * (y + - w'') < 0.
        apply mul_SNo_pos_neg v (y + - w'') Hv1 (SNo_add_SNo y (- w'') H1 (SNo_minus_SNo w'' Lw''1)) Hvpos.
        prove y + - w'' < 0.
        apply add_SNo_minus_Lt1b y w'' 0 H1 Lw''1 SNo_0.
        prove y < 0 + w''.
        rewrite add_SNo_0L w'' Lw''1.
        prove y < w''.
        exact H4 w'' Hw''.
    }
    apply mul_SNo_SNoL_interpolate_impred x y Hx H1 1 L10.
    * { let v. assume Hv: v :e SNoL x.
        let w. assume Hw: w :e SNoL y.
        assume H7: 1 + v * w <= v * y + x * w.
        apply SNoL_E x Hx v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev x.
        assume Hv3: v < x.
        apply SNoL_E y H1 w Hw.
        assume Hw1: SNo w.
        assume Hw2: SNoLev w :e SNoLev y.
        assume Hw3: w < y.
        claim LvS: v :e SNoS_ (SNoLev x).
        { exact SNoS_I2 v x Hv1 Hx Hv2. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        apply L6 w Hw.
        let w'. assume Hw'. apply Hw'.
        assume Hw'1: w' :e L.
        assume Hw'2: w <= w'.
        claim Lw': SNo w'.
        { exact HL w' Hw'1. }
        claim Lxw': SNo (x * w').
        { exact SNo_mul_SNo x w' Hx Lw'. }
        claim Lvpos: 0 < v.
        { apply SNoLtLe_or 0 v SNo_0 Hv1.
          - assume H8: 0 < v. exact H8.
          - assume H8: v <= 0. prove False.
            apply SNoLt_irref 1.
            prove 1 < 1.
            apply SNoLeLt_tra 1 (x * w') 1 SNo_1 Lxw' SNo_1.
            + prove 1 <= x * w'.
              apply SNoLe_tra 1 (x * w) (x * w') SNo_1 Lxw Lxw'.
              * { prove 1 <= x * w.
                  apply SNoLe_tra 1 (v * (y + - w) + x * w) (x * w) SNo_1 (SNo_add_SNo (v * (y + - w)) (x * w) (SNo_mul_SNo v (y + - w) Hv1 (SNo_add_SNo y (- w) H1 (SNo_minus_SNo w Hw1))) Lxw) Lxw.
                  - prove 1 <= v * (y + - w) + x * w.
                    rewrite mul_SNo_distrL v y (- w) Hv1 H1 (SNo_minus_SNo w Hw1).
                    prove 1 <= (v * y + v * (- w)) + x * w.
                    rewrite add_SNo_com_3b_1_2 (v * y) (v * (- w)) (x * w) (SNo_mul_SNo v y Hv1 H1) (SNo_mul_SNo v (- w) Hv1 (SNo_minus_SNo w Hw1)) Lxw.
                    prove 1 <= (v * y + x * w) + v * (- w).
                    rewrite mul_SNo_minus_distrR v w Hv1 Hw1.
                    prove 1 <= (v * y + x * w) + - v * w.
                    apply add_SNo_minus_Le2b (v * y + x * w) (v * w) 1 (SNo_add_SNo (v * y) (x * w) (SNo_mul_SNo v y Hv1 H1) Lxw) (SNo_mul_SNo v w Hv1 Hw1) SNo_1.
                    prove 1 + v * w <= v * y + x * w.
                    exact H7.
                  - prove v * (y + - w) + x * w <= x * w.
                    rewrite <- add_SNo_0L (x * w) Lxw at 2.
                    prove v * (y + - w) + x * w <= 0 + x * w.
                    apply add_SNo_Le1 (v * (y + - w)) (x * w) 0 (SNo_mul_SNo v (y + - w) Hv1 (SNo_add_SNo y (- w) H1 (SNo_minus_SNo w Hw1))) Lxw SNo_0.
                    prove v * (y + - w) <= 0.
                    apply mul_SNo_nonpos_pos v (y + - w) Hv1 (SNo_add_SNo y (- w) H1 (SNo_minus_SNo w Hw1)) H8.
                    prove 0 < y + - w.
                    apply add_SNo_minus_Lt2b y w 0 H1 Hw1 SNo_0.
                    prove 0 + w < y.
                    rewrite add_SNo_0L w Hw1.
                    prove w < y.
                    exact Hw3.
                }
              * prove x * w <= x * w'.
                exact nonneg_mul_SNo_Le x w w' Hx (SNoLtLe 0 x Hxpos) Hw1 Lw' Hw'2.
            + prove x * w' < 1.
              exact L1L w' Hw'1.
        }
        set w'' := (1 + (v + - x) * w') * recip_SNo_pos v.
        claim Lw'': w'' :e R.
        { apply famunionE_impred omega (fun k => SNo_recipaux x recip_SNo_pos k 0) w' Hw'1.
          let k. assume Hk: k :e omega.
          assume H9: w' :e SNo_recipaux x recip_SNo_pos k 0.
          apply famunionI omega (fun k => SNo_recipaux x recip_SNo_pos k 1) (ordsucc k) w'' (omega_ordsucc k Hk).
          prove w'' :e SNo_recipaux x recip_SNo_pos (ordsucc k) 1.
          rewrite SNo_recipaux_S x recip_SNo_pos k (omega_nat_p k Hk).
          rewrite tuple_2_1_eq.
          prove w'' :e SNo_recipaux x recip_SNo_pos k 1 :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 0) x (SNoL_pos x) recip_SNo_pos
                           :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 1) x (SNoR x) recip_SNo_pos.
          apply binunionI1. apply binunionI2.
          prove w'' :e SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 0) x (SNoL_pos x) recip_SNo_pos.
          apply SNo_recipauxset_I (SNo_recipaux x recip_SNo_pos k 0) x (SNoL_pos x) recip_SNo_pos.
          - prove w' :e SNo_recipaux x recip_SNo_pos k 0.
            exact H9.
          - prove v :e SNoL_pos x.
            prove v :e {w :e SNoL x|0 < w}.
            apply SepI.
            + exact Hv.
            + prove 0 < v. exact Lvpos.
        }
        apply L11 v w w' Hv1 Hw1 Lw' LvS Lvpos H7 Lw''.
        prove (- v + x) * w <= (- v + x) * w'.
        apply nonneg_mul_SNo_Le (- v + x) w w' (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx).
        - prove 0 <= - v + x.
          rewrite add_SNo_com (- v) x (SNo_minus_SNo v Hv1) Hx.
          prove 0 <= x + - v.
          apply add_SNo_minus_Le2b x v 0 Hx Hv1 SNo_0.
          prove 0 + v <= x.
          rewrite add_SNo_0L v Hv1.
          prove v <= x.
          apply SNoLtLe. exact Hv3.
        - exact Hw1.
        - exact Lw'.
        - exact Hw'2.
      }
    * { let v. assume Hv: v :e SNoR x.
        let w. assume Hw: w :e SNoR y.
        assume H7: 1 + v * w <= v * y + x * w.
        apply SNoR_E x Hx v Hv.
        assume Hv1: SNo v.
        assume Hv2: SNoLev v :e SNoLev x.
        assume Hv3: x < v.
        apply SNoR_E y H1 w Hw.
        assume Hw1: SNo w.
        assume Hw2: SNoLev w :e SNoLev y.
        assume Hw3: y < w.
        claim LvS: v :e SNoS_ (SNoLev x).
        { exact SNoS_I2 v x Hv1 Hx Hv2. }
        claim Lvpos: 0 < v.
        { exact SNoLt_tra 0 x v SNo_0 Hx Hv1 Hxpos Hv3. }
        claim Lxw: SNo (x * w).
        { exact SNo_mul_SNo x w Hx Hw1. }
        apply L7 w Hw.
        let w'. assume Hw'. apply Hw'.
        assume Hw'1: w' :e R.
        assume Hw'2: w' <= w.
        claim Lw': SNo w'.
        { exact HR w' Hw'1. }
        claim Lxw': SNo (x * w').
        { exact SNo_mul_SNo x w' Hx Lw'. }
        set w'' := (1 + (v + - x) * w') * recip_SNo_pos v.
        claim Lw'': w'' :e R.
        { apply famunionE_impred omega (fun k => SNo_recipaux x recip_SNo_pos k 1) w' Hw'1.
          let k. assume Hk: k :e omega.
          assume H9: w' :e SNo_recipaux x recip_SNo_pos k 1.
          apply famunionI omega (fun k => SNo_recipaux x recip_SNo_pos k 1) (ordsucc k) w'' (omega_ordsucc k Hk).
          prove w'' :e SNo_recipaux x recip_SNo_pos (ordsucc k) 1.
          rewrite SNo_recipaux_S x recip_SNo_pos k (omega_nat_p k Hk).
          rewrite tuple_2_1_eq.
          prove w'' :e SNo_recipaux x recip_SNo_pos k 1 :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 0) x (SNoL_pos x) recip_SNo_pos
                           :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 1) x (SNoR x) recip_SNo_pos.
          apply binunionI2.
          prove w'' :e SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 1) x (SNoR x) recip_SNo_pos.
          apply SNo_recipauxset_I (SNo_recipaux x recip_SNo_pos k 1) x (SNoR x) recip_SNo_pos.
          - prove w' :e SNo_recipaux x recip_SNo_pos k 1.
            exact H9.
          - prove v :e SNoR x. exact Hv.
        }
        apply L11 v w w' Hv1 Hw1 Lw' LvS Lvpos H7 Lw''.
        prove (- v + x) * w <= (- v + x) * w'.
        apply L11 v w w' Hv1 Hw1 Lw' LvS Lvpos H7 Lw''.
        prove (- v + x) * w <= (- v + x) * w'.
        apply nonpos_mul_SNo_Le (- v + x) w w' (SNo_add_SNo (- v) x (SNo_minus_SNo v Hv1) Hx).
        - prove - v + x <= 0.
          rewrite add_SNo_com (- v) x (SNo_minus_SNo v Hv1) Hx.
          prove x + - v <= 0.
          apply add_SNo_minus_Le2 0 (- v) x SNo_0 (SNo_minus_SNo v Hv1) Hx.
          rewrite minus_SNo_invol v Hv1.
          prove x <= 0 + v.
          rewrite add_SNo_0L v Hv1.
          apply SNoLtLe. exact Hv3.
        - exact Hw1.
        - exact Lw'.
        - exact Hw'2.
      }
Qed.

Theorem SNo_recip_SNo_pos: forall x, SNo x -> 0 < x -> SNo (recip_SNo_pos x).
let x. assume Hx Hxpos.
apply recip_SNo_pos_prop1 x Hx Hxpos. assume H _. exact H.
Qed.

Theorem recip_SNo_pos_invR: forall x, SNo x -> 0 < x -> x * recip_SNo_pos x = 1.
let x. assume Hx Hxpos.
apply recip_SNo_pos_prop1 x Hx Hxpos. assume _ H. exact H.
Qed.

Theorem recip_SNo_pos_is_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo_pos x.
let x. assume Hx Hxpos.
claim Lrx: SNo (recip_SNo_pos x).
{ exact SNo_recip_SNo_pos x Hx Hxpos. }
apply SNoLt_trichotomy_or_impred (recip_SNo_pos x) 0 Lrx SNo_0.
- assume H1: recip_SNo_pos x < 0.
  prove False.
  apply SNoLt_irref 0.
  prove 0 < 0.
  apply SNoLt_tra 0 1 0 SNo_0 SNo_1 SNo_0 SNoLt_0_1.
  prove 1 < 0.
  rewrite <- recip_SNo_pos_invR x Hx Hxpos.
  prove x * recip_SNo_pos x < 0.
  exact mul_SNo_pos_neg x (recip_SNo_pos x) Hx Lrx Hxpos H1.
- assume H1: recip_SNo_pos x = 0.
  prove False.
  apply neq_1_0.
  prove 1 = 0.
  rewrite <- recip_SNo_pos_invR x Hx Hxpos.
  prove x * recip_SNo_pos x = 0.
  rewrite H1.
  exact mul_SNo_zeroR x Hx.
- assume H1. exact H1.
Qed.

Theorem recip_SNo_pos_invol: forall x, SNo x -> 0 < x -> recip_SNo_pos (recip_SNo_pos x) = x.
let x. assume Hx Hxpos.
claim Lrx: SNo (recip_SNo_pos x).
{ exact SNo_recip_SNo_pos x Hx Hxpos. }
claim Lrxpos: 0 < recip_SNo_pos x.
{ exact recip_SNo_pos_is_pos x Hx Hxpos. }
claim Lrrx: SNo (recip_SNo_pos (recip_SNo_pos x)).
{ exact SNo_recip_SNo_pos (recip_SNo_pos x) Lrx Lrxpos. }
claim Lrxn0: recip_SNo_pos x <> 0.
{ assume Hrx0: recip_SNo_pos x = 0.
  apply SNoLt_irref 0.
  prove 0 < 0.
  rewrite <- Hrx0 at 2.
  exact Lrxpos.
}
prove recip_SNo_pos (recip_SNo_pos x) = x.
apply mul_SNo_nonzero_cancel (recip_SNo_pos x) (recip_SNo_pos (recip_SNo_pos x)) x Lrx Lrxn0 Lrrx Hx.
prove recip_SNo_pos x * recip_SNo_pos (recip_SNo_pos x) = recip_SNo_pos x * x.
rewrite mul_SNo_com (recip_SNo_pos x) x Lrx Hx.
rewrite recip_SNo_pos_invR x Hx Hxpos.
exact recip_SNo_pos_invR (recip_SNo_pos x) Lrx Lrxpos.
Qed.

Theorem recip_SNo_pos_eps_: forall n, nat_p n -> recip_SNo_pos (eps_ n) = 2 ^ n.
let n. assume Hn.
claim Len1: SNo (eps_ n).
{ exact SNo_eps_ n (nat_p_omega n Hn). }
claim Len2: 0 < eps_ n.
{ exact SNo_eps_pos n (nat_p_omega n Hn). }
claim Len3: eps_ n <> 0.
{ assume H1: eps_ n = 0.
  apply SNoLt_irref 0.
  prove 0 < 0.
  rewrite <- H1 at 2.
  prove 0 < eps_ n.
  exact Len2.
}
apply mul_SNo_nonzero_cancel (eps_ n) (recip_SNo_pos (eps_ n)) (2 ^ n) Len1 Len3 (SNo_recip_SNo_pos (eps_ n) Len1 Len2) (SNo_exp_SNo_nat 2 SNo_2 n Hn).
prove eps_ n * recip_SNo_pos (eps_ n) = eps_ n * 2 ^ n.
rewrite mul_SNo_eps_power_2 n Hn.
prove eps_ n * recip_SNo_pos (eps_ n) = 1.
exact recip_SNo_pos_invR (eps_ n) Len1 Len2.
Qed.

Theorem recip_SNo_pos_pow_2: forall n, nat_p n -> recip_SNo_pos (2 ^ n) = eps_ n.
let n. assume Hn.
rewrite <- recip_SNo_pos_eps_ n Hn.
exact recip_SNo_pos_invol (eps_ n) (SNo_eps_ n (nat_p_omega n Hn)) (SNo_eps_pos n (nat_p_omega n Hn)).
Qed.

Theorem recip_SNo_pos_2: recip_SNo_pos 2 = eps_ 1.
rewrite <- exp_SNo_nat_1 2 SNo_2.
exact recip_SNo_pos_pow_2 1 nat_1.
Qed.

End recip_SNo_pos.
Definition recip_SNo : set -> set := fun x => if 0 < x then recip_SNo_pos x else if x < 0 then - recip_SNo_pos (- x) else 0.

Theorem recip_SNo_poscase: forall x, 0 < x -> recip_SNo x = recip_SNo_pos x.
let x. assume Hxpos.
exact If_i_1 (0 < x) (recip_SNo_pos x) (if x < 0 then - recip_SNo_pos (- x) else 0) Hxpos.
Qed.

Theorem recip_SNo_negcase: forall x, SNo x -> x < 0 -> recip_SNo x = - recip_SNo_pos (- x).
let x. assume Hx Hxneg.
claim L1: ~(0 < x).
{ assume H1. apply SNoLt_irref 0.
  prove 0 < 0.
  exact SNoLt_tra 0 x 0 SNo_0 Hx SNo_0 H1 Hxneg.
}
prove (if 0 < x then recip_SNo_pos x else if x < 0 then - recip_SNo_pos (- x) else 0) = - recip_SNo_pos (- x).
rewrite If_i_0 (0 < x) (recip_SNo_pos x) (if x < 0 then - recip_SNo_pos (- x) else 0) L1.
exact If_i_1 (x < 0) (- recip_SNo_pos (- x)) 0 Hxneg.
Qed.

Theorem recip_SNo_0: recip_SNo 0 = 0.
prove (if 0 < 0 then recip_SNo_pos 0 else if 0 < 0 then - recip_SNo_pos (- 0) else 0) = 0.
rewrite If_i_0 (0 < 0) (recip_SNo_pos 0) (if 0 < 0 then - recip_SNo_pos (- 0) else 0) (SNoLt_irref 0).
prove (if 0 < 0 then - recip_SNo_pos (- 0) else 0) = 0.
exact If_i_0 (0 < 0) (- recip_SNo_pos (- 0)) 0 (SNoLt_irref 0).
Qed.

Theorem SNo_recip_SNo: forall x, SNo x -> SNo (recip_SNo x).
let x. assume Hx.
apply SNoLt_trichotomy_or_impred x 0 Hx SNo_0.
- assume H1: x < 0. rewrite recip_SNo_negcase x Hx H1.
  prove SNo (- recip_SNo_pos (- x)).
  apply SNo_minus_SNo.
  prove SNo (recip_SNo_pos (- x)).
  apply SNo_recip_SNo_pos.
  + exact SNo_minus_SNo x Hx.
  + prove 0 < - x.
    apply minus_SNo_Lt_contra2 x 0 Hx SNo_0.
    prove x < - 0.
    rewrite minus_SNo_0.
    prove x < 0.
    exact H1.
- assume H1: x = 0. rewrite H1. rewrite recip_SNo_0. exact SNo_0.
- assume H1: 0 < x. rewrite recip_SNo_poscase x H1.
  exact SNo_recip_SNo_pos x Hx H1.
Qed.

Theorem recip_SNo_invR: forall x, SNo x -> x <> 0 -> x * recip_SNo x = 1.
let x. assume Hx Hx0.
apply SNoLt_trichotomy_or_impred x 0 Hx SNo_0.
- assume H1: x < 0. rewrite recip_SNo_negcase x Hx H1.
  claim L1: 0 < - x.
  { apply minus_SNo_Lt_contra2 x 0 Hx SNo_0.
    prove x < - 0.
    rewrite minus_SNo_0.
    prove x < 0.
    exact H1.
  }
  prove x * (- recip_SNo_pos (- x)) = 1.
  rewrite mul_SNo_minus_distrR x (recip_SNo_pos (- x)) Hx (SNo_recip_SNo_pos (- x) (SNo_minus_SNo x Hx) L1).
  prove - (x * recip_SNo_pos (- x)) = 1.
  rewrite <- mul_SNo_minus_distrL x (recip_SNo_pos (- x)) Hx (SNo_recip_SNo_pos (- x) (SNo_minus_SNo x Hx) L1).
  prove (- x) * recip_SNo_pos (- x) = 1.
  exact recip_SNo_pos_invR (- x) (SNo_minus_SNo x Hx) L1.
- assume H1: x = 0. prove False. exact Hx0 H1.
- assume H1: 0 < x. rewrite recip_SNo_poscase x H1.
  exact recip_SNo_pos_invR x Hx H1.
Qed.

Theorem recip_SNo_invL: forall x, SNo x -> x <> 0 -> recip_SNo x * x = 1.
let x. assume Hx Hx0.
rewrite mul_SNo_com (recip_SNo x) x (SNo_recip_SNo x Hx) Hx.
prove x * recip_SNo x = 1.
exact recip_SNo_invR x Hx Hx0.
Qed.

Theorem mul_SNo_nonzero_cancel_L: forall x y z, SNo x -> x <> 0 -> SNo y -> SNo z -> x * y = x * z -> y = z.
let x y z. assume Hx Hx0 Hy Hz.
assume H1: x * y = x * z.
prove y = z.
rewrite <- mul_SNo_oneL y Hy.
rewrite <- mul_SNo_oneL z Hz.
prove 1 * y = 1 * z.
rewrite <- recip_SNo_invL x Hx Hx0.
prove (recip_SNo x * x) * y = (recip_SNo x * x) * z.
rewrite <- mul_SNo_assoc (recip_SNo x) x y (SNo_recip_SNo x Hx) Hx Hy.
rewrite <- mul_SNo_assoc (recip_SNo x) x z (SNo_recip_SNo x Hx) Hx Hz.
prove recip_SNo x * (x * y) = recip_SNo x * (x * z).
f_equal.
exact H1.
Qed.

Theorem recip_SNo_pow_2 : forall n, nat_p n -> recip_SNo (2 ^ n) = eps_ n.
let n. assume Hn.
claim L1: 0 < 2 ^ n.
{ exact exp_SNo_nat_pos 2 SNo_2 SNoLt_0_2 n Hn. }
rewrite recip_SNo_poscase (2 ^ n) L1.
exact recip_SNo_pos_pow_2 n Hn.
Qed.

Theorem recip_SNo_of_pos_is_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo x.
let x. assume Hx Hxpos.
rewrite recip_SNo_poscase x Hxpos.
exact recip_SNo_pos_is_pos x Hx Hxpos.
Qed.

Definition div_SNo : set -> set -> set := fun x y => x * recip_SNo y.

Infix :/: 353 := div_SNo.

Theorem SNo_div_SNo: forall x y, SNo x -> SNo y -> SNo (x :/: y).
let x y. assume Hx Hy.
prove SNo (x * recip_SNo y).
exact SNo_mul_SNo x (recip_SNo y) Hx (SNo_recip_SNo y Hy).
Qed.

Theorem div_SNo_0_num: forall x, SNo x -> 0 :/: x = 0.
let x. assume Hx.
exact mul_SNo_zeroL (recip_SNo x) (SNo_recip_SNo x Hx).
Qed.

Theorem div_SNo_0_denum: forall x, SNo x -> x :/: 0 = 0.
let x. assume Hx.
prove x * recip_SNo 0 = 0.
rewrite recip_SNo_0.
exact mul_SNo_zeroR x Hx.
Qed.

Theorem mul_div_SNo_invL: forall x y, SNo x -> SNo y -> y <> 0 -> (x :/: y) * y = x.
let x y. assume Hx Hy Hy0.
prove (x * recip_SNo y) * y = x.
rewrite <- mul_SNo_assoc x (recip_SNo y) y Hx (SNo_recip_SNo y Hy) Hy.
prove x * (recip_SNo y * y) = x.
rewrite recip_SNo_invL y Hy Hy0.
prove x * 1 = x.
exact mul_SNo_oneR x Hx.
Qed.

Theorem mul_div_SNo_invR: forall x y, SNo x -> SNo y -> y <> 0 -> y * (x :/: y) = x.
let x y. assume Hx Hy Hy0.
rewrite mul_SNo_com y (x :/: y) Hy (SNo_div_SNo x y Hx Hy).
exact mul_div_SNo_invL x y Hx Hy Hy0.
Qed.

Theorem mul_div_SNo_R: forall x y z, SNo x -> SNo y -> SNo z -> (x :/: y) * z = (x * z) :/: y.
let x y z. assume Hx Hy Hz.
apply xm (y = 0).
- assume H1: y = 0.
  rewrite H1.
  rewrite div_SNo_0_denum x Hx.
  rewrite div_SNo_0_denum (x * z) (SNo_mul_SNo x z Hx Hz).
  prove 0 * z = 0.
  exact mul_SNo_zeroL z Hz.
- assume H1: y <> 0.
  apply mul_SNo_nonzero_cancel y ((x :/: y) * z) ((x * z) :/: y) Hy H1 (SNo_mul_SNo (x :/: y) z (SNo_div_SNo x y Hx Hy) Hz) (SNo_div_SNo (x * z) y (SNo_mul_SNo x z Hx Hz) Hy).
  prove y * (x :/: y) * z = y * (x * z) :/: y.
  rewrite mul_div_SNo_invR (x * z) y (SNo_mul_SNo x z Hx Hz) Hy H1.
  prove y * (x :/: y) * z = x * z.
  rewrite mul_SNo_assoc y (x :/: y) z Hy (SNo_div_SNo x y Hx Hy) Hz.
  prove (y * (x :/: y)) * z = x * z.
  f_equal.
  prove y * (x :/: y) = x.
  exact mul_div_SNo_invR x y Hx Hy H1.
Qed.

Theorem mul_div_SNo_L: forall x y z, SNo x -> SNo y -> SNo z -> z * (x :/: y) = (z * x) :/: y.
let x y z. assume Hx Hy Hz.
transitivity (x :/: y) * z, (x * z) :/: y.
- exact mul_SNo_com z (x :/: y) Hz (SNo_div_SNo x y Hx Hy).
- exact mul_div_SNo_R x y z Hx Hy Hz.
- f_equal. exact mul_SNo_com x z Hx Hz.
Qed.

Theorem div_mul_SNo_invL: forall x y, SNo x -> SNo y -> y <> 0 -> (x * y) :/: y = x.
let x y. assume Hx Hy Hy0.
rewrite <- mul_div_SNo_R x y y Hx Hy Hy.
prove (x :/: y) * y = x.
exact mul_div_SNo_invL x y Hx Hy Hy0.
Qed.

Theorem div_div_SNo: forall x y z, SNo x -> SNo y -> SNo z -> (x :/: y) :/: z = x :/: (y * z).
let x y z. assume Hx Hy Hz.
claim Lxdy: SNo (x :/: y).
{ exact SNo_div_SNo x y Hx Hy. }
claim Lxdydz: SNo ((x :/: y) :/: z).
{ exact SNo_div_SNo (x :/: y) z Lxdy Hz. }
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Hx Hy. }
claim Lyz: SNo (y * z).
{ exact SNo_mul_SNo y z Hy Hz. }
claim Lxdyz: SNo (x :/: (y * z)).
{ exact SNo_div_SNo x (y * z) Hx Lyz. }
apply xm (y = 0).
- assume Hy0: y = 0.
  rewrite Hy0.
  prove (x :/: 0) :/: z = x :/: (0 * z).
  rewrite mul_SNo_zeroL z Hz.
  rewrite div_SNo_0_denum x Hx.
  prove 0 :/: z = 0.
  exact div_SNo_0_num z Hz.
- assume Hy0: y <> 0.
  apply xm (z = 0).
  + assume Hz0: z = 0.
    rewrite Hz0.
    prove (x :/: y) :/: 0 = x :/: (y * 0).
    rewrite mul_SNo_zeroR y Hy.
    prove (x :/: y) :/: 0 = x :/: 0.
    rewrite div_SNo_0_denum x Hx.
    exact div_SNo_0_denum (x :/: y) Lxdy.
  + assume Hz0: z <> 0.
    claim Lyz0: y * z <> 0.
    { assume H1: y * z = 0.
      apply Hz0.
      prove z = 0.
      apply mul_SNo_nonzero_cancel y z 0 Hy Hy0 Hz SNo_0.
      prove y * z = y * 0.
      rewrite mul_SNo_zeroR y Hy.
      exact H1.
    }
    apply mul_SNo_nonzero_cancel z ((x :/: y) :/: z) (x :/: (y * z)) Hz Hz0 Lxdydz Lxdyz.
    rewrite mul_div_SNo_invR (x :/: y) z Lxdy Hz Hz0.
    prove x :/: y = z * (x :/: (y * z)).
    apply mul_SNo_nonzero_cancel y (x :/: y) (z * (x :/: (y * z))) Hy Hy0 Lxdy (SNo_mul_SNo z (x :/: (y * z)) Hz Lxdyz).
    rewrite mul_div_SNo_invR x y Hx Hy Hy0.
    prove x = y * z * (x :/: (y * z)).
    rewrite mul_SNo_assoc y z (x :/: (y * z)) Hy Hz Lxdyz.
    symmetry.
    exact mul_div_SNo_invR x (y * z) Hx Lyz Lyz0.
Qed.

Theorem mul_div_SNo_both: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x :/: y) * (z :/: w) = (x * z) :/: (y * w).
let x y z w. assume Hx Hy Hz Hw.
rewrite mul_div_SNo_L z w (x :/: y) Hz Hw (SNo_div_SNo x y Hx Hy).
prove ((x :/: y) * z) :/: w = (x * z) :/: (y * w).
rewrite mul_div_SNo_R x y z Hx Hy Hz.
prove ((x * z) :/: y) :/: w = (x * z) :/: (y * w).
exact div_div_SNo (x * z) y w (SNo_mul_SNo x z Hx Hz) Hy Hw.
Qed.

Theorem recip_SNo_pos_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo_pos x.
let x. assume Hx Hxpos.
apply SNoLtLe_or 0 (recip_SNo_pos x) SNo_0 (SNo_recip_SNo_pos x Hx Hxpos).
- assume H1: 0 < recip_SNo_pos x. exact H1.
- assume H1: recip_SNo_pos x <= 0. prove False.
  apply SNoLt_irref 0.
  prove 0 < 0.
  apply SNoLtLe_tra 0 1 0 SNo_0 SNo_1 SNo_0 SNoLt_0_1.
  prove 1 <= 0.
  rewrite <- recip_SNo_pos_invR x Hx Hxpos.
  prove x * recip_SNo_pos x <= 0.
  rewrite <- mul_SNo_zeroR x Hx.
  prove x * recip_SNo_pos x <= x * 0.
  exact nonneg_mul_SNo_Le x (recip_SNo_pos x) 0 Hx (SNoLtLe 0 x Hxpos) (SNo_recip_SNo_pos x Hx Hxpos) SNo_0 H1.
Qed.

Theorem div_SNo_pos_pos: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> 0 < x :/: y.
let x y. assume Hx Hy Hxpos Hypos.
prove 0 < x * recip_SNo y.
apply mul_SNo_pos_pos x (recip_SNo y) Hx (SNo_recip_SNo y Hy) Hxpos.
prove 0 < recip_SNo y.
exact recip_SNo_of_pos_is_pos y Hy Hypos.
Qed.

Theorem div_SNo_neg_pos: forall x y, SNo x -> SNo y -> x < 0 -> 0 < y -> x :/: y < 0.
let x y. assume Hx Hy Hxneg Hypos.
prove x * recip_SNo y < 0.
apply mul_SNo_neg_pos x (recip_SNo y) Hx (SNo_recip_SNo y Hy) Hxneg.
prove 0 < recip_SNo y.
exact recip_SNo_of_pos_is_pos y Hy Hypos.
Qed.

Theorem div_SNo_pos_LtL : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> x < z * y -> x :/: y < z.
let x y z. assume Hx Hy Hz Hypos.
assume H1: x < z * y.
prove x :/: y < z.
rewrite <- mul_SNo_oneR z Hz.
prove x :/: y < z * 1.
claim Ly0: y <> 0.
{ assume H2: y = 0. apply SNoLt_irref y.
  prove y < y. rewrite H2 at 1.
  exact Hypos.
}
rewrite <- recip_SNo_invR y Hy Ly0.
prove x * recip_SNo y < z * y * recip_SNo y.
rewrite mul_SNo_assoc z y (recip_SNo y) Hz Hy (SNo_recip_SNo y Hy).
prove x * recip_SNo y < (z * y) * recip_SNo y.
apply pos_mul_SNo_Lt' x (z * y) (recip_SNo y) Hx (SNo_mul_SNo z y Hz Hy) (SNo_recip_SNo y Hy).
- prove 0 < recip_SNo y.
  exact recip_SNo_of_pos_is_pos y Hy Hypos.
- prove x < z * y. exact H1.
Qed.

Theorem div_SNo_pos_LtR : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> z * y < x -> z < x :/: y.
let x y z. assume Hx Hy Hz Hypos.
assume H1: z * y < x.
prove z < x :/: y.
rewrite <- mul_SNo_oneR z Hz.
prove z * 1 < x :/: y.
claim Ly0: y <> 0.
{ assume H2: y = 0. apply SNoLt_irref y.
  prove y < y. rewrite H2 at 1.
  exact Hypos.
}
rewrite <- recip_SNo_invR y Hy Ly0.
prove z * y * recip_SNo y < x * recip_SNo y.
rewrite mul_SNo_assoc z y (recip_SNo y) Hz Hy (SNo_recip_SNo y Hy).
prove (z * y) * recip_SNo y < x * recip_SNo y.
apply pos_mul_SNo_Lt' (z * y) x (recip_SNo y) (SNo_mul_SNo z y Hz Hy) Hx (SNo_recip_SNo y Hy).
- prove 0 < recip_SNo y.
  exact recip_SNo_of_pos_is_pos y Hy Hypos.
- prove z * y < x. exact H1.
Qed.

Theorem div_SNo_pos_LtL' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> x :/: y < z -> x < z * y.
let x y z. assume Hx Hy Hz Hypos.
assume H1: x :/: y < z.
prove x < z * y.
rewrite <- mul_SNo_oneR x Hx.
prove x * 1 < z * y.
claim Ly0: y <> 0.
{ assume H2: y = 0. apply SNoLt_irref y.
  prove y < y. rewrite H2 at 1.
  exact Hypos.
}
rewrite <- recip_SNo_invL y Hy Ly0.
prove x * (recip_SNo y * y) < z * y.
rewrite mul_SNo_assoc x (recip_SNo y) y Hx (SNo_recip_SNo y Hy) Hy.
prove (x * recip_SNo y) * y < z * y.
prove (x :/: y) * y < z * y.
exact pos_mul_SNo_Lt' (x :/: y) z y (SNo_div_SNo x y Hx Hy) Hz Hy Hypos H1.
Qed.

Theorem div_SNo_pos_LtR' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> z < x :/: y -> z * y < x.
let x y z. assume Hx Hy Hz Hypos.
assume H1: z < x :/: y.
prove z * y < x.
rewrite <- mul_SNo_oneR x Hx.
prove z * y < x * 1.
claim Ly0: y <> 0.
{ assume H2: y = 0. apply SNoLt_irref y.
  prove y < y. rewrite H2 at 1.
  exact Hypos.
}
rewrite <- recip_SNo_invL y Hy Ly0.
prove z * y < x * (recip_SNo y * y).
rewrite mul_SNo_assoc x (recip_SNo y) y Hx (SNo_recip_SNo y Hy) Hy.
prove z * y < (x * recip_SNo y) * y.
prove z * y < (x :/: y) * y.
exact pos_mul_SNo_Lt' z (x :/: y) y Hz (SNo_div_SNo x y Hx Hy) Hy Hypos H1.
Qed.

Theorem mul_div_SNo_nonzero_eq: forall x y z, SNo x -> SNo y -> SNo z -> y <> 0 -> x = y * z -> x :/: y = z.
let x y z. assume Hx Hy Hz Hy0 H1.
apply mul_SNo_nonzero_cancel y (x :/: y) z Hy Hy0 (SNo_div_SNo x y Hx Hy) Hz.
prove y * (x :/: y) = y * z.
rewrite mul_div_SNo_invR x y Hx Hy Hy0.
exact H1.
Qed.

End SurrealDiv.

Opaque recip_SNo_pos recip_SNo.

Section Reals.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem SNoS_omega_drat_intvl : forall x :e SNoS_ omega,
  forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
let x. assume Hx.
apply SNoS_E2 omega omega_ordinal x Hx.
assume Hx1 Hx2 Hx3 Hx4.
let k. assume Hk. prove exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
claim Lk1: SNo (eps_ (ordsucc k)).
{ exact SNo_eps_ (ordsucc k) (omega_ordsucc k Hk). }
witness x + - eps_ (ordsucc k).
apply andI.
- prove x + - eps_ (ordsucc k) :e SNoS_ omega.
  exact add_SNo_SNoS_omega x Hx (- eps_ (ordsucc k)) (minus_SNo_SNoS_omega (eps_ (ordsucc k)) (SNo_eps_SNoS_omega (ordsucc k) (omega_ordsucc k Hk))).
- apply andI.
  + prove x + - eps_ (ordsucc k) < x.
    apply add_SNo_minus_Lt1b x (eps_ (ordsucc k)) x Hx3 Lk1 Hx3.
    prove x < x + eps_ (ordsucc k).
    exact add_SNo_eps_Lt x Hx3 (ordsucc k) (omega_ordsucc k Hk).
  + prove x < (x + - eps_ (ordsucc k)) + eps_ k.
    rewrite <- eps_ordsucc_half_add k (omega_nat_p k Hk).
    prove x < (x + - eps_ (ordsucc k)) + (eps_ (ordsucc k) + eps_ (ordsucc k)).
    rewrite add_SNo_com_4_inner_mid x (- eps_ (ordsucc k)) (eps_ (ordsucc k)) (eps_ (ordsucc k)) Hx3 (SNo_minus_SNo (eps_ (ordsucc k)) Lk1) Lk1 Lk1.
    prove x < (x + eps_ (ordsucc k)) + (- eps_ (ordsucc k) + eps_ (ordsucc k)).
    rewrite add_SNo_minus_SNo_linv (eps_ (ordsucc k)) Lk1.
    rewrite add_SNo_0R (x + eps_ (ordsucc k)) (SNo_add_SNo x (eps_ (ordsucc k)) Hx3 Lk1).
    prove x < x + eps_ (ordsucc k).
    exact add_SNo_eps_Lt x Hx3 (ordsucc k) (omega_ordsucc k Hk).
Qed.

Theorem SNoS_ordsucc_omega_bdd_above : forall x :e SNoS_ (ordsucc omega), x < omega -> exists N :e omega, x < N.
let x. assume Hx1 Hx2.
apply SNoS_E2 (ordsucc omega) ordsucc_omega_ordinal x Hx1.
assume Hx1a Hx1b Hx1c Hx1d.
apply SNoLtE x omega Hx1c SNo_omega Hx2.
- let z.
  assume Hz1: SNo z.
  assume Hz2: SNoLev z :e SNoLev x :/\: SNoLev omega.
  assume Hz3: SNoEq_ (SNoLev z) z x.
  assume Hz4: SNoEq_ (SNoLev z) z omega.
  assume Hz5: x < z.
  assume Hz6: z < omega.
  assume Hz7: SNoLev z /:e x.
  assume Hz8: SNoLev z :e omega.
  claim Lz1: ordinal (SNoLev z).
  { apply SNoLev_ordinal. exact Hz1. }
  claim Lz2: SNo (SNoLev z).
  { apply ordinal_SNo. exact Lz1. }
  witness (SNoLev z). apply andI.
  + exact Hz8.
  + prove x < SNoLev z.
    apply SNoLtLe_tra x z (SNoLev z) Hx1c Hz1 Lz2 Hz5.
    prove z <= SNoLev z.
    apply ordinal_SNoLev_max_2 (SNoLev z) Lz1 z Hz1.
    prove SNoLev z :e ordsucc (SNoLev z).
    apply ordsuccI2.
- assume H1: SNoLev x :e SNoLev omega.
  assume H2: SNoEq_ (SNoLev x) x omega.
  assume H3: SNoLev x :e omega.
  claim Lx1: ordinal (SNoLev x).
  { apply SNoLev_ordinal. exact Hx1c. }
  claim Lx2: ordinal (ordsucc (SNoLev x)).
  { apply ordinal_ordsucc. exact Lx1. }
  witness (ordsucc (SNoLev x)). apply andI.
  + apply omega_ordsucc. exact H3.
  + prove x < ordsucc (SNoLev x).
    apply ordinal_SNoLev_max (ordsucc (SNoLev x)) Lx2 x Hx1c.
    prove SNoLev x :e ordsucc (SNoLev x).
    apply ordsuccI2.
- rewrite ordinal_SNoLev omega omega_ordinal.
  assume H1: omega :e SNoLev x.
  prove False.
  apply ordsuccE omega (SNoLev x) Hx1a.
  + assume H2: SNoLev x :e omega. exact In_no2cycle (SNoLev x) omega H2 H1.
  + assume H2: SNoLev x = omega. apply In_irref omega. rewrite <- H2 at 2. exact H1.
Qed.

Theorem SNoS_ordsucc_omega_bdd_below : forall x :e SNoS_ (ordsucc omega), - omega < x -> exists N :e omega, - N < x.
let x. assume Hx1 Hx2.
apply SNoS_E2 (ordsucc omega) ordsucc_omega_ordinal x Hx1.
assume Hx1a Hx1b Hx1c Hx1d.
claim Lx1: - x :e SNoS_ (ordsucc omega).
{ exact minus_SNo_SNoS_ (ordsucc omega) ordsucc_omega_ordinal x Hx1. }
claim Lx2: - x < omega.
{ apply minus_SNo_Lt_contra1 omega x SNo_omega Hx1c.
  prove - omega < x. exact Hx2.
}
apply SNoS_ordsucc_omega_bdd_above (- x) Lx1 Lx2.
let N. assume HN. apply HN.
assume HN1: N :e omega.
assume HN2: - x < N.
witness N. apply andI.
- exact HN1.
- prove - N < x.
  apply minus_SNo_Lt_contra1 x N Hx1c (omega_SNo N HN1).
  prove - x < N. exact HN2.
Qed.

Theorem SNoS_ordsucc_omega_bdd_drat_intvl : forall x :e SNoS_ (ordsucc omega),
    - omega < x -> x < omega
 -> forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
let x. assume Hx1 Hx2 Hx3.
apply SNoS_E2 (ordsucc omega) ordsucc_omega_ordinal x Hx1.
assume Hx1a Hx1b Hx1c Hx1d.
apply dneg.
assume HC: ~(forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k).
claim L1: x /:e SNoS_ omega.
{ assume H1: x :e SNoS_ omega.
  apply HC.
  exact SNoS_omega_drat_intvl x H1.
}
claim L2: forall k, nat_p k -> exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
{ apply nat_ind.
  - prove exists q :e SNoS_ omega, q < x /\ x < q + eps_ 0.
    rewrite eps_0_1.
    prove exists q :e SNoS_ omega, q < x /\ x < q + 1.
    claim L1a: forall N, nat_p N -> - N < x -> x < N -> exists q :e SNoS_ omega, q < x /\ x < q + 1.
    { apply nat_ind.
      - rewrite minus_SNo_0.
        assume H1: 0 < x.
        assume H2: x < 0.
        prove False. apply SNoLt_irref x.
        exact SNoLt_tra x 0 x Hx1c SNo_0 Hx1c H2 H1.
      - let N. assume HN.
        assume IHN: - N < x -> x < N -> exists q :e SNoS_ omega, q < x /\ x < q + 1.
        assume H1: - ordsucc N < x.
        assume H2: x < ordsucc N.
        prove exists q :e SNoS_ omega, q < x /\ x < q + 1.
        claim LN1: SNo N.
        { exact nat_p_SNo N HN. }
        claim LN2: SNo (- N).
        { exact SNo_minus_SNo N LN1. }
        claim LN3: N :e SNoS_ omega.
        { apply omega_SNoS_omega. exact nat_p_omega N HN. }
        apply SNoLt_trichotomy_or_impred x N Hx1c LN1.
        + assume H3: x < N.
          apply SNoLt_trichotomy_or_impred x (- N) Hx1c LN2.
          * { assume H4: x < - N.
              witness (- ordsucc N). apply andI.
              - prove - ordsucc N :e SNoS_ omega.
                apply minus_SNo_SNoS_omega.
                prove ordsucc N :e SNoS_ omega.
                apply omega_SNoS_omega. apply omega_ordsucc. apply nat_p_omega. exact HN.
              - apply andI.
                + prove - ordsucc N < x. exact H1.
                + prove x < - ordsucc N + 1.
                  rewrite <- add_SNo_1_ordsucc N (nat_p_omega N HN).
                  prove x < -(N + 1) + 1.
                  rewrite minus_add_SNo_distr N 1 LN1 SNo_1.
                  prove x < (- N + - 1) + 1.
                  rewrite add_SNo_minus_R2' (- N) 1 LN2 SNo_1.
                  prove x < - N. exact H4.
            }
          * assume H4: x = - N. prove False. apply L1.
            prove x :e SNoS_ omega.
            rewrite H4. apply minus_SNo_SNoS_omega.
            prove N :e SNoS_ omega. exact LN3.
          * assume H4: - N < x.
            exact IHN H4 H3.
        + assume H3: x = N. prove False. apply L1.
          prove x :e SNoS_ omega.
          rewrite H3.
          prove N :e SNoS_ omega. exact LN3.
        + assume H3: N < x.
          witness N. apply andI.
          * prove N :e SNoS_ omega. exact LN3.
          * { apply andI.
              - prove N < x. exact H3.
              - prove x < N + 1.
                rewrite add_SNo_1_ordsucc N (nat_p_omega N HN).
                prove x < ordsucc N.
                exact H2.
            }
    }
    apply SNoS_ordsucc_omega_bdd_above x Hx1 Hx3.
    let N. assume HN. apply HN.
    assume HN1: N :e omega.
    assume HN2: x < N.
    apply SNoS_ordsucc_omega_bdd_below x Hx1 Hx2.
    let N'. assume HN'. apply HN'.
    assume HN'1: N' :e omega.
    assume HN'2: - N' < x.
    apply SNoLt_trichotomy_or_impred N N' (omega_SNo N HN1) (omega_SNo N' HN'1).
    + assume H1: N < N'.
      apply L1a N' (omega_nat_p N' HN'1) HN'2.
      prove x < N'.
      exact SNoLt_tra x N N' Hx1c (omega_SNo N HN1) (omega_SNo N' HN'1) HN2 H1.
    + assume H1: N = N'.
      apply L1a N' (omega_nat_p N' HN'1) HN'2.
      prove x < N'. rewrite <- H1. exact HN2.
    + assume H1: N' < N.
      apply L1a N (omega_nat_p N HN1).
      * { prove - N < x.
          apply SNoLt_tra (- N) (- N') x (SNo_minus_SNo N (omega_SNo N HN1)) (SNo_minus_SNo N' (omega_SNo N' HN'1)) Hx1c.
          - prove - N < - N'. apply minus_SNo_Lt_contra N' N (omega_SNo N' HN'1) (omega_SNo N HN1).
            exact H1.
          - prove - N' < x. exact HN'2.
        }
      * prove x < N. exact HN2.
  - let k. assume Hk.
    assume IHk. apply IHk.
    let q. assume H. apply H.
    assume Hq1: q :e SNoS_ omega. assume H. apply H.
    assume Hq2: q < x.
    assume Hq3: x < q + eps_ k.
    apply SNoS_E2 omega omega_ordinal q Hq1.
    assume Hq1a Hq1b Hq1c Hq1d.
    prove exists q :e SNoS_ omega, q < x /\ x < q + eps_ (ordsucc k).
    apply SNoLt_trichotomy_or_impred x (q + eps_ (ordsucc k)) Hx1c (SNo_add_SNo q (eps_ (ordsucc k)) Hq1c (SNo_eps_ (ordsucc k) (omega_ordsucc k (nat_p_omega k Hk)))).
    + assume H1: x < q + eps_ (ordsucc k).
      witness q. apply andI.
      * exact Hq1.
      * { apply andI.
          - exact Hq2.
          - exact H1.
        }
    + assume H1: x = q + eps_ (ordsucc k). prove False.
      apply L1. rewrite H1.
      exact add_SNo_SNoS_omega q Hq1 (eps_ (ordsucc k)) (SNo_eps_SNoS_omega (ordsucc k) (omega_ordsucc k (nat_p_omega k Hk))).
    + assume H1: q + eps_ (ordsucc k) < x.
      witness (q + eps_ (ordsucc k)). apply andI.
      * exact add_SNo_SNoS_omega q Hq1 (eps_ (ordsucc k)) (SNo_eps_SNoS_omega (ordsucc k) (omega_ordsucc k (nat_p_omega k Hk))).
      * { apply andI.
          - exact H1.
          - prove x < (q + eps_ (ordsucc k)) + eps_ (ordsucc k).
            rewrite <- add_SNo_assoc q (eps_ (ordsucc k)) (eps_ (ordsucc k)) Hq1c (SNo_eps_ (ordsucc k) (omega_ordsucc k (nat_p_omega k Hk))) (SNo_eps_ (ordsucc k) (omega_ordsucc k (nat_p_omega k Hk))).
            prove x < q + (eps_ (ordsucc k) + eps_ (ordsucc k)).
            rewrite eps_ordsucc_half_add k Hk.
            prove x < q + eps_ k.
            exact Hq3.
        }
}
apply HC.
let k. assume Hk. exact L2 k (omega_nat_p k Hk).
Qed.

Definition real : set := {x :e SNoS_ (ordsucc omega)| x <> omega /\ x <> - omega /\ (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)}.

Theorem real_I : forall x :e SNoS_ (ordsucc omega),
    x <> omega
 -> x <> - omega
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> x :e real.
let x. assume Hx H1 H2 H3.
prove x :e {x :e SNoS_ (ordsucc omega)| x <> omega /\ x <> - omega /\ (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)}.
apply SepI.
- exact Hx.
- prove x <> omega /\ x <> - omega /\ (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x).
  apply and3I.
  + exact H1.
  + exact H2.
  + exact H3.
Qed.

Theorem real_E : forall x :e real,
 forall p:prop,
      (SNo x
    -> SNoLev x :e ordsucc omega
    -> x :e SNoS_ (ordsucc omega)
    -> - omega < x
    -> x < omega
    -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
    -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
    -> p)
   -> p.
let x. assume Hx.
let p. assume Hp.
apply SepE (SNoS_ (ordsucc omega)) (fun x => x <> omega /\ x <> - omega /\ (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)) x Hx.
assume H1 H2. apply H2. assume H2. apply H2.
assume H2: x <> omega.
assume H3: x <> - omega.
assume H4.
apply SNoS_E2 (ordsucc omega) ordsucc_omega_ordinal x H1.
assume H1a H1b H1c H1d.
claim L1: x < omega.
{ claim L1a: x <= omega.
  { apply ordinal_SNoLev_max_2 omega omega_ordinal x H1c.
    prove SNoLev x :e ordsucc omega. exact H1a.
  }
  apply SNoLeE x omega H1c SNo_omega L1a.
  - assume H. exact H.
  - assume H: x = omega. prove False. exact H2 H.
}
claim L2: - omega < x.
{ claim L2a: - omega <= x.
  { apply mordinal_SNoLev_min_2 omega omega_ordinal x H1c.
    prove SNoLev x :e ordsucc omega. exact H1a.
  }
  apply SNoLeE (- omega) x (SNo_minus_SNo omega SNo_omega) H1c L2a.
  - assume H. exact H.
  - assume H: - omega = x. prove False. apply H3. symmetry. exact H.
}
claim L3: forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
{ exact SNoS_ordsucc_omega_bdd_drat_intvl x H1 L2 L1. }
exact Hp H1c H1a H1 L2 L1 H4 L3.
Qed.

Theorem real_SNo : forall x :e real, SNo x.
let x. assume Hx. apply real_E x Hx.
assume Hx1 _ _ _ _ _ _. exact Hx1.
Qed.

Theorem real_SNoS_omega_prop : forall x :e real, forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x.
let x. assume Hx. apply real_E x Hx.
assume _ _ _ _ _ Hx6 _. exact Hx6.
Qed.

Theorem SNoS_omega_real : SNoS_ omega c= real.
let x. assume Hx: x :e SNoS_ omega.
apply SNoS_E2 omega omega_ordinal x Hx.
assume Hx1 Hx2 Hx3 Hx4.
apply real_I.
- prove x :e SNoS_ (ordsucc omega).
  apply SNoS_Subq omega (ordsucc omega) omega_ordinal ordsucc_omega_ordinal (ordsuccI1 omega).
  exact Hx.
- prove x <> omega.
  assume H1: x = omega.
  apply In_irref (SNoLev x).
  prove SNoLev x :e SNoLev x.
  rewrite H1 at 2.
  prove SNoLev x :e SNoLev omega.
  rewrite ordinal_SNoLev omega omega_ordinal.
  exact Hx1.
- prove x <> - omega.
  assume H1: x = - omega.
  apply In_irref (SNoLev x).
  prove SNoLev x :e SNoLev x.
  rewrite H1 at 2.
  prove SNoLev x :e SNoLev (- omega).
  rewrite minus_SNo_Lev omega SNo_omega.
  prove SNoLev x :e SNoLev omega.
  rewrite ordinal_SNoLev omega omega_ordinal.
  exact Hx1.
- let q. assume Hq: q :e SNoS_ omega.
  assume H1: forall k :e omega, abs_SNo (q + - x) < eps_ k.
  apply SNoS_E2 omega omega_ordinal q Hq.
  assume Hq1 Hq2 Hq3 Hq4.
  prove q = x.
  apply SNoLt_trichotomy_or_impred q x Hq3 Hx3.
  + assume Hqx: q < x. prove False.
    claim L1: 0 < x + - q.
    { apply SNoLt_minus_pos q x Hq3 Hx3.
      exact Hqx.
    }
    claim L2: x + - q :e SNoS_ omega.
    { exact add_SNo_SNoS_omega x Hx (- q) (minus_SNo_SNoS_omega q Hq). }
    apply SNoS_E2 omega omega_ordinal (x + - q) L2.
    assume H2: SNoLev (x + - q) :e omega.
    assume H3: ordinal (SNoLev (x + - q)).
    assume H4: SNo (x + - q).
    assume H5: SNo_ (SNoLev (x + - q)) (x + - q).
    apply SNoLt_irref (x + - q).
    apply SNoLt_tra (x + - q) (eps_ (SNoLev (x + - q))) (x + - q) H4 (SNo_eps_ (SNoLev (x + - q)) H2) H4.
    * prove x + - q < eps_ (SNoLev (x + - q)).
      claim L3: abs_SNo (q + - x) = x + - q.
      { rewrite abs_SNo_dist_swap q x Hq3 Hx3.
        exact pos_abs_SNo (x + - q) L1.
      }
      rewrite <- L3 at 1.
      exact H1 (SNoLev (x + - q)) H2.
    * { prove eps_ (SNoLev (x + - q)) < x + - q.
        apply SNo_pos_eps_Lt (SNoLev (x + - q)) (omega_nat_p (SNoLev (x + - q)) H2) (x + - q).
        - prove (x + - q) :e SNoS_ (ordsucc (SNoLev (x + - q))).
          apply SNoS_I (ordsucc (SNoLev (x + - q))) (ordinal_ordsucc (SNoLev (x + - q)) H3) (x + - q) (SNoLev (x + - q)).
          + apply ordsuccI2.
          + exact H5.
        - exact L1.
      }
  + assume Hqx: q = x. exact Hqx.
  + assume Hxq: x < q. prove False.
    claim L4: 0 < q + - x.
    { apply SNoLt_minus_pos x q Hx3 Hq3.
      exact Hxq.
    }
    claim L5: q + - x :e SNoS_ omega.
    { exact add_SNo_SNoS_omega q Hq (- x) (minus_SNo_SNoS_omega x Hx). }
    apply SNoS_E2 omega omega_ordinal (q + - x) L5.
    assume H2: SNoLev (q + - x) :e omega.
    assume H3: ordinal (SNoLev (q + - x)).
    assume H4: SNo (q + - x).
    assume H5: SNo_ (SNoLev (q + - x)) (q + - x).
    apply SNoLt_irref (q + - x).
    apply SNoLt_tra (q + - x) (eps_ (SNoLev (q + - x))) (q + - x) H4 (SNo_eps_ (SNoLev (q + - x)) H2) H4.
    * prove q + - x < eps_ (SNoLev (q + - x)).
      claim L6: abs_SNo (q + - x) = q + - x.
      { exact pos_abs_SNo (q + - x) L4. }
      rewrite <- L6 at 1.
      exact H1 (SNoLev (q + - x)) H2.
    * { prove eps_ (SNoLev (q + - x)) < q + - x.
        apply SNo_pos_eps_Lt (SNoLev (q + - x)) (omega_nat_p (SNoLev (q + - x)) H2) (q + - x).
        - prove (q + - x) :e SNoS_ (ordsucc (SNoLev (q + - x))).
          apply SNoS_I (ordsucc (SNoLev (q + - x))) (ordinal_ordsucc (SNoLev (q + - x)) H3) (q + - x) (SNoLev (q + - x)).
          + apply ordsuccI2.
          + exact H5.
        - exact L4.
      }
Qed.

Theorem real_0 : 0 :e real.
exact SNoS_omega_real 0 (omega_SNoS_omega 0 (nat_p_omega 0 nat_0)).
Qed.

Theorem real_1 : 1 :e real.
exact SNoS_omega_real 1 (omega_SNoS_omega 1 (nat_p_omega 1 nat_1)).
Qed.

Theorem SNoLev_In_real_SNoS_omega : forall x :e real, forall w, SNo w -> SNoLev w :e SNoLev x -> w :e SNoS_ omega.
let x. assume Hx. let w. assume Hw1 Hw2.
apply real_E x Hx.
assume Hx1: SNo x.
assume Hx2: SNoLev x :e ordsucc omega.
assume _ _ _ _ _.
claim L1: SNoLev w :e omega.
{ apply ordsuccE omega (SNoLev x) Hx2.
  - assume H1: SNoLev x :e omega.
    exact omega_TransSet (SNoLev x) H1 (SNoLev w) Hw2.
  - assume H1: SNoLev x = omega.
    rewrite <- H1. exact Hw2.
}
apply SNoS_I omega omega_ordinal w (SNoLev w) L1.
prove SNo_ (SNoLev w) w. apply SNoLev_. exact Hw1.
Qed.

Theorem real_SNoCut_SNoS_omega: forall L R c= SNoS_ omega, SNoCutP L R
 -> L <> 0
 -> R <> 0
 -> (forall w :e L, exists w' :e L, w < w')
 -> (forall z :e R, exists z' :e R, z' < z)
 -> SNoCut L R :e real.
let L. assume HL. let R. assume HR.
assume HLR. apply HLR. assume H. apply H.
assume HLR1: forall w :e L, SNo w.
assume HLR2: forall z :e R, SNo z.
assume HLR3: forall w :e L, forall z :e R, w < z.
assume HL0: L <> 0.
assume HR0: R <> 0.
assume HL1: forall w :e L, exists w' :e L, w < w'.
assume HR1: forall z :e R, exists z' :e R, z' < z.
set x := SNoCut L R.
apply SNoCutP_SNoCut_impred L R HLR.
assume H1: SNo x.
assume H2: SNoLev x :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume H3: forall w :e L, w < x.
assume H4: forall z :e R, x < z.
assume H5: forall u, SNo u -> (forall w :e L, w < u) -> (forall z :e R, u < z) -> SNoLev x c= SNoLev u /\ SNoEq_ (SNoLev x) x u.
claim Lo: ordinal ((\/_ w :e L, ordsucc (SNoLev w)) :\/: (\/_ z :e R, ordsucc (SNoLev z))).
{ apply ordinal_binunion.
  - apply ordinal_famunion.
    let w. assume Hw.
    prove ordinal (ordsucc (SNoLev w)).
    apply ordinal_ordsucc.
    prove ordinal (SNoLev w).
    apply SNoLev_ordinal.
    exact HLR1 w Hw.
  - apply ordinal_famunion.
    let z. assume Hz.
    prove ordinal (ordsucc (SNoLev z)).
    apply ordinal_ordsucc.
    prove ordinal (SNoLev z).
    apply SNoLev_ordinal.
    exact HLR2 z Hz.
}
claim LLRsoo: ordsucc ((\/_ w :e L, ordsucc (SNoLev w)) :\/: (\/_ z :e R, ordsucc (SNoLev z))) c= ordsucc omega.
{ apply ordinal_ordsucc_In_Subq (ordsucc omega) ordsucc_omega_ordinal ((\/_ w :e L, ordsucc (SNoLev w)) :\/: (\/_ z :e R, ordsucc (SNoLev z))).
  prove ((\/_ w :e L, ordsucc (SNoLev w)) :\/: (\/_ z :e R, ordsucc (SNoLev z))) :e ordsucc omega.
  apply ordinal_In_Or_Subq ((\/_ w :e L, ordsucc (SNoLev w)) :\/: (\/_ z :e R, ordsucc (SNoLev z))) (ordsucc omega) Lo ordsucc_omega_ordinal.
  - assume H6. exact H6.
  - assume H6: ordsucc omega c= (\/_ w :e L, ordsucc (SNoLev w)) :\/: (\/_ z :e R, ordsucc (SNoLev z)).
    prove False.
    apply binunionE (\/_ w :e L, ordsucc (SNoLev w)) (\/_ z :e R, ordsucc (SNoLev z)) omega (H6 omega (ordsuccI2 omega)).
    + assume H7: omega :e \/_ w :e L, ordsucc (SNoLev w).
      apply famunionE_impred L (fun w => ordsucc (SNoLev w)) omega H7.
      let w. assume Hw: w :e L.
      assume H8: omega :e ordsucc (SNoLev w).
      apply SNoS_E2 omega omega_ordinal w (HL w Hw).
      assume Hw1: SNoLev w :e omega.
      prove False.
      apply ordsuccE (SNoLev w) omega H8.
      * assume H9: omega :e SNoLev w.
        exact In_no2cycle omega (SNoLev w) H9 Hw1.
      * assume H9: omega = SNoLev w.
        prove False.
        apply In_irref omega.
        rewrite H9 at 1. exact Hw1.
    + assume H7: omega :e \/_ z :e R, ordsucc (SNoLev z).
      apply famunionE_impred R (fun z => ordsucc (SNoLev z)) omega H7.
      let z. assume Hz: z :e R.
      assume H8: omega :e ordsucc (SNoLev z).
      apply SNoS_E2 omega omega_ordinal z (HR z Hz).
      assume Hz1: SNoLev z :e omega.
      prove False.
      apply ordsuccE (SNoLev z) omega H8.
      * assume H9: omega :e SNoLev z.
        exact In_no2cycle omega (SNoLev z) H9 Hz1.
      * assume H9: omega = SNoLev z.
        prove False.
        apply In_irref omega.
        rewrite H9 at 1. exact Hz1.
}
apply ordsuccE omega (SNoLev x) (LLRsoo (SNoLev x) H2).
- assume H6: SNoLev x :e omega.
  prove x :e real.
  apply SNoS_omega_real.
  prove x :e SNoS_ omega.
  apply SNoS_I omega omega_ordinal x (SNoLev x) H6.
  prove SNo_ (SNoLev x) x.
  apply SNoLev_.
  exact H1.
- assume H6: SNoLev x = omega.
  prove x :e real.
  apply real_I.
  + prove x :e SNoS_ (ordsucc omega).
    apply SNoS_I (ordsucc omega) ordsucc_omega_ordinal x (SNoLev x).
    * prove SNoLev x :e ordsucc omega.
      rewrite H6. apply ordsuccI2.
    * prove SNo_ (SNoLev x) x. apply SNoLev_. exact H1.
  + assume H7: x = omega.
    apply HR0.
    apply Empty_eq.
    let z. assume Hz: z :e R.
    apply SNoLt_irref z.
    prove z < z.
    apply SNoLt_tra z x z (HLR2 z Hz) H1 (HLR2 z Hz).
    * prove z < x. rewrite H7.
      prove z < omega.
      apply ordinal_SNoLev_max omega omega_ordinal z (HLR2 z Hz).
      prove SNoLev z :e omega.
      apply SNoS_E2 omega omega_ordinal z (HR z Hz).
      assume Hz1: SNoLev z :e omega.
      assume _ _ _.
      exact Hz1.
    * prove x < z. apply H4. exact Hz.
  + assume H7: x = - omega.
    apply HL0.
    apply Empty_eq.
    let w. assume Hw: w :e L.
    apply SNoLt_irref w.
    prove w < w.
    apply SNoLt_tra w x w (HLR1 w Hw) H1 (HLR1 w Hw).
    * prove w < x. apply H3. exact Hw.
    * prove x < w. rewrite H7.
      prove - omega < w.
      apply minus_SNo_Lt_contra1 w omega (HLR1 w Hw) SNo_omega.
      prove - w < omega.
      apply ordinal_SNoLev_max omega omega_ordinal (- w) (SNo_minus_SNo w (HLR1 w Hw)).
      prove SNoLev (- w) :e omega.
      rewrite minus_SNo_Lev w (HLR1 w Hw).
      apply SNoS_E2 omega omega_ordinal w (HL w Hw).
      assume Hw1: SNoLev w :e omega.
      assume _ _ _.
      exact Hw1.
  + let q. assume Hq: q :e SNoS_ omega.
    assume H7: forall k :e omega, abs_SNo (q + - x) < eps_ k.
    prove False.
    apply SNoS_E2 omega omega_ordinal q Hq.
    assume Hq1: SNoLev q :e omega.
    assume Hq2: ordinal (SNoLev q).
    assume Hq3: SNo q.
    assume Hq4: SNo_ (SNoLev q) q.
    claim LqL: forall w :e L, w < q.
    { let w. assume Hw: w :e L.
      apply SNoLtLe_or w q (HLR1 w Hw) Hq3.
      - assume H8: w < q. exact H8.
      - assume H8: q <= w. prove False.
        apply HL1 w Hw.
        let w'. assume H. apply H.
        assume H9: w' :e L.
        assume H10: w < w'.
        claim LqL1: w' + - q :e SNoS_ omega.
        { apply add_SNo_SNoS_omega.
          - exact HL w' H9.
          - apply minus_SNo_SNoS_omega. exact Hq.
        }
        apply SNoS_E2 omega omega_ordinal (w' + - q) LqL1.
        assume Hw'q1: SNoLev (w' + - q) :e omega.
        assume Hw'q2: ordinal (SNoLev (w' + - q)).
        assume Hw'q3: SNo (w' + - q).
        assume Hw'q4: SNo_ (SNoLev (w' + - q)) (w' + - q).
        claim LqL2: 0 < w' + - q.
        { apply SNoLt_minus_pos q w' Hq3 (HLR1 w' H9).
          prove q < w'.
          exact SNoLeLt_tra q w w' Hq3 (HLR1 w Hw) (HLR1 w' H9) H8 H10.
        }
        set k := SNoLev (w' + - q).
        claim LqL3: w' + - q :e SNoS_ (ordsucc k).
        { exact SNoS_I (ordsucc k) (ordinal_ordsucc k (nat_p_ordinal k (omega_nat_p k Hw'q1))) (w' + - q) k (ordsuccI2 k) Hw'q4. }
        claim Lek: SNo (eps_ k).
        { exact SNo_eps_ k Hw'q1. }
        claim LqL4: eps_ k < w' + - q.
        { exact SNo_pos_eps_Lt k (omega_nat_p k Hw'q1) (w' + - q) LqL3 LqL2. }
        apply SNoLt_irref (eps_ k).
        apply SNoLt_tra (eps_ k) (w' + - q) (eps_ k) Lek Hw'q3 Lek LqL4.
        prove w' + - q < eps_ k.
        claim Lxq: SNo (x + - q).
        { exact SNo_add_SNo x (- q) H1 (SNo_minus_SNo q Hq3). }
        apply SNoLt_tra (w' + - q) (x + - q) (eps_ k) Hw'q3 Lxq Lek.
        + prove w' + - q < x + - q.
          apply add_SNo_Lt1 w' (- q) x (HLR1 w' H9) (SNo_minus_SNo q Hq3) H1.
          prove w' < x.
          apply H3. prove w' :e L. exact H9.
        + prove x + - q < eps_ k.
          apply SNoLtLe_or (x + - q) 0 Lxq SNo_0.
          * assume H11: x + - q < 0.
            exact SNoLt_tra (x + - q) 0 (eps_ k) Lxq SNo_0 Lek H11 (SNo_eps_pos k Hw'q1).
          * assume H11: 0 <= x + - q.
            rewrite <- nonneg_abs_SNo (x + - q) H11.
            prove abs_SNo (x + - q) < eps_ k.
            rewrite abs_SNo_dist_swap x q H1 Hq3.
            exact H7 k Hw'q1.
    }
    claim LqR: forall z :e R, q < z.
    { let z. assume Hz: z :e R.
      apply SNoLtLe_or q z Hq3 (HLR2 z Hz).
      - assume H8: q < z. exact H8.
      - assume H8: z <= q. prove False.
        apply HR1 z Hz.
        let z'. assume H. apply H.
        assume H9: z' :e R.
        assume H10: z' < z.
        claim LqR1: q + - z' :e SNoS_ omega.
        { apply add_SNo_SNoS_omega.
          - exact Hq.
          - apply minus_SNo_SNoS_omega. exact HR z' H9.
        }
        apply SNoS_E2 omega omega_ordinal (q + - z') LqR1.
        assume Hz'q1: SNoLev (q + - z') :e omega.
        assume Hz'q2: ordinal (SNoLev (q + - z')).
        assume Hz'q3: SNo (q + - z').
        assume Hz'q4: SNo_ (SNoLev (q + - z')) (q + - z').
        claim LqR2: 0 < q + - z'.
        { apply SNoLt_minus_pos z' q (HLR2 z' H9) Hq3.
          prove z' < q.
          exact SNoLtLe_tra z' z q (HLR2 z' H9) (HLR2 z Hz) Hq3 H10 H8.
        }
        set k := SNoLev (q + - z').
        claim LqR3: q + - z' :e SNoS_ (ordsucc k).
        { exact SNoS_I (ordsucc k) (ordinal_ordsucc k (nat_p_ordinal k (omega_nat_p k Hz'q1))) (q + - z') k (ordsuccI2 k) Hz'q4. }
        claim Lek: SNo (eps_ k).
        { exact SNo_eps_ k Hz'q1. }
        claim LqR4: eps_ k < q + - z'.
        { exact SNo_pos_eps_Lt k (omega_nat_p k Hz'q1) (q + - z') LqR3 LqR2. }
        apply SNoLt_irref (eps_ k).
        apply SNoLt_tra (eps_ k) (q + - z') (eps_ k) Lek Hz'q3 Lek LqR4.
        prove q + - z' < eps_ k.
        claim Lxq: SNo (q + - x).
        { exact SNo_add_SNo q (- x) Hq3 (SNo_minus_SNo x H1). }
        apply SNoLt_tra (q + - z') (q + - x) (eps_ k) Hz'q3 Lxq Lek.
        + prove q + - z' < q + - x.
          apply add_SNo_Lt2 q (- z') (- x) Hq3 (SNo_minus_SNo z' (HLR2 z' H9)) (SNo_minus_SNo x H1).
          prove - z' < - x.
          apply minus_SNo_Lt_contra x z' H1 (HLR2 z' H9).
          prove x < z'.
          apply H4. prove z' :e R. exact H9.
        + prove q + - x < eps_ k.
          apply SNoLtLe_or (q + - x) 0 Lxq SNo_0.
          * assume H11: q + - x < 0.
            exact SNoLt_tra (q + - x) 0 (eps_ k) Lxq SNo_0 Lek H11 (SNo_eps_pos k Hz'q1).
          * assume H11: 0 <= q + - x.
            rewrite <- nonneg_abs_SNo (q + - x) H11.
            prove abs_SNo (q + - x) < eps_ k.
            exact H7 k Hz'q1.
    }
    apply H5 q Hq3 LqL LqR.
    assume H10: SNoLev x c= SNoLev q.
    prove False.
    apply In_irref (SNoLev q).
    apply H10.
    prove SNoLev q :e SNoLev x.
    rewrite H6.
    exact Hq1.
Qed.

Theorem real_SNoCut: forall L R c= real, SNoCutP L R
 -> L <> 0
 -> R <> 0
 -> (forall w :e L, exists w' :e L, w < w')
 -> (forall z :e R, exists z' :e R, z' < z)
 -> SNoCut L R :e real.
let L. assume HL. let R. assume HR.
assume HLR. apply HLR. assume H. apply H.
assume HLR1: forall w :e L, SNo w.
assume HLR2: forall z :e R, SNo z.
assume HLR3: forall w :e L, forall z :e R, w < z.
assume HL0: L <> 0.
assume HR0: R <> 0.
assume HL1: forall w :e L, exists w' :e L, w < w'.
assume HR1: forall z :e R, exists z' :e R, z' < z.
set x := SNoCut L R.
apply SNoCutP_SNoCut_impred L R HLR.
assume H1: SNo x.
assume H2: SNoLev x :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume H3: forall w :e L, w < x.
assume H4: forall z :e R, x < z.
assume H5: forall u, SNo u -> (forall w :e L, w < u) -> (forall z :e R, u < z) -> SNoLev x c= SNoLev u /\ SNoEq_ (SNoLev x) x u.
set L_ : set -> set := fun n => {w' :e SNoS_ n|exists w :e L, w' <= w}.
set R_ : set -> set := fun n => {z' :e SNoS_ n|exists z :e R, z <= z'}.
set L' := \/_ n :e omega, L_ n.
set R' := \/_ n :e omega, R_ n.
set x' := SNoCut L' R'.
claim LL'L: forall w' :e L', exists w :e L, w' <= w.
{ let w'. assume Hw'.
  apply famunionE_impred omega L_ w' Hw'.
  let n.
  assume Hn: n :e omega.
  assume Hw'2: w' :e L_ n.
  exact SepE2 (SNoS_ n) (fun w' => exists w :e L, w' <= w) w' Hw'2.
}
claim LR'R: forall z' :e R', exists z :e R, z <= z'.
{ let z'. assume Hz'.
  apply famunionE_impred omega R_ z' Hz'.
  let n.
  assume Hn: n :e omega.
  assume Hz'2: z' :e R_ n.
  exact SepE2 (SNoS_ n) (fun z' => exists z :e R, z <= z') z' Hz'2.
}
claim LL'o: L' c= SNoS_ omega.
{ let w'. assume Hw'.
  apply famunionE_impred omega L_ w' Hw'.
  let n.
  assume Hn: n :e omega.
  assume Hw'2: w' :e L_ n.
  apply SNoS_E2 n (nat_p_ordinal n (omega_nat_p n Hn )) w' (SepE1 (SNoS_ n) (fun w' => exists w :e L, w' <= w) w' Hw'2).
  assume Hw'3: SNoLev w' :e n.
  assume Hw'4: ordinal (SNoLev w').
  assume Hw'5: SNo w'.
  assume Hw'6: SNo_ (SNoLev w') w'.
  apply SNoS_I omega omega_ordinal w' (SNoLev w').
  - prove SNoLev w' :e omega.
    exact omega_TransSet n Hn (SNoLev w') Hw'3.
  - exact Hw'6.
}
claim LR'o: R' c= SNoS_ omega.
{ let z'. assume Hz'.
  apply famunionE_impred omega R_ z' Hz'.
  let n.
  assume Hn: n :e omega.
  assume Hz'2: z' :e R_ n.
  apply SNoS_E2 n (nat_p_ordinal n (omega_nat_p n Hn )) z' (SepE1 (SNoS_ n) (fun z' => exists z :e R, z <= z') z' Hz'2).
  assume Hz'3: SNoLev z' :e n.
  assume Hz'4: ordinal (SNoLev z').
  assume Hz'5: SNo z'.
  assume Hz'6: SNo_ (SNoLev z') z'.
  apply SNoS_I omega omega_ordinal z' (SNoLev z').
  - prove SNoLev z' :e omega.
    exact omega_TransSet n Hn (SNoLev z') Hz'3.
  - exact Hz'6.
}
claim LL': forall w' :e L', SNo w'.
{ let w'. assume Hw'.
  apply SNoS_E2 omega omega_ordinal w' (LL'o w' Hw').
  assume _ _ H _. exact H.
}
claim LR': forall z :e R', SNo z.
{ let z'. assume Hz'.
  apply SNoS_E2 omega omega_ordinal z' (LR'o z' Hz').
  assume _ _ H _. exact H.
}
claim LLR': SNoCutP L' R'.
{ prove (forall w :e L', SNo w)
     /\ (forall z :e R', SNo z)
     /\ (forall w :e L', forall z :e R', w < z).
  apply and3I.
  - exact LL'.
  - exact LR'.
  - let w'. assume Hw'. let z'. assume Hz'.
    apply LL'L w' Hw'.
    let w. assume H. apply H.
    assume Hw: w :e L.
    assume Hw'w: w' <= w.
    apply LR'R z' Hz'.
    let z. assume H. apply H.
    assume Hz: z :e R.
    assume Hzz': z <= z'.
    prove w' < z'.
    apply SNoLeLt_tra w' w z' (LL' w' Hw') (HLR1 w Hw) (LR' z' Hz') Hw'w.
    prove w < z'.
    apply SNoLtLe_tra w z z' (HLR1 w Hw) (HLR2 z Hz) (LR' z' Hz').
    + prove w < z.
      apply HLR3.
      * exact Hw.
      * exact Hz.
    + prove z <= z'. exact Hzz'.
}
apply SNoCutP_SNoCut_impred L' R' LLR'.
assume H1': SNo x'.
assume H2': SNoLev x' :e ordsucc ((\/_ x :e L', ordsucc (SNoLev x)) :\/: (\/_ y :e R', ordsucc (SNoLev y))).
assume H3': forall w :e L', w < x'.
assume H4': forall z :e R', x' < z.
assume H5': forall u, SNo u -> (forall w :e L', w < u) -> (forall z :e R', u < z) -> SNoLev x' c= SNoLev u /\ SNoEq_ (SNoLev x') x' u.
claim L1: forall w :e L, exists w' :e L', w <= w'.
{ let w. assume Hw.
  apply real_E w (HL w Hw).
  assume Hw1: SNo w.
  assume Hw2: SNoLev w :e ordsucc omega.
  assume _ _ _ _ _.
  apply ordsuccE omega (SNoLev w) Hw2.
  - assume H6: SNoLev w :e omega.
    witness w. apply andI.
    + prove w :e L'.
      prove w :e famunion omega L_.
      apply famunionI omega L_ (ordsucc (SNoLev w)) w.
      * prove ordsucc (SNoLev w) :e omega.
        apply omega_ordsucc.
        exact H6.
      * { prove w :e {w' :e SNoS_ (ordsucc (SNoLev w))|exists w :e L, w' <= w}.
          apply SepI.
          - apply SNoS_SNoLev. exact Hw1.
          - prove exists u :e L, w <= u.
            witness w. apply andI.
            + exact Hw.
            + apply SNoLe_ref.
        }
    + apply SNoLe_ref.
  - assume H6: SNoLev w = omega.
    apply HL1 w Hw.
    let w'. assume H. apply H.
    assume Hw': w' :e L.
    assume Hww': w < w'.
    apply real_E w' (HL w' Hw').
    assume Hw'1: SNo w'.
    assume Hw'2: SNoLev w' :e ordsucc omega.
    assume _ _ _ _ _.
    apply ordsuccE omega (SNoLev w') Hw'2.
    + assume H7: SNoLev w' :e omega.
      witness w'. apply andI.
      * { prove w' :e L'.
          prove w' :e famunion omega L_.
          apply famunionI omega L_ (ordsucc (SNoLev w')) w'.
          - prove ordsucc (SNoLev w') :e omega.
            apply omega_ordsucc. exact H7.
          - prove w' :e {w' :e SNoS_ (ordsucc (SNoLev w'))|exists w :e L, w' <= w}.
            apply SepI.
            + apply SNoS_SNoLev. exact Hw'1.
            + prove exists u :e L, w' <= u.
              witness w'.
              apply andI.
              * exact Hw'.
              * apply SNoLe_ref.
        }
      * apply SNoLtLe. exact Hww'.
    + assume H7: SNoLev w' = omega.
      apply SNoLtE w w' Hw1 Hw'1 Hww'.
      * { let w''. rewrite H6.
          assume Hw''1: SNo w''.
          assume Hw''2: SNoLev w'' :e omega :/\: SNoLev w'.
          assume _ _.
          assume Hw''3: w < w''.
          assume Hw''4: w'' < w'.
          assume _ _.
          witness w''. apply andI.
          - prove w'' :e L'.
            prove w'' :e famunion omega L_.
            apply famunionI omega L_ (ordsucc (SNoLev w'')) w''.
            + prove ordsucc (SNoLev w'') :e omega.
              apply omega_ordsucc.
              exact binintersectE1 omega (SNoLev w') (SNoLev w'') Hw''2.
            + prove w'' :e {w' :e SNoS_ (ordsucc (SNoLev w''))|exists w :e L, w' <= w}.
              apply SepI.
              * apply SNoS_SNoLev. exact Hw''1.
              * { prove exists u :e L, w'' <= u.
                  witness w'.
                  apply andI.
                  - exact Hw'.
                  - apply SNoLtLe. exact Hw''4.
                }
          - prove w <= w''. apply SNoLtLe. exact Hw''3.
        }
      * rewrite H6. rewrite H7. assume H8: omega :e omega.
        prove False. exact In_irref omega H8.
      * rewrite H6. rewrite H7. assume H8: omega :e omega.
        prove False. exact In_irref omega H8.
}
claim L2: forall z :e R, exists z' :e R', z' <= z.
{ let z. assume Hz.
  apply real_E z (HR z Hz).
  assume Hz1: SNo z.
  assume Hz2: SNoLev z :e ordsucc omega.
  assume _ _ _ _ _.
  apply ordsuccE omega (SNoLev z) Hz2.
  - assume H6: SNoLev z :e omega.
    witness z. apply andI.
    + prove z :e R'.
      prove z :e famunion omega R_.
      apply famunionI omega R_ (ordsucc (SNoLev z)) z.
      * prove ordsucc (SNoLev z) :e omega.
        apply omega_ordsucc.
        exact H6.
      * { prove z :e {z' :e SNoS_ (ordsucc (SNoLev z))|exists z :e R, z <= z'}.
          apply SepI.
          - apply SNoS_SNoLev. exact Hz1.
          - prove exists u :e R, u <= z.
            witness z. apply andI.
            + exact Hz.
            + apply SNoLe_ref.
        }
    + apply SNoLe_ref.
  - assume H6: SNoLev z = omega.
    apply HR1 z Hz.
    let z'. assume H. apply H.
    assume Hz': z' :e R.
    assume Hz'z: z' < z.
    apply real_E z' (HR z' Hz').
    assume Hz'1: SNo z'.
    assume Hz'2: SNoLev z' :e ordsucc omega.
    assume _ _ _ _ _.
    apply ordsuccE omega (SNoLev z') Hz'2.
    + assume H7: SNoLev z' :e omega.
      witness z'. apply andI.
      * { prove z' :e R'.
          prove z' :e famunion omega R_.
          apply famunionI omega R_ (ordsucc (SNoLev z')) z'.
          - prove ordsucc (SNoLev z') :e omega.
            apply omega_ordsucc. exact H7.
          - prove z' :e {z' :e SNoS_ (ordsucc (SNoLev z'))|exists z :e R, z <= z'}.
            apply SepI.
            + apply SNoS_SNoLev. exact Hz'1.
            + prove exists u :e R, u <= z'.
              witness z'.
              apply andI.
              * exact Hz'.
              * apply SNoLe_ref.
        }
      * apply SNoLtLe. exact Hz'z.
    + assume H7: SNoLev z' = omega.
      apply SNoLtE z' z Hz'1 Hz1 Hz'z.
      * { let z''. rewrite H7.
          assume Hz''1: SNo z''.
          assume Hz''2: SNoLev z'' :e omega :/\: SNoLev z.
          assume _ _.
          assume Hz''3: z' < z''.
          assume Hz''4: z'' < z.
          assume _ _.
          witness z''. apply andI.
          - prove z'' :e R'.
            prove z'' :e famunion omega R_.
            apply famunionI omega R_ (ordsucc (SNoLev z'')) z''.
            + prove ordsucc (SNoLev z'') :e omega.
              apply omega_ordsucc.
              exact binintersectE1 omega (SNoLev z) (SNoLev z'') Hz''2.
            + prove z'' :e {z' :e SNoS_ (ordsucc (SNoLev z''))|exists z :e R, z <= z'}.
              apply SepI.
              * apply SNoS_SNoLev. exact Hz''1.
              * { prove exists u :e R, u <= z''.
                  witness z'.
                  apply andI.
                  - exact Hz'.
                  - apply SNoLtLe. exact Hz''3.
                }
          - prove z'' <= z. apply SNoLtLe. exact Hz''4.
        }
      * rewrite H6. rewrite H7. assume H8: omega :e omega.
        prove False. exact In_irref omega H8.
      * rewrite H6. rewrite H7. assume H8: omega :e omega.
        prove False. exact In_irref omega H8.
}
claim L3: L' <> 0.
{ assume H6: L' = 0.
  apply HL0.
  prove L = 0.
  apply Empty_eq.
  let w. assume Hw: w :e L.
  apply L1 w Hw.
  let w'. assume H. apply H.
  assume Hw': w' :e L'.
  prove False.
  apply EmptyE w'.
  prove w' :e 0. rewrite <- H6. exact Hw'.
}
claim L4: R' <> 0.
{ assume H6: R' = 0.
  apply HR0.
  prove R = 0.
  apply Empty_eq.
  let z. assume Hz: z :e R.
  apply L2 z Hz.
  let z'. assume H. apply H.
  assume Hz': z' :e R'.
  prove False. apply EmptyE z'.
  prove z' :e 0.
  rewrite <- H6. exact Hz'.
}
claim L5: forall w :e L', exists w' :e L', w < w'.
{ let w. assume Hw.
  apply LL'L w Hw.
  let u. assume H. apply H.
  assume Hu: u :e L.
  assume Hwu: w <= u.
  apply HL1 u Hu.
  let v. assume H. apply H.
  assume Hv: v :e L.
  assume Huv: u < v.
  apply L1 v Hv.
  let w'. assume H. apply H.
  assume Hw': w' :e L'.
  assume Hvw': v <= w'.
  witness w'. apply andI.
  - exact Hw'.
  - prove w < w'.
    apply SNoLeLt_tra w u w' (LL' w Hw) (HLR1 u Hu) (LL' w' Hw') Hwu.
    prove u < w'.
    exact SNoLtLe_tra u v w' (HLR1 u Hu) (HLR1 v Hv) (LL' w' Hw') Huv Hvw'.
}
claim L6: forall z :e R', exists z' :e R', z' < z.
{ let z. assume Hz.
  apply LR'R z Hz.
  let u. assume H. apply H.
  assume Hu: u :e R.
  assume Huz: u <= z.
  apply HR1 u Hu.
  let v. assume H. apply H.
  assume Hv: v :e R.
  assume Hvu: v < u.
  apply L2 v Hv.
  let z'. assume H. apply H.
  assume Hz': z' :e R'.
  assume Hz'v: z' <= v.
  witness z'. apply andI.
  - exact Hz'.
  - prove z' < z.
    apply SNoLeLt_tra z' v z (LR' z' Hz') (HLR2 v Hv) (LR' z Hz) Hz'v.
    prove v < z.
    exact SNoLtLe_tra v u z (HLR2 v Hv) (HLR2 u Hu) (LR' z Hz) Hvu Huz.
}
claim Lxx': x = x'.
{ apply SNoCut_ext.
  - exact HLR.
  - exact LLR'.
  - let w. assume Hw: w :e L.
    prove w < x'.
    apply L1 w Hw.
    let w'. assume H. apply H.
    assume Hw': w' :e L'.
    assume Hww': w <= w'.
    apply SNoLeLt_tra w w' x'.
    + prove SNo w. exact HLR1 w Hw.
    + prove SNo w'. exact LL' w' Hw'.
    + prove SNo x'. exact H1'.
    + exact Hww'.
    + prove w' < x'. apply H3'.
      prove w' :e L'. exact Hw'.
  - let z. assume Hz: z :e R.
    prove x' < z.
    apply L2 z Hz.
    let z'. assume H. apply H.
    assume Hz': z' :e R'.
    assume Hz'z: z' <= z.
    prove x' < z.
    exact SNoLtLe_tra x' z' z H1' (LR' z' Hz') (HLR2 z Hz) (H4' z' Hz') Hz'z.
  - let w. assume Hw: w :e L'.
    prove w < x.
    apply LL'L w Hw.
    let u. assume H. apply H.
    assume Hu: u :e L.
    assume Hwu: w <= u.
    exact SNoLeLt_tra w u x (LL' w Hw) (HLR1 u Hu) H1 Hwu (H3 u Hu).
  - let z. assume Hz: z :e R'.
    prove x < z.
    apply LR'R z Hz.
    let u. assume H. apply H.
    assume Hu: u :e R.
    assume Huz: u <= z.
    exact SNoLtLe_tra x u z H1 (HLR2 u Hu) (LR' z Hz) (H4 u Hu) Huz.
}
prove x :e real.
rewrite Lxx'.
prove x' :e real.
exact real_SNoCut_SNoS_omega L' LL'o R' LR'o LLR' L3 L4 L5 L6.
Qed.

Theorem minus_SNo_prereal_1 : forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - - x) < eps_ k) -> q = - x).
let x. assume Hx H1. let q.
assume Hq1: q :e SNoS_ omega.
rewrite minus_SNo_invol x Hx.
assume Hq2: forall k :e omega, abs_SNo (q + x) < eps_ k.
prove q = - x.
apply SNoS_E2 omega omega_ordinal q Hq1.
assume Hq1a Hq1b Hq1c Hq1d.
rewrite <- minus_SNo_invol q Hq1c.
prove - - q = - x.
f_equal.
prove - q = x.
apply H1 (- q) (minus_SNo_SNoS_omega q Hq1).
let k. assume Hk.
prove abs_SNo (- q + - x) < eps_ k.
rewrite abs_SNo_dist_swap (- q) x (SNo_minus_SNo q Hq1c) Hx.
prove abs_SNo (x + - - q) < eps_ k.
rewrite minus_SNo_invol q Hq1c.
prove abs_SNo (x + q) < eps_ k.
rewrite add_SNo_com x q Hx Hq1c.
prove abs_SNo (q + x) < eps_ k.
exact Hq2 k Hk.
Qed.

Theorem minus_SNo_prereal_2 : forall x, SNo x ->
    (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < - x /\ - x < q + eps_ k).
let x. assume Hx H1. let k. assume Hk.
apply H1 k Hk. let q. assume Hq. apply Hq.
assume Hq1: q :e SNoS_ omega.
assume Hq. apply Hq.
assume Hq2: q < x.
assume Hq3: x < q + eps_ k.
apply SNoS_E2 omega omega_ordinal q Hq1.
assume Hq1a Hq1b Hq1c Hq1d.
claim Lqk: SNo (q + eps_ k).
{ exact SNo_add_SNo q (eps_ k) Hq1c (SNo_eps_ k Hk). }
witness (- (q + eps_ k)). apply andI.
- exact minus_SNo_SNoS_omega (q + eps_ k) (add_SNo_SNoS_omega q Hq1 (eps_ k) (SNo_eps_SNoS_omega k Hk)).
- apply andI.
  + prove - (q + eps_ k) < - x.
    apply minus_SNo_Lt_contra x (q + eps_ k) Hx Lqk.
    prove x < q + eps_ k.
    exact Hq3.
  + prove - x < - (q + eps_ k) + eps_ k.
    rewrite minus_add_SNo_distr q (eps_ k) Hq1c (SNo_eps_ k Hk).
    prove - x < (- q + - eps_ k) + eps_ k.
    rewrite add_SNo_minus_R2' (- q) (eps_ k) (SNo_minus_SNo q Hq1c) (SNo_eps_ k Hk).
    prove - x < - q.
    apply minus_SNo_Lt_contra q x Hq1c Hx.
    prove q < x.
    exact Hq2.
Qed.

Theorem SNo_prereal_incr_lower_pos: forall x, SNo x -> 0 < x
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> forall k :e omega,
     forall p:prop,
         (forall q :e SNoS_ omega, 0 < q -> q < x -> x < q + eps_ k -> p)
      -> p.
let x. assume Hx Hx0 Hx2 Hx3.
let k. assume Hk. let p. assume Hp.
apply Hx3 k Hk.
let q. assume H. apply H.
assume Hq1: q :e SNoS_ omega. assume H. apply H.
assume Hq2: q < x.
assume Hq3: x < q + eps_ k.
apply SNoS_E2 omega omega_ordinal q Hq1.
assume Hq1a Hq1b Hq1c Hq1d.
apply SNoLtLe_or 0 q SNo_0 Hq1c.
- assume H1: 0 < q. exact Hp q Hq1 H1 Hq2 Hq3.
- assume H1: q <= 0.
  apply xm (forall k' :e omega, x < eps_ k').
  + assume H2: forall k' :e omega, x < eps_ k'. prove False.
    claim L1: 0 = x.
    { apply Hx2 0 (omega_SNoS_omega 0 (nat_p_omega 0 nat_0)).
      let k'. assume Hk': k' :e omega.
      prove abs_SNo (0 + - x) < eps_ k'.
      rewrite add_SNo_0L (- x) (SNo_minus_SNo x Hx).
      prove abs_SNo (- x) < eps_ k'.
      rewrite abs_SNo_minus x Hx.
      prove abs_SNo x < eps_ k'.
      rewrite pos_abs_SNo x Hx0.
      exact H2 k' Hk'.
    }
    apply SNoLt_irref x.
    prove x < x. rewrite <- L1 at 1. exact Hx0.
  + assume H2: ~(forall k' :e omega, x < eps_ k').
    apply dneg.
    assume H3: ~p.
    apply H2.
    let k'. assume Hk': k' :e omega.
    apply SNoLtLe_or x (eps_ k') Hx (SNo_eps_ k' Hk').
    * assume H4: x < eps_ k'. exact H4.
    * { assume H4: eps_ k' <= x.
        claim Lek': SNo (eps_ k').
        { apply SNo_eps_.
          exact Hk'.
        }
        claim LeSk': SNo (eps_ (ordsucc k')).
        { apply SNo_eps_.
          apply omega_ordsucc.
          exact Hk'.
        }
        claim LeSk'pos: 0 < eps_ (ordsucc k').
        { apply SNo_eps_pos.
          apply omega_ordsucc.
          exact Hk'.
        }
        apply H3.
        apply Hp (eps_ (ordsucc k')).
        - prove eps_ (ordsucc k') :e SNoS_ omega.
          apply SNo_eps_SNoS_omega.
          apply omega_ordsucc.
          exact Hk'.
        - prove 0 < eps_ (ordsucc k'). exact LeSk'pos.
        - prove eps_ (ordsucc k') < x.
          apply SNoLtLe_tra (eps_ (ordsucc k')) (eps_ k') x LeSk' Lek' Hx.
          + prove eps_ (ordsucc k') < eps_ k'.
            exact SNo_eps_decr (ordsucc k') (omega_ordsucc k' Hk') k' (ordsuccI2 k').
          + prove eps_ k' <= x. exact H4.
        - prove x < eps_ (ordsucc k') + eps_ k.
          claim L2: q < eps_ (ordsucc k').
          { apply SNoLeLt_tra q 0 (eps_ (ordsucc k')) Hq1c SNo_0 LeSk'.
            - prove q <= 0. exact H1.
            - prove 0 < eps_ (ordsucc k'). exact LeSk'pos.
          }
          apply SNoLt_tra x (q + eps_ k) (eps_ (ordsucc k') + eps_ k)
                          Hx
                          (SNo_add_SNo q (eps_ k) Hq1c (SNo_eps_ k Hk))
                          (SNo_add_SNo (eps_ (ordsucc k')) (eps_ k) LeSk' (SNo_eps_ k Hk)).
          + prove x < q + eps_ k. exact Hq3.
          + prove q + eps_ k < eps_ (ordsucc k') + eps_ k.
            apply add_SNo_Lt1 q (eps_ k) (eps_ (ordsucc k')) Hq1c (SNo_eps_ k Hk) LeSk'.
            prove q < eps_ (ordsucc k').
            exact L2.
      }
Qed.

Theorem real_minus_SNo : forall x :e real, - x :e real.
let x. assume Hx. apply real_E x Hx.
assume Hx1 Hx2 Hx3 Hx4 Hx5 Hx6 Hx7.
apply real_I.
- prove - x :e SNoS_ (ordsucc omega).
  exact minus_SNo_SNoS_ (ordsucc omega) ordsucc_omega_ordinal x Hx3.
- prove - x <> omega.
  assume H1: - x = omega.
  apply SNoLt_irref x.
  prove x < x.
  rewrite <- minus_SNo_invol x Hx1 at 1.
  prove - - x < x. rewrite H1.
  prove - omega < x. exact Hx4.
- prove - x <> - omega.
  assume H1: - x = - omega.
  apply SNoLt_irref x.
  prove x < x.
  rewrite <- minus_SNo_invol x Hx1 at 2.
  prove x < - - x.
  rewrite H1.
  prove x < - - omega.
  rewrite minus_SNo_invol omega SNo_omega.
  prove x < omega. exact Hx5.
- prove forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - - x) < eps_ k) -> q = - x.
  exact minus_SNo_prereal_1 x Hx1 Hx6.
Qed.

Theorem SNo_prereal_incr_lower_approx: forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> exists f :e SNoS_ omega :^: omega,
       forall n :e omega, f n < x /\ x < f n + eps_ n
                       /\ forall i :e n, f i < f n.
let x. assume H1 H2 H3.
set f' : set -> set
 := nat_primrec (Eps_i (fun q => q :e SNoS_ omega /\ q < x /\ x < q + eps_ 0))
                (fun n r => (Eps_i (fun q => q :e SNoS_ omega /\ q < x /\ x < q + eps_ (ordsucc n) /\ r < q))).
set f := fun n :e omega => f' n.
claim Lf'0: f' 0 = Eps_i (fun q => q :e SNoS_ omega /\ q < x /\ x < q + eps_ 0).
{ exact nat_primrec_0
                (Eps_i (fun q => q :e SNoS_ omega /\ q < x /\ x < q + eps_ 0))
                (fun n r => (Eps_i (fun q => q :e SNoS_ omega /\ q < x /\ x < q + eps_ (ordsucc n) /\ r < q))).
}
claim Lf'0b: f' 0 :e SNoS_ omega /\ f' 0 < x /\ x < f' 0 + eps_ 0.
{ rewrite Lf'0.
  apply Eps_i_ex (fun q => q :e SNoS_ omega /\ q < x /\ x < q + eps_ 0).
  prove exists q, q :e SNoS_ omega /\ q < x /\ x < q + eps_ 0.
  apply H3 0 (nat_p_omega 0 nat_0).
  let q. assume Hq. apply Hq.
  assume Hq1 Hq. apply Hq.
  assume Hq2 Hq3.
  witness q.
  apply and3I.
  - exact Hq1.
  - exact Hq2.
  - exact Hq3.
}
claim Lf'S: forall n, nat_p n -> f' (ordsucc n) = Eps_i (fun q => q :e SNoS_ omega /\ q < x /\ x < q + eps_ (ordsucc n) /\ f' n < q).
{ exact nat_primrec_S
                (Eps_i (fun q => q :e SNoS_ omega /\ q < x /\ x < q + eps_ 0))
                (fun n r => (Eps_i (fun q => q :e SNoS_ omega /\ q < x /\ x < q + eps_ (ordsucc n) /\ r < q))).
}
claim L1: forall n, nat_p n -> f' n :e SNoS_ omega /\ f' n < x /\ x < f' n + eps_ n /\ forall i :e n, SNo (f i) -> f i < f' n.
{ apply nat_ind.
  - prove f' 0 :e SNoS_ omega /\ f' 0 < x /\ x < f' 0 + eps_ 0 /\ forall i :e 0, SNo (f i) -> f i < f' 0.
    apply Lf'0b. assume H H6. apply H. assume H4 H5.
    apply and4I.
    + exact H4.
    + exact H5.
    + exact H6.
    + let i. assume Hi. prove False. exact EmptyE i Hi.
  - let n. assume Hn.
    assume IHn: f' n :e SNoS_ omega /\ f' n < x /\ x < f' n + eps_ n /\ forall i :e n, SNo (f i) -> f i < f' n.
    prove f' (ordsucc n) :e SNoS_ omega /\ f' (ordsucc n) < x /\ x < f' (ordsucc n) + eps_ (ordsucc n)
       /\ forall i :e ordsucc n, SNo (f i) -> f i < f' (ordsucc n).
    apply IHn. assume IHn123 IHn4. apply IHn123. assume IHn12 IHn3. apply IHn12. assume IHn1 IHn2.
    apply SNoS_E2 omega omega_ordinal (f' n) IHn1.
    assume _ _.
    assume IHn1c: SNo (f' n).
    assume _.
    claim L1b: exists q, q :e SNoS_ omega /\ q < x /\ x < q + eps_ (ordsucc n) /\ f' n < q.
    { apply H3 (ordsucc n) (nat_p_omega (ordsucc n) (nat_ordsucc n Hn)).
      let q. assume Hq. apply Hq.
      assume Hq1 Hq. apply Hq.
      assume Hq2 Hq3.
      apply SNoS_E2 omega omega_ordinal q Hq1.
      assume Hq1a Hq1b Hq1c Hq1d.
      apply SNoLtLe_or (f' n) q IHn1c Hq1c.
      - assume H4: f' n < q.
        witness q. apply and4I.
        + exact Hq1.
        + exact Hq2.
        + exact Hq3.
        + exact H4.
      - assume H4: q <= f' n.
        claim L1ba: SNo (- f' n).
        { exact SNo_minus_SNo (f' n) IHn1c. }
        claim L1bb: SNo (x + - f' n).
        { exact SNo_add_SNo x (- f' n) H1 L1ba. }
        claim L1bc: SNo (eps_ (ordsucc n)).
        { exact SNo_eps_ (ordsucc n) (omega_ordsucc n (nat_p_omega n Hn)). }
        apply xm (exists k :e omega, eps_ k <= x + - f' n).
        + assume H5. apply H5. let k. assume H5. apply H5.
          assume Hk1: k :e omega.
          assume Hk2: eps_ k <= x + - f' n.
          witness (f' n + eps_ (ordsucc k)).
          claim Lk1: ordsucc k :e omega.
          { exact omega_ordsucc k Hk1. }
          claim Lk2: SNo (eps_ (ordsucc k)).
          { exact SNo_eps_ (ordsucc k) Lk1. }
          claim Lk3: f' n + eps_ (ordsucc k) :e SNoS_ omega.
          { exact add_SNo_SNoS_omega (f' n) IHn1 (eps_ (ordsucc k)) (SNo_eps_SNoS_omega (ordsucc k) (omega_ordsucc k Hk1)). }
          apply SNoS_E2 omega omega_ordinal (f' n + eps_ (ordsucc k)) Lk3.
          assume _ _.
          assume H6: SNo (f' n + eps_ (ordsucc k)).
          assume _.
          apply and4I.
          * exact Lk3.
          * { prove f' n + eps_ (ordsucc k) < x.
              apply SNoLtLe_tra (f' n + eps_ (ordsucc k)) (f' n + eps_ k) x.
              - exact H6.
              - exact SNo_add_SNo (f' n) (eps_ k) IHn1c (SNo_eps_ k Hk1).
              - exact H1.
              - prove f' n + eps_ (ordsucc k) < f' n + eps_ k.
                apply add_SNo_Lt2 (f' n) (eps_ (ordsucc k)) (eps_ k) IHn1c Lk2 (SNo_eps_ k Hk1).
                prove eps_ (ordsucc k) < eps_ k.
                apply SNo_eps_decr.
                + prove ordsucc k :e omega. exact Lk1.
                + prove k :e ordsucc k. apply ordsuccI2.
              - prove f' n + eps_ k <= x.
                apply add_SNo_minus_L2' (f' n) x IHn1c H1 (fun u v => f' n + eps_ k <= u).
                prove f' n + eps_ k <= f' n + (- f' n + x).
                rewrite add_SNo_com (- f' n) x L1ba H1.
                prove f' n + eps_ k <= f' n + (x + - f' n).
                exact add_SNo_Le2 (f' n) (eps_ k) (x + - f' n) IHn1c (SNo_eps_ k Hk1) L1bb Hk2.
            }
          * { prove x < (f' n + eps_ (ordsucc k)) + eps_ (ordsucc n).
              rewrite add_SNo_com_3b_1_2 (f' n) (eps_ (ordsucc k)) (eps_ (ordsucc n))
                          IHn1c Lk2 L1bc.
              prove x < (f' n + eps_ (ordsucc n)) + eps_ (ordsucc k).
              apply add_SNo_eps_Lt' x (f' n + eps_ (ordsucc n)) H1 (SNo_add_SNo (f' n) (eps_ (ordsucc n)) IHn1c L1bc) (ordsucc k) Lk1.
              prove x < f' n + eps_ (ordsucc n).
              apply SNoLtLe_tra x (q + (eps_ (ordsucc n))).
              - exact H1.
              - exact SNo_add_SNo q (eps_ (ordsucc n)) Hq1c L1bc.
              - exact SNo_add_SNo (f' n) (eps_ (ordsucc n)) IHn1c L1bc.
              - prove x < q + eps_ (ordsucc n). exact Hq3.
              - prove q + eps_ (ordsucc n) <= f' n + eps_ (ordsucc n).
                exact add_SNo_Le1 q (eps_ (ordsucc n)) (f' n) Hq1c L1bc IHn1c H4.
            }
          * prove f' n < f' n + eps_ (ordsucc k).
            exact add_SNo_eps_Lt (f' n) IHn1c (ordsucc k) (omega_ordsucc k Hk1).
        + assume H5: ~(exists k :e omega, eps_ k <= x + - f' n).
          prove False.
          apply SNoLt_irref x.
          prove x < x.
          claim L1bd: 0 < x + - f' n.
          { apply add_SNo_Lt1_cancel 0 (f' n) (x + - f' n) SNo_0 IHn1c L1bb.
            prove 0 + f' n < (x + - f' n) + f' n.
            rewrite add_SNo_0L (f' n) IHn1c.
            rewrite add_SNo_minus_R2' x (f' n) H1 IHn1c.
            prove f' n < x. exact IHn2.
          }
          claim L1be: f' n = x.
          { apply H2 (f' n) IHn1.
            let k. assume Hk.
            prove abs_SNo (f' n + - x) < eps_ k.
            apply SNoLtLe_or (x + - f' n) (eps_ k) L1bb (SNo_eps_ k Hk).
            - assume H6: x + - f' n < eps_ k.
              prove abs_SNo (f' n + - x) < eps_ k.
              rewrite abs_SNo_dist_swap (f' n) x IHn1c H1.
              prove abs_SNo (x + - f' n) < eps_ k.
              rewrite pos_abs_SNo (x + - f' n) L1bd. exact H6.
            - assume H6: eps_ k <= x + - f' n.
              apply H5. witness k. apply andI.
              + exact Hk.
              + exact H6.
          }
          rewrite <- L1be at 1.
          exact IHn2.
    }
    claim L1c: f' (ordsucc n) :e SNoS_ omega /\ f' (ordsucc n) < x /\ x < f' (ordsucc n) + eps_ (ordsucc n) /\ f' n < f' (ordsucc n).
    { rewrite Lf'S n Hn.
      exact Eps_i_ex (fun q => q :e SNoS_ omega /\ q < x /\ x < q + eps_ (ordsucc n) /\ f' n < q) L1b.
    }
    apply L1c. assume H H7. apply H. assume H H6. apply H. assume H4 H5.
    apply and4I.
    + exact H4.
    + exact H5.
    + exact H6.
    + let i. assume Hi: i :e ordsucc n. assume Hfi: SNo (f i).
      apply ordsuccE n i Hi.
      * { assume H8: i :e n.
          prove f i < f' (ordsucc n).
          apply SNoLt_tra (f i) (f' n) (f' (ordsucc n)).
          - prove SNo (f i). exact Hfi.
          - exact IHn1c.
          - apply SNoS_E2 omega omega_ordinal (f' (ordsucc n)) H4. assume _ _ H9 _. exact H9.
          - apply IHn. assume _.
            assume IHn4: forall i :e n, SNo (f i) -> f i < f' n.
            exact IHn4 i H8 Hfi.
          - exact H7.
        }
      * assume H8: i = n. rewrite H8.
        prove f n < f' (ordsucc n).
        rewrite beta omega f' n (nat_p_omega n Hn).
        exact H7.
}
claim L2: forall n :e omega, f' n :e SNoS_ omega /\ f n < x /\ x < f n + eps_ n /\ forall i :e n, SNo (f i) -> f i < f n.
{ let n. assume Hn.
  exact beta omega f' n Hn
         (fun u v => f' n :e SNoS_ omega /\ v < x /\ x < v + eps_ n /\ forall i :e n, SNo (f i) -> f i < v)
         (L1 n (omega_nat_p n Hn)).
}
witness f.
apply andI.
- prove (fun n :e omega => f' n) :e Pi_ n :e omega, SNoS_ omega.
  apply lam_Pi.
  let n. assume Hn.
  apply L2 n Hn. assume H _. apply H. assume H _.
  apply H. assume H _. exact H.
- let n. assume Hn. apply L2 n Hn. assume H H7.
  apply H. assume H H6. apply H. assume H4 H5.
  apply and3I.
  + exact H5.
  + exact H6.
  + let i. assume Hi: i :e n.
    apply H7 i Hi.
    prove SNo (f i).
    claim Li: i :e omega.
    { exact nat_p_omega i (nat_p_trans n (omega_nat_p n Hn) i Hi). }
    rewrite beta omega f' i Li.
    prove SNo (f' i).
    apply L2 i Li.
    assume H _. apply H. assume H _. apply H.
    assume H8: f' i :e SNoS_ omega.
    assume _.
    apply SNoS_E2 omega omega_ordinal (f' i) H8.
    assume _ _ H9 _.
    prove SNo (f' i).
    exact H9.
Qed.

Theorem SNo_prereal_decr_upper_approx: forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> exists g :e SNoS_ omega :^: omega,
       forall n :e omega, g n + - eps_ n < x /\ x < g n
                       /\ forall i :e n, g n < g i.
let x. assume H1 H2 H3.
claim L1: SNo (- x).
{ exact SNo_minus_SNo x H1. }
apply SNo_prereal_incr_lower_approx (- x) L1
       (minus_SNo_prereal_1 x H1 H2)
       (minus_SNo_prereal_2 x H1 H3).
let f. assume Hf. apply Hf.
assume Hf1: f :e SNoS_ omega :^: omega.
assume Hf2: forall n :e omega, f n < - x /\ - x < f n + eps_ n
                       /\ forall i :e n, f i < f n.
claim Lf: forall n :e omega, SNo (f n).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (f n) (ap_Pi omega (fun _ => SNoS_ omega) f n Hf1 Hn).
  assume _ _ H _. exact H.
}
set g := fun n :e omega => - f n.
witness g.
apply andI.
- prove g :e SNoS_ omega :^: omega.
  prove (fun n :e omega => - f n) :e Pi_ _ :e omega, SNoS_ omega.
  apply lam_Pi. let n. assume Hn.
  prove - f n :e SNoS_ omega.
  apply minus_SNo_SNoS_omega.
  prove f n :e SNoS_ omega.
  exact ap_Pi omega (fun _ => SNoS_ omega) f n Hf1 Hn.
- let n. assume Hn.
  prove g n + - eps_ n < x /\ x < g n /\ forall i :e n, g n < g i.
  claim L1: - f n + - eps_ n < x /\ x < - f n /\ forall i :e n, - f n < g i.
  { apply Hf2 n Hn.
    assume H. apply H.
    assume Hf2a: f n < - x.
    assume Hf2b: - x < f n + eps_ n.
    assume Hf2c: forall i :e n, f i < f n.
    apply and3I.
    - prove - f n + - eps_ n < x.
      rewrite <- minus_add_SNo_distr (f n) (eps_ n) (Lf n Hn) (SNo_eps_ n Hn).
      prove - (f n + eps_ n) < x.
      apply minus_SNo_Lt_contra1 x (f n + eps_ n) H1 (SNo_add_SNo (f n) (eps_ n) (Lf n Hn) (SNo_eps_ n Hn)).
      prove - x < f n + eps_ n.
      exact Hf2b.
    - prove x < - f n.
      apply minus_SNo_Lt_contra2 (f n) x (Lf n Hn) H1.
      prove f n < - x.
      exact Hf2a.
    - let i. assume Hi.
      claim Li: i :e omega.
      { exact nat_p_omega i (nat_p_trans n (omega_nat_p n Hn) i Hi). }
      rewrite beta omega (fun n => - f n) i Li.
      prove - f n < - f i.
      apply minus_SNo_Lt_contra (f i) (f n) (Lf i Li) (Lf n Hn).
      exact Hf2c i Hi.
  }
  claim L2: g n = - f n.
  { exact beta omega (fun n => - f n) n Hn. }
  exact L2 (fun u v => v + - eps_ n < x /\ x < v /\ forall i :e n, v < g i) L1.
Qed.

Theorem SNoCutP_SNoCut_lim : forall lambda, ordinal lambda
 -> (forall alpha :e lambda, ordsucc alpha :e lambda)
 -> forall L R c= SNoS_ lambda, SNoCutP L R
 -> SNoLev (SNoCut L R) :e ordsucc lambda.
let lambda. assume Hl1 Hl2.
let L. assume HL. let R. assume HR HLR.
claim L1: forall x :e L, SNoLev x :e lambda.
{ let x. assume Hx.
  apply SNoS_E2 lambda Hl1 x (HL x Hx).
  assume H _ _ _. exact H.
}
claim L2: forall y :e R, SNoLev y :e lambda.
{ let y. assume Hy.
  apply SNoS_E2 lambda Hl1 y (HR y Hy).
  assume H _ _ _. exact H.
}
claim L3: ordinal ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
{ apply ordinal_binunion.
  - apply ordinal_famunion.
    let x. assume Hx.
    apply SNoS_E2 lambda Hl1 x (HL x Hx).
    assume _ H _ _.
    prove ordinal (ordsucc (SNoLev x)).
    apply ordinal_ordsucc.
    prove ordinal (SNoLev x). exact H.
  - apply ordinal_famunion.
    let y. assume Hy.
    apply SNoS_E2 lambda Hl1 y (HR y Hy).
    assume _ H _ _.
    prove ordinal (ordsucc (SNoLev y)).
    apply ordinal_ordsucc.
    prove ordinal (SNoLev y). exact H.
}
claim L4: ordinal (ordsucc lambda).
{ apply ordinal_ordsucc. exact Hl1. }
claim L5: ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))) c= ordsucc lambda.
{ apply ordinal_ordsucc_In_Subq.
  - prove ordinal (ordsucc lambda). exact L4.
  - prove ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))) :e ordsucc lambda.
    apply ordinal_In_Or_Subq ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))) (ordsucc lambda) L3 L4.
    + assume H1. exact H1.
    + assume H1: ordsucc lambda c= ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
      prove False.
      apply binunionE (\/_ x :e L, ordsucc (SNoLev x)) (\/_ y :e R, ordsucc (SNoLev y)) lambda (H1 lambda (ordsuccI2 lambda)).
      * assume H2: lambda :e \/_ x :e L, ordsucc (SNoLev x).
        apply famunionE_impred L (fun x => ordsucc (SNoLev x)) lambda H2.
        let x. assume Hx: x :e L.
        assume H3: lambda :e ordsucc (SNoLev x).
        apply In_no2cycle lambda (ordsucc (SNoLev x)) H3.
        prove ordsucc (SNoLev x) :e lambda.
        apply Hl2. exact L1 x Hx.
      * assume H2: lambda :e \/_ y :e R, ordsucc (SNoLev y).
        apply famunionE_impred R (fun y => ordsucc (SNoLev y)) lambda H2.
        let y. assume Hy: y :e R.
        assume H3: lambda :e ordsucc (SNoLev y).
        apply In_no2cycle lambda (ordsucc (SNoLev y)) H3.
        prove ordsucc (SNoLev y) :e lambda.
        apply Hl2. exact L2 y Hy.
}
apply SNoCutP_SNoCut_impred L R HLR.
assume H1: SNo (SNoCut L R).
assume H2: SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume _ _ _.
exact L5 (SNoLev (SNoCut L R)) H2.
Qed.

Theorem SNoCutP_SNoCut_omega : forall L R c= SNoS_ omega, SNoCutP L R
 -> SNoLev (SNoCut L R) :e ordsucc omega.
exact SNoCutP_SNoCut_lim omega omega_ordinal omega_ordsucc.
Qed.

Theorem SNo_approx_real_lem:
  forall f g :e SNoS_ omega :^: omega,
     (forall n m :e omega, f n < g m)
  -> forall p:prop,
         (SNoCutP {f n|n :e omega} {g n|n :e omega}
       -> SNo (SNoCut {f n|n :e omega} {g n|n :e omega})
       -> SNoLev (SNoCut {f n|n :e omega} {g n|n :e omega}) :e ordsucc omega
       -> SNoCut {f n|n :e omega} {g n|n :e omega} :e SNoS_ (ordsucc omega)
       -> (forall n :e omega, f n < SNoCut {f n|n :e omega} {g n|n :e omega})
       -> (forall n :e omega, SNoCut {f n|n :e omega} {g n|n :e omega} < g n)
       -> p)
      -> p.
let f. assume Hf1. let g. assume Hg1 Hfg.
let p. assume Hp.
set L := {f n|n :e omega}.
set R := {g n|n :e omega}.
set x := SNoCut L R.
claim Lf: forall n :e omega, SNo (f n).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (f n) (ap_Pi omega (fun _ => SNoS_ omega) f n Hf1 Hn).
  assume _ _ H _. exact H.
}
claim Lg: forall n :e omega, SNo (g n).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (g n) (ap_Pi omega (fun _ => SNoS_ omega) g n Hg1 Hn).
  assume _ _ H _. exact H.
}
claim L1: SNoCutP L R.
{ prove (forall w :e L, SNo w)
     /\ (forall z :e R, SNo z)
     /\ (forall w :e L, forall z :e R, w < z).
  apply and3I.
  - let w. assume Hw: w :e L.
    apply ReplE_impred omega (fun n => f n) w Hw.
    let n. assume Hn.
    assume Hwn: w = f n.
    rewrite Hwn.
    prove SNo (f n).
    exact Lf n Hn.
  - let z. assume Hz: z :e R.
    apply ReplE_impred omega (fun n => g n) z Hz.
    let m. assume Hm.
    assume Hzm: z = g m.
    rewrite Hzm.
    prove SNo (g m).
    exact Lg m Hm.
  - let w. assume Hw: w :e L.
    let z. assume Hz: z :e R.
    apply ReplE_impred omega (fun n => f n) w Hw.
    let n. assume Hn.
    assume Hwn: w = f n.
    rewrite Hwn.
    apply ReplE_impred omega (fun n => g n) z Hz.
    let m. assume Hm.
    assume Hzm: z = g m.
    rewrite Hzm.
    prove f n < g m.
    exact Hfg n Hn m Hm.
}
apply SNoCutP_SNoCut_impred L R L1.
assume HLR1: SNo x.
assume HLR2: SNoLev x :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume HLR3: forall w :e L, w < x.
assume HLR4: forall y :e R, x < y.
assume HLR5: forall z, SNo z -> (forall w :e L, w < z) -> (forall y :e R, z < y) -> SNoLev x c= SNoLev z /\ SNoEq_ (SNoLev x) x z.
claim L2: L c= SNoS_ omega.
{ let w. assume Hw.
  apply ReplE_impred omega (fun n => f n) w Hw.
  let n. assume Hn.
  assume Hwn: w = f n.
  rewrite Hwn.
  prove f n :e SNoS_ omega.
  exact ap_Pi omega (fun _ => SNoS_ omega) f n Hf1 Hn.
}
claim L3: R c= SNoS_ omega.
{ let z. assume Hz: z :e R.
  apply ReplE_impred omega (fun n => g n) z Hz.
  let m. assume Hm.
  assume Hzm: z = g m.
  rewrite Hzm.
  prove g m :e SNoS_ omega.
  exact (ap_Pi omega (fun _ => SNoS_ omega) g m Hg1 Hm).
}
claim L4: SNoLev x :e ordsucc omega.
{ exact SNoCutP_SNoCut_omega L L2 R L3 L1. }
claim L5: x :e SNoS_ (ordsucc omega).
{ apply SNoS_I (ordsucc omega) ordsucc_omega_ordinal x (SNoLev x).
  - prove SNoLev x :e ordsucc omega. exact L4.
  - prove SNo_ (SNoLev x) x. apply SNoLev_. exact HLR1.
}
apply Hp L1 HLR1 L4 L5.
- let n. assume Hn.
  prove f n < x.
  apply HLR3.
  exact ReplI omega (fun n => f n) n Hn.
- let n. assume Hn.
  prove x < g n.
  apply HLR4.
  exact ReplI omega (fun n => g n) n Hn.
Qed.

Theorem SNo_approx_real: forall x, SNo x ->
 forall f g :e SNoS_ omega :^: omega,
     (forall n :e omega, f n < x)
  -> (forall n :e omega, x < f n + eps_ n)
  -> (forall n :e omega, forall i :e n, f i < f n)
  -> (forall n :e omega, x < g n)
  -> (forall n :e omega, forall i :e n, g n < g i)
  -> x = SNoCut {f n|n :e omega} {g n|n :e omega}
  -> x :e real.
let x. assume Hx. let f. assume Hf1. let g. assume Hg1 Hf2 Hf3 Hf4 Hg3 Hg4.
set L := {f n|n :e omega}.
set R := {g n|n :e omega}.
assume Hxfg: x = SNoCut L R.
claim Lmx: SNo (- x).
{ exact SNo_minus_SNo x Hx. }
claim Lf: forall n :e omega, SNo (f n).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (f n) (ap_Pi omega (fun _ => SNoS_ omega) f n Hf1 Hn).
  assume _ _ H _. exact H.
}
claim Lg: forall n :e omega, SNo (g n).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (g n) (ap_Pi omega (fun _ => SNoS_ omega) g n Hg1 Hn).
  assume _ _ H _. exact H.
}
claim Lfg: forall n m :e omega, f n < g m.
{ let n. assume Hn. let m. assume Hm.
  apply SNoLt_tra (f n) x (g m) (Lf n Hn) Hx (Lg m Hm).
  - exact Hf2 n Hn.
  - exact Hg3 m Hm.
}
apply SNo_approx_real_lem f Hf1 g Hg1 Lfg.
rewrite <- Hxfg.
assume H1: SNoCutP L R.
assume H2: SNo x.
rewrite <- Hxfg.
assume H3: SNoLev x :e ordsucc omega.
rewrite <- Hxfg.
assume H4: x :e SNoS_ (ordsucc omega).
rewrite <- Hxfg.
assume H5: forall n :e omega, f n < x.
rewrite <- Hxfg.
assume H6: forall n :e omega, x < g n.
apply SNoCutP_SNoCut_impred L R H1.
assume _ _ _ _.
assume H7: forall z, SNo z -> (forall w :e L, w < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z.
apply ordsuccE omega (SNoLev x) H3.
- assume H8: SNoLev x :e omega.
  apply SNoS_omega_real.
  prove x :e SNoS_ omega.
  apply SNoS_I omega omega_ordinal x (SNoLev x) H8.
  prove SNo_ (SNoLev x) x.
  exact SNoLev_ x Hx.
- assume H8: SNoLev x = omega.
  apply real_I.
  + prove x :e SNoS_ (ordsucc omega). exact H4.
  + prove x <> omega.
    assume H9: x = omega.
    claim Lbd1: x < g 0.
    { exact Hg3 0 (nat_p_omega 0 nat_0). }
    apply real_E (g 0) (SNoS_omega_real (g 0) (ap_Pi omega (fun _ => SNoS_ omega) g 0 Hg1 (nat_p_omega 0 nat_0))).
    assume Hg0a: SNo (g 0).
    assume _ _ _.
    assume Hg0b: g 0 < omega.
    assume _ _.
    apply SNoLt_irref x.
    prove x < x.
    apply SNoLt_tra x (g 0) x Hx Hg0a Hx Lbd1.
    prove g 0 < x. rewrite H9.
    prove g 0 < omega. exact Hg0b.
  + prove x <> - omega.
    assume H9: x = - omega.
    claim Lbd2: f 0 < x.
    { exact Hf2 0 (nat_p_omega 0 nat_0). }
    apply real_E (f 0) (SNoS_omega_real (f 0) (ap_Pi omega (fun _ => SNoS_ omega) f 0 Hf1 (nat_p_omega 0 nat_0))).
    assume Hf0a: SNo (f 0).
    assume _ _.
    assume Hf0b: - omega < f 0.
    assume _ _ _.
    apply SNoLt_irref x.
    prove x < x.
    apply SNoLt_tra x (f 0) x Hx Hf0a Hx.
    * prove x < f 0. rewrite H9. exact Hf0b.
    * prove f 0 < x. exact Lbd2.
  + prove forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x.
    let q. assume Hq1 Hq2. prove q = x.
    apply SNoS_E2 omega omega_ordinal q Hq1.
    assume Hq1a Hq1b Hq1c Hq1d.
    claim Lmq: SNo (- q).
    { exact SNo_minus_SNo q Hq1c. }
    claim Lxmq: SNo (x + - q).
    { exact SNo_add_SNo x (- q) Hx Lmq. }
    claim Lqmx: SNo (q + - x).
    { exact SNo_add_SNo q (- x) Hq1c Lmx. }
    claim L5: forall w :e L, w < q.
    { let w. assume Hw.
      apply ReplE_impred omega (fun n => f n) w Hw.
      let n. assume Hn.
      assume Hwn: w = f n.
      rewrite Hwn.
      prove f n < q.
      apply SNoLtLe_or (f n) q (Lf n Hn) Hq1c.
      - assume H9: f n < q. exact H9.
      - assume H9: q <= f n.
        apply real_E (f (ordsucc n)) (SNoS_omega_real (f (ordsucc n)) (ap_Pi omega (fun _ => SNoS_ omega) f (ordsucc n) Hf1 (omega_ordsucc n Hn))).
        assume _ _ _ _ _.
        assume Hfn2: forall q' :e SNoS_ omega, (forall k :e omega, abs_SNo (q' + - f (ordsucc n)) < eps_ k) -> q' = f (ordsucc n).
        assume _.
        claim L5a: SNo (f (ordsucc n)).
        { exact Lf (ordsucc n) (omega_ordsucc n Hn). }
        claim L5b: q < f (ordsucc n).
        { apply SNoLeLt_tra q (f n) (f (ordsucc n)) Hq1c (Lf n Hn) L5a H9.
          prove f n < f (ordsucc n).
          apply Hf4 (ordsucc n) (omega_ordsucc n Hn).
          prove n :e ordsucc n. apply ordsuccI2.
        }
        claim L5c: 0 < f (ordsucc n) + - q.
        { exact SNoLt_minus_pos q (f (ordsucc n)) Hq1c L5a L5b. }
        claim L5d: SNo (f (ordsucc n) + - q).
        { exact SNo_add_SNo (f (ordsucc n)) (- q) L5a Lmq. }
        claim L5e: f (ordsucc n) < x.
        { exact Hf2 (ordsucc n) (omega_ordsucc n Hn). }
        claim L5f: q < x.
        { exact SNoLt_tra q (f (ordsucc n)) x Hq1c L5a Hx L5b L5e. }
        claim L5g: 0 < x + - q.
        { exact SNoLt_minus_pos q x Hq1c Hx L5f. }
        claim L5h: abs_SNo (q + - x) = x + - q.
        { rewrite abs_SNo_dist_swap q x Hq1c Hx.
          exact pos_abs_SNo (x + - q) L5g.
        }
        claim L5i: q = f (ordsucc n).
        { apply Hfn2 q Hq1.
          let k. assume Hk: k :e omega.
          prove abs_SNo (q + - f (ordsucc n)) < eps_ k.
          rewrite abs_SNo_dist_swap q (f (ordsucc n)) Hq1c (Lf (ordsucc n) (omega_ordsucc n Hn)).
          prove abs_SNo (f (ordsucc n) + - q) < eps_ k.
          rewrite pos_abs_SNo (f (ordsucc n) + - q) L5c.
          prove f (ordsucc n) + - q < eps_ k.
          apply SNoLt_tra (f (ordsucc n) + - q) (x + - q) (eps_ k) L5d Lxmq (SNo_eps_ k Hk).
          - prove f (ordsucc n) + - q < x + - q.
            apply add_SNo_Lt1 (f (ordsucc n)) (- q) x L5a Lmq Hx.
            prove f (ordsucc n) < x.
            exact L5e.
          - prove x + - q < eps_ k.
            rewrite <- L5h.
            prove abs_SNo (q + - x) < eps_ k.
            exact Hq2 k Hk.
        }
        apply SNoLt_irref q.
        rewrite L5i at 2. exact L5b.
    }
    claim L6: forall z :e R, q < z.
    { let z. assume Hz: z :e R.
      apply ReplE_impred omega (fun n => g n) z Hz.
      let m. assume Hm.
      assume Hzm: z = g m.
      rewrite Hzm.
      prove q < g m.
      apply SNoLtLe_or q (g m) Hq1c (Lg m Hm).
      - assume H9: q < g m. exact H9.
      - assume H9: g m <= q.
        apply real_E (g (ordsucc m)) (SNoS_omega_real (g (ordsucc m)) (ap_Pi omega (fun _ => SNoS_ omega) g (ordsucc m) Hg1 (omega_ordsucc m Hm))).
        assume _ _ _ _ _.
        assume Hgm2: forall q' :e SNoS_ omega, (forall k :e omega, abs_SNo (q' + - g (ordsucc m)) < eps_ k) -> q' = g (ordsucc m).
        assume _.
        claim L6a: SNo (g (ordsucc m)).
        { exact Lg (ordsucc m) (omega_ordsucc m Hm). }
        claim L6b: g (ordsucc m) < q.
        { apply SNoLtLe_tra (g (ordsucc m)) (g m) q L6a (Lg m Hm) Hq1c.
          - prove g (ordsucc m) < g m.
            apply Hg4 (ordsucc m) (omega_ordsucc m Hm).
            prove m :e ordsucc m. apply ordsuccI2.
          - exact H9.
        }
        claim L6c: 0 < q + - g (ordsucc m).
        { exact SNoLt_minus_pos (g (ordsucc m)) q L6a Hq1c L6b. }
        claim L6d: SNo (q + - g (ordsucc m)).
        { exact SNo_add_SNo q (- g (ordsucc m)) Hq1c (SNo_minus_SNo (g (ordsucc m)) L6a). }
        claim L6e: x < g (ordsucc m).
        { exact Hg3 (ordsucc m) (omega_ordsucc m Hm). }
        claim L6f: x < q.
        { exact SNoLt_tra x (g (ordsucc m)) q Hx L6a Hq1c L6e L6b. }
        claim L6g: 0 < q + - x.
        { exact SNoLt_minus_pos x q Hx Hq1c L6f. }
        claim L6h: abs_SNo (q + - x) = q + - x.
        { exact pos_abs_SNo (q + - x) L6g. }
        claim L6i: q = g (ordsucc m).
        { apply Hgm2 q Hq1.
          let k. assume Hk: k :e omega.
          prove abs_SNo (q + - g (ordsucc m)) < eps_ k.
          rewrite pos_abs_SNo (q + - g (ordsucc m)) L6c.
          prove q + - g (ordsucc m) < eps_ k.
          apply SNoLt_tra (q + - g (ordsucc m)) (q + - x) (eps_ k) L6d Lqmx (SNo_eps_ k Hk).
          - prove q + - g (ordsucc m) < q + - x.
            apply add_SNo_Lt2 q (- g (ordsucc m)) (- x) Hq1c (SNo_minus_SNo (g (ordsucc m)) L6a) Lmx.
            prove - g (ordsucc m) < - x.
            apply minus_SNo_Lt_contra x (g (ordsucc m)) Hx L6a.
            exact L6e.
          - prove q + - x < eps_ k.
            rewrite <- L6h.
            prove abs_SNo (q + - x) < eps_ k.
            exact Hq2 k Hk.
        }
        apply SNoLt_irref q.
        rewrite L6i at 1. exact L6b.
    }
    apply H7 q Hq1c L5 L6.
    rewrite <- Hxfg. rewrite H8.
    assume H9: omega c= SNoLev q.
    prove False.
    apply In_irref (SNoLev q).
    prove SNoLev q :e SNoLev q.
    apply H9.
    prove SNoLev q :e omega.
    exact Hq1a.
Qed.

Theorem SNo_approx_real_rep : forall x :e real,
 forall p:prop,
     (forall f g :e SNoS_ omega :^: omega,
           (forall n :e omega, f n < x)
        -> (forall n :e omega, x < f n + eps_ n)
        -> (forall n :e omega, forall i :e n, f i < f n)
        -> (forall n :e omega, g n + - eps_ n < x)
        -> (forall n :e omega, x < g n)
        -> (forall n :e omega, forall i :e n, g n < g i)
        -> SNoCutP {f n|n :e omega} {g n|n :e omega}
        -> x = SNoCut {f n|n :e omega} {g n|n :e omega}
        -> p)
  -> p.
let x. assume Hx. let p. assume Hp.
apply real_E x Hx.
assume Hx1 Hx2 Hx3 _ _ Hx4 Hx5.
apply SNo_prereal_incr_lower_approx x Hx1 Hx4 Hx5.
let f. assume Hf. apply Hf.
assume Hf1 Hf2.
apply SNo_prereal_decr_upper_approx x Hx1 Hx4 Hx5.
let g. assume Hg. apply Hg.
assume Hg1 Hg2.
claim Lf: forall n :e omega, SNo (f n).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (f n) (ap_Pi omega (fun _ => SNoS_ omega) f n Hf1 Hn).
  assume _ _ H _. exact H.
}
claim Lg: forall n :e omega, SNo (g n).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (g n) (ap_Pi omega (fun _ => SNoS_ omega) g n Hg1 Hn).
  assume _ _ H _. exact H.
}
claim Lf1: forall n :e omega, f n < x.
{ let n. assume Hn. apply Hf2 n Hn. assume H _. apply H. assume H _. exact H. }
claim Lf2: forall n :e omega, x < f n + eps_ n.
{ let n. assume Hn. apply Hf2 n Hn. assume H _. apply H. assume _ H. exact H. }
claim Lf3: forall n :e omega, forall i :e n, f i < f n.
{ let n. assume Hn. apply Hf2 n Hn. assume _ H. exact H. }
claim Lg1: forall n :e omega, g n + - eps_ n < x.
{ let n. assume Hn. apply Hg2 n Hn. assume H _. apply H. assume H _. exact H. }
claim Lg2: forall n :e omega, x < g n.
{ let n. assume Hn. apply Hg2 n Hn. assume H _. apply H. assume _ H. exact H. }
claim Lg3: forall n :e omega, forall i :e n, g n < g i.
{ let n. assume Hn. apply Hg2 n Hn. assume _ H. exact H. }
claim Lfg: forall n m :e omega, f n < g m.
{ let n. assume Hn. let m. assume Hm.
  apply SNoLt_tra (f n) x (g m) (Lf n Hn) Hx1 (Lg m Hm).
  - prove f n < x. exact Lf1 n Hn.
  - prove x < g m. exact Lg2 m Hm.
}
set L := {f n|n :e omega}.
set R := {g n|n :e omega}.
apply SNo_approx_real_lem f Hf1 g Hg1 Lfg.
assume H1: SNoCutP L R.
assume H2: SNo (SNoCut L R).
assume H3: SNoLev (SNoCut L R) :e ordsucc omega.
assume H4: SNoCut L R :e SNoS_ (ordsucc omega).
assume H5: forall n :e omega, f n < SNoCut L R.
assume H6: forall n :e omega, SNoCut L R < g n.
claim Lxfg: x = SNoCut L R.
{ rewrite SNo_eta x Hx1.
  apply SNoCut_ext (SNoL x) (SNoR x) L R (SNoCutP_SNoL_SNoR x Hx1) H1.
  - let w. assume Hw: w :e SNoL x. prove w < SNoCut L R.
    apply SNoL_E x Hx1 w Hw.
    assume Hw1: SNo w.
    assume Hw2: SNoLev w :e SNoLev x.
    assume Hw3: w < x.
    claim Lw1: w :e SNoS_ omega.
    { exact SNoLev_In_real_SNoS_omega x Hx w Hw1 Hw2. }
    claim Lw2: 0 < x + - w.
    { exact SNoLt_minus_pos w x Hw1 Hx1 Hw3. }
    claim Lw3: exists k :e omega, w + eps_ k <= x.
    { apply dneg.
      assume H7: ~exists k :e omega, w + eps_ k <= x.
      claim Lw3a: w = x.
      { apply Hx4 w Lw1.
        let k. assume Hk: k :e omega.
        prove abs_SNo (w + - x) < eps_ k.
        rewrite abs_SNo_dist_swap w x Hw1 Hx1.
        prove abs_SNo (x + - w) < eps_ k.
        rewrite pos_abs_SNo (x + - w) Lw2.
        prove x + - w < eps_ k.
        apply SNoLtLe_or (x + - w) (eps_ k) (SNo_add_SNo x (- w) Hx1 (SNo_minus_SNo w Hw1)) (SNo_eps_ k Hk).
        - assume H8: x + - w < eps_ k. exact H8.
        - assume H8: eps_ k <= x + - w. prove False.
          apply H7. witness k. apply andI.
          + exact Hk.
          + prove w + eps_ k <= x.
            rewrite <- add_SNo_minus_R2' x w Hx1 Hw1.
            prove w + eps_ k <= (x + - w) + w.
            rewrite add_SNo_com w (eps_ k) Hw1 (SNo_eps_ k Hk).
            prove eps_ k + w <= (x + - w) + w.
            exact add_SNo_Le1 (eps_ k) w (x + - w) (SNo_eps_ k Hk) Hw1 (SNo_add_SNo x (- w) Hx1 (SNo_minus_SNo w Hw1)) H8.
      }
      apply SNoLt_irref x.
      rewrite <- Lw3a at 1. exact Hw3.
    }
    apply Lw3.
    let k. assume Hk. apply Hk.
    assume Hk1: k :e omega.
    assume Hk2: w + eps_ k <= x.
    prove w < SNoCut L R.
    apply SNoLt_tra w (f k) (SNoCut L R) Hw1 (Lf k Hk1) H2.
    + prove w < f k.
      apply add_SNo_Lt1_cancel w (eps_ k) (f k) Hw1 (SNo_eps_ k Hk1) (Lf k Hk1).
      prove w + eps_ k < f k + eps_ k.
      apply SNoLeLt_tra (w + eps_ k) x (f k + eps_ k)
              (SNo_add_SNo w (eps_ k) Hw1 (SNo_eps_ k Hk1))
              Hx1 
              (SNo_add_SNo (f k) (eps_ k) (Lf k Hk1) (SNo_eps_ k Hk1))
              Hk2.
      prove x < f k + eps_ k.
      apply Hf2 k Hk1. assume H _. apply H. assume _ H. exact H.
    + prove f k < SNoCut L R. exact H5 k Hk1.
  - let z. assume Hz: z :e SNoR x. prove SNoCut L R < z.
    apply SNoR_E x Hx1 z Hz.
    assume Hz1: SNo z.
    assume Hz2: SNoLev z :e SNoLev x.
    assume Hz3: x < z.
    claim Lz1: z :e SNoS_ omega.
    { exact SNoLev_In_real_SNoS_omega x Hx z Hz1 Hz2. }
    claim Lz2: 0 < z + - x.
    { exact SNoLt_minus_pos x z Hx1 Hz1 Hz3. }
    claim Lz3: exists k :e omega, x + eps_ k <= z.
    { apply dneg.
      assume H7: ~exists k :e omega, x + eps_ k <= z.
      claim Lz3a: z = x.
      { apply Hx4 z Lz1.
        let k. assume Hk: k :e omega.
        prove abs_SNo (z + - x) < eps_ k.
        rewrite pos_abs_SNo (z + - x) Lz2.
        prove z + - x < eps_ k.
        apply SNoLtLe_or (z + - x) (eps_ k) (SNo_add_SNo z (- x) Hz1 (SNo_minus_SNo x Hx1)) (SNo_eps_ k Hk).
        - assume H8: z + - x < eps_ k. exact H8.
        - assume H8: eps_ k <= z + - x. prove False.
          apply H7. witness k. apply andI.
          + exact Hk.
          + prove x + eps_ k <= z.
            rewrite <- add_SNo_minus_R2' z x Hz1 Hx1.
            prove x + eps_ k <= (z + - x) + x.
            rewrite add_SNo_com x (eps_ k) Hx1 (SNo_eps_ k Hk).
            prove eps_ k + x <= (z + - x) + x.
            exact add_SNo_Le1 (eps_ k) x (z + - x) (SNo_eps_ k Hk) Hx1 (SNo_add_SNo z (- x) Hz1 (SNo_minus_SNo x Hx1)) H8.
      }
      apply SNoLt_irref x.
      rewrite <- Lz3a at 2. exact Hz3.
    }
    apply Lz3.
    let k. assume Hk. apply Hk.
    assume Hk1: k :e omega.
    assume Hk2: x + eps_ k <= z.
    prove SNoCut L R < z.
    apply SNoLt_tra (SNoCut L R) (g k) z H2 (Lg k Hk1) Hz1.
    + exact H6 k Hk1.
    + prove g k < z.
      apply SNoLtLe_tra (g k) (x + eps_ k) z (Lg k Hk1) (SNo_add_SNo x (eps_ k) Hx1 (SNo_eps_ k Hk1)) Hz1.
      * prove g k < x + eps_ k.
        apply add_SNo_minus_Lt1 (g k) (eps_ k) x (Lg k Hk1) (SNo_eps_ k Hk1) Hx1.
        prove g k + - eps_ k < x.
        exact Lg1 k Hk1.
      * prove x + eps_ k <= z. exact Hk2.
  - let w. assume Hw: w :e L.
    rewrite <- SNo_eta x Hx1.
    prove w < x.
    apply ReplE_impred omega (fun n => f n) w Hw.
    let n. assume Hn.
    assume Hwn: w = f n.
    rewrite Hwn.
    prove f n < x.
    exact Lf1 n Hn.
  - let z. assume Hz: z :e R.
    rewrite <- SNo_eta x Hx1.
    prove x < z.
    apply ReplE_impred omega (fun n => g n) z Hz.
    let m. assume Hm.
    assume Hzm: z = g m.
    rewrite Hzm.
    prove x < g m.
    exact Lg2 m Hm.
}
exact Hp f Hf1 g Hg1 Lf1 Lf2 Lf3 Lg1 Lg2 Lg3 H1 Lxfg.
Qed.

Theorem real_add_SNo : forall x y :e real, x + y :e real.
let x. assume Hx. let y. assume Hy.
apply SNo_approx_real_rep x Hx.
let fL. assume HfL. let fR. assume HfR HfL1 HfL2 HfL3 HfR1 HfR2 HfR3 HfLR HxfLR.
apply SNo_approx_real_rep y Hy.
let gL. assume HgL. let gR. assume HgR HgL1 HgL2 HgL3 HgR1 HgR2 HgR3 HgLR HygLR.
set hL := fun n :e omega => fL (ordsucc n) + gL (ordsucc n).
set hR := fun n :e omega => fR (ordsucc n) + gR (ordsucc n).
set L := {hL n|n :e omega}.
set R := {hR n|n :e omega}.
claim Lx: SNo x.
{ exact real_SNo x Hx. }
claim Ly: SNo y.
{ exact real_SNo y Hy. }
claim Lxy: SNo (x + y).
{ exact SNo_add_SNo x y Lx Ly. }
claim Lx2: forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x.
{ exact real_SNoS_omega_prop x Hx. }
claim Ly2: forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - y) < eps_ k) -> q = y.
{ exact real_SNoS_omega_prop y Hy. }
claim LfLa: forall n :e omega, fL (ordsucc n) :e SNoS_ omega.
{ let n. assume Hn. exact ap_Pi omega (fun _ => SNoS_ omega) fL (ordsucc n) HfL (omega_ordsucc n Hn). }
claim LfLb: forall n :e omega, SNo (fL (ordsucc n)).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (fL (ordsucc n)) (LfLa n Hn).
  assume _ _ H _. exact H.
}
claim LgLa: forall n :e omega, gL (ordsucc n) :e SNoS_ omega.
{ let n. assume Hn. exact ap_Pi omega (fun _ => SNoS_ omega) gL (ordsucc n) HgL (omega_ordsucc n Hn). }
claim LgLb: forall n :e omega, SNo (gL (ordsucc n)).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (gL (ordsucc n)) (LgLa n Hn).
  assume _ _ H _. exact H.
}
claim LfRa: forall n :e omega, fR (ordsucc n) :e SNoS_ omega.
{ let n. assume Hn. exact ap_Pi omega (fun _ => SNoS_ omega) fR (ordsucc n) HfR (omega_ordsucc n Hn). }
claim LfRb: forall n :e omega, SNo (fR (ordsucc n)).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (fR (ordsucc n)) (LfRa n Hn).
  assume _ _ H _. exact H.
}
claim LgRa: forall n :e omega, gR (ordsucc n) :e SNoS_ omega.
{ let n. assume Hn. exact ap_Pi omega (fun _ => SNoS_ omega) gR (ordsucc n) HgR (omega_ordsucc n Hn). }
claim LgRb: forall n :e omega, SNo (gR (ordsucc n)).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (gR (ordsucc n)) (LgRa n Hn).
  assume _ _ H _. exact H.
}
claim LhL: forall n :e omega, hL n = fL (ordsucc n) + gL (ordsucc n).
{ let n. assume Hn.
  exact beta omega (fun n => fL (ordsucc n) + gL (ordsucc n)) n Hn.
}
claim LhR: forall n :e omega, hR n = fR (ordsucc n) + gR (ordsucc n).
{ let n. assume Hn.
  exact beta omega (fun n => fR (ordsucc n) + gR (ordsucc n)) n Hn.
}
claim LhLb: forall n :e omega, SNo (hL n).
{ let n. assume Hn. rewrite LhL n Hn.
  prove SNo (fL (ordsucc n) + gL (ordsucc n)).
  exact SNo_add_SNo (fL (ordsucc n)) (gL (ordsucc n)) (LfLb n Hn) (LgLb n Hn).
}
claim LhRb: forall n :e omega, SNo (hR n).
{ let n. assume Hn. rewrite LhR n Hn.
  prove SNo (fR (ordsucc n) + gR (ordsucc n)).
  exact SNo_add_SNo (fR (ordsucc n)) (gR (ordsucc n)) (LfRb n Hn) (LgRb n Hn).
}
claim L1: hL :e SNoS_ omega :^: omega.
{ prove (fun n :e omega => fL (ordsucc n) + gL (ordsucc n)) :e Pi_ _ :e omega, SNoS_ omega.
  apply lam_Pi.
  let n. assume Hn.
  prove fL (ordsucc n) + gL (ordsucc n) :e SNoS_ omega.
  apply add_SNo_SNoS_omega.
  - exact LfLa n Hn.
  - exact LgLa n Hn.
}
claim L2: hR :e SNoS_ omega :^: omega.
{ prove (fun n :e omega => fR (ordsucc n) + gR (ordsucc n)) :e Pi_ _ :e omega, SNoS_ omega.
  apply lam_Pi.
  let n. assume Hn.
  prove fR (ordsucc n) + gR (ordsucc n) :e SNoS_ omega.
  apply add_SNo_SNoS_omega.
  - exact LfRa n Hn.
  - exact LgRa n Hn.
}
claim L3: forall n :e omega, hL n < x + y.
{ let n. assume Hn. rewrite LhL n Hn.
  prove fL (ordsucc n) + gL (ordsucc n) < x + y.
  apply add_SNo_Lt3 (fL (ordsucc n)) (gL (ordsucc n)) x y
                    (LfLb n Hn) (LgLb n Hn) Lx Ly.
  - prove fL (ordsucc n) < x.
    exact HfL1 (ordsucc n) (omega_ordsucc n Hn).
  - prove gL (ordsucc n) < y.
    exact HgL1 (ordsucc n) (omega_ordsucc n Hn).
}
claim L4: forall n :e omega, x + y < hL n + eps_ n.
{ let n. assume Hn.
  rewrite LhL n Hn.
  prove x + y < (fL (ordsucc n) + gL (ordsucc n)) + eps_ n.
  rewrite <- eps_ordsucc_half_add n (omega_nat_p n Hn).
  prove x + y < (fL (ordsucc n) + gL (ordsucc n)) + (eps_ (ordsucc n) + eps_ (ordsucc n)).
  claim LeSn: SNo (eps_ (ordsucc n)).
  { exact SNo_eps_ (ordsucc n) (omega_ordsucc n Hn). }
  rewrite add_SNo_com_4_inner_mid (fL (ordsucc n)) (gL (ordsucc n)) (eps_ (ordsucc n)) (eps_ (ordsucc n))
                                  (LfLb n Hn) (LgLb n Hn) LeSn LeSn.
  prove x + y < (fL (ordsucc n) + eps_ (ordsucc n)) + (gL (ordsucc n) + eps_ (ordsucc n)).
  apply add_SNo_Lt3 x y (fL (ordsucc n) + eps_ (ordsucc n)) (gL (ordsucc n) + eps_ (ordsucc n))
                    Lx Ly
                    (SNo_add_SNo (fL (ordsucc n)) (eps_ (ordsucc n)) (LfLb n Hn) LeSn)
                    (SNo_add_SNo (gL (ordsucc n)) (eps_ (ordsucc n)) (LgLb n Hn) LeSn).
  - exact HfL2 (ordsucc n) (omega_ordsucc n Hn).
  - exact HgL2 (ordsucc n) (omega_ordsucc n Hn).
}
claim L5: forall n :e omega, forall i :e n, hL i < hL n.
{ let n. assume Hn. let i. assume Hi.
  rewrite LhL n Hn.
  claim Li: i :e omega.
  { exact nat_p_omega i (nat_p_trans n (omega_nat_p n Hn) i Hi). }
  rewrite LhL i Li.
  prove fL (ordsucc i) + gL (ordsucc i) < fL (ordsucc n) + gL (ordsucc n).
  apply add_SNo_Lt3 (fL (ordsucc i)) (gL (ordsucc i)) (fL (ordsucc n)) (gL (ordsucc n))
                    (LfLb i Li) (LgLb i Li)
                    (LfLb n Hn) (LgLb n Hn).
  - prove fL (ordsucc i) < fL (ordsucc n).
    exact HfL3 (ordsucc n) (omega_ordsucc n Hn) (ordsucc i) (nat_ordsucc_in_ordsucc n (omega_nat_p n Hn) i Hi).
  - prove gL (ordsucc i) < gL (ordsucc n).
    exact HgL3 (ordsucc n) (omega_ordsucc n Hn) (ordsucc i) (nat_ordsucc_in_ordsucc n (omega_nat_p n Hn) i Hi).
}
claim L6: forall n :e omega, hR n + - eps_ n < x + y.
{ let n. assume Hn. rewrite LhR n Hn.
  prove (fR (ordsucc n) + gR (ordsucc n)) + - eps_ n < x + y.
  rewrite <- eps_ordsucc_half_add n (omega_nat_p n Hn).
  prove (fR (ordsucc n) + gR (ordsucc n)) + - (eps_ (ordsucc n) + eps_ (ordsucc n)) < x + y.
  claim LeSn: SNo (eps_ (ordsucc n)).
  { exact SNo_eps_ (ordsucc n) (omega_ordsucc n Hn). }
  claim LmeSn: SNo (- eps_ (ordsucc n)).
  { exact SNo_minus_SNo (eps_ (ordsucc n)) LeSn. }
  rewrite minus_add_SNo_distr (eps_ (ordsucc n)) (eps_ (ordsucc n)) LeSn LeSn.
  prove (fR (ordsucc n) + gR (ordsucc n)) + (- eps_ (ordsucc n) + - eps_ (ordsucc n)) < x + y.
  rewrite add_SNo_com_4_inner_mid (fR (ordsucc n)) (gR (ordsucc n)) (- eps_ (ordsucc n)) (- eps_ (ordsucc n))
                                  (LfRb n Hn) (LgRb n Hn) LmeSn LmeSn.
  prove (fR (ordsucc n) + - eps_ (ordsucc n)) + (gR (ordsucc n) + - eps_ (ordsucc n)) < x + y.
  apply add_SNo_Lt3 (fR (ordsucc n) + - eps_ (ordsucc n)) (gR (ordsucc n) + - eps_ (ordsucc n)) x y
                    (SNo_add_SNo (fR (ordsucc n)) (- eps_ (ordsucc n)) (LfRb n Hn) LmeSn)
                    (SNo_add_SNo (gR (ordsucc n)) (- eps_ (ordsucc n)) (LgRb n Hn) LmeSn)
                    Lx Ly.
  - prove fR (ordsucc n) + - eps_ (ordsucc n) < x.
    exact HfR1 (ordsucc n) (omega_ordsucc n Hn).
  - prove gR (ordsucc n) + - eps_ (ordsucc n) < y.
    exact HgR1 (ordsucc n) (omega_ordsucc n Hn).
}
claim L7: forall n :e omega, x + y < hR n.
{ let n. assume Hn. rewrite LhR n Hn.
  prove x + y < fR (ordsucc n) + gR (ordsucc n).
  apply add_SNo_Lt3 x y (fR (ordsucc n)) (gR (ordsucc n))
                    Lx Ly (LfRb n Hn) (LgRb n Hn).
  - prove x < fR (ordsucc n).
    exact HfR2 (ordsucc n) (omega_ordsucc n Hn).
  - prove y < gR (ordsucc n).
    exact HgR2 (ordsucc n) (omega_ordsucc n Hn).
}
claim L8: forall n :e omega, forall i :e n, hR n < hR i.
{ let n. assume Hn. let i. assume Hi.
  rewrite LhR n Hn.
  claim Li: i :e omega.
  { exact nat_p_omega i (nat_p_trans n (omega_nat_p n Hn) i Hi). }
  rewrite LhR i Li.
  prove fR (ordsucc n) + gR (ordsucc n) < fR (ordsucc i) + gR (ordsucc i).
  apply add_SNo_Lt3 (fR (ordsucc n)) (gR (ordsucc n)) (fR (ordsucc i)) (gR (ordsucc i))
                    (LfRb n Hn) (LgRb n Hn)
                    (LfRb i Li) (LgRb i Li).
  - prove fR (ordsucc n) < fR (ordsucc i).
    exact HfR3 (ordsucc n) (omega_ordsucc n Hn) (ordsucc i) (nat_ordsucc_in_ordsucc n (omega_nat_p n Hn) i Hi).
  - prove gR (ordsucc n) < gR (ordsucc i).
    exact HgR3 (ordsucc n) (omega_ordsucc n Hn) (ordsucc i) (nat_ordsucc_in_ordsucc n (omega_nat_p n Hn) i Hi).
}
claim LLR: SNoCutP L R.
{ prove (forall w :e L, SNo w)
     /\ (forall z :e R, SNo z)
     /\ (forall w :e L, forall z :e R, w < z).
  apply and3I.
  - let w. assume Hw.
    apply ReplE_impred omega (fun n => hL n) w Hw.
    let n. assume Hn: n :e omega.
    assume Hwn: w = hL n. rewrite Hwn.
    prove SNo (hL n). exact LhLb n Hn.
  - let z. assume Hz.
    apply ReplE_impred omega (fun n => hR n) z Hz.
    let m. assume Hm: m :e omega.
    assume Hzm: z = hR m. rewrite Hzm.
    prove SNo (hR m). exact LhRb m Hm.
  - let w. assume Hw.
    let z. assume Hz.
    apply ReplE_impred omega (fun n => hL n) w Hw.
    let n. assume Hn: n :e omega.
    assume Hwn: w = hL n. rewrite Hwn.
    apply ReplE_impred omega (fun n => hR n) z Hz.
    let m. assume Hm: m :e omega.
    assume Hzm: z = hR m. rewrite Hzm.
    prove hL n < hR m.
    apply SNoLt_tra (hL n) (x + y) (hR m) (LhLb n Hn) (SNo_add_SNo x y Lx Ly) (LhRb m Hm).
    + prove hL n < x + y. exact L3 n Hn.
    + prove x + y < hR m. exact L7 m Hm.
}
apply SNoCutP_SNoCut_impred L R LLR.
assume HLR1 HLR2 HLR3 HLR4 HLR5.
claim L9: x + y = SNoCut L R.
{ rewrite add_SNo_eq x Lx y Ly.
  prove SNoCut ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y})
      = SNoCut L R.
  apply SNoCut_ext ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y})
                   ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y})
                   L R
                   (add_SNo_SNoCutP x y Lx Ly)
                   LLR.
  - prove forall w :e {w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}, w < SNoCut L R.
    let w. assume Hw.
    apply binunionE {w + y|w :e SNoL x} {x + w|w :e SNoL y} w Hw.
    + assume Hw: w :e {w + y|w :e SNoL x}.
      apply ReplE_impred (SNoL x) (fun w => w + y) w Hw.
      let w'. assume Hw': w' :e SNoL x.
      assume Hww'. rewrite Hww'.
      prove w' + y < SNoCut L R.
      apply SNoL_E x Lx w' Hw'.
      assume Hw'1 Hw'2 Hw'3.
      claim Lw'1: w' :e SNoS_ omega.
      { exact SNoLev_In_real_SNoS_omega x Hx w' Hw'1 Hw'2. }
      claim Lw'2: exists n :e omega, w' + y <= hL n.
      { apply dneg. assume HC: ~(exists n :e omega, w' + y <= hL n).
        claim Lw'2a: 0 < x + - w'.
        { apply SNoLt_minus_pos w' x Hw'1 Lx Hw'3. }
        claim Lw'2b: w' = x.
        { apply Lx2 w' Lw'1.
          let k. assume Hk.
          prove abs_SNo (w' + - x) < eps_ k.
          rewrite abs_SNo_dist_swap w' x Hw'1 Lx.
          prove abs_SNo (x + - w') < eps_ k.
          rewrite pos_abs_SNo (x + - w') Lw'2a.
          prove x + - w' < eps_ k.
          apply add_SNo_minus_Lt1b x w' (eps_ k) Lx Hw'1 (SNo_eps_ k Hk).
          prove x < eps_ k + w'.
          apply SNoLtLe_or x (eps_ k + w') Lx (SNo_add_SNo (eps_ k) w' (SNo_eps_ k Hk) Hw'1).
          - assume H2. exact H2.
          - assume H2: eps_ k + w' <= x. prove False.
            apply HC.
            witness k. apply andI.
            + exact Hk.
            + prove w' + y <= hL k.
              apply SNoLtLe.
              prove w' + y < hL k.
              apply add_SNo_Lt1_cancel (w' + y) (eps_ k) (hL k) (SNo_add_SNo w' y Hw'1 Ly) (SNo_eps_ k Hk) (LhLb k Hk).
              prove (w' + y) + eps_ k < hL k + eps_ k.
              apply SNoLeLt_tra ((w' + y) + eps_ k) (x + y) (hL k + eps_ k)
                                (SNo_add_SNo (w' + y) (eps_ k) (SNo_add_SNo w' y Hw'1 Ly) (SNo_eps_ k Hk))
                                Lxy
                                (SNo_add_SNo (hL k) (eps_ k) (LhLb k Hk) (SNo_eps_ k Hk)).
              * prove (w' + y) + eps_ k <= x + y.
                rewrite add_SNo_com_3b_1_2 w' y (eps_ k) Hw'1 Ly (SNo_eps_ k Hk).
                prove (w' + eps_ k) + y <= x + y.
                apply add_SNo_Le1 (w' + eps_ k) y x (SNo_add_SNo w' (eps_ k) Hw'1 (SNo_eps_ k Hk)) Ly Lx.
                prove w' + eps_ k <= x.
                rewrite add_SNo_com w' (eps_ k) Hw'1 (SNo_eps_ k Hk).
                prove eps_ k + w' <= x.
                exact H2.
              * prove x + y < hL k + eps_ k.
                exact L4 k Hk.
        }
        apply SNoLt_irref x.
        prove x < x. rewrite <- Lw'2b at 1. exact Hw'3.
      }
      apply Lw'2. let n. assume Hn. apply Hn. assume Hn1 Hn2.
      apply SNoLeLt_tra (w' + y) (hL n) (SNoCut L R)
                        (SNo_add_SNo w' y Hw'1 Ly)
                        (LhLb n Hn1)
                        HLR1.
      * prove w' + y <= hL n. exact Hn2.
      * prove hL n < SNoCut L R. apply HLR3.
        prove hL n :e L. apply ReplI. exact Hn1.
    + assume Hw: w :e {x + w|w :e SNoL y}.
      apply ReplE_impred (SNoL y) (fun w => x + w) w Hw.
      let w'. assume Hw': w' :e SNoL y.
      assume Hww'. rewrite Hww'.
      prove x + w' < SNoCut L R.
      apply SNoL_E y Ly w' Hw'.
      assume Hw'1 Hw'2 Hw'3.
      claim Lw'1: w' :e SNoS_ omega.
      { exact SNoLev_In_real_SNoS_omega y Hy w' Hw'1 Hw'2. }
      claim Lw'2: exists n :e omega, x + w' <= hL n.
      { apply dneg. assume HC: ~(exists n :e omega, x + w' <= hL n).
        claim Lw'2a: 0 < y + - w'.
        { apply SNoLt_minus_pos w' y Hw'1 Ly Hw'3. }
        claim Lw'2b: w' = y.
        { apply Ly2 w' Lw'1.
          let k. assume Hk.
          prove abs_SNo (w' + - y) < eps_ k.
          rewrite abs_SNo_dist_swap w' y Hw'1 Ly.
          prove abs_SNo (y + - w') < eps_ k.
          rewrite pos_abs_SNo (y + - w') Lw'2a.
          prove y + - w' < eps_ k.
          apply add_SNo_minus_Lt1b y w' (eps_ k) Ly Hw'1 (SNo_eps_ k Hk).
          prove y < eps_ k + w'.
          apply SNoLtLe_or y (eps_ k + w') Ly (SNo_add_SNo (eps_ k) w' (SNo_eps_ k Hk) Hw'1).
          - assume H2. exact H2.
          - assume H2: eps_ k + w' <= y. prove False.
            apply HC.
            witness k. apply andI.
            + exact Hk.
            + prove x + w' <= hL k.
              apply SNoLtLe.
              prove x + w' < hL k.
              apply add_SNo_Lt1_cancel (x + w') (eps_ k) (hL k) (SNo_add_SNo x w' Lx Hw'1) (SNo_eps_ k Hk) (LhLb k Hk).
              prove (x + w') + eps_ k < hL k + eps_ k.
              apply SNoLeLt_tra ((x + w') + eps_ k) (x + y) (hL k + eps_ k)
                                (SNo_add_SNo (x + w') (eps_ k) (SNo_add_SNo x w' Lx Hw'1) (SNo_eps_ k Hk))
                                Lxy
                                (SNo_add_SNo (hL k) (eps_ k) (LhLb k Hk) (SNo_eps_ k Hk)).
              * prove (x + w') + eps_ k <= x + y.
                rewrite <- add_SNo_assoc x w' (eps_ k) Lx Hw'1 (SNo_eps_ k Hk).
                prove x + (w' + eps_ k) <= x + y.
                apply add_SNo_Le2 x (w' + eps_ k) y Lx (SNo_add_SNo w' (eps_ k) Hw'1 (SNo_eps_ k Hk)) Ly.
                prove w' + eps_ k <= y.
                rewrite add_SNo_com w' (eps_ k) Hw'1 (SNo_eps_ k Hk).
                prove eps_ k + w' <= y.
                exact H2.
              * prove x + y < hL k + eps_ k.
                exact L4 k Hk.
        }
        apply SNoLt_irref y.
        prove y < y. rewrite <- Lw'2b at 1. exact Hw'3.
      }
      apply Lw'2. let n. assume Hn. apply Hn. assume Hn1 Hn2.
      apply SNoLeLt_tra (x + w') (hL n) (SNoCut L R)
                        (SNo_add_SNo x w' Lx Hw'1)
                        (LhLb n Hn1)
                        HLR1.
      * prove x + w' <= hL n. exact Hn2.
      * prove hL n < SNoCut L R. apply HLR3.
        prove hL n :e L. apply ReplI. exact Hn1.
  - prove forall z :e {z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}, SNoCut L R < z.
    let z. assume Hz.
    apply binunionE {z + y|z :e SNoR x} {x + z|z :e SNoR y} z Hz.
    + assume Hz: z :e {z + y|z :e SNoR x}.
      apply ReplE_impred (SNoR x) (fun z => z + y) z Hz.
      let z'. assume Hz': z' :e SNoR x.
      assume Hzz'. rewrite Hzz'.
      prove SNoCut L R < z' + y.
      apply SNoR_E x Lx z' Hz'.
      assume Hz'1 Hz'2 Hz'3.
      claim Lz'1: z' :e SNoS_ omega.
      { exact SNoLev_In_real_SNoS_omega x Hx z' Hz'1 Hz'2. }
      claim Lz'2: exists n :e omega, hR n <= z' + y.
      { apply dneg. assume HC: ~(exists n :e omega, hR n <= z' + y).
        claim Lz'2a: 0 < z' + - x.
        { apply SNoLt_minus_pos x z' Lx Hz'1 Hz'3. }
        claim Lz'2b: z' = x.
        { apply Lx2 z' Lz'1.
          let k. assume Hk.
          prove abs_SNo (z' + - x) < eps_ k.
          rewrite pos_abs_SNo (z' + - x) Lz'2a.
          prove z' + - x < eps_ k.
          apply add_SNo_minus_Lt1b z' x (eps_ k) Hz'1 Lx (SNo_eps_ k Hk).
          prove z' < eps_ k + x.
          apply SNoLtLe_or z' (eps_ k + x) Hz'1 (SNo_add_SNo (eps_ k) x (SNo_eps_ k Hk) Lx).
          - assume H2. exact H2.
          - assume H2: eps_ k + x <= z'. prove False.
            apply HC.
            witness k. apply andI.
            + exact Hk.
            + prove hR k <= z' + y.
              apply SNoLtLe.
              apply add_SNo_Lt1_cancel (hR k) (- eps_ k) (z' + y) (LhRb k Hk) (SNo_minus_SNo (eps_ k) (SNo_eps_ k Hk)) (SNo_add_SNo z' y Hz'1 Ly).
              prove hR k + - eps_ k < (z' + y) + - eps_ k.
              apply SNoLtLe_tra (hR k + - eps_ k) (x + y) ((z' + y) + - eps_ k)
                                (SNo_add_SNo (hR k) (- eps_ k) (LhRb k Hk) (SNo_minus_SNo (eps_ k) (SNo_eps_ k Hk)))
                                Lxy
                                (SNo_add_SNo (z' + y) (- eps_ k) (SNo_add_SNo z' y Hz'1 Ly) (SNo_minus_SNo (eps_ k) (SNo_eps_ k Hk))).
              * prove hR k + - eps_ k < x + y.
                exact L6 k Hk.
              * prove x + y <= (z' + y) + - eps_ k.
                apply add_SNo_minus_Le2b (z' + y) (eps_ k) (x + y) (SNo_add_SNo z' y Hz'1 Ly) (SNo_eps_ k Hk) Lxy.
                prove (x + y) + eps_ k <= z' + y.
                rewrite add_SNo_com_3b_1_2 x y (eps_ k) Lx Ly (SNo_eps_ k Hk).
                prove (x + eps_ k) + y <= z' + y.
                apply add_SNo_Le1 (x + eps_ k) y z' (SNo_add_SNo x (eps_ k) Lx (SNo_eps_ k Hk)) Ly Hz'1.
                prove x + eps_ k <= z'.
                rewrite add_SNo_com x (eps_ k) Lx (SNo_eps_ k Hk).
                exact H2.
        }
        apply SNoLt_irref x.
        prove x < x. rewrite <- Lz'2b at 2. exact Hz'3.
      }
      apply Lz'2. let n. assume Hn. apply Hn. assume Hn1 Hn2.
      apply SNoLtLe_tra (SNoCut L R) (hR n) (z' + y)
                        HLR1
                        (LhRb n Hn1)
                        (SNo_add_SNo z' y Hz'1 Ly).
      * prove SNoCut L R < hR n. apply HLR4.
        prove hR n :e R. apply ReplI. exact Hn1.
      * prove hR n <= z' + y. exact Hn2.
    + assume Hz: z :e {x + z|z :e SNoR y}.
      apply ReplE_impred (SNoR y) (fun z => x + z) z Hz.
      let z'. assume Hz': z' :e SNoR y.
      assume Hzz'. rewrite Hzz'.
      prove SNoCut L R < x + z'.
      apply SNoR_E y Ly z' Hz'.
      assume Hz'1 Hz'2 Hz'3.
      claim Lz'1: z' :e SNoS_ omega.
      { exact SNoLev_In_real_SNoS_omega y Hy z' Hz'1 Hz'2. }
      claim Lz'2: exists n :e omega, hR n <= x + z'.
      { apply dneg. assume HC: ~(exists n :e omega, hR n <= x + z').
        claim Lz'2a: 0 < z' + - y.
        { apply SNoLt_minus_pos y z' Ly Hz'1 Hz'3. }
        claim Lz'2b: z' = y.
        { apply Ly2 z' Lz'1.
          let k. assume Hk.
          prove abs_SNo (z' + - y) < eps_ k.
          rewrite pos_abs_SNo (z' + - y) Lz'2a.
          prove z' + - y < eps_ k.
          apply add_SNo_minus_Lt1b z' y (eps_ k) Hz'1 Ly (SNo_eps_ k Hk).
          prove z' < eps_ k + y.
          apply SNoLtLe_or z' (eps_ k + y) Hz'1 (SNo_add_SNo (eps_ k) y (SNo_eps_ k Hk) Ly).
          - assume H2. exact H2.
          - assume H2: eps_ k + y <= z'. prove False.
            apply HC.
            witness k. apply andI.
            + exact Hk.
            + prove hR k <= x + z'.
              apply SNoLtLe.
              apply add_SNo_Lt1_cancel (hR k) (- eps_ k) (x + z') (LhRb k Hk) (SNo_minus_SNo (eps_ k) (SNo_eps_ k Hk)) (SNo_add_SNo x z' Lx Hz'1).
              prove hR k + - eps_ k < (x + z') + - eps_ k.
              apply SNoLtLe_tra (hR k + - eps_ k) (x + y) ((x + z') + - eps_ k)
                                (SNo_add_SNo (hR k) (- eps_ k) (LhRb k Hk) (SNo_minus_SNo (eps_ k) (SNo_eps_ k Hk)))
                                Lxy
                                (SNo_add_SNo (x + z') (- eps_ k) (SNo_add_SNo x z' Lx Hz'1) (SNo_minus_SNo (eps_ k) (SNo_eps_ k Hk))).
              * prove hR k + - eps_ k < x + y.
                exact L6 k Hk.
              * prove x + y <= (x + z') + - eps_ k.
                apply add_SNo_minus_Le2b (x + z') (eps_ k) (x + y) (SNo_add_SNo x z' Lx Hz'1) (SNo_eps_ k Hk) Lxy.
                prove (x + y) + eps_ k <= x + z'.
                rewrite <- add_SNo_assoc x y (eps_ k) Lx Ly (SNo_eps_ k Hk).
                prove x + (y + eps_ k) <= x + z'.
                apply add_SNo_Le2 x (y + eps_ k) z' Lx (SNo_add_SNo y (eps_ k) Ly (SNo_eps_ k Hk)) Hz'1.
                prove y + eps_ k <= z'.
                rewrite add_SNo_com y (eps_ k) Ly (SNo_eps_ k Hk).
                exact H2.
        }
        apply SNoLt_irref y.
        prove y < y. rewrite <- Lz'2b at 2. exact Hz'3.
      }
      apply Lz'2. let n. assume Hn. apply Hn. assume Hn1 Hn2.
      apply SNoLtLe_tra (SNoCut L R) (hR n) (x + z')
                        HLR1
                        (LhRb n Hn1)
                        (SNo_add_SNo x z' Lx Hz'1).
      * prove SNoCut L R < hR n. apply HLR4.
        prove hR n :e R. apply ReplI. exact Hn1.
      * prove hR n <= x + z'. exact Hn2.
  - let w. assume Hw: w :e L.
    rewrite <- add_SNo_eq x Lx y Ly.
    prove w < x + y.
    apply ReplE_impred omega (fun n => hL n) w Hw.
    let n. assume Hn: n :e omega.
    assume Hwn: w = hL n. rewrite Hwn.
    prove hL n < x + y.
    exact L3 n Hn.
  - let z. assume Hz: z :e R.
    rewrite <- add_SNo_eq x Lx y Ly.
    prove x + y < z.
    apply ReplE_impred omega (fun n => hR n) z Hz.
    let n. assume Hn: n :e omega.
    assume Hzn: z = hR n. rewrite Hzn.
    prove x + y < hR n.
    exact L7 n Hn.
}
exact SNo_approx_real (x + y) (SNo_add_SNo x y Lx Ly) hL L1 hR L2 L3 L4 L5 L7 L8 L9.
Qed.

Theorem SNoS_ordsucc_omega_bdd_eps_pos : forall x :e SNoS_ (ordsucc omega), 0 < x -> x < omega -> exists N :e omega, eps_ N * x < 1.
let x. assume Hx1 Hx2 Hx3.
apply SNoS_E2 (ordsucc omega) ordsucc_omega_ordinal x Hx1.
assume Hx1a Hx1b Hx1c Hx1d.
apply SNoS_ordsucc_omega_bdd_above x Hx1 Hx3.
let N. assume HN. apply HN.
assume HN1: N :e omega.
assume HN2: x < N.
claim LN: SNo N.
{ exact omega_SNo N HN1. }
witness N. apply andI.
- exact HN1.
- prove eps_ N * x < 1.
  apply SNoLt_tra (eps_ N * x) (eps_ N * N) 1
                  (SNo_mul_SNo (eps_ N) x (SNo_eps_ N HN1) Hx1c)
                  (SNo_mul_SNo (eps_ N) N (SNo_eps_ N HN1) LN)
                  SNo_1.
  + prove eps_ N * x < eps_ N * N.
    apply pos_mul_SNo_Lt (eps_ N) x N (SNo_eps_ N HN1) (SNo_eps_pos N HN1) Hx1c LN.
    prove x < N. exact HN2.
  + prove eps_ N * N < 1.
    apply SNoLtLe_or (eps_ N * N) 1
                  (SNo_mul_SNo (eps_ N) N (SNo_eps_ N HN1) LN) SNo_1.
    * assume H1: eps_ N * N < 1. exact H1.
    * { assume H1: 1 <= eps_ N * N. prove False.
        claim L2N: SNo (2 ^ N).
        { exact SNo_exp_SNo_nat 2 SNo_2 N (omega_nat_p N HN1). }
        claim L1: 2 ^ N <= 2 ^ N * eps_ N * N.
        { rewrite <- mul_SNo_oneR (2 ^ N) L2N at 1.
          prove 2 ^ N * 1 <= 2 ^ N * eps_ N * N.
          apply nonneg_mul_SNo_Le (2 ^ N) 1 (eps_ N * N) L2N.
          - prove 0 <= 2 ^ N. apply SNoLtLe.
            exact exp_SNo_nat_pos 2 SNo_2 SNoLt_0_2 N (omega_nat_p N HN1).
          - exact SNo_1.
          - exact SNo_mul_SNo (eps_ N) N (SNo_eps_ N HN1) LN.
          - prove 1 <= eps_ N * N. exact H1.
        }
        apply SNoLt_irref (2 ^ N).
        prove 2 ^ N < 2 ^ N.
        apply SNoLeLt_tra (2 ^ N) N (2 ^ N) L2N LN L2N.
        - prove 2 ^ N <= N.
          rewrite <- mul_SNo_oneL N LN at 2.
          prove 2 ^ N <= 1 * N.
          rewrite <- mul_SNo_eps_power_2' N (omega_nat_p N HN1) at 2.
          prove 2 ^ N <= (2 ^ N * eps_ N) * N.
          rewrite <- mul_SNo_assoc (2 ^ N) (eps_ N) N L2N (SNo_eps_ N HN1) LN.
          exact L1.
        - prove N < 2 ^ N. exact exp_SNo_2_bd N (omega_nat_p N HN1).
      }
Qed.

Theorem real_mul_SNo_pos : forall x y :e real, 0 < x -> 0 < y -> x * y :e real.
let x. assume Hx. let y. assume Hy Hx0 Hy0.
apply dneg.
assume HC: x * y /:e real.
apply real_E x Hx.
assume Hx1 Hx2 Hx3 Hx4 Hx5 Hx6 Hx7.
apply real_E y Hy.
assume Hy1 Hy2 Hy3 Hy4 Hy5 Hy6 Hy7.
claim Lx7: forall k :e omega,
  forall p:prop,
      (forall q :e SNoS_ omega, 0 < q -> q < x -> x < q + eps_ k -> p)
   -> p.
{ exact SNo_prereal_incr_lower_pos x Hx1 Hx0 Hx6 Hx7. }
claim Ly7: forall k :e omega,
  forall p:prop,
      (forall q :e SNoS_ omega, 0 < q -> q < y -> y < q + eps_ k -> p)
   -> p.
{ exact SNo_prereal_incr_lower_pos y Hy1 Hy0 Hy6 Hy7. }
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Hx1 Hy1. }
claim Lmxy: SNo (- x * y).
{ exact SNo_minus_SNo (x * y) Lxy. }
claim Lxy2: SNoLev (x * y) /:e omega.
{ assume H1: SNoLev (x * y) :e omega.
  apply HC.
  apply SNoS_omega_real (x * y).
  prove x * y :e SNoS_ omega.
  apply SNoS_I omega omega_ordinal (x * y) (SNoLev (x * y)) H1.
  prove SNo_ (SNoLev (x * y)) (x * y). apply SNoLev_. exact Lxy.
}
claim Lxy3: forall q, SNo q -> SNoLev q :e omega -> SNoLev q :e SNoLev (x * y).
{ let q. assume Hq1 Hq2.
  apply ordinal_trichotomy_or_impred (SNoLev q) (SNoLev (x * y)) (SNoLev_ordinal q Hq1) (SNoLev_ordinal (x * y) Lxy).
  - assume H1. exact H1.
  - assume H1: SNoLev q = SNoLev (x * y). prove False.
    apply Lxy2.
    rewrite <- H1. exact Hq2.
  - assume H1: SNoLev (x * y) :e SNoLev q. prove False.
    apply Lxy2. apply nat_p_omega.
    exact nat_p_trans (SNoLev q) (omega_nat_p (SNoLev q) Hq2) (SNoLev (x * y)) H1.
}
claim LLx: SNoL x c= SNoS_ omega.
{ let v. assume Hv.
  apply SNoL_E x Hx1 v Hv.
  assume Hv1: SNo v.
  assume Hv2: SNoLev v :e SNoLev x.
  assume Hv3.
  apply SNoS_I omega omega_ordinal v (SNoLev v).
  - prove SNoLev v :e omega.
    apply ordsuccE omega (SNoLev x) Hx2.
    + assume H1: SNoLev x :e omega.
      exact omega_TransSet (SNoLev x) H1 (SNoLev v) Hv2.
    + assume H1: SNoLev x = omega. rewrite <- H1. exact Hv2.
  - prove SNo_ (SNoLev v) v. apply SNoLev_. exact Hv1.
}
claim LRx: SNoR x c= SNoS_ omega.
{ let v. assume Hv.
  apply SNoR_E x Hx1 v Hv.
  assume Hv1: SNo v.
  assume Hv2: SNoLev v :e SNoLev x.
  assume Hv3.
  apply SNoS_I omega omega_ordinal v (SNoLev v).
  - prove SNoLev v :e omega.
    apply ordsuccE omega (SNoLev x) Hx2.
    + assume H1: SNoLev x :e omega.
      exact omega_TransSet (SNoLev x) H1 (SNoLev v) Hv2.
    + assume H1: SNoLev x = omega. rewrite <- H1. exact Hv2.
  - prove SNo_ (SNoLev v) v. apply SNoLev_. exact Hv1.
}
claim LLy: SNoL y c= SNoS_ omega.
{ let v. assume Hv.
  apply SNoL_E y Hy1 v Hv.
  assume Hv1: SNo v.
  assume Hv2: SNoLev v :e SNoLev y.
  assume Hv3.
  apply SNoS_I omega omega_ordinal v (SNoLev v).
  - prove SNoLev v :e omega.
    apply ordsuccE omega (SNoLev y) Hy2.
    + assume H1: SNoLev y :e omega.
      exact omega_TransSet (SNoLev y) H1 (SNoLev v) Hv2.
    + assume H1: SNoLev y = omega. rewrite <- H1. exact Hv2.
  - prove SNo_ (SNoLev v) v. apply SNoLev_. exact Hv1.
}
claim LRy: SNoR y c= SNoS_ omega.
{ let v. assume Hv.
  apply SNoR_E y Hy1 v Hv.
  assume Hv1: SNo v.
  assume Hv2: SNoLev v :e SNoLev y.
  assume Hv3.
  apply SNoS_I omega omega_ordinal v (SNoLev v).
  - prove SNoLev v :e omega.
    apply ordsuccE omega (SNoLev y) Hy2.
    + assume H1: SNoLev y :e omega.
      exact omega_TransSet (SNoLev y) H1 (SNoLev v) Hv2.
    + assume H1: SNoLev y = omega. rewrite <- H1. exact Hv2.
  - prove SNo_ (SNoLev v) v. apply SNoLev_. exact Hv1.
}
claim LLx2: forall v :e SNoL x, forall p:prop, (forall k, k :e omega -> eps_ k <= x + - v -> p) -> p.
{ let v. assume Hv. let p. assume Hp.
  apply SNoL_E x Hx1 v Hv.
  assume Hv1: SNo v.
  assume Hv2: SNoLev v :e SNoLev x.
  assume Hv3: v < x.
  apply xm (forall k :e omega, abs_SNo (v + - x) < eps_ k).
  - assume H1. prove False.
    apply SNoLt_irref x.
    prove x < x.
    rewrite <- Hx6 v (LLx v Hv) H1 at 1.
    prove v < x. exact Hv3.
  - assume H1: ~(forall k :e omega, abs_SNo (v + - x) < eps_ k).
    apply dneg. assume H2: ~p.
    apply H1. let k. assume Hk: k :e omega.
    prove abs_SNo (v + - x) < eps_ k.
    rewrite abs_SNo_dist_swap v x Hv1 Hx1.
    prove abs_SNo (x + - v) < eps_ k.
    rewrite pos_abs_SNo (x + - v) (SNoLt_minus_pos v x Hv1 Hx1 Hv3).
    prove x + - v < eps_ k.
    apply SNoLtLe_or (x + - v) (eps_ k) (SNo_add_SNo x (- v) Hx1 (SNo_minus_SNo v Hv1)) (SNo_eps_ k Hk).
    + assume H3: x + - v < eps_ k. exact H3.
    + assume H3: eps_ k <= x + - v. prove False.
      apply H2. apply Hp k Hk. exact H3.
}
claim LRx2: forall v :e SNoR x, forall p:prop, (forall k, k :e omega -> eps_ k <= v + - x -> p) -> p.
{ let v. assume Hv. let p. assume Hp.
  apply SNoR_E x Hx1 v Hv.
  assume Hv1: SNo v.
  assume Hv2: SNoLev v :e SNoLev x.
  assume Hv3: x < v.
  apply xm (forall k :e omega, abs_SNo (v + - x) < eps_ k).
  - assume H1. prove False.
    apply SNoLt_irref x.
    prove x < x.
    rewrite <- Hx6 v (LRx v Hv) H1 at 2.
    prove x < v. exact Hv3.
  - assume H1: ~(forall k :e omega, abs_SNo (v + - x) < eps_ k).
    apply dneg. assume H2: ~p.
    apply H1. let k. assume Hk: k :e omega.
    prove abs_SNo (v + - x) < eps_ k.
    rewrite pos_abs_SNo (v + - x) (SNoLt_minus_pos x v Hx1 Hv1 Hv3).
    prove v + - x < eps_ k.
    apply SNoLtLe_or (v + - x) (eps_ k) (SNo_add_SNo v (- x) Hv1 (SNo_minus_SNo x Hx1)) (SNo_eps_ k Hk).
    + assume H3: v + - x < eps_ k. exact H3.
    + assume H3: eps_ k <= v + - x. prove False.
      apply H2. apply Hp k Hk. exact H3.
}
claim LLy2: forall v :e SNoL y, forall p:prop, (forall k, k :e omega -> eps_ k <= y + - v -> p) -> p.
{ let v. assume Hv. let p. assume Hp.
  apply SNoL_E y Hy1 v Hv.
  assume Hv1: SNo v.
  assume Hv2: SNoLev v :e SNoLev y.
  assume Hv3: v < y.
  apply xm (forall k :e omega, abs_SNo (v + - y) < eps_ k).
  - assume H1. prove False.
    apply SNoLt_irref y.
    prove y < y.
    rewrite <- Hy6 v (LLy v Hv) H1 at 1.
    prove v < y. exact Hv3.
  - assume H1: ~(forall k :e omega, abs_SNo (v + - y) < eps_ k).
    apply dneg. assume H2: ~p.
    apply H1. let k. assume Hk: k :e omega.
    prove abs_SNo (v + - y) < eps_ k.
    rewrite abs_SNo_dist_swap v y Hv1 Hy1.
    prove abs_SNo (y + - v) < eps_ k.
    rewrite pos_abs_SNo (y + - v) (SNoLt_minus_pos v y Hv1 Hy1 Hv3).
    prove y + - v < eps_ k.
    apply SNoLtLe_or (y + - v) (eps_ k) (SNo_add_SNo y (- v) Hy1 (SNo_minus_SNo v Hv1)) (SNo_eps_ k Hk).
    + assume H3: y + - v < eps_ k. exact H3.
    + assume H3: eps_ k <= y + - v. prove False.
      apply H2. apply Hp k Hk. exact H3.
}
claim LRy2: forall v :e SNoR y, forall p:prop, (forall k, k :e omega -> eps_ k <= v + - y -> p) -> p.
{ let v. assume Hv. let p. assume Hp.
  apply SNoR_E y Hy1 v Hv.
  assume Hv1: SNo v.
  assume Hv2: SNoLev v :e SNoLev y.
  assume Hv3: y < v.
  apply xm (forall k :e omega, abs_SNo (v + - y) < eps_ k).
  - assume H1. prove False.
    apply SNoLt_irref y.
    prove y < y.
    rewrite <- Hy6 v (LRy v Hv) H1 at 2.
    prove y < v. exact Hv3.
  - assume H1: ~(forall k :e omega, abs_SNo (v + - y) < eps_ k).
    apply dneg. assume H2: ~p.
    apply H1. let k. assume Hk: k :e omega.
    prove abs_SNo (v + - y) < eps_ k.
    rewrite pos_abs_SNo (v + - y) (SNoLt_minus_pos y v Hy1 Hv1 Hv3).
    prove v + - y < eps_ k.
    apply SNoLtLe_or (v + - y) (eps_ k) (SNo_add_SNo v (- y) Hv1 (SNo_minus_SNo y Hy1)) (SNo_eps_ k Hk).
    + assume H3: v + - y < eps_ k. exact H3.
    + assume H3: eps_ k <= v + - y. prove False.
      apply H2. apply Hp k Hk. exact H3.
}
apply mul_SNo_eq_3 x y Hx1 Hy1.
let L R.
assume HLR: SNoCutP L R.
assume HLE: forall u, u :e L -> forall q:prop,
                (forall w0 :e SNoL x, forall w1 :e SNoL y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e SNoR x, forall z1 :e SNoR y, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q.
assume HLI1: forall w0 :e SNoL x, forall w1 :e SNoL y, w0 * y + x * w1 + - w0 * w1 :e L.
assume HLI2: forall z0 :e SNoR x, forall z1 :e SNoR y, z0 * y + x * z1 + - z0 * z1 :e L.
assume HRE: forall u, u :e R -> forall q:prop,
                (forall w0 :e SNoL x, forall z1 :e SNoR y, u = w0 * y + x * z1 + - w0 * z1 -> q)
             -> (forall z0 :e SNoR x, forall w1 :e SNoL y, u = z0 * y + x * w1 + - z0 * w1 -> q)
             -> q.
assume HRI1: forall w0 :e SNoL x, forall z1 :e SNoR y, w0 * y + x * z1 + - w0 * z1 :e R.
assume HRI2: forall z0 :e SNoR x, forall w1 :e SNoL y, z0 * y + x * w1 + - z0 * w1 :e R.
assume HxyLR: x * y = SNoCut L R.
claim L1: forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - (x * y)) < eps_ k) -> q = x * y.
{ let q. assume Hq1 Hq2.
  prove q = x * y.
  apply SNoS_E2 omega omega_ordinal q Hq1.
  assume Hq1a Hq1b Hq1c Hq1d.
  apply SNoLt_trichotomy_or_impred q (x * y) Hq1c Lxy.
  - assume H1: q < x * y. prove False.
    claim Lq1: q :e SNoL (x * y).
    { apply SNoL_I.
      - exact Lxy.
      - exact Hq1c.
      - prove SNoLev q :e SNoLev (x * y).
        exact Lxy3 q Hq1c Hq1a.
      - prove q < x * y. exact H1.
    }
    apply mul_SNo_SNoL_interpolate_impred x y Hx1 Hy1 q Lq1.
    + let v. assume Hv: v :e SNoL x. let w. assume Hw: w :e SNoL y.
      apply SNoL_E x Hx1 v Hv.
      assume Hv1 _ _.
      apply SNoL_E y Hy1 w Hw.
      assume Hw1 _ _.
      assume H2: q + v * w <= v * y + x * w.
      claim Lvw: SNo (v * w).
      { exact SNo_mul_SNo v w Hv1 Hw1. }
      claim Lxw: SNo (x * w).
      { exact SNo_mul_SNo x w ?? Hw1. }
      claim Lmxw: SNo (- x * w).
      { exact SNo_minus_SNo (x * w) Lxw. }
      claim Lvy: SNo (v * y).
      { exact SNo_mul_SNo v y Hv1 ??. }
      claim Lmvy: SNo (- v * y).
      { exact SNo_minus_SNo (v * y) Lvy. }
      claim Lxmv: SNo (x + - v).
      { exact SNo_add_SNo x (- v) ?? (SNo_minus_SNo v ??). }
      claim Lymw: SNo (y + - w).
      { exact SNo_add_SNo y (- w) ?? (SNo_minus_SNo w ??). }
      apply LLx2 v Hv.
      let k. assume Hk1: k :e omega. assume Hk2: eps_ k <= x + - v.
      apply LLy2 w Hw.
      let k'. assume Hk'1: k' :e omega. assume Hk'2: eps_ k' <= y + - w.
      claim Lek: SNo (eps_ k).
      { exact SNo_eps_ k Hk1. }
      claim Lek': SNo (eps_ k').
      { exact SNo_eps_ k' Hk'1. }
      claim Lkk': k + k' :e omega.
      { exact add_SNo_In_omega k Hk1 k' Hk'1. }
      claim Lekk': SNo (eps_ (k + k')).
      { exact SNo_eps_ (k + k') Lkk'. }
      claim Lekek': SNo (eps_ k * eps_ k').
      { exact SNo_mul_SNo (eps_ k) (eps_ k') Lek Lek'. }
      claim L1a: abs_SNo (q + - (x * y)) < eps_ (k + k').
      { exact Hq2 (k + k') (add_SNo_In_omega k Hk1 k' Hk'1). }
      claim L1b: eps_ (k + k') <= abs_SNo (q + - (x * y)).
      { rewrite abs_SNo_dist_swap q (x * y) Hq1c Lxy.
        prove eps_ (k + k') <= abs_SNo (x * y + - q).
        rewrite pos_abs_SNo (x * y + - q) (SNoLt_minus_pos q (x * y) Hq1c Lxy H1).
        prove eps_ (k + k') <= x * y + - q.
        apply add_SNo_minus_Le2b (x * y) q (eps_ (k + k')) Lxy Hq1c Lekk'.
        prove eps_ (k + k') + q <= x * y.
        rewrite <- mul_SNo_eps_eps_add_SNo k Hk1 k' Hk'1.
        prove eps_ k * eps_ k' + q <= x * y.
        apply SNoLe_tra (eps_ k * eps_ k' + q)
                        ((x + - v) * (y + - w) + q)
                        (x * y)
                        (SNo_add_SNo (eps_ k * eps_ k') q ?? ??)
                        (SNo_add_SNo ((x + - v) * (y + - w)) q
                            (SNo_mul_SNo (x + - v) (y + - w) Lxmv Lymw)
                            Hq1c)
                        Lxy.
        - prove eps_ k * eps_ k' + q <= (x + - v) * (y + - w) + q.
          apply add_SNo_Le1 (eps_ k * eps_ k') q ((x + - v) * (y + - w))
                            Lekek'
                            Hq1c
                            (SNo_mul_SNo (x + - v) (y + - w) Lxmv Lymw).
          prove eps_ k * eps_ k' <= (x + - v) * (y + - w).
          apply nonneg_mul_SNo_Le2 (eps_ k) (eps_ k') (x + - v) (y + - w)
                         Lek Lek' Lxmv Lymw.
          + prove 0 <= eps_ k. apply SNoLtLe. exact SNo_eps_pos k Hk1.
          + prove 0 <= eps_ k'. apply SNoLtLe. exact SNo_eps_pos k' Hk'1.
          + prove eps_ k <= x + - v. exact Hk2.
          + prove eps_ k' <= y + - w. exact Hk'2.
        - prove (x + - v) * (y + - w) + q <= x * y.
          rewrite SNo_foil_mm x v y w Hx1 Hv1 Hy1 Hw1.
          prove (x * y + - x * w + - v * y + v * w) + q <= x * y.
          rewrite add_SNo_assoc_4 (x * y) (- x * w) (- v * y) (v * w)
                         ?? ?? ?? ??.
          prove ((x * y + - x * w + - v * y) + v * w) + q <= x * y.
          rewrite <- add_SNo_assoc
                       (x * y + - x * w + - v * y) (v * w) q
                       (SNo_add_SNo_3 (x * y) (- x * w) (- v * y) ?? ?? ??)
                       ??
                       Hq1c.                           
          prove (x * y + - x * w + - v * y) + (v * w + q) <= x * y.
          rewrite add_SNo_com (v * w) q ?? Hq1c.
          prove (x * y + - x * w + - v * y) + (q + v * w) <= x * y.
          apply SNoLe_tra ((x * y + - x * w + - v * y) + (q + v * w))
                          ((x * y + - x * w + - v * y) + (v * y + x * w))
                          (x * y)
                          (SNo_add_SNo
                           (x * y + - x * w + - v * y)
                           (q + v * w)
                           (SNo_add_SNo_3 (x * y) (- x * w) (- v * y) ?? ?? ??)
                           (SNo_add_SNo q (v * w) Hq1c ??))
                          (SNo_add_SNo
                           (x * y + - x * w + - v * y)
                           (v * y + x * w)
                           (SNo_add_SNo_3 (x * y) (- x * w) (- v * y) ?? ?? ??)
                           (SNo_add_SNo (v * y) (x * w) ?? ??))
                          (SNo_mul_SNo x y Hx1 Hy1).
          + prove (x * y + - x * w + - v * y) + (q + v * w)
               <= (x * y + - x * w + - v * y) + (v * y + x * w).
            exact add_SNo_Le2 (x * y + - x * w + - v * y)
                              (q + v * w)
                              (v * y + x * w)
                              (SNo_add_SNo_3 (x * y) (- x * w) (- v * y) ?? ?? ??)
                              (SNo_add_SNo q (v * w) Hq1c ??)
                              (SNo_add_SNo (v * y) (x * w) ?? ??)
                              H2.
          + prove (x * y + - x * w + - v * y) + (v * y + x * w)
               <= x * y.
            rewrite add_SNo_minus_SNo_prop5 (x * y) (- x * w) (v * y) (x * w) ?? ?? ?? ??.
            prove x * y + - x * w + x * w <= x * y.
            rewrite add_SNo_minus_SNo_linv (x * w) ??.
            prove x * y + 0 <= x * y.
            rewrite add_SNo_0R (x * y) ??.
            prove x * y <= x * y. apply SNoLe_ref.
      }
      apply SNoLt_irref (eps_ (k + k')).
      prove eps_ (k + k') < eps_ (k + k').
      exact SNoLeLt_tra (eps_ (k + k')) (abs_SNo (q + - (x * y))) (eps_ (k + k'))
                        Lekk'
                        (SNo_abs_SNo (q + - (x * y)) (SNo_add_SNo q (- (x * y)) Hq1c ??))
                        Lekk'
                        L1b L1a.
    + let v. assume Hv: v :e SNoR x. let w. assume Hw: w :e SNoR y.
      apply SNoR_E x Hx1 v Hv.
      assume Hv1 _ _.
      apply SNoR_E y Hy1 w Hw.
      assume Hw1 _ _.
      assume H2: q + v * w <= v * y + x * w.
      claim Lvw: SNo (v * w).
      { exact SNo_mul_SNo v w Hv1 Hw1. }
      claim Lxw: SNo (x * w).
      { exact SNo_mul_SNo x w ?? Hw1. }
      claim Lmxw: SNo (- x * w).
      { exact SNo_minus_SNo (x * w) Lxw. }
      claim Lvy: SNo (v * y).
      { exact SNo_mul_SNo v y Hv1 ??. }
      claim Lmvy: SNo (- v * y).
      { exact SNo_minus_SNo (v * y) Lvy. }
      claim Lvmx: SNo (v + - x).
      { exact SNo_add_SNo v (- x) ?? (SNo_minus_SNo x ??). }
      claim Lwmy: SNo (w + - y).
      { exact SNo_add_SNo w (- y) ?? (SNo_minus_SNo y ??). }
      apply LRx2 v Hv.
      let k. assume Hk1: k :e omega. assume Hk2: eps_ k <= v + - x.
      apply LRy2 w Hw.
      let k'. assume Hk'1: k' :e omega. assume Hk'2: eps_ k' <= w + - y.
      claim Lek: SNo (eps_ k).
      { exact SNo_eps_ k Hk1. }
      claim Lek': SNo (eps_ k').
      { exact SNo_eps_ k' Hk'1. }
      claim Lkk': k + k' :e omega.
      { exact add_SNo_In_omega k Hk1 k' Hk'1. }
      claim Lekk': SNo (eps_ (k + k')).
      { exact SNo_eps_ (k + k') Lkk'. }
      claim Lekek': SNo (eps_ k * eps_ k').
      { exact SNo_mul_SNo (eps_ k) (eps_ k') Lek Lek'. }
      claim L1c: abs_SNo (q + - (x * y)) < eps_ (k + k').
      { exact Hq2 (k + k') (add_SNo_In_omega k Hk1 k' Hk'1). }
      claim L1d: eps_ (k + k') <= abs_SNo (q + - (x * y)).
      { rewrite abs_SNo_dist_swap q (x * y) Hq1c Lxy.
        prove eps_ (k + k') <= abs_SNo (x * y + - q).
        rewrite pos_abs_SNo (x * y + - q) (SNoLt_minus_pos q (x * y) Hq1c Lxy H1).
        prove eps_ (k + k') <= x * y + - q.
        apply add_SNo_minus_Le2b (x * y) q (eps_ (k + k')) Lxy Hq1c Lekk'.
        prove eps_ (k + k') + q <= x * y.
        rewrite <- mul_SNo_eps_eps_add_SNo k Hk1 k' Hk'1.
        prove eps_ k * eps_ k' + q <= x * y.
        apply SNoLe_tra (eps_ k * eps_ k' + q)
                        ((v + - x) * (w + - y) + q)
                        (x * y)
                        (SNo_add_SNo (eps_ k * eps_ k') q ?? Hq1c)
                        (SNo_add_SNo ((v + - x) * (w + - y)) q
                            (SNo_mul_SNo (v + - x) (w + - y) ?? ??)
                            Hq1c)
                        Lxy.
        - prove eps_ k * eps_ k' + q <= (v + - x) * (w + - y) + q.
          apply add_SNo_Le1 (eps_ k * eps_ k') q ((v + - x) * (w + - y)) Lekek'
                            Hq1c
                            (SNo_mul_SNo (v + - x) (w + - y) ?? ??).
          prove eps_ k * eps_ k' <= (v + - x) * (w + - y).
          apply nonneg_mul_SNo_Le2 (eps_ k) (eps_ k') (v + - x) (w + - y) Lek Lek' ?? ??.
          + prove 0 <= eps_ k. apply SNoLtLe. exact SNo_eps_pos k Hk1.
          + prove 0 <= eps_ k'. apply SNoLtLe. exact SNo_eps_pos k' Hk'1.
          + prove eps_ k <= v + - x. exact Hk2.
          + prove eps_ k' <= w + - y. exact Hk'2.
        - prove (v + - x) * (w + - y) + q <= x * y.
          rewrite SNo_foil_mm v x w y Hv1 Hx1 Hw1 Hy1.
          prove (v * w + - v * y + - x * w + x * y) + q <= x * y.
          rewrite add_SNo_assoc_4 (v * w) (- v * y) (- x * w) (x * y) ?? ?? ?? ??.
          prove ((v * w + - v * y + - x * w) + x * y) + q <= x * y.
          rewrite <- add_SNo_assoc
                       (v * w + - v * y + - x * w) (x * y) q
                       (SNo_add_SNo_3 (v * w) (- v * y) (- x * w) ?? ?? ??)
                       ??
                       Hq1c.                           
          prove (v * w + - v * y + - x * w) + (x * y + q) <= x * y.
          rewrite add_SNo_com (x * y) q ?? Hq1c.
          prove (v * w + - v * y + - x * w) + (q + x * y) <= x * y.
          rewrite add_SNo_3a_2b (v * w) (- v * y) (- x * w) q (x * y) ?? ?? ?? ?? ??.
          prove (x * y + - v * y + - x * w) + (q + v * w) <= x * y.
          apply SNoLe_tra ((x * y + - v * y + - x * w) + (q + v * w))
                          ((x * y + - v * y + - x * w) + (v * y + x * w))
                          (x * y)
                          (SNo_add_SNo (x * y + - v * y + - x * w) (q + v * w)
                            (SNo_add_SNo_3 (x * y) (- v * y) (- x * w) ?? ?? ??)
                            (SNo_add_SNo q (v * w) ?? ??))
                          (SNo_add_SNo (x * y + - v * y + - x * w) (v * y + x * w)
                            (SNo_add_SNo_3 (x * y) (- v * y) (- x * w) ?? ?? ??)
                            (SNo_add_SNo (v * y) (x * w) ?? ??))
                          ??.
          + prove (x * y + - v * y + - x * w) + (q + v * w)
               <= (x * y + - v * y + - x * w) + (v * y + x * w).
            apply add_SNo_Le2 (x * y + - v * y + - x * w) (q + v * w) (v * y + x * w)
                              (SNo_add_SNo_3 (x * y) (- v * y) (- x * w) ?? ?? ??)
                              (SNo_add_SNo q (v * w) ?? ??)
                              (SNo_add_SNo (v * y) (x * w) ?? ??).
            prove q + v * w <= v * y + x * w. exact H2.
          + prove (x * y + - v * y + - x * w) + (v * y + x * w)
               <= x * y.
            rewrite add_SNo_com (v * y) (x * w) ?? ??.
            prove (x * y + - v * y + - x * w) + (x * w + v * y)
               <= x * y.
            rewrite add_SNo_minus_SNo_prop5 (x * y) (- v * y) (x * w) (v * y) ?? ?? ?? ??.
            prove x * y + - v * y + v * y <= x * y.
            rewrite add_SNo_minus_SNo_linv (v * y) ??.
            prove x * y + 0 <= x * y.
            rewrite add_SNo_0R (x * y) ??.
            apply SNoLe_ref.
      }
      apply SNoLt_irref (eps_ (k + k')).
      prove eps_ (k + k') < eps_ (k + k').
      exact SNoLeLt_tra (eps_ (k + k')) (abs_SNo (q + - (x * y))) (eps_ (k + k'))
                        Lekk'
                        (SNo_abs_SNo (q + - (x * y)) (SNo_add_SNo q (- (x * y)) Hq1c (SNo_minus_SNo (x * y) Lxy)))
                        Lekk'
                        L1d L1c.
  - assume H1: q = x * y. exact H1.
  - assume H1: x * y < q. prove False.
    claim Lq2: q :e SNoR (x * y).
    { apply SNoR_I.
      - exact Lxy.
      - exact Hq1c.
      - prove SNoLev q :e SNoLev (x * y).
        exact Lxy3 q Hq1c Hq1a.
      - prove x * y < q. exact H1.
    }
    apply mul_SNo_SNoR_interpolate_impred x y Hx1 Hy1 q Lq2.
    + let v. assume Hv: v :e SNoL x. let w. assume Hw: w :e SNoR y.
      apply SNoL_E x Hx1 v Hv.
      assume Hv1 _ _.
      apply SNoR_E y Hy1 w Hw.
      assume Hw1 _ _.
      assume H2: v * y + x * w <= q + v * w.
      claim Lvy: SNo (v * y).
      { exact SNo_mul_SNo v y Hv1 Hy1. }
      claim Lxw: SNo (x * w).
      { exact SNo_mul_SNo x w ?? Hw1. }
      claim Lmxw: SNo (- x * w).
      { exact SNo_minus_SNo (x * w) Lxw. }
      claim Lvw: SNo (v * w).
      { exact SNo_mul_SNo v w Hv1 ??. }
      claim Lmvw: SNo (- v * w).
      { exact SNo_minus_SNo (v * w) Lvw. }
      claim Lxmv: SNo (x + - v).
      { exact SNo_add_SNo x (- v) ?? (SNo_minus_SNo v ??). }
      claim Lwmy: SNo (w + - y).
      { exact SNo_add_SNo w (- y) ?? (SNo_minus_SNo y ??). }
      apply LLx2 v Hv.
      let k. assume Hk1: k :e omega. assume Hk2: eps_ k <= x + - v.
      apply LRy2 w Hw.
      let k'. assume Hk'1: k' :e omega. assume Hk'2: eps_ k' <= w + - y.
      claim Lek: SNo (eps_ k).
      { exact SNo_eps_ k Hk1. }
      claim Lek': SNo (eps_ k').
      { exact SNo_eps_ k' Hk'1. }
      claim Lkk': k + k' :e omega.
      { exact add_SNo_In_omega k Hk1 k' Hk'1. }
      claim Lekk': SNo (eps_ (k + k')).
      { exact SNo_eps_ (k + k') Lkk'. }
      claim Lekek': SNo (eps_ k * eps_ k').
      { exact SNo_mul_SNo (eps_ k) (eps_ k') Lek Lek'. }
      claim L1e: abs_SNo (q + - (x * y)) < eps_ (k + k').
      { exact Hq2 (k + k') (add_SNo_In_omega k Hk1 k' Hk'1). }
      claim L1f: eps_ (k + k') <= abs_SNo (q + - (x * y)).
      { rewrite pos_abs_SNo (q + - x * y) (SNoLt_minus_pos (x * y) q Lxy Hq1c H1).
        prove eps_ (k + k') <= q + - x * y.
        apply add_SNo_minus_Le2b q (x * y) (eps_ (k + k')) Hq1c Lxy Lekk'.
        prove eps_ (k + k') + x * y <= q.
        rewrite <- mul_SNo_eps_eps_add_SNo k Hk1 k' Hk'1.
        prove eps_ k * eps_ k' + x * y <= q.
        apply SNoLe_tra (eps_ k * eps_ k' + x * y)
                        ((x + - v) * (w + - y) + x * y)
                        q
                        (SNo_add_SNo (eps_ k * eps_ k') (x * y) ?? ??)
                        (SNo_add_SNo ((x + - v) * (w + - y)) (x * y)
                            (SNo_mul_SNo (x + - v) (w + - y) Lxmv Lwmy)
                            Lxy)
                        Hq1c.
        - prove eps_ k * eps_ k' + x * y <= (x + - v) * (w + - y) + x * y.
          apply add_SNo_Le1 (eps_ k * eps_ k') (x * y) ((x + - v) * (w + - y))
                            Lekek'
                            Lxy
                            (SNo_mul_SNo (x + - v) (w + - y) Lxmv Lwmy).
          prove eps_ k * eps_ k' <= (x + - v) * (w + - y).
          apply nonneg_mul_SNo_Le2 (eps_ k) (eps_ k') (x + - v) (w + - y)
                         Lek Lek' Lxmv Lwmy.
          + prove 0 <= eps_ k. apply SNoLtLe. exact SNo_eps_pos k Hk1.
          + prove 0 <= eps_ k'. apply SNoLtLe. exact SNo_eps_pos k' Hk'1.
          + prove eps_ k <= x + - v. exact Hk2.
          + prove eps_ k' <= w + - y. exact Hk'2.
        - prove (x + - v) * (w + - y) + x * y <= q.
          rewrite SNo_foil_mm x v w y Hx1 Hv1 Hw1 Hy1.
          prove (x * w + - x * y + - v * w + v * y) + x * y <= q.
          rewrite <- add_SNo_rotate_4_1 (- x * y) (- v * w) (v * y) (x * w) ?? ?? ?? ??.
          prove (- x * y + - v * w + v * y + x * w) + x * y <= q.
          rewrite add_SNo_com (- x * y + - v * w + v * y + x * w) (x * y)
                              (SNo_add_SNo_4 (- x * y) (- v * w) (v * y) (x * w) ?? ?? ?? ??)
                              ??.
          rewrite add_SNo_minus_L2' (x * y) (- v * w + v * y + x * w)
                                    ??
                                    (SNo_add_SNo_3 (- v * w) (v * y) (x * w) ?? ?? ??).
          prove - v * w + v * y + x * w <= q.
          apply SNoLe_tra (- v * w + v * y + x * w)
                          (- v * w + q + v * w)
                          q
                          (SNo_add_SNo_3 (- v * w) (v * y) (x * w) ?? ?? ??)
                          (SNo_add_SNo_3 (- v * w) q (v * w) ?? ?? ??)
                          Hq1c.
          + prove - v * w + v * y + x * w
               <= - v * w + q + v * w.
            exact add_SNo_Le2 (- v * w)
                              (v * y + x * w)
                              (q + v * w)
                              ??
                              (SNo_add_SNo (v * y) (x * w) ?? ??)
                              (SNo_add_SNo q (v * w) Hq1c ??)
                              H2.
          + prove - v * w + q + v * w <= q.
            rewrite add_SNo_com q (v * w) ?? ??.
            rewrite add_SNo_minus_L2 (v * w) q ?? ??.
            prove q <= q. apply SNoLe_ref.
      }
      apply SNoLt_irref (eps_ (k + k')).
      prove eps_ (k + k') < eps_ (k + k').
      exact SNoLeLt_tra (eps_ (k + k')) (abs_SNo (q + - (x * y))) (eps_ (k + k'))
                        Lekk'
                        (SNo_abs_SNo (q + - (x * y)) (SNo_add_SNo q (- (x * y)) Hq1c ??))
                        Lekk'
                        L1f L1e.
    + let v. assume Hv: v :e SNoR x. let w. assume Hw: w :e SNoL y.
      apply SNoR_E x Hx1 v Hv.
      assume Hv1 _ _.
      apply SNoL_E y Hy1 w Hw.
      assume Hw1 _ _.
      assume H2: v * y + x * w <= q + v * w.
      claim Lvy: SNo (v * y).
      { exact SNo_mul_SNo v y Hv1 Hy1. }
      claim Lxw: SNo (x * w).
      { exact SNo_mul_SNo x w ?? Hw1. }
      claim Lvw: SNo (v * w).
      { exact SNo_mul_SNo v w Hv1 ??. }
      claim Lmvw: SNo (- v * w).
      { exact SNo_minus_SNo (v * w) Lvw. }
      claim Lvmx: SNo (v + - x).
      { exact SNo_add_SNo v (- x) ?? (SNo_minus_SNo x ??). }
      claim Lymw: SNo (y + - w).
      { exact SNo_add_SNo y (- w) ?? (SNo_minus_SNo w ??). }
      apply LRx2 v Hv.
      let k. assume Hk1: k :e omega. assume Hk2: eps_ k <= v + - x.
      apply LLy2 w Hw.
      let k'. assume Hk'1: k' :e omega. assume Hk'2: eps_ k' <= y + - w.
      claim Lek: SNo (eps_ k).
      { exact SNo_eps_ k Hk1. }
      claim Lek': SNo (eps_ k').
      { exact SNo_eps_ k' Hk'1. }
      claim Lkk': k + k' :e omega.
      { exact add_SNo_In_omega k Hk1 k' Hk'1. }
      claim Lekk': SNo (eps_ (k + k')).
      { exact SNo_eps_ (k + k') Lkk'. }
      claim Lekek': SNo (eps_ k * eps_ k').
      { exact SNo_mul_SNo (eps_ k) (eps_ k') Lek Lek'. }
      claim L1g: abs_SNo (q + - (x * y)) < eps_ (k + k').
      { exact Hq2 (k + k') (add_SNo_In_omega k Hk1 k' Hk'1). }
      claim L1h: eps_ (k + k') <= abs_SNo (q + - (x * y)).
      { rewrite pos_abs_SNo (q + - x * y) (SNoLt_minus_pos (x * y) q Lxy Hq1c H1).
        prove eps_ (k + k') <= q + - x * y.
        apply add_SNo_minus_Le2b q (x * y) (eps_ (k + k')) Hq1c Lxy Lekk'.
        prove eps_ (k + k') + x * y <= q.
        rewrite <- mul_SNo_eps_eps_add_SNo k Hk1 k' Hk'1.
        prove eps_ k * eps_ k' + x * y <= q.
        apply SNoLe_tra (eps_ k * eps_ k' + x * y)
                        ((v + - x) * (y + - w) + x * y)
                        q
                        (SNo_add_SNo (eps_ k * eps_ k') (x * y) ?? Lxy)
                        (SNo_add_SNo ((v + - x) * (y + - w)) (x * y)
                            (SNo_mul_SNo (v + - x) (y + - w) ?? ??)
                            Lxy)
                        Hq1c.
        - prove eps_ k * eps_ k' + x * y <= (v + - x) * (y + - w) + x * y.
          apply add_SNo_Le1 (eps_ k * eps_ k') (x * y) ((v + - x) * (y + - w)) Lekek'
                            Lxy
                            (SNo_mul_SNo (v + - x) (y + - w) ?? ??).
          prove eps_ k * eps_ k' <= (v + - x) * (y + - w).
          apply nonneg_mul_SNo_Le2 (eps_ k) (eps_ k') (v + - x) (y + - w) Lek Lek' ?? ??.
          + prove 0 <= eps_ k. apply SNoLtLe. exact SNo_eps_pos k Hk1.
          + prove 0 <= eps_ k'. apply SNoLtLe. exact SNo_eps_pos k' Hk'1.
          + prove eps_ k <= v + - x. exact Hk2.
          + prove eps_ k' <= y + - w. exact Hk'2.
        - prove (v + - x) * (y + - w) + x * y <= q.
          rewrite SNo_foil_mm v x y w Hv1 Hx1 Hy1 Hw1.
          prove (v * y + - v * w + - x * y + x * w) + x * y <= q.
          rewrite add_SNo_rotate_4_1 (v * y) (- v * w) (- x * y) (x * w) ?? ?? ?? ??.
          rewrite add_SNo_rotate_4_1 (x * w) (v * y) (- v * w) (- x * y) ?? ?? ?? ??.
          prove (- x * y + x * w + v * y + - v * w) + x * y <= q.
          rewrite add_SNo_com (- x * y + x * w + v * y + - v * w) (x * y)
                              (SNo_add_SNo_4 (- x * y) (x * w) (v * y) (- v * w) ?? ?? ?? ??)
                              ??.
          prove x * y + - x * y + x * w + v * y + - v * w <= q.
          rewrite add_SNo_minus_L2' (x * y) (x * w + v * y + - v * w) ?? (SNo_add_SNo_3 (x * w) (v * y) (- v * w) ?? ?? ??).
          prove x * w + v * y + - v * w <= q.
          rewrite add_SNo_rotate_3_1 (x * w) (v * y) (- v * w) ?? ?? ??.
          prove - v * w + x * w + v * y <= q.
          apply SNoLe_tra (- v * w + x * w + v * y)
                          (- v * w + q + v * w)
                          q
                          (SNo_add_SNo_3 (- v * w) (x * w) (v * y) ?? ?? ??)
                          (SNo_add_SNo_3 (- v * w) q (v * w) ?? ?? ??)
                          ??.
          + prove - v * w + x * w + v * y
               <= - v * w + q + v * w.
            apply add_SNo_Le2 (- v * w) (x * w + v * y) (q + v * w)
                              ??
                              (SNo_add_SNo (x * w) (v * y) ?? ??)
                              (SNo_add_SNo q (v * w) ?? ??).
            prove x * w + v * y <= q + v * w.
            rewrite add_SNo_com (x * w) (v * y) ?? ??. exact H2.
          + prove - v * w + q + v * w <= q.
            rewrite add_SNo_com q (v * w) ?? ??.
            prove - v * w + v * w + q <= q.
            rewrite add_SNo_minus_L2 (v * w) q ?? ??.
            prove q <= q.
            apply SNoLe_ref.
      }
      apply SNoLt_irref (eps_ (k + k')).
      prove eps_ (k + k') < eps_ (k + k').
      exact SNoLeLt_tra (eps_ (k + k')) (abs_SNo (q + - (x * y))) (eps_ (k + k'))
                        Lekk'
                        (SNo_abs_SNo (q + - (x * y)) (SNo_add_SNo q (- (x * y)) Hq1c (SNo_minus_SNo (x * y) Lxy)))
                        Lekk'
                        L1h L1g.
}
claim LNex: exists N :e omega, eps_ N * x < 1 /\ eps_ N * y < 1.
{ apply SNoS_ordsucc_omega_bdd_eps_pos x Hx3 Hx0 Hx5.
  let N. assume HN. apply HN.
  assume HN1: N :e omega.
  assume HN2: eps_ N * x < 1.
  apply SNoS_ordsucc_omega_bdd_eps_pos y Hy3 Hy0 Hy5.
  let N'. assume HN'. apply HN'.
  assume HN'1: N' :e omega.
  assume HN'2: eps_ N' * y < 1.
  apply ordinal_trichotomy_or_impred N N'
               (nat_p_ordinal N (omega_nat_p N HN1))
               (nat_p_ordinal N' (omega_nat_p N' HN'1)).
  - assume H1: N :e N'.
    witness N'. apply andI.
    + exact HN'1.
    + apply andI.
      * { prove eps_ N' * x < 1.
          apply SNoLt_tra (eps_ N' * x) (eps_ N * x) 1
                          (SNo_mul_SNo (eps_ N') x (SNo_eps_ N' HN'1) Hx1)
                          (SNo_mul_SNo (eps_ N) x (SNo_eps_ N HN1) Hx1)
                          SNo_1.
          - prove eps_ N' * x < eps_ N * x.
            apply pos_mul_SNo_Lt' (eps_ N') (eps_ N) x (SNo_eps_ N' HN'1) (SNo_eps_ N HN1) Hx1 Hx0.
            prove eps_ N' < eps_ N.
            exact SNo_eps_decr N' HN'1 N H1.
          - exact HN2.
        }
      * exact HN'2.
  - assume H1: N = N'.
    witness N. apply andI.
    + exact HN1.
    + apply andI.
      * exact HN2.
      * rewrite H1. exact HN'2.
  - assume H1: N' :e N.
    witness N. apply andI.
    + exact HN1.
    + apply andI.
      * exact HN2.
      * { prove eps_ N * y < 1.
          apply SNoLt_tra (eps_ N * y) (eps_ N' * y) 1
                          (SNo_mul_SNo (eps_ N) y (SNo_eps_ N HN1) Hy1)
                          (SNo_mul_SNo (eps_ N') y (SNo_eps_ N' HN'1) Hy1)
                          SNo_1.
          - prove eps_ N * y < eps_ N' * y.
            apply pos_mul_SNo_Lt' (eps_ N) (eps_ N') y (SNo_eps_ N HN1) (SNo_eps_ N' HN'1) Hy1 Hy0.
            prove eps_ N < eps_ N'.
            exact SNo_eps_decr N HN1 N' H1.
          - exact HN'2.
        }
}
apply LNex.
let N. assume HN. apply HN.
assume HN1: N :e omega. assume HN. apply HN.
assume HN2: eps_ N * x < 1.
assume HN3: eps_ N * y < 1.
claim L2: forall k :e omega, exists q :e SNoS_ omega, q < x * y /\ x * y < q + eps_ k.
{ let k. assume Hk.
  claim Lek: SNo (eps_ k).
  { exact SNo_eps_ k Hk. }
  claim Lk1: k + 1 :e omega.
  { exact add_SNo_In_omega k Hk 1 (nat_p_omega 1 nat_1). }
  claim Lk2: k + 2 :e omega.
  { exact add_SNo_In_omega k Hk 2 (nat_p_omega 2 nat_2). }
  set k' := N + k + 2.
  claim Lk': k' :e omega.
  { exact add_SNo_In_omega N HN1 (k+2) Lk2. }
  claim Lek': SNo (eps_ k').
  { exact SNo_eps_ k' Lk'. }
  apply Lx7 k' Lk'.
  let q.
  assume Hq1: q :e SNoS_ omega.
  assume Hqpos: 0 < q.
  assume Hq2: q < x.
  assume Hq3: x < q + eps_ k'.
  apply SNoS_E2 omega omega_ordinal q Hq1.
  assume Hq1a Hq1b Hq1c Hq1d.
  apply Ly7 k' Lk'.
  let q'.
  assume Hq'1: q' :e SNoS_ omega.
  assume Hq'pos: 0 < q'.
  assume Hq'2: q' < y.
  assume Hq'3: y < q' + eps_ k'.
  apply SNoS_E2 omega omega_ordinal q' Hq'1.
  assume Hq'1a Hq'1b Hq'1c Hq'1d.
  claim Lqq': SNo (q * q').
  { exact SNo_mul_SNo q q' Hq1c Hq'1c. }
  witness (q * q'). apply andI.
  + prove q * q' :e SNoS_ omega.
    exact mul_SNo_SNoS_omega q Hq1 q' Hq'1.
  + apply andI.
    * prove q * q' < x * y.
      exact pos_mul_SNo_Lt2 q q' x y Hq1c Hq'1c Hx1 Hy1 Hqpos Hq'pos Hq2 Hq'2.
    * { prove x * y < q * q' + eps_ k.
        apply SNoLt_tra (x * y) ((q + eps_ k') * (q' + eps_ k')) (q * q' + eps_ k)
                        Lxy
                        (SNo_mul_SNo
                          (q + eps_ k')
                          (q' + eps_ k')
                          (SNo_add_SNo q (eps_ k') Hq1c Lek')
                          (SNo_add_SNo q' (eps_ k') Hq'1c Lek'))
                        (SNo_add_SNo (q * q') (eps_ k) (SNo_mul_SNo q q' Hq1c Hq'1c) Lek).
        - prove x * y < (q + eps_ k') * (q' + eps_ k').
          exact pos_mul_SNo_Lt2 x y (q + eps_ k') (q' + eps_ k')
                                Hx1 Hy1
                                (SNo_add_SNo q (eps_ k') Hq1c Lek')
                                (SNo_add_SNo q' (eps_ k') Hq'1c Lek')
                                Hx0 Hy0 Hq3 Hq'3.
        - prove (q + eps_ k') * (q' + eps_ k') < q * q' + eps_ k.
          rewrite SNo_foil q (eps_ k') q' (eps_ k') Hq1c Lek' Hq'1c Lek'.
          prove q * q' + q * eps_ k' + eps_ k' * q' + eps_ k' * eps_ k' < q * q' + eps_ k.
          apply add_SNo_Lt2 (q * q') (q * eps_ k' + eps_ k' * q' + eps_ k' * eps_ k') (eps_ k)
                            Lqq'
                            (SNo_add_SNo_3 (q * eps_ k') (eps_ k' * q') (eps_ k' * eps_ k')
                                           (SNo_mul_SNo q (eps_ k') Hq1c Lek')
                                           (SNo_mul_SNo (eps_ k') q' Lek' Hq'1c)
                                           (SNo_mul_SNo (eps_ k') (eps_ k') Lek' Lek'))
                            Lek.
          prove q * eps_ k' + eps_ k' * q' + eps_ k' * eps_ k' < eps_ k.
          prove q * eps_ (N + k + 2) + eps_ (N + k + 2) * q' + eps_ (N + k + 2) * eps_ (N + k + 2) < eps_ k.
          rewrite <- mul_SNo_eps_eps_add_SNo N HN1 (k + 2) Lk2.
          prove q * eps_ N * eps_ (k + 2) + (eps_ N * eps_ (k + 2)) * q' + (eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2)) < eps_ k.
          rewrite <- eps_ordsucc_half_add k (omega_nat_p k Hk).
          prove q * eps_ N * eps_ (k + 2) + (eps_ N * eps_ (k + 2)) * q' + (eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2)) < eps_ (ordsucc k) + eps_ (ordsucc k).
          rewrite <- eps_ordsucc_half_add (ordsucc k) (nat_ordsucc k (omega_nat_p k Hk)) at 1.
          prove q * eps_ N * eps_ (k + 2) + (eps_ N * eps_ (k + 2)) * q' + (eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2)) < (eps_ (ordsucc (ordsucc k)) + eps_ (ordsucc (ordsucc k))) + eps_ (ordsucc k).
          rewrite <- add_SNo_1_ordsucc k Hk.
          prove q * eps_ N * eps_ (k + 2) + (eps_ N * eps_ (k + 2)) * q' + (eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2)) < (eps_ (ordsucc (k + 1)) + eps_ (ordsucc (k + 1))) + eps_ (k + 1).
          rewrite <- add_SNo_1_ordsucc (k+1) (add_SNo_In_omega k Hk 1 (nat_p_omega 1 nat_1)).
          prove q * eps_ N * eps_ (k + 2) + (eps_ N * eps_ (k + 2)) * q' + (eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2)) < (eps_ (((k + 1) + 1)) + eps_ (((k + 1) + 1))) + eps_ (k + 1).
          rewrite <- add_SNo_assoc k 1 1 (omega_SNo k Hk) SNo_1 SNo_1.
          rewrite add_SNo_1_1_2.
          prove q * eps_ N * eps_ (k + 2) + (eps_ N * eps_ (k + 2)) * q' + (eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2)) < (eps_ (k + 2) + eps_ (k + 2)) + eps_ (k + 1).
          claim LeN: SNo (eps_ N).
          { exact SNo_eps_ N HN1. }
          claim Lek1: SNo (eps_ (k + 1)).
          { exact SNo_eps_ (k+1) Lk1. }
          claim Lek2: SNo (eps_ (k + 2)).
          { exact SNo_eps_ (k+2) Lk2. }
          claim LeNek2: SNo (eps_ N * eps_ (k + 2)).
          { exact SNo_mul_SNo (eps_ N) (eps_ (k + 2)) LeN Lek2. }
          claim LeNek2sq: SNo ((eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2))).
          { exact SNo_mul_SNo (eps_ N * eps_ (k + 2)) (eps_ N * eps_ (k + 2)) LeNek2 LeNek2. }
          rewrite <- add_SNo_assoc (eps_ (k + 2)) (eps_ (k + 2)) (eps_ (k + 1))
                                   Lek2 Lek2 Lek1.
          apply add_SNo_Lt4 (q * eps_ N * eps_ (k + 2))
                            ((eps_ N * eps_ (k + 2)) * q')
                            ((eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2)))
                            (eps_ (k + 2))
                            (eps_ (k + 2))
                            (eps_ (k + 1))
                            (SNo_mul_SNo q (eps_ N * eps_ (k + 2)) Hq1c LeNek2)
                            (SNo_mul_SNo (eps_ N * eps_ (k + 2)) q' LeNek2 Hq'1c)
                            LeNek2sq Lek2 Lek2 Lek1.
          + prove q * eps_ N * eps_ (k + 2) < eps_ (k+2).
            rewrite mul_SNo_assoc q (eps_ N) (eps_ (k+2)) Hq1c LeN Lek2.
            prove (q * eps_ N) * eps_ (k + 2) < eps_ (k+2).
            apply mul_SNo_Lt1_pos_Lt (q * eps_ N) (eps_ (k + 2)) (SNo_mul_SNo q (eps_ N) Hq1c LeN) Lek2.
            * { prove q * eps_ N < 1.
                apply SNoLt_tra (q * eps_ N) (x * eps_ N) 1
                         (SNo_mul_SNo q (eps_ N) Hq1c LeN)
                         (SNo_mul_SNo x (eps_ N) Hx1 LeN)
                         SNo_1.
                - prove q * eps_ N < x * eps_ N.
                  apply pos_mul_SNo_Lt' q x (eps_ N) Hq1c Hx1 (SNo_eps_ N HN1).
                  + prove 0 < eps_ N. exact SNo_eps_pos N HN1.
                  + prove q < x. exact Hq2.
                - prove x * eps_ N < 1.
                  rewrite mul_SNo_com x (eps_ N) Hx1 LeN.
                  exact HN2.
              }
            * prove 0 < eps_ (k+2).
              exact SNo_eps_pos (k+2) Lk2.
          + prove (eps_ N * eps_ (k + 2)) * q' < eps_ (k+2).
            rewrite mul_SNo_com (eps_ N * eps_ (k+2)) q' (SNo_mul_SNo (eps_ N) (eps_ (k+2)) LeN Lek2) Hq'1c.
            prove q' * (eps_ N * eps_ (k + 2)) < eps_ (k+2).
            rewrite mul_SNo_assoc q' (eps_ N) (eps_ (k+2)) Hq'1c LeN Lek2.
            prove (q' * eps_ N) * eps_ (k + 2) < eps_ (k+2).
            apply mul_SNo_Lt1_pos_Lt (q' * eps_ N) (eps_ (k + 2)) (SNo_mul_SNo q' (eps_ N) Hq'1c LeN) Lek2.
            * { prove q' * eps_ N < 1.
                apply SNoLt_tra (q' * eps_ N) (y * eps_ N) 1
                         (SNo_mul_SNo q' (eps_ N) Hq'1c LeN)
                         (SNo_mul_SNo y (eps_ N) Hy1 LeN)
                         SNo_1.
                - prove q' * eps_ N < y * eps_ N.
                  apply pos_mul_SNo_Lt' q' y (eps_ N) Hq'1c Hy1 (SNo_eps_ N HN1).
                  + prove 0 < eps_ N. exact SNo_eps_pos N HN1.
                  + prove q' < y. exact Hq'2.
                - prove y * eps_ N < 1.
                  rewrite mul_SNo_com y (eps_ N) Hy1 LeN.
                  exact HN3.
              }
            * prove 0 < eps_ (k+2).
              exact SNo_eps_pos (k+2) Lk2.
          + prove (eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2)) < eps_ (k+1).
            apply SNoLeLt_tra ((eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2))) (eps_ (k+2)) (eps_ (k+1))
                            LeNek2sq Lek2 Lek1.
            * { prove (eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2)) <= eps_ (k+2).
                apply SNoLe_tra ((eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2))) (eps_ N * eps_ (k + 2)) (eps_ (k+2))
                                LeNek2sq LeNek2 Lek2.
                - prove (eps_ N * eps_ (k + 2)) * (eps_ N * eps_ (k + 2)) <= eps_ N * eps_ (k + 2).
                  apply mul_SNo_Le1_nonneg_Le (eps_ N * eps_ (k + 2)) (eps_ N * eps_ (k+2)) LeNek2 LeNek2.
                  + prove eps_ N * eps_ (k+2) <= 1.
                    rewrite <- mul_SNo_oneL 1 SNo_1 at 2.
                    prove eps_ N * eps_ (k+2) <= 1 * 1.
                    apply nonneg_mul_SNo_Le2 (eps_ N) (eps_ (k+2)) 1 1 LeN Lek2 SNo_1 SNo_1.
                    * prove 0 <= eps_ N. apply SNoLtLe. exact SNo_eps_pos N HN1.
                    * prove 0 <= eps_ (k+2). apply SNoLtLe. exact SNo_eps_pos (k+2) Lk2.
                    * prove eps_ N <= 1. apply eps_bd_1. exact HN1.
                    * prove eps_ (k+2) <= 1.  apply eps_bd_1. exact Lk2.
                  + prove 0 <= eps_ N * eps_ (k+2).
                    apply SNoLtLe.
                    apply mul_SNo_pos_pos (eps_ N) (eps_ (k+2)) LeN Lek2.
                    * exact SNo_eps_pos N HN1.
                    * exact SNo_eps_pos (k+2) Lk2.
                - prove eps_ N * eps_ (k + 2) <= eps_ (k+2).
                  apply mul_SNo_Le1_nonneg_Le (eps_ N) (eps_ (k+2)) LeN Lek2.
                  + prove eps_ N <= 1. apply eps_bd_1. exact HN1.
                  + prove 0 <= eps_ (k+2). apply SNoLtLe. exact SNo_eps_pos (k+2) Lk2.
              }
            * prove eps_ (k+2) < eps_ (k+1).
              apply SNo_eps_decr (k+2) Lk2 (k+1).
              prove k+1 :e k+2.
              apply ordinal_SNoLt_In (k+1) (k+2)
                        (nat_p_ordinal (k+1) (omega_nat_p (k+1) Lk1))
                        (nat_p_ordinal (k+2) (omega_nat_p (k+2) Lk2)).
              prove k+1 < k+2.
              apply add_SNo_Lt2 k 1 2 (omega_SNo k Hk) SNo_1 SNo_2.
              prove 1 < 2.
              exact SNoLt_1_2.
      }
}      
apply SNo_prereal_incr_lower_approx (x * y) Lxy L1 L2.
let hL. assume HhL. apply HhL.
assume HhL1: hL :e SNoS_ omega :^: omega.
assume HhL2: forall n :e omega, hL n < x * y /\ x * y < hL n + eps_ n
                             /\ forall i :e n, hL i < hL n.
apply SNo_prereal_decr_upper_approx (x * y) Lxy L1 L2.
let hR. assume HhR. apply HhR.
assume HhR1: hR :e SNoS_ omega :^: omega.
assume HhR2: forall n :e omega, hR n + - eps_ n < x * y /\ x * y < hR n
                             /\ forall i :e n, hR n < hR i.
claim LhL: forall n :e omega, SNo (hL n).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (hL n) (ap_Pi omega (fun _ => SNoS_ omega) hL n HhL1 Hn).
  assume _ _ H _. exact H.
}
claim LhR: forall n :e omega, SNo (hR n).
{ let n. assume Hn.
  apply SNoS_E2 omega omega_ordinal (hR n) (ap_Pi omega (fun _ => SNoS_ omega) hR n HhR1 Hn).
  assume _ _ H _. exact H.
}
claim L3: forall n :e omega, hL n < x * y.
{ let n. assume Hn.
  apply HhL2 n Hn. assume H _. apply H. assume H _. exact H.
}
claim L4: forall n :e omega, x * y < hR n.
{ let n. assume Hn.
  apply HhR2 n Hn. assume H _. apply H. assume _ H. exact H.
}
claim L5: forall n m :e omega, hL n < hR m.
{ let n. assume Hn. let m. assume Hm.
  apply SNoLt_tra (hL n) (x * y) (hR m) (LhL n Hn) Lxy (LhR m Hm).
  - prove hL n < x * y. exact L3 n Hn.
  - prove x * y < hR m. exact L4 m Hm.
}
apply SNo_approx_real_lem hL HhL1 hR HhR1 L5.
assume HhLR1: SNoCutP {hL n|n :e omega} {hR n|n :e omega}.
assume HhLR2: SNo (SNoCut {hL n|n :e omega} {hR n|n :e omega}).
assume _ _.
assume HhLR5: forall n :e omega, hL n < SNoCut {hL n|n :e omega} {hR n|n :e omega}.
assume HhLR6: forall n :e omega, SNoCut {hL n|n :e omega} {hR n|n :e omega} < hR n.
claim L6: forall n :e omega, x * y < hL n + eps_ n.
{ let n. assume Hn.
  apply HhL2 n Hn. assume H _. apply H. assume _ H. exact H.
}
claim L7: forall n :e omega, forall i :e n, hL i < hL n.
{ let n. assume Hn.
  apply HhL2 n Hn. assume _ H. exact H.
}
claim L8: forall n :e omega, hR n + - eps_ n < x * y.
{ let n. assume Hn.
  apply HhR2 n Hn. assume H _. apply H. assume H _. exact H.
}
claim L9: forall n :e omega, forall i :e n, hR n < hR i.
{ let n. assume Hn.
  apply HhR2 n Hn. assume _ H. exact H.
}
claim L10: x * y = SNoCut {hL n|n :e omega} {hR n|n :e omega}.
{ rewrite HxyLR.
  prove SNoCut L R = SNoCut {hL n|n :e omega} {hR n|n :e omega}.
  apply SNoCut_ext L R {hL n|n :e omega} {hR n|n :e omega}
                   HLR HhLR1.
  - let w. assume Hw: w :e L.
    prove w < SNoCut {hL n|n :e omega} {hR n|n :e omega}.
    apply HLE w Hw.
    + let w0. assume Hw0: w0 :e SNoL x.
      let w1. assume Hw1: w1 :e SNoL y.
      assume Hwe: w = w0 * y + x * w1 + - w0 * w1.
      apply LLx2 w0 Hw0.
      let k0. assume Hk0: k0 :e omega.
      assume Hk0b: eps_ k0 <= x + - w0.
      apply LLy2 w1 Hw1.
      let k1. assume Hk1: k1 :e omega.
      assume Hk1b: eps_ k1 <= y + - w1.
      apply SNoL_E x Hx1 w0 Hw0.
      assume Hw01: SNo w0.
      assume Hw02: SNoLev w0 :e SNoLev x.
      assume Hw03: w0 < x.
      apply SNoL_E y Hy1 w1 Hw1.
      assume Hw11: SNo w1.
      assume Hw12: SNoLev w1 :e SNoLev y.
      assume Hw13: w1 < y.
      claim Lek0: SNo (eps_ k0).
      { exact SNo_eps_ k0 Hk0. }
      claim Lek1: SNo (eps_ k1).
      { exact SNo_eps_ k1 Hk1. }
      claim Lk0k1: k0 + k1 :e omega.
      { exact add_SNo_In_omega k0 Hk0 k1 Hk1. }
      claim Lek0k1: SNo (eps_ (k0 + k1)).
      { exact SNo_eps_ (k0 + k1) Lk0k1. }
      claim LhLk0k1: SNo (hL (k0 + k1)).
      { exact LhL (k0 + k1) Lk0k1. }
      claim Lw0y: SNo (w0 * y).
      { exact SNo_mul_SNo w0 y Hw01 Hy1. }
      claim Lxw1: SNo (x * w1).
      { exact SNo_mul_SNo x w1 Hx1 Hw11. }
      claim Lw0w1: SNo (w0 * w1).
      { exact SNo_mul_SNo w0 w1 Hw01 Hw11. }
      claim Lmw0w1: SNo (- w0 * w1).
      { exact SNo_minus_SNo (w0 * w1) Lw0w1. }
      claim Lw0yxw1mw0w1: SNo (w0 * y + x * w1 + - w0 * w1).
      { exact SNo_add_SNo_3 (w0 * y) (x * w1) (- w0 * w1) Lw0y Lxw1 Lmw0w1. }
      rewrite Hwe.
      apply SNoLeLt_tra (w0 * y + x * w1 + - w0 * w1)
                        (hL (k0 + k1))
                        (SNoCut {hL n|n :e omega} {hR n|n :e omega})
                        Lw0yxw1mw0w1
                        LhLk0k1
                        HhLR2.
      * { prove w0 * y + x * w1 + - w0 * w1 <= hL (k0 + k1).
          apply SNoLtLe_or (hL (k0 + k1)) (w0 * y + x * w1 + - w0 * w1) LhLk0k1 Lw0yxw1mw0w1.
          - assume H1: hL (k0 + k1) < w0 * y + x * w1 + - w0 * w1. prove False.
            apply SNoLt_irref (x * y).
            prove x * y < x * y.
            apply SNoLt_tra (x * y) (hL (k0 + k1) + eps_ (k0 + k1)) (x * y)
                            Lxy (SNo_add_SNo (hL (k0 + k1)) (eps_ (k0 + k1)) LhLk0k1 Lek0k1) Lxy
                            (L6 (k0 + k1) Lk0k1).
            prove hL (k0 + k1) + eps_ (k0 + k1) < x * y.
            apply SNoLtLe_tra (hL (k0 + k1) + eps_ (k0 + k1))
                              ((w0 * y + x * w1 + - w0 * w1) + eps_ (k0 + k1))
                              (x * y)
                              (SNo_add_SNo (hL (k0 + k1)) (eps_ (k0 + k1)) LhLk0k1 Lek0k1)
                              (SNo_add_SNo (w0 * y + x * w1 + - w0 * w1) (eps_ (k0 + k1)) Lw0yxw1mw0w1 Lek0k1)
                              Lxy.
            + prove hL (k0 + k1) + eps_ (k0 + k1) < (w0 * y + x * w1 + - w0 * w1) + eps_ (k0 + k1).
              apply add_SNo_Lt1 (hL (k0 + k1)) (eps_ (k0 + k1)) (w0 * y + x * w1 + - w0 * w1)
                                LhLk0k1 Lek0k1 Lw0yxw1mw0w1.
              exact H1.
            + prove (w0 * y + x * w1 + - w0 * w1) + eps_ (k0 + k1) <= x * y.
              rewrite add_SNo_com (w0 * y + x * w1 + - w0 * w1) (eps_ (k0 + k1)) Lw0yxw1mw0w1 Lek0k1.
              apply add_SNo_minus_Le2 (x * y) (w0 * y + x * w1 + - w0 * w1) (eps_ (k0 + k1)) Lxy Lw0yxw1mw0w1 Lek0k1.
              prove eps_ (k0 + k1) <= x * y + - (w0 * y + x * w1 + - w0 * w1).
              rewrite add_SNo_com_3_0_1 (w0 * y) (x * w1) (- w0 * w1) Lw0y Lxw1 Lmw0w1.
              prove eps_ (k0 + k1) <= x * y + - (x * w1 + w0 * y + - w0 * w1).
              rewrite minus_add_SNo_distr_3 (x * w1) (w0 * y) (- w0 * w1) Lxw1 Lw0y Lmw0w1.
              prove eps_ (k0 + k1) <= x * y + - x * w1 + - w0 * y + - - w0 * w1.
              rewrite <- mul_SNo_minus_distrL w0 y Hw01 Hy1.
              rewrite <- mul_SNo_minus_distrL w0 w1 Hw01 Hw11.
              prove eps_ (k0 + k1) <= x * y + - x * w1 + (- w0) * y + - (- w0) * w1.
              rewrite <- mul_SNo_minus_distrR x w1 Hx1 Hw11.
              rewrite <- mul_SNo_minus_distrR (- w0) w1 (SNo_minus_SNo w0 Hw01) Hw11.
              prove eps_ (k0 + k1) <= x * y + x * (- w1) + (- w0) * y + (- w0) * (- w1).
              rewrite <- SNo_foil x (- w0) y (- w1) Hx1 (SNo_minus_SNo w0 Hw01) Hy1 (SNo_minus_SNo w1 Hw11).
              prove eps_ (k0 + k1) <= (x + - w0) * (y + - w1).
              rewrite <- mul_SNo_eps_eps_add_SNo k0 Hk0 k1 Hk1.
              prove eps_ k0 * eps_ k1 <= (x + - w0) * (y + - w1).
              apply nonneg_mul_SNo_Le2 (eps_ k0) (eps_ k1) (x + - w0) (y + - w1) Lek0 Lek1 (SNo_add_SNo x (- w0) Hx1 (SNo_minus_SNo w0 Hw01)) (SNo_add_SNo y (- w1) Hy1 (SNo_minus_SNo w1 Hw11)).
              * prove 0 <= eps_ k0. apply SNoLtLe. exact SNo_eps_pos k0 Hk0.
              * prove 0 <= eps_ k1. apply SNoLtLe. exact SNo_eps_pos k1 Hk1.
              * prove eps_ k0 <= x + - w0. exact Hk0b.
              * prove eps_ k1 <= y + - w1. exact Hk1b.
          - assume H1: w0 * y + x * w1 + - w0 * w1 <= hL (k0 + k1). exact H1.
        }
      * prove hL (k0 + k1) < SNoCut {hL n|n :e omega} {hR n|n :e omega}.
        exact HhLR5 (k0 + k1) Lk0k1.
    + let z0. assume Hz0: z0 :e SNoR x.
      let z1. assume Hz1: z1 :e SNoR y.
      assume Hwe: w = z0 * y + x * z1 + - z0 * z1.
      apply LRx2 z0 Hz0.
      let k0. assume Hk0: k0 :e omega.
      assume Hk0b: eps_ k0 <= z0 + - x.
      apply LRy2 z1 Hz1.
      let k1. assume Hk1: k1 :e omega.
      assume Hk1b: eps_ k1 <= z1 + - y.
      apply SNoR_E x Hx1 z0 Hz0.
      assume Hz01: SNo z0.
      assume Hz02: SNoLev z0 :e SNoLev x.
      assume Hz03: x < z0.
      apply SNoR_E y Hy1 z1 Hz1.
      assume Hz11: SNo z1.
      assume Hz12: SNoLev z1 :e SNoLev y.
      assume Hz13: y < z1.
      claim Lek0: SNo (eps_ k0).
      { exact SNo_eps_ k0 Hk0. }
      claim Lek1: SNo (eps_ k1).
      { exact SNo_eps_ k1 Hk1. }
      claim Lk0k1: k0 + k1 :e omega.
      { exact add_SNo_In_omega k0 Hk0 k1 Hk1. }
      claim Lek0k1: SNo (eps_ (k0 + k1)).
      { exact SNo_eps_ (k0 + k1) Lk0k1. }
      claim LhLk0k1: SNo (hL (k0 + k1)).
      { exact LhL (k0 + k1) Lk0k1. }
      claim Lz0y: SNo (z0 * y).
      { exact SNo_mul_SNo z0 y Hz01 Hy1. }
      claim Lxz1: SNo (x * z1).
      { exact SNo_mul_SNo x z1 Hx1 Hz11. }
      claim Lz0z1: SNo (z0 * z1).
      { exact SNo_mul_SNo z0 z1 Hz01 Hz11. }
      claim Lmz0z1: SNo (- z0 * z1).
      { exact SNo_minus_SNo (z0 * z1) Lz0z1. }
      claim Lz0yxz1mz0z1: SNo (z0 * y + x * z1 + - z0 * z1).
      { exact SNo_add_SNo_3 (z0 * y) (x * z1) (- z0 * z1) Lz0y Lxz1 Lmz0z1. }
      rewrite Hwe.
      apply SNoLeLt_tra (z0 * y + x * z1 + - z0 * z1)
                        (hL (k0 + k1))
                        (SNoCut {hL n|n :e omega} {hR n|n :e omega})
                        Lz0yxz1mz0z1
                        LhLk0k1
                        HhLR2.
      * { prove z0 * y + x * z1 + - z0 * z1 <= hL (k0 + k1).
          apply SNoLtLe_or (hL (k0 + k1)) (z0 * y + x * z1 + - z0 * z1) LhLk0k1 Lz0yxz1mz0z1.
          - assume H1: hL (k0 + k1) < z0 * y + x * z1 + - z0 * z1. prove False.
            apply SNoLt_irref (x * y).
            prove x * y < x * y.
            apply SNoLt_tra (x * y) (hL (k0 + k1) + eps_ (k0 + k1)) (x * y)
                            Lxy (SNo_add_SNo (hL (k0 + k1)) (eps_ (k0 + k1)) LhLk0k1 Lek0k1) Lxy
                            (L6 (k0 + k1) Lk0k1).
            prove hL (k0 + k1) + eps_ (k0 + k1) < x * y.
            apply SNoLtLe_tra (hL (k0 + k1) + eps_ (k0 + k1))
                              ((z0 * y + x * z1 + - z0 * z1) + eps_ (k0 + k1))
                              (x * y)
                              (SNo_add_SNo (hL (k0 + k1)) (eps_ (k0 + k1)) LhLk0k1 Lek0k1)
                              (SNo_add_SNo (z0 * y + x * z1 + - z0 * z1) (eps_ (k0 + k1)) Lz0yxz1mz0z1 Lek0k1)
                              Lxy.
            + prove hL (k0 + k1) + eps_ (k0 + k1) < (z0 * y + x * z1 + - z0 * z1) + eps_ (k0 + k1).
              apply add_SNo_Lt1 (hL (k0 + k1)) (eps_ (k0 + k1)) (z0 * y + x * z1 + - z0 * z1)
                                LhLk0k1 Lek0k1 Lz0yxz1mz0z1.
              exact H1.
            + prove (z0 * y + x * z1 + - z0 * z1) + eps_ (k0 + k1) <= x * y.
              rewrite add_SNo_com (z0 * y + x * z1 + - z0 * z1) (eps_ (k0 + k1)) Lz0yxz1mz0z1 Lek0k1.
              apply add_SNo_minus_Le2 (x * y) (z0 * y + x * z1 + - z0 * z1) (eps_ (k0 + k1)) Lxy Lz0yxz1mz0z1 Lek0k1.
              prove eps_ (k0 + k1) <= x * y + - (z0 * y + x * z1 + - z0 * z1).
              rewrite add_SNo_com (x * y) (- (z0 * y + x * z1 + - z0 * z1))
                                  Lxy (SNo_minus_SNo (z0 * y + x * z1 + - z0 * z1) Lz0yxz1mz0z1).
              rewrite add_SNo_rotate_3_1 (z0 * y) (x * z1) (- z0 * z1) Lz0y Lxz1 Lmz0z1.
              rewrite minus_add_SNo_distr_3 (- z0 * z1) (z0 * y) (x * z1) Lmz0z1 Lz0y Lxz1.
              rewrite minus_SNo_invol (z0 * z1) Lz0z1.
              prove eps_ (k0 + k1) <= (z0 * z1 + - z0 * y + - x * z1) + x * y.
              rewrite <- add_SNo_assoc_4 (z0 * z1) (- z0 * y) (- x * z1) (x * y)
                                         Lz0z1
                                         (SNo_minus_SNo (z0 * y) Lz0y)
                                         (SNo_minus_SNo (x * z1) Lxz1)
                                         Lxy.
              prove eps_ (k0 + k1) <= z0 * z1 + - z0 * y + - x * z1 + x * y.
              rewrite <- mul_SNo_minus_distrR z0 y Hz01 Hy1.
              rewrite <- mul_SNo_minus_distrL x z1 Hx1 Hz11.
              prove eps_ (k0 + k1) <= z0 * z1 + z0 * (- y) + (- x) * z1 + x * y.
              rewrite <- mul_SNo_minus_minus x y Hx1 Hy1.
              prove eps_ (k0 + k1) <= z0 * z1 + z0 * (- y) + (- x) * z1 + (- x) * (- y).
              rewrite <- SNo_foil z0 (- x) z1 (- y) Hz01 (SNo_minus_SNo x Hx1) Hz11 (SNo_minus_SNo y Hy1).
              prove eps_ (k0 + k1) <= (z0 + - x) * (z1 + - y).
              rewrite <- mul_SNo_eps_eps_add_SNo k0 Hk0 k1 Hk1.
              prove eps_ k0 * eps_ k1 <= (z0 + - x) * (z1 + - y).
              apply nonneg_mul_SNo_Le2 (eps_ k0) (eps_ k1) (z0 + - x) (z1 + - y) Lek0 Lek1 (SNo_add_SNo z0 (- x) Hz01 (SNo_minus_SNo x Hx1)) (SNo_add_SNo z1 (- y) Hz11 (SNo_minus_SNo y Hy1)).
              * prove 0 <= eps_ k0. apply SNoLtLe. exact SNo_eps_pos k0 Hk0.
              * prove 0 <= eps_ k1. apply SNoLtLe. exact SNo_eps_pos k1 Hk1.
              * prove eps_ k0 <= z0 + - x. exact Hk0b.
              * prove eps_ k1 <= z1 + - y. exact Hk1b.
          - assume H1: z0 * y + x * z1 + - z0 * z1 <= hL (k0 + k1). exact H1.
        }
      * prove hL (k0 + k1) < SNoCut {hL n|n :e omega} {hR n|n :e omega}.
        exact HhLR5 (k0 + k1) Lk0k1.
  - let z. assume Hz: z :e R.
    prove SNoCut {hL n|n :e omega} {hR n|n :e omega} < z.
    apply HRE z Hz.
    + let w0. assume Hw0: w0 :e SNoL x.
      let z1. assume Hz1: z1 :e SNoR y.
      assume Hze: z = w0 * y + x * z1 + - w0 * z1.
      apply LLx2 w0 Hw0.
      let k0. assume Hk0: k0 :e omega.
      assume Hk0b: eps_ k0 <= x + - w0.
      apply LRy2 z1 Hz1.
      let k1. assume Hk1: k1 :e omega.
      assume Hk1b: eps_ k1 <= z1 + - y.
      apply SNoL_E x Hx1 w0 Hw0.
      assume Hw01: SNo w0.
      assume Hw02: SNoLev w0 :e SNoLev x.
      assume Hw03: w0 < x.
      apply SNoR_E y Hy1 z1 Hz1.
      assume Hz11: SNo z1.
      assume Hz12: SNoLev z1 :e SNoLev y.
      assume Hz13: y < z1.
      claim Lek0: SNo (eps_ k0).
      { exact SNo_eps_ k0 Hk0. }
      claim Lek1: SNo (eps_ k1).
      { exact SNo_eps_ k1 Hk1. }
      claim Lk0k1: k0 + k1 :e omega.
      { exact add_SNo_In_omega k0 Hk0 k1 Hk1. }
      claim Lek0k1: SNo (eps_ (k0 + k1)).
      { exact SNo_eps_ (k0 + k1) Lk0k1. }
      claim Lmek0k1: SNo (- eps_ (k0 + k1)).
      { exact SNo_minus_SNo (eps_ (k0 + k1)) Lek0k1. }
      claim LhRk0k1: SNo (hR (k0 + k1)).
      { exact LhR (k0 + k1) Lk0k1. }
      claim Lw0y: SNo (w0 * y).
      { exact SNo_mul_SNo w0 y Hw01 Hy1. }
      claim Lxz1: SNo (x * z1).
      { exact SNo_mul_SNo x z1 Hx1 Hz11. }
      claim Lw0z1: SNo (w0 * z1).
      { exact SNo_mul_SNo w0 z1 Hw01 Hz11. }
      claim Lmw0z1: SNo (- w0 * z1).
      { exact SNo_minus_SNo (w0 * z1) Lw0z1. }
      claim Lw0yxz1mw0z1: SNo (w0 * y + x * z1 + - w0 * z1).
      { exact SNo_add_SNo_3 (w0 * y) (x * z1) (- w0 * z1) Lw0y Lxz1 Lmw0z1. }
      rewrite Hze.
      apply SNoLtLe_tra (SNoCut {hL n|n :e omega} {hR n|n :e omega})
                        (hR (k0 + k1))
                        (w0 * y + x * z1 + - w0 * z1)
                        HhLR2
                        LhRk0k1
                        Lw0yxz1mw0z1.
      * prove SNoCut {hL n|n :e omega} {hR n|n :e omega} < hR (k0 + k1).
        exact HhLR6 (k0 + k1) Lk0k1.
      * { prove hR (k0 + k1) <= w0 * y + x * z1 + - w0 * z1.
          apply SNoLtLe_or (w0 * y + x * z1 + - w0 * z1) (hR (k0 + k1)) Lw0yxz1mw0z1 LhRk0k1.
          - assume H1: w0 * y + x * z1 + - w0 * z1 < hR (k0 + k1). prove False.
            apply SNoLt_irref (x * y).
            prove x * y < x * y.
            apply SNoLt_tra (x * y) (hR (k0 + k1) + - eps_ (k0 + k1)) (x * y)
                            Lxy (SNo_add_SNo (hR (k0 + k1)) (- eps_ (k0 + k1)) LhRk0k1 Lmek0k1) Lxy.
            + prove x * y < hR (k0 + k1) + - eps_ (k0 + k1).
              apply SNoLeLt_tra (x * y)
                                ((w0 * y + x * z1 + - w0 * z1) + - eps_ (k0 + k1))
                                (hR (k0 + k1) + - eps_ (k0 + k1))
                                Lxy
                                (SNo_add_SNo (w0 * y + x * z1 + - w0 * z1) (- eps_ (k0 + k1)) Lw0yxz1mw0z1 Lmek0k1)
                                (SNo_add_SNo (hR (k0 + k1)) (- eps_ (k0 + k1)) LhRk0k1 Lmek0k1).
              * { prove x * y <= (w0 * y + x * z1 + - w0 * z1) + - eps_ (k0 + k1).
                  apply add_SNo_minus_Le2b (w0 * y + x * z1 + - w0 * z1) (eps_ (k0 + k1)) (x * y)
                                           Lw0yxz1mw0z1 Lek0k1 Lxy.
                  prove x * y + eps_ (k0 + k1) <= w0 * y + x * z1 + - w0 * z1.
                  rewrite add_SNo_com (x * y) (eps_ (k0 + k1)) Lxy Lek0k1.
                  apply add_SNo_minus_Le2 (w0 * y + x * z1 + - w0 * z1) (x * y) (eps_ (k0 + k1)) Lw0yxz1mw0z1 Lxy Lek0k1.
                  prove eps_ (k0 + k1) <= (w0 * y + x * z1 + - w0 * z1) + - x * y.
                  rewrite add_SNo_rotate_3_1 (w0 * y) (x * z1) (- w0 * z1) Lw0y Lxz1 Lmw0z1.
                  prove eps_ (k0 + k1) <= (- w0 * z1 + w0 * y + x * z1) + - x * y.
                  rewrite <- add_SNo_assoc_4 (- w0 * z1) (w0 * y) (x * z1) (- x * y) Lmw0z1 Lw0y Lxz1 Lmxy.
                  prove eps_ (k0 + k1) <= - w0 * z1 + w0 * y + x * z1 + - x * y.
                  rewrite add_SNo_rotate_4_1 (- w0 * z1) (w0 * y) (x * z1) (- x * y) Lmw0z1 Lw0y Lxz1 Lmxy.
                  prove eps_ (k0 + k1) <= - x * y + - w0 * z1 + w0 * y + x * z1.
                  rewrite add_SNo_rotate_4_1 (- x * y) (- w0 * z1) (w0 * y) (x * z1) Lmxy Lmw0z1 Lw0y Lxz1.
                  prove eps_ (k0 + k1) <= x * z1 + - x * y + - w0 * z1 + w0 * y.
                  rewrite <- mul_SNo_minus_distrR x y Hx1 Hy1.
                  rewrite <- mul_SNo_minus_distrL w0 z1 Hw01 Hz11.
                  rewrite <- mul_SNo_minus_minus w0 y Hw01 Hy1.
                  prove eps_ (k0 + k1) <= x * z1 + x * (- y) + (- w0) * z1 + (- w0) * (- y).
                  rewrite <- SNo_foil x (- w0) z1 (- y) Hx1 (SNo_minus_SNo w0 Hw01) Hz11 (SNo_minus_SNo y Hy1).
                  rewrite <- mul_SNo_eps_eps_add_SNo k0 Hk0 k1 Hk1.
                  prove eps_ k0 * eps_ k1 <= (x + - w0) * (z1 + - y).
                  apply nonneg_mul_SNo_Le2 (eps_ k0) (eps_ k1) (x + - w0) (z1 + - y) Lek0 Lek1 (SNo_add_SNo x (- w0) Hx1 (SNo_minus_SNo w0 Hw01)) (SNo_add_SNo z1 (- y) Hz11 (SNo_minus_SNo y Hy1)).
                  - prove 0 <= eps_ k0. apply SNoLtLe. exact SNo_eps_pos k0 Hk0.
                  - prove 0 <= eps_ k1. apply SNoLtLe. exact SNo_eps_pos k1 Hk1.
                  - prove eps_ k0 <= x + - w0. exact Hk0b.
                  - prove eps_ k1 <= z1 + - y. exact Hk1b.
                }
              * prove (w0 * y + x * z1 + - w0 * z1) + - eps_ (k0 + k1) < hR (k0 + k1) + - eps_ (k0 + k1).
                apply add_SNo_Lt1 (w0 * y + x * z1 + - w0 * z1) (- eps_ (k0 + k1)) (hR (k0 + k1))
                                  Lw0yxz1mw0z1 Lmek0k1 LhRk0k1.
                exact H1.
            + exact L8 (k0 + k1) Lk0k1.
          - assume H1: hR (k0 + k1) <= w0 * y + x * z1 + - w0 * z1. exact H1.
        }
    + let z0. assume Hz0: z0 :e SNoR x.
      let w1. assume Hw1: w1 :e SNoL y.
      assume Hze: z = z0 * y + x * w1 + - z0 * w1.
      apply LRx2 z0 Hz0.
      let k0. assume Hk0: k0 :e omega.
      assume Hk0b: eps_ k0 <= z0 + - x.
      apply LLy2 w1 Hw1.
      let k1. assume Hk1: k1 :e omega.
      assume Hk1b: eps_ k1 <= y + - w1.
      apply SNoR_E x Hx1 z0 Hz0.
      assume Hz01: SNo z0.
      assume Hz02: SNoLev z0 :e SNoLev x.
      assume Hz03: x < z0.
      apply SNoL_E y Hy1 w1 Hw1.
      assume Hw11: SNo w1.
      assume Hw12: SNoLev w1 :e SNoLev y.
      assume Hw13: w1 < y.
      claim Lek0: SNo (eps_ k0).
      { exact SNo_eps_ k0 Hk0. }
      claim Lek1: SNo (eps_ k1).
      { exact SNo_eps_ k1 Hk1. }
      claim Lk0k1: k0 + k1 :e omega.
      { exact add_SNo_In_omega k0 Hk0 k1 Hk1. }
      claim Lek0k1: SNo (eps_ (k0 + k1)).
      { exact SNo_eps_ (k0 + k1) Lk0k1. }
      claim Lmek0k1: SNo (- eps_ (k0 + k1)).
      { exact SNo_minus_SNo (eps_ (k0 + k1)) Lek0k1. }
      claim LhRk0k1: SNo (hR (k0 + k1)).
      { exact LhR (k0 + k1) Lk0k1. }
      claim Lz0y: SNo (z0 * y).
      { exact SNo_mul_SNo z0 y Hz01 Hy1. }
      claim Lxw1: SNo (x * w1).
      { exact SNo_mul_SNo x w1 Hx1 Hw11. }
      claim Lz0w1: SNo (z0 * w1).
      { exact SNo_mul_SNo z0 w1 Hz01 Hw11. }
      claim Lmz0w1: SNo (- z0 * w1).
      { exact SNo_minus_SNo (z0 * w1) Lz0w1. }
      claim Lz0yxw1mz0w1: SNo (z0 * y + x * w1 + - z0 * w1).
      { exact SNo_add_SNo_3 (z0 * y) (x * w1) (- z0 * w1) Lz0y Lxw1 Lmz0w1. }
      rewrite Hze.
      apply SNoLtLe_tra (SNoCut {hL n|n :e omega} {hR n|n :e omega})
                        (hR (k0 + k1))
                        (z0 * y + x * w1 + - z0 * w1)
                        HhLR2
                        LhRk0k1
                        Lz0yxw1mz0w1.
      * prove SNoCut {hL n|n :e omega} {hR n|n :e omega} < hR (k0 + k1).
        exact HhLR6 (k0 + k1) Lk0k1.
      * { prove hR (k0 + k1) <= z0 * y + x * w1 + - z0 * w1.
          apply SNoLtLe_or (z0 * y + x * w1 + - z0 * w1) (hR (k0 + k1)) Lz0yxw1mz0w1 LhRk0k1.
          - assume H1: z0 * y + x * w1 + - z0 * w1 < hR (k0 + k1). prove False.
            apply SNoLt_irref (x * y).
            prove x * y < x * y.
            apply SNoLt_tra (x * y) (hR (k0 + k1) + - eps_ (k0 + k1)) (x * y)
                            Lxy (SNo_add_SNo (hR (k0 + k1)) (- eps_ (k0 + k1)) LhRk0k1 Lmek0k1) Lxy.
            + prove x * y < hR (k0 + k1) + - eps_ (k0 + k1).
              apply SNoLeLt_tra (x * y)
                                ((z0 * y + x * w1 + - z0 * w1) + - eps_ (k0 + k1))
                                (hR (k0 + k1) + - eps_ (k0 + k1))
                                Lxy
                                (SNo_add_SNo (z0 * y + x * w1 + - z0 * w1) (- eps_ (k0 + k1)) Lz0yxw1mz0w1 Lmek0k1)
                                (SNo_add_SNo (hR (k0 + k1)) (- eps_ (k0 + k1)) LhRk0k1 Lmek0k1).
              * { prove x * y <= (z0 * y + x * w1 + - z0 * w1) + - eps_ (k0 + k1).
                  apply add_SNo_minus_Le2b (z0 * y + x * w1 + - z0 * w1) (eps_ (k0 + k1)) (x * y)
                                           Lz0yxw1mz0w1 Lek0k1 Lxy.
                  prove x * y + eps_ (k0 + k1) <= z0 * y + x * w1 + - z0 * w1.
                  rewrite add_SNo_com (x * y) (eps_ (k0 + k1)) Lxy Lek0k1.
                  apply add_SNo_minus_Le2 (z0 * y + x * w1 + - z0 * w1) (x * y) (eps_ (k0 + k1)) Lz0yxw1mz0w1 Lxy Lek0k1.
                  prove eps_ (k0 + k1) <= (z0 * y + x * w1 + - z0 * w1) + - x * y.
                  rewrite <- add_SNo_assoc_4 (z0 * y) (x * w1) (- z0 * w1) (- x * y) Lz0y Lxw1 Lmz0w1 Lmxy.
                  prove eps_ (k0 + k1) <= z0 * y + x * w1 + - z0 * w1 + - x * y.
                  rewrite <- add_SNo_rotate_3_1 (- z0 * w1) (- x * y) (x * w1) Lmz0w1 Lmxy Lxw1.
                  prove eps_ (k0 + k1) <= z0 * y + - z0 * w1 + - x * y + x * w1.
                  rewrite <- mul_SNo_minus_distrR z0 w1 Hz01 Hw11.
                  rewrite <- mul_SNo_minus_distrL x y Hx1 Hy1.
                  rewrite <- mul_SNo_minus_minus x w1 Hx1 Hw11.
                  prove eps_ (k0 + k1) <= z0 * y + z0 * (- w1) + (- x) * y + (- x) * (- w1).
                  rewrite <- SNo_foil z0 (- x) y (- w1) Hz01 (SNo_minus_SNo x Hx1) Hy1 (SNo_minus_SNo w1 Hw11).
                  rewrite <- mul_SNo_eps_eps_add_SNo k0 Hk0 k1 Hk1.
                  prove eps_ k0 * eps_ k1 <= (z0 + - x) * (y + - w1).
                  apply nonneg_mul_SNo_Le2 (eps_ k0) (eps_ k1) (z0 + - x) (y + - w1) Lek0 Lek1 (SNo_add_SNo z0 (- x) Hz01 (SNo_minus_SNo x Hx1)) (SNo_add_SNo y (- w1) Hy1 (SNo_minus_SNo w1 Hw11)).
                  - prove 0 <= eps_ k0. apply SNoLtLe. exact SNo_eps_pos k0 Hk0.
                  - prove 0 <= eps_ k1. apply SNoLtLe. exact SNo_eps_pos k1 Hk1.
                  - prove eps_ k0 <= z0 + - x. exact Hk0b.
                  - prove eps_ k1 <= y + - w1. exact Hk1b.
                }
              * prove (z0 * y + x * w1 + - z0 * w1) + - eps_ (k0 + k1) < hR (k0 + k1) + - eps_ (k0 + k1).
                apply add_SNo_Lt1 (z0 * y + x * w1 + - z0 * w1) (- eps_ (k0 + k1)) (hR (k0 + k1))
                                  Lz0yxw1mz0w1 Lmek0k1 LhRk0k1.
                exact H1.
            + exact L8 (k0 + k1) Lk0k1.
          - assume H1: hR (k0 + k1) <= z0 * y + x * w1 + - z0 * w1. exact H1.
        }
  - let w. assume Hw: w :e {hL n|n :e omega}. rewrite <- HxyLR.
    prove w < x * y.
    apply ReplE_impred omega (fun n => hL n) w Hw.
    let n. assume Hn Hwn.
    rewrite Hwn.
    prove hL n < x * y. exact L3 n Hn.
  - let z. assume Hz: z :e {hR n|n :e omega}. rewrite <- HxyLR.
    prove x * y < z.
    apply ReplE_impred omega (fun n => hR n) z Hz.
    let n. assume Hn Hzn.
    rewrite Hzn.
    prove x * y < hR n. exact L4 n Hn.
}
apply HC.
exact SNo_approx_real (x * y) Lxy hL HhL1 hR HhR1 L3 L6 L7 L4 L9 L10.
Qed.

Theorem real_mul_SNo : forall x y :e real, x * y :e real.
let x. assume Hx. let y. assume Hy.
claim Lx: SNo x.
{ exact real_SNo x Hx. }
claim Ly: SNo y.
{ exact real_SNo y Hy. }
claim Lxy: SNo (x * y).
{ exact SNo_mul_SNo x y Lx Ly. }
apply SNoLt_trichotomy_or_impred x 0 Lx SNo_0.
- assume H1: x < 0.
  claim Lmx: 0 < - x.
  { apply minus_SNo_Lt_contra2 x 0 Lx SNo_0.
    prove x < - 0. rewrite minus_SNo_0. exact H1.
  }
  apply SNoLt_trichotomy_or_impred y 0 Ly SNo_0.
  + assume H2: y < 0.
    prove x * y :e real.
    rewrite <- mul_SNo_minus_minus x y Lx Ly.
    prove (- x) * (- y) :e real.
    apply real_mul_SNo_pos (- x) (real_minus_SNo x Hx) (- y) (real_minus_SNo y Hy) Lmx.
    prove 0 < - y.
    apply minus_SNo_Lt_contra2 y 0 Ly SNo_0.
    prove y < - 0. rewrite minus_SNo_0. exact H2.
  + assume H2: y = 0. rewrite H2. rewrite mul_SNo_zeroR x Lx.
    exact real_0.
  + assume H2: 0 < y.
    prove x * y :e real.
    rewrite <- minus_SNo_invol (x * y) Lxy.
    prove - - (x * y) :e real.
    rewrite <- mul_SNo_minus_distrL x y Lx Ly.
    prove - ((- x) * y) :e real.
    apply real_minus_SNo.
    prove (- x) * y :e real.
    exact real_mul_SNo_pos (- x) (real_minus_SNo x Hx) y Hy Lmx H2.
- assume H1: x = 0.
  prove x * y :e real.
  rewrite H1.
  rewrite mul_SNo_zeroL y Ly.
  exact real_0.
- assume H1: 0 < x.
  apply SNoLt_trichotomy_or_impred y 0 Ly SNo_0.
  + assume H2: y < 0.
    rewrite <- minus_SNo_invol (x * y) Lxy.
    prove - - (x * y) :e real.
    rewrite <- mul_SNo_minus_distrR x y Lx Ly.
    prove - (x * (- y)) :e real.
    apply real_minus_SNo.
    prove x * (- y) :e real.
    apply real_mul_SNo_pos x Hx (- y) (real_minus_SNo y Hy) H1.
    prove 0 < - y.
    apply minus_SNo_Lt_contra2 y 0 Ly SNo_0.
    prove y < - 0. rewrite minus_SNo_0. exact H2.
  + assume H2: y = 0. rewrite H2. rewrite mul_SNo_zeroR x Lx.
    exact real_0.
  + assume H2: 0 < y.
    exact real_mul_SNo_pos x Hx y Hy H1 H2.
Qed.

Theorem nonneg_real_nat_interval: forall x :e real, 0 <= x -> exists n :e omega, n <= x /\ x < ordsucc n.
let x. assume HxR Hxnn.
apply real_E x HxR.
assume Hx1: SNo x.
assume Hx2: SNoLev x :e ordsucc omega.
assume Hx3: x :e SNoS_ (ordsucc omega).
assume Hx4: - omega < x.
assume Hx5: x < omega.
assume Hx6: forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x.
assume Hx7: forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
claim L1: forall m, nat_p m -> x < m -> exists n :e omega, n <= x /\ x < ordsucc n.
{ apply nat_ind.
  - assume H1: x < 0. prove False.
    apply SNoLt_irref 0.
    prove 0 < 0.
    exact SNoLeLt_tra 0 x 0 SNo_0 Hx1 SNo_0 Hxnn H1.
  - let m.
    assume Hm.
    assume IHm: x < m -> exists n :e omega, n <= x /\ x < ordsucc n.
    assume H2: x < ordsucc m.
    apply SNoLtLe_or x m Hx1 (nat_p_SNo m Hm).
    + assume H3: x < m. apply IHm. prove x < m. exact H3.
    + assume H3: m <= x.
      witness m.
      apply andI.
      * prove m :e omega. exact nat_p_omega m Hm.
      * { apply andI.
          - prove m <= x. exact H3.
          - prove x < ordsucc m. exact H2.
        }
}
apply Hx7 0 (nat_p_omega 0 nat_0).
let q. assume H. apply H.
assume Hq: q :e SNoS_ omega. assume H. apply H.
assume Hqx: q < x.
rewrite eps_0_1.
assume Hxq1: x < q + 1.
apply SNoS_E omega omega_ordinal q Hq.
let m. assume H. apply H.
assume Hm: m :e omega.
assume H1: SNo_ m q.
claim Lq: SNo q.
{ exact SNo_SNo m (nat_p_ordinal m (omega_nat_p m Hm)) q H1. }
apply L1 (ordsucc m).
- prove nat_p (ordsucc m). apply nat_ordsucc. apply omega_nat_p. exact Hm.
- prove x < ordsucc m.
  apply SNoLtLe_tra x (q + 1) (ordsucc m) Hx1 (SNo_add_SNo q 1 Lq SNo_1) (nat_p_SNo (ordsucc m) (nat_ordsucc m (omega_nat_p m Hm))) Hxq1.
  prove q + 1 <= ordsucc m.
  claim Lq1: SNo (q + 1).
  { apply SNo_add_SNo.
    - exact Lq.
    - exact SNo_1.
  }
  apply ordinal_SNoLev_max_2 (ordsucc m) (nat_p_ordinal (ordsucc m) (nat_ordsucc m (omega_nat_p m Hm))) (q + 1).
  + prove SNo (q + 1). exact Lq1.
  + prove SNoLev (q + 1) :e ordsucc (ordsucc m).
    apply ordinal_In_Or_Subq (SNoLev (q + 1)) (ordsucc m) (SNoLev_ordinal (q + 1) Lq1) (nat_p_ordinal (ordsucc m) (nat_ordsucc m (omega_nat_p m Hm))).
    * assume H2: SNoLev (q + 1) :e ordsucc m. apply ordsuccI1. exact H2.
    * assume H2: ordsucc m c= SNoLev (q + 1).
      claim L2: SNoLev (q + 1) c= ordsucc m.
      { apply Subq_tra (SNoLev (q + 1)) (SNoLev q + SNoLev 1).
        - prove SNoLev (q + 1) c= SNoLev q + SNoLev 1.
          apply add_SNo_Lev_bd.
          + exact Lq.
          + exact SNo_1.
        - prove SNoLev q + SNoLev 1 c= ordsucc m.
          rewrite SNoLev_uniq2 m (nat_p_ordinal m (omega_nat_p m Hm)) q H1.
          rewrite ordinal_SNoLev 1 (nat_p_ordinal 1 nat_1).
          prove m + 1 c= ordsucc m.
          rewrite add_SNo_1_ordsucc m Hm. apply Subq_ref.
      }
      claim L3: SNoLev (q + 1) = ordsucc m.
      { apply set_ext.
        - exact L2.
        - exact H2.
      }
      rewrite L3. apply ordsuccI2.
Qed.

Theorem pos_real_left_approx_double: forall x :e real, 0 < x
 -> x <> 2 -> (forall m :e omega, x <> eps_ m)
 -> exists w :e SNoL_pos x, x < 2 * w.
let x. assume HxR Hxpos Hxn2 Hxne.
apply real_E x HxR.
assume Hx1: SNo x.
assume Hx2: SNoLev x :e ordsucc omega.
assume Hx3: x :e SNoS_ (ordsucc omega).
assume Hx4: - omega < x.
assume Hx5: x < omega.
assume Hx6: forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x.
assume Hx7: forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
claim L1: forall m, nat_p m -> eps_ m < x -> exists w :e SNoL_pos x, x < 2 * w.
{ apply nat_ind.
  - prove eps_ 0 < x -> exists w :e SNoL_pos x, x < 2 * w.
    rewrite eps_0_1.
    assume H1: 1 < x.
    apply SNoLt_trichotomy_or_impred x 2 Hx1 SNo_2.
    + assume H2: x < 2.
      witness 1. apply andI.
      * { prove 1 :e SNoL_pos x.
          prove 1 :e {w :e SNoL x|0 < w}.
          apply SepI.
          - prove 1 :e SNoL x.
            apply SNoL_I x Hx1 1 SNo_1.
            + prove SNoLev 1 :e SNoLev x.
              rewrite ordinal_SNoLev 1 (nat_p_ordinal 1 nat_1).
              prove 1 :e SNoLev x.
              apply ordinal_In_Or_Subq 1 (SNoLev x) (nat_p_ordinal 1 nat_1) (SNoLev_ordinal x Hx1).
              * assume H3: 1 :e SNoLev x. exact H3.
              * assume H3: SNoLev x c= 1. prove False.
                apply Hxne 0 (nat_p_omega 0 nat_0).
                prove x = eps_ 0.
                rewrite eps_0_1.
                exact pos_low_eq_one x Hx1 Hxpos H3.
            + prove 1 < x. exact H1.
          - prove 0 < 1. exact SNoLt_0_1.
        }
      * prove x < 2 * 1.
        rewrite mul_SNo_oneR 2 SNo_2.
        exact H2.
    + assume H2: x = 2. prove False. apply Hxn2. exact H2.
    + assume H2: 2 < x.
      apply nonneg_real_nat_interval x HxR (SNoLtLe 0 x Hxpos).
      let m. assume H. apply H.
      assume Hm: m :e omega. assume H. apply H.
      assume Hmx: m <= x.
      assume Hxm1: x < ordsucc m.
      claim Lm: nat_p m.
      { exact omega_nat_p m Hm. }
      apply nat_inv m Lm.
      * { assume Hm0: m = 0. prove False.
          apply SNoLt_irref x.
          prove x < x.
          apply SNoLt_tra x 1 x Hx1 SNo_1 Hx1.
          - prove x < ordsucc 0. rewrite <- Hm0.
            exact Hxm1.
          - prove 1 < x. exact H1.
        }
      * { assume H. apply H.
          let m'. assume H. apply H.
          assume Hm': nat_p m'.
          assume Hmm': m = ordsucc m'.
          apply nat_inv m' Hm'.
          - assume Hm'0: m' = 0.
            apply SNoLt_irref x.
            prove x < x.
            apply SNoLt_tra x 2 x Hx1 SNo_2 Hx1.
            + prove x < ordsucc (ordsucc 0).
              rewrite <- Hm'0.
              rewrite <- Hmm'.
              exact Hxm1.
            + prove 2 < x. exact H2.
          - assume H. apply H.
            let m''. assume H. apply H.
            assume Hm'': nat_p m''.
            assume Hm'm'': m' = ordsucc m''.
            claim L1a: exists k :e omega, 2 <= k /\ k < x /\ x <= ordsucc k.
            { apply SNoLeE m x (nat_p_SNo m Lm) Hx1 Hmx.
              - assume H4: m < x.
                witness m. apply andI.
                + prove m :e omega. exact Hm.
                + apply and3I.
                  * { prove 2 <= m.
                      apply SNoLtLe_or m 2 (nat_p_SNo m Lm) SNo_2.
                      - assume H5: m < 2. prove False.
                        claim L1aa: m :e 2.
                        { apply ordinal_SNoLt_In.
                          - exact nat_p_ordinal m Lm.
                          - exact nat_p_ordinal 2 nat_2.
                          - exact H5.
                        }
                        apply cases_2 m L1aa (fun i => m <> i).
                        + rewrite Hmm'.
                          exact neq_ordsucc_0 m'.
                        + rewrite Hmm'. rewrite Hm'm''.
                          assume H6: ordsucc (ordsucc m'') = 1.
                          exact neq_ordsucc_0 m'' (ordsucc_inj (ordsucc m'') 0 H6).
                        + reflexivity.
                      - assume H5: 2 <= m. exact H5.
                    }
                  * prove m < x. exact H4.
                  * prove x <= ordsucc m.
                    apply SNoLtLe.
                    prove x < ordsucc m.
                    exact Hxm1.
              - assume H4: m = x.
                apply nat_inv m'' Hm''.
                + assume Hm''0: m'' = 0.
                  prove False. apply Hxn2.
                  prove x = 2. rewrite <- H4.
                  rewrite Hmm'. rewrite Hm'm''.
                  rewrite Hm''0. reflexivity.
                + assume H. apply H.
                  let m'''. assume H. apply H.
                  assume Hm''': nat_p m'''.
                  assume Hm''m''': m'' = ordsucc m'''.
                  prove exists k :e omega, 2 <= k /\ k < x /\ x <= ordsucc k.
                  witness m'. apply andI.
                  * prove m' :e omega. apply nat_p_omega. exact Hm'.
                  * { prove 2 <= m' /\ m' < x /\ x <= ordsucc m'.
                      apply and3I.
                      - prove 2 <= m'.
                        rewrite Hm'm''.
                        prove 2 <= ordsucc m''.
                        rewrite ordinal_ordsucc_SNo_eq m'' (nat_p_ordinal m'' Hm'').
                        prove 2 <= 1 + m''.
                        rewrite Hm''m'''.
                        prove 2 <= 1 + ordsucc m'''.
                        rewrite ordinal_ordsucc_SNo_eq m''' (nat_p_ordinal m''' Hm''').
                        prove 2 <= 1 + 1 + m'''.
                        rewrite add_SNo_assoc 1 1 m''' SNo_1 SNo_1 (nat_p_SNo m''' Hm''').
                        prove 2 <= (1 + 1) + m'''.
                        rewrite add_SNo_1_1_2.
                        prove 2 <= 2 + m'''.
                        rewrite <- add_SNo_0R 2 SNo_2 at 1.
                        prove 2 + 0 <= 2 + m'''.
                        apply add_SNo_Le2 2 0 m''' SNo_2 SNo_0 (nat_p_SNo m''' Hm''').
                        prove 0 <= m'''.
                        apply ordinal_Subq_SNoLe 0 m''' ordinal_Empty (nat_p_ordinal m''' Hm''').
                        prove 0 c= m'''.
                        apply Subq_Empty.
                      - prove m' < x. rewrite <- H4.
                        prove m' < m.
                        apply ordinal_In_SNoLt.
                        + exact nat_p_ordinal m Lm.
                        + rewrite Hmm'. apply ordsuccI2.
                      - prove x <= ordsucc m'.
                        rewrite <- H4. rewrite Hmm'.
                        prove ordsucc m' <= ordsucc m'.
                        apply SNoLe_ref.
                    }
            }
            apply L1a.
            let k. assume H. apply H.
            assume Hk: k :e omega. assume H. apply H. assume H. apply H.
            assume H2k: 2 <= k.
            assume Hkx: k < x.
            assume HxSk: x <= ordsucc k.
            claim Lk: nat_p k.
            { exact omega_nat_p k Hk. }
            claim LkS: SNo k.
            { exact nat_p_SNo k Lk. }
            witness k.
            apply andI.
            + prove k :e SNoL_pos x.
              prove k :e {w :e SNoL x|0 < w}.
              apply SepI.
              * { prove k :e SNoL x.
                  apply SNoL_I.
                  - exact Hx1.
                  - exact LkS.
                  - prove SNoLev k :e SNoLev x.
                    rewrite ordinal_SNoLev k (nat_p_ordinal k Lk).
                    prove k :e SNoLev x.
                    apply ordinal_trichotomy_or_impred k (SNoLev x) (nat_p_ordinal k Lk) (SNoLev_ordinal x Hx1).
                    + assume H4: k :e SNoLev x. exact H4.
                    + assume H4: k = SNoLev x. prove False.
                      apply SNoLt_irref k.
                      apply SNoLtLe_tra k x k LkS Hx1 LkS Hkx.
                      prove x <= k.
                      apply ordinal_SNoLev_max_2 k (nat_p_ordinal k Lk) x Hx1.
                      rewrite <- H4. apply ordsuccI2.
                    + assume H4: SNoLev x :e k. prove False.
                      apply SNoLt_irref k.
                      apply SNoLt_tra k x k LkS Hx1 LkS Hkx.
                      prove x < k.
                      exact ordinal_SNoLev_max k (nat_p_ordinal k Lk) x Hx1 H4.
                  - prove k < x. exact Hkx.
                }
              * prove 0 < k.
                apply SNoLtLe_tra 0 2 k SNo_0 SNo_2 LkS SNoLt_0_2.
                prove 2 <= k. exact H2k.
            + prove x < 2 * k.
              rewrite <- add_SNo_1_1_2.
              rewrite mul_SNo_distrR 1 1 k SNo_1 SNo_1 LkS.
              rewrite mul_SNo_oneL k LkS.
              prove x < k + k.
              apply SNoLeLt_tra x (ordsucc k) (k + k) Hx1 (nat_p_SNo (ordsucc k) (nat_ordsucc k Lk)) (SNo_add_SNo k k LkS LkS) HxSk.
              prove ordsucc k < k + k.
              rewrite ordinal_ordsucc_SNo_eq k (nat_p_ordinal k Lk).
              prove 1 + k < k + k.
              apply add_SNo_Lt1 1 k k SNo_1 LkS LkS.
              prove 1 < k.
              apply SNoLtLe_tra 1 2 k SNo_1 SNo_2 LkS SNoLt_1_2.
              prove 2 <= k. exact H2k.
        }
  - let m. assume Hm.
    assume IHm: eps_ m < x -> exists w :e SNoL_pos x, x < 2 * w.
    assume H1: eps_ (ordsucc m) < x.
    claim Lm: m :e omega.
    { exact nat_p_omega m Hm. }
    claim Lem: SNo (eps_ m).
    { exact SNo_eps_ m Lm. }
    apply SNoLt_trichotomy_or_impred x (eps_ m) Hx1 Lem.
    + assume H2: x < eps_ m.
      claim LSm: ordsucc m :e omega.
      { exact omega_ordsucc m Lm. }
      claim LeSm: SNo (eps_ (ordsucc m)).
      { exact SNo_eps_ (ordsucc m) LSm. }
      witness (eps_ (ordsucc m)).
      apply andI.
      * { prove eps_ (ordsucc m) :e SNoL_pos x.
          prove eps_ (ordsucc m) :e {w :e SNoL x|0 < w}.
          apply SepI.
          - prove eps_ (ordsucc m) :e SNoL x.
            apply SNoL_I x Hx1 (eps_ (ordsucc m)) LeSm.
            + prove SNoLev (eps_ (ordsucc m)) :e SNoLev x.
              apply SNoLtE x (eps_ m) Hx1 Lem H2.
              * let z.
                assume Hz1: SNo z.
                assume Hz2: SNoLev z :e SNoLev x :/\: SNoLev (eps_ m).
                assume Hz3: SNoEq_ (SNoLev z) z x.
                assume Hz4: SNoEq_ (SNoLev z) z (eps_ m).
                assume Hz5: x < z.
                assume Hz6: z < eps_ m.
                assume Hz7: SNoLev z /:e x.
                assume Hz8: SNoLev z :e eps_ m.
                prove False.
                claim Lz0: z = 0.
                { apply SNoLev_0_eq_0 z Hz1.
                  prove SNoLev z = 0.
                  apply eps_ordinal_In_eq_0 m.
                  - prove ordinal (SNoLev z). exact SNoLev_ordinal z Hz1.
                  - prove SNoLev z :e eps_ m. exact Hz8.
                }
                apply SNoLt_irref x.
                apply SNoLt_tra x z x Hx1 Hz1 Hx1 Hz5.
                prove z < x.
                rewrite Lz0.
                exact Hxpos.
              * assume H3: SNoLev x :e SNoLev (eps_ m).
                assume H4: SNoEq_ (SNoLev x) x (eps_ m).
                assume H5: SNoLev x :e eps_ m.
                prove False.
                claim Lx0: x = 0.
                { apply SNoLev_0_eq_0 x Hx1.
                  prove SNoLev x = 0.
                  apply eps_ordinal_In_eq_0 m.
                  - prove ordinal (SNoLev x). exact SNoLev_ordinal x Hx1.
                  - prove SNoLev x :e eps_ m. exact H5.
                }
                apply SNoLt_irref x.
                rewrite Lx0 at 1.
                exact Hxpos.
              * { rewrite SNoLev_eps_ m Lm.
                  assume H3: ordsucc m :e SNoLev x.
                  assume H4: SNoEq_ (ordsucc m) x (eps_ m).
                  assume H5: ordsucc m /:e x.
                  apply SNoLtE (eps_ (ordsucc m)) x LeSm Hx1 H1.
                  - let z.
                    assume Hz1: SNo z.
                    rewrite SNoLev_eps_ (ordsucc m) LSm.
                    assume Hz2: SNoLev z :e ordsucc (ordsucc m) :/\: SNoLev x.
                    assume Hz3: SNoEq_ (SNoLev z) z (eps_ (ordsucc m)).
                    assume Hz4: SNoEq_ (SNoLev z) z x.
                    assume Hz5: eps_ (ordsucc m) < z.
                    assume Hz6: z < x.
                    assume Hz7: SNoLev z /:e eps_ (ordsucc m).
                    assume Hz8: SNoLev z :e x.
                    prove False.
                    apply ordsuccE (ordsucc m) (SNoLev z) (binintersectE1 (ordsucc (ordsucc m)) (SNoLev x) (SNoLev z) Hz2).
                    + assume H6: SNoLev z :e ordsucc m.
                      claim Lz0: z = 0.
                      { apply SNoLev_0_eq_0 z Hz1.
                        prove SNoLev z = 0.
                        apply eps_ordinal_In_eq_0 m.
                        - prove ordinal (SNoLev z). exact SNoLev_ordinal z Hz1.
                        - prove SNoLev z :e eps_ m.
                          apply H4 (SNoLev z) H6.
                          assume H7 _. apply H7.
                          prove SNoLev z :e x. exact Hz8.
                      }
                      apply SNoLt_irref (eps_ (ordsucc m)).
                      apply SNoLt_tra (eps_ (ordsucc m)) z (eps_ (ordsucc m)) LeSm Hz1 LeSm Hz5.
                      prove z < eps_ (ordsucc m).
                      rewrite Lz0.
                      exact SNo_eps_pos (ordsucc m) LSm.
                    + assume H6: SNoLev z = ordsucc m.
                      apply H5. rewrite <- H6.
                      exact Hz8.
                  - assume H6: SNoLev (eps_ (ordsucc m)) :e SNoLev x.
                    assume H7: SNoEq_ (SNoLev (eps_ (ordsucc m))) (eps_ (ordsucc m)) x.
                    assume H8: SNoLev (eps_ (ordsucc m)) :e x.
                    exact H6.
                  - rewrite SNoLev_eps_ (ordsucc m) LSm.
                    assume H6: SNoLev x :e ordsucc (ordsucc m).
                    assume H7: SNoEq_ (SNoLev x) (eps_ (ordsucc m)) x.
                    assume H8: SNoLev x /:e eps_ (ordsucc m).
                    prove False.
                    apply ordsuccE (ordsucc m) (SNoLev x) H6.
                    + assume H9: SNoLev x :e ordsucc m.
                      exact In_no2cycle (SNoLev x) (ordsucc m) H9 H3.
                    + assume H9: SNoLev x = ordsucc m.
                      apply In_irref (SNoLev x).
                      rewrite H9 at 1.
                      exact H3.
                }
            + prove eps_ (ordsucc m) < x. exact H1.
          - prove 0 < eps_ (ordsucc m).
            exact SNo_eps_pos (ordsucc m) LSm.
        }
      * prove x < 2 * eps_ (ordsucc m).
        rewrite <- add_SNo_1_1_2.
        rewrite mul_SNo_distrR 1 1 (eps_ (ordsucc m)) SNo_1 SNo_1 LeSm.
        rewrite mul_SNo_oneL (eps_ (ordsucc m)) LeSm.
        rewrite eps_ordsucc_half_add m Hm.
        exact H2.
    + assume H2: x = eps_ m. prove False. exact Hxne m (nat_p_omega m Hm) H2.
    + assume H2: eps_ m < x. exact IHm H2.
}
claim L2: exists k :e omega, eps_ k < x.
{ apply dneg.
  assume H1: ~exists k :e omega, eps_ k < x.
  claim Lx0: 0 = x.
  { apply Hx6 0.
    - prove 0 :e SNoS_ omega.
      apply SNoS_I omega omega_ordinal 0 0.
      + prove 0 :e omega. apply nat_p_omega. exact nat_0.
      + prove SNo_ 0 0. apply ordinal_SNo_. exact ordinal_Empty.
    - prove forall k :e omega, abs_SNo (0 + - x) < eps_ k.
      let k. assume Hk.
      rewrite add_SNo_0L (- x) (SNo_minus_SNo x Hx1).
      rewrite abs_SNo_minus x Hx1.
      rewrite pos_abs_SNo x Hxpos.
      prove x < eps_ k.
      apply SNoLt_trichotomy_or_impred x (eps_ k) Hx1 (SNo_eps_ k Hk).
      + assume H2: x < eps_ k. exact H2.
      + assume H2: x = eps_ k. prove False. exact Hxne k Hk H2.
      + assume H2: eps_ k < x. prove False. apply H1.
        witness k. apply andI.
        * exact Hk.
        * exact H2.
  }
  apply SNoLt_irref x.
  rewrite <- Lx0 at 1.
  exact Hxpos.
}
apply L2.
let k. assume H. apply H.
assume Hk: k :e omega.
assume H1: eps_ k < x.
exact L1 k (omega_nat_p k Hk) H1.
Qed.

Theorem real_recip_SNo_lem1: forall x, SNo x -> x :e real -> 0 < x ->
    recip_SNo_pos x :e real
 /\ forall k, nat_p k ->
         (SNo_recipaux x recip_SNo_pos k 0 c= real)
      /\ (SNo_recipaux x recip_SNo_pos k 1 c= real).
apply SNoLev_ind.
let x. assume Hx: SNo x.
assume IHx: forall u :e SNoS_ (SNoLev x), u :e real -> 0 < u ->
    recip_SNo_pos u :e real
 /\ forall k, nat_p k ->
         (forall y :e SNo_recipaux u recip_SNo_pos k 0, y :e real)
      /\ (forall y :e SNo_recipaux u recip_SNo_pos k 1, y :e real).
assume HxR: x :e real.
assume Hxpos: 0 < x.
apply real_E x HxR.
assume _.
assume HxR2: SNoLev x :e ordsucc omega.
assume _ _ _ _ _.
claim Lmx: SNo (- x).
{ exact SNo_minus_SNo x Hx. }
claim L1: forall y :e real, forall z :e SNoS_ (SNoLev x), 0 < z -> (1 + (z + - x) * y) * recip_SNo_pos z :e real.
{ let y. assume Hy. let z. assume Hz Hzpos.
  apply SNoS_E2 (SNoLev x) (SNoLev_ordinal x Hx) z Hz.
  assume Hz1: SNoLev z :e SNoLev x.
  assume Hz2: ordinal (SNoLev z).
  assume Hz3: SNo z.
  assume Hz4: SNo_ (SNoLev z) z.
  claim LzR: z :e real.
  { apply SNoS_omega_real.
    apply SNoS_I omega omega_ordinal z (SNoLev z).
    - prove SNoLev z :e omega.
      apply ordsuccE omega (SNoLev x) HxR2.
      + assume H1: SNoLev x :e omega.
        apply nat_p_omega.
        exact nat_p_trans (SNoLev x) (omega_nat_p (SNoLev x) H1) (SNoLev z) Hz1.
      + assume H1: SNoLev x = omega. rewrite <- H1. exact Hz1.
    - exact Hz4.
  }
  apply IHx z Hz LzR Hzpos.
  assume IH1: recip_SNo_pos z :e real.
  assume _.
  apply real_mul_SNo.
  - apply real_add_SNo.
    + exact real_1.
    + apply real_mul_SNo.
      * { apply real_add_SNo.
          - exact LzR.
          - apply real_minus_SNo. exact HxR.
        }
      * exact Hy.
  - exact IH1.
}
claim L2: forall k, nat_p k ->
    (SNo_recipaux x recip_SNo_pos k 0 c= real)
 /\ (SNo_recipaux x recip_SNo_pos k 1 c= real).
{ apply nat_ind.
  + prove (SNo_recipaux x recip_SNo_pos 0 0 c= real)
       /\ (SNo_recipaux x recip_SNo_pos 0 1 c= real).
    rewrite SNo_recipaux_0.
    apply andI.
    * rewrite tuple_2_0_eq.
      let y. assume Hy: y :e {0}.
      rewrite SingE 0 y Hy.
      prove 0 :e real.
      exact real_0.
    * rewrite tuple_2_1_eq.
      let y. assume Hy: y :e 0.
      prove False. exact EmptyE y Hy.
  + let k. assume Hk: nat_p k.
    assume IHk: (SNo_recipaux x recip_SNo_pos k 0 c= real)
             /\ (SNo_recipaux x recip_SNo_pos k 1 c= real).
    apply IHk. assume IHk0 IHk1.
    rewrite SNo_recipaux_S x recip_SNo_pos k Hk.
    apply andI.
    * { rewrite tuple_2_0_eq.
        let y.
        apply binunionE'.
        - apply binunionE'.
          + exact IHk0 y.
          + assume Hy: y :e SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 0) x (SNoR x) recip_SNo_pos.
            apply SNo_recipauxset_E (SNo_recipaux x recip_SNo_pos k 0) x (SNoR x) recip_SNo_pos y Hy.
            let u. assume Hu: u :e SNo_recipaux x recip_SNo_pos k 0.
            let z. assume Hz: z :e SNoR x.
            assume Hye: y = (1 + (z + - x) * u) * recip_SNo_pos z.
            apply SNoR_E x Hx z Hz.
            assume Hz1: SNo z.
            assume Hz2: SNoLev z :e SNoLev x.
            assume Hz3: x < z.
            rewrite Hye.
            apply L1.
            * prove u :e real. exact IHk0 u Hu.
            * prove z :e SNoS_ (SNoLev x).
              exact SNoS_I2 z x Hz1 Hx Hz2.
            * prove 0 < z.
              exact SNoLt_tra 0 x z SNo_0 Hx Hz1 Hxpos Hz3.
        - assume Hy: y :e SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 1) x (SNoL_pos x) recip_SNo_pos.
          apply SNo_recipauxset_E (SNo_recipaux x recip_SNo_pos k 1) x (SNoL_pos x) recip_SNo_pos y Hy.
          let u. assume Hu: u :e SNo_recipaux x recip_SNo_pos k 1.
          let w. assume Hw: w :e SNoL_pos x.
          assume Hye: y = (1 + (w + - x) * u) * recip_SNo_pos w.
          apply SepE (SNoL x) (fun w => 0 < w) w Hw.
          assume Hw0: w :e SNoL x.
          assume Hwpos: 0 < w.
          apply SNoL_E x Hx w Hw0.
          assume Hw1: SNo w.
          assume Hw2: SNoLev w :e SNoLev x.
          assume Hw3: w < x.
          rewrite Hye.
          apply L1.
          + prove u :e real. exact IHk1 u Hu.
          + prove w :e SNoS_ (SNoLev x).
            exact SNoS_I2 w x Hw1 Hx Hw2.
          + prove 0 < w. exact Hwpos.
      }
    * { rewrite tuple_2_1_eq.
        let y.
        apply binunionE'.
        - apply binunionE'.
          + exact IHk1 y.
          + assume Hy: y :e SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 0) x (SNoL_pos x) recip_SNo_pos.
            apply SNo_recipauxset_E (SNo_recipaux x recip_SNo_pos k 0) x (SNoL_pos x) recip_SNo_pos y Hy.
            let u. assume Hu: u :e SNo_recipaux x recip_SNo_pos k 0.
            let w. assume Hw: w :e SNoL_pos x.
            assume Hye: y = (1 + (w + - x) * u) * recip_SNo_pos w.
            apply SepE (SNoL x) (fun w => 0 < w) w Hw.
            assume Hw0: w :e SNoL x.
            assume Hwpos: 0 < w.
            apply SNoL_E x Hx w Hw0.
            assume Hw1: SNo w.
            assume Hw2: SNoLev w :e SNoLev x.
            assume Hw3: w < x.
            rewrite Hye.
            apply L1.
            * prove u :e real. exact IHk0 u Hu.
            * prove w :e SNoS_ (SNoLev x).
              exact SNoS_I2 w x Hw1 Hx Hw2.
            * prove 0 < w. exact Hwpos.
        - assume Hy: y :e SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 1) x (SNoR x) recip_SNo_pos.
          apply SNo_recipauxset_E (SNo_recipaux x recip_SNo_pos k 1) x (SNoR x) recip_SNo_pos y Hy.
          let u. assume Hu: u :e SNo_recipaux x recip_SNo_pos k 1.
          let z. assume Hz: z :e SNoR x.
          assume Hye: y = (1 + (z + - x) * u) * recip_SNo_pos z.
          apply SNoR_E x Hx z Hz.
          assume Hz1: SNo z.
          assume Hz2: SNoLev z :e SNoLev x.
          assume Hz3: x < z.
          rewrite Hye.
          apply L1.
          + prove u :e real. exact IHk1 u Hu.
          + prove z :e SNoS_ (SNoLev x).
            exact SNoS_I2 z x Hz1 Hx Hz2.
          + prove 0 < z.
            exact SNoLt_tra 0 x z SNo_0 Hx Hz1 Hxpos Hz3.
      }
}
apply andI.
- prove recip_SNo_pos x :e real.
  claim L3: forall u :e SNoS_ (SNoLev x), 0 < u -> SNo (recip_SNo_pos u) /\ u * recip_SNo_pos u = 1.
  { let u. assume Hu Hupos.
    apply SNoS_E2 (SNoLev x) (SNoLev_ordinal x Hx) u Hu.
    assume _ _.
    assume Hu1: SNo u.
    assume _.
    exact recip_SNo_pos_prop1 u Hu1 Hupos.
  }
  set L := (\/_ k :e omega, SNo_recipaux x recip_SNo_pos k 0).
  set R := (\/_ k :e omega, SNo_recipaux x recip_SNo_pos k 1).
  claim LrxLR: recip_SNo_pos x = SNoCut L R.
  { exact recip_SNo_pos_eq x Hx. }
  claim LLR: SNoCutP L R.
  { exact SNo_recipaux_lem2 x Hx Hxpos recip_SNo_pos L3. }
  apply SNoCutP_SNoCut_impred L R LLR.
  set y := SNoCut L R.
  assume HLR1: SNo y.
  assume HLR2: SNoLev y :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
  assume HLR3: forall w :e L, w < y.
  assume HLR4: forall z :e R, y < z.
  assume HLR5: forall u, SNo u -> (forall w :e L, w < u) -> (forall z :e R, u < z) -> SNoLev y c= SNoLev u /\ SNoEq_ (SNoLev y) y u.
  claim LLI: forall k :e omega, SNo_recipaux x recip_SNo_pos k 0 c= L.
  { let k. assume Hk.
    let w. assume Hw.
    prove w :e \/_ k :e omega, SNo_recipaux x recip_SNo_pos k 0.
    exact famunionI omega (fun k => SNo_recipaux x recip_SNo_pos k 0) k w Hk Hw.
  }
  claim LRI: forall k :e omega, SNo_recipaux x recip_SNo_pos k 1 c= R.
  { let k. assume Hk.
    let z. assume Hz.
    prove z :e \/_ k :e omega, SNo_recipaux x recip_SNo_pos k 1.
    exact famunionI omega (fun k => SNo_recipaux x recip_SNo_pos k 1) k z Hk Hz.
  }
  claim LLE: forall w :e L, forall p:prop, (forall k :e omega, w :e SNo_recipaux x recip_SNo_pos k 0 -> p) -> p.
  { let w. assume Hw: w :e L.
    let p. assume Hp.
    apply famunionE_impred omega (fun k => SNo_recipaux x recip_SNo_pos k 0) w Hw.
    let k. assume Hk: k :e omega.
    assume Hwk: w :e SNo_recipaux x recip_SNo_pos k 0.
    exact Hp k Hk Hwk.
  }
  claim LRE: forall z :e R, forall p:prop, (forall k :e omega, z :e SNo_recipaux x recip_SNo_pos k 1 -> p) -> p.
  { let z. assume Hz: z :e R.
    let p. assume Hp.
    apply famunionE_impred omega (fun k => SNo_recipaux x recip_SNo_pos k 1) z Hz.
    let k. assume Hk: k :e omega.
    assume Hzk: z :e SNo_recipaux x recip_SNo_pos k 1.
    exact Hp k Hk Hzk.
  }
  claim LLreal: L c= real.
  { let w. assume Hw: w :e L.
    apply LLE w Hw.
    let k. assume Hk: k :e omega.
    assume Hwk: w :e SNo_recipaux x recip_SNo_pos k 0.
    apply L2 k (omega_nat_p k Hk).
    assume H2: SNo_recipaux x recip_SNo_pos k 0 c= real.
    assume _.
    exact H2 w Hwk.
  }
  claim LRreal: R c= real.
  { let z. assume Hz: z :e R.
    apply LRE z Hz.
    let k. assume Hk: k :e omega.
    assume Hzk: z :e SNo_recipaux x recip_SNo_pos k 1.
    apply L2 k (omega_nat_p k Hk).
    assume _.
    assume H2: SNo_recipaux x recip_SNo_pos k 1 c= real.
    exact H2 z Hzk.
  }
  claim LL0: L <> 0.
  { assume H1: L = 0.
    apply EmptyE 0.
    prove 0 :e 0.
    rewrite <- H1 at 2.
    prove 0 :e L.
    apply LLI 0 (nat_p_omega 0 nat_0).
    prove 0 :e SNo_recipaux x recip_SNo_pos 0 0.
    rewrite SNo_recipaux_0. rewrite tuple_2_0_eq.
    prove 0 :e {0}. apply SingI.
  }
  apply xm (exists m :e omega, x = eps_ m).
  + assume H. apply H.
    let m. assume H. apply H.
    assume Hm: m :e omega.
    assume H1: x = eps_ m.
    prove recip_SNo_pos x :e real.
    rewrite H1.
    prove recip_SNo_pos (eps_ m) :e real.
    rewrite recip_SNo_pos_eps_ m (omega_nat_p m Hm).   
    prove 2 ^ m :e real.
    apply SNoS_omega_real.
    apply omega_SNoS_omega.
    apply nat_p_omega.
    exact nat_exp_SNo_nat 2 nat_2 m (omega_nat_p m Hm).
  + assume H1: ~(exists m :e omega, x = eps_ m).
    apply xm (x = 2).
    * assume H2: x = 2.
      rewrite H2.
      prove recip_SNo_pos 2 :e real.
      rewrite recip_SNo_pos_2.
      prove eps_ 1 :e real.
      apply SNoS_omega_real.
      apply SNo_eps_SNoS_omega.
      apply nat_p_omega. exact nat_1.
    * { assume H2: x <> 2.
        claim L4: forall m :e omega, x <> eps_ m.
        { let m. assume Hm H3.
          apply H1. witness m. apply andI.
          - exact Hm.
          - exact H3.
        }
        apply pos_real_left_approx_double x HxR Hxpos H2 L4.
        let u. assume H. apply H.
        assume Hu: u :e SNoL_pos x.
        apply SepE (SNoL x) (fun w => 0 < w) u Hu.
        assume Hua: u :e SNoL x.
        assume Hub: 0 < u.
        apply SNoL_E x Hx u Hua.
        assume Hua1: SNo u.
        assume Hua2: SNoLev u :e SNoLev x.
        assume Hua3: u < x.
        assume H3: x < 2 * u.
        claim Lru: SNo (recip_SNo_pos u).
        { exact SNo_recip_SNo_pos u Hua1 Hub. }
        claim Lumx: SNo (u + - x).
        { apply SNo_add_SNo.
          - exact Hua1.
          - exact Lmx.
        }
        set f:set -> set := fun v => (1 + (u + - x) * v) * recip_SNo_pos u.
        claim L5: forall w :e L, f w :e R.
        { let w. assume Hw.
          apply LLE w Hw.
          let k. assume Hk: k :e omega.
          assume Hwk: w :e SNo_recipaux x recip_SNo_pos k 0.
          apply LRI (ordsucc k) (omega_ordsucc k Hk).
          prove f w :e SNo_recipaux x recip_SNo_pos (ordsucc k) 1.
          rewrite SNo_recipaux_S x recip_SNo_pos k (omega_nat_p k Hk).
          rewrite tuple_2_1_eq.
          prove f w :e SNo_recipaux x recip_SNo_pos k 1
                  :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 0) x (SNoL_pos x) recip_SNo_pos
                  :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 1) x (SNoR x) recip_SNo_pos.
          apply binunionI1.
          apply binunionI2.
          prove (1 + (u + - x) * w) * recip_SNo_pos u :e SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 0) x (SNoL_pos x) recip_SNo_pos.
          apply SNo_recipauxset_I (SNo_recipaux x recip_SNo_pos k 0) x (SNoL_pos x) recip_SNo_pos w.
          - prove w :e SNo_recipaux x recip_SNo_pos k 0.
            exact Hwk.
          - exact Hu.
        }
        claim L6: forall z :e R, f z :e L.
        { let z. assume Hz.
          apply LRE z Hz.
          let k. assume Hk: k :e omega.
          assume Hzk: z :e SNo_recipaux x recip_SNo_pos k 1.
          apply LLI (ordsucc k) (omega_ordsucc k Hk).
          prove (1 + (u + - x) * z) * recip_SNo_pos u :e SNo_recipaux x recip_SNo_pos (ordsucc k) 0.
          rewrite SNo_recipaux_S x recip_SNo_pos k (omega_nat_p k Hk).
          rewrite tuple_2_0_eq.
          prove (1 + (u + - x) * z) * recip_SNo_pos u
             :e SNo_recipaux x recip_SNo_pos k 0
           :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 0) x (SNoR x) recip_SNo_pos
           :\/: SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 1) x (SNoL_pos x) recip_SNo_pos.
          apply binunionI2.
          prove (1 + (u + - x) * z) * recip_SNo_pos u :e SNo_recipauxset (SNo_recipaux x recip_SNo_pos k 1) x (SNoL_pos x) recip_SNo_pos.
          apply SNo_recipauxset_I (SNo_recipaux x recip_SNo_pos k 1) x (SNoL_pos x) recip_SNo_pos z.
          - prove z :e SNo_recipaux x recip_SNo_pos k 1.
            exact Hzk.
          - exact Hu.
        }
        claim Luu: SNo (u * u).
        { exact SNo_mul_SNo u u Hua1 Hua1. }
        claim Luupos: 0 < u * u.
        { exact mul_SNo_pos_pos u u Hua1 Hua1 Hub Hub. }
        claim Luun0: u * u <> 0.
        { assume H. apply SNoLt_irref 0. rewrite <- H at 2. exact Luupos. }
        claim L2u: SNo (2 * u).
        { exact SNo_mul_SNo 2 u SNo_2 Hua1. }
        claim Lf: forall v, SNo v -> forall p:prop, (SNo ((u + - x) * v) -> SNo (1 + ((u + - x) * v)) -> SNo (f v) -> p) -> p.
        { let v. assume Hv. let p. assume Hp.
          claim Lf1: SNo ((u + - x) * v).
          { apply SNo_mul_SNo.
            - exact Lumx.
            - exact Hv.
          }
          claim Lf2: SNo (1 + (u + - x) * v).
          { apply SNo_add_SNo.
            - exact SNo_1.
            - exact Lf1.
          }
          claim Lf3: SNo ((1 + (u + - x) * v) * recip_SNo_pos u).
          { apply SNo_mul_SNo.
            - exact Lf2.
            - exact Lru.
          }
          exact Hp Lf1 Lf2 Lf3.
        }
        claim Luf: forall v, SNo v -> u * f v = 1 + (u + - x) * v.
        { let v. assume Hv.
          apply Lf v Hv.
          assume Humxv: SNo ((u + - x) * v).
          assume H1umxv: SNo (1 + (u + - x) * v).
          assume Hfv: SNo (f v).
          prove u * ((1 + (u + - x) * v) * recip_SNo_pos u) = 1 + (u + - x) * v.
          rewrite mul_SNo_com (1 + (u + - x) * v) (recip_SNo_pos u) H1umxv Lru.
          rewrite mul_SNo_assoc u (recip_SNo_pos u) (1 + (u + - x) * v) Hua1 Lru H1umxv.
          rewrite recip_SNo_pos_invR u Hua1 Hub.
          exact mul_SNo_oneL (1 + (u + - x) * v) H1umxv.
        }
        claim L7: forall v, SNo v -> f (f v) = (v * u * u + x * x * v + 2 * u + - ((2 * u) * x * v + x)) :/: (u * u).
        { let v. assume Hv.
          set v' := f v.
          apply Lf v Hv.
          assume Humxv: SNo ((u + - x) * v).
          assume H1umxv: SNo (1 + (u + - x) * v).
          assume Hv': SNo v'.
          apply Lf v' Hv'.
          assume Humxv': SNo ((u + - x) * v').
          assume H1umxv': SNo (1 + (u + - x) * v').
          assume Hfv': SNo (f v').
          claim Lxv: SNo (x * v).
          { exact SNo_mul_SNo x v Hx Hv. }
          claim Lxxv: SNo (x * x * v).
          { exact SNo_mul_SNo x (x * v) Hx Lxv. }
          claim L2uxv: SNo ((2 * u) * x * v).
          { exact SNo_mul_SNo (2 * u) (x * v) L2u Lxv. }
          claim Lvuu: SNo (v * u * u).
          { exact SNo_mul_SNo v (u * u) Hv Luu. }
          claim Luxv: SNo (u * x * v).
          { exact SNo_mul_SNo u (x * v) Hua1 Lxv. }
          claim Luv: SNo (u * v).
          { exact SNo_mul_SNo u v Hua1 Hv. }
          claim Lxuv: SNo (x * u * v).
          { exact SNo_mul_SNo x (u * v) Hx Luv. }
          claim Lmuxv: SNo (- u * x * v).
          { exact SNo_minus_SNo (u * x * v) Luxv. }
          claim Lmxuv: SNo (- x * u * v).
          { exact SNo_minus_SNo (x * u * v) Lxuv. }
          claim Lmxmxuv: SNo (- x + - x * u * v).
          { apply SNo_add_SNo.
            - exact Lmx.
            - exact Lmxuv.
          }
          claim Lmxmxuvxxv: SNo (- x + - x * u * v + x * x * v).
          { apply SNo_add_SNo_3.
            - exact Lmx.
            - exact Lmxuv.
            - exact Lxxv.
          }
          prove f v' = (v * u * u + x * x * v + 2 * u + - ((2 * u) * x * v + x)) :/: (u * u).
          symmetry.
          apply mul_div_SNo_nonzero_eq (v * u * u + x * x * v + 2 * u + - ((2 * u) * x * v + x)) (u * u) (f v')
                           (SNo_add_SNo_4 (v * u * u) (x * x * v) (2 * u) (- ((2 * u) * x * v + x))
                                          Lvuu Lxxv L2u (SNo_minus_SNo ((2 * u) * x * v + x) (SNo_add_SNo ((2 * u) * x * v) x L2uxv Hx)))
                           Luu
                           Hfv' Luun0.
          prove v * u * u + x * x * v + 2 * u + - ((2 * u) * x * v + x) = (u * u) * f v'.
          transitivity u + u * (1 + (u + - x) * v) + - x * (1 + (u + - x) * v),
                       u + u * u * v' + - x * u * v',
                       u * (1 + (u + - x) * v'),
                       u * (u * f v').
          - prove v * u * u + x * x * v + 2 * u + - ((2 * u) * x * v + x)
                = u + u * (1 + (u + - x) * v) + - x * (1 + (u + - x) * v).
            transitivity v * u * u + u + u + - u * x * v + (- x + - x * u * v + x * x * v),
                         u + (v * u * u + u + - u * x * v) + (- x + - x * u * v + x * x * v).
            + prove v * u * u + x * x * v + 2 * u + - ((2 * u) * x * v + x)
                  = v * u * u + u + u + - u * x * v + (- x + - x * u * v + x * x * v).
              f_equal.
              prove x * x * v + 2 * u + - ((2 * u) * x * v + x)
                  = u + u + - u * x * v + (- x + - x * u * v + x * x * v).
              rewrite add_SNo_com_3_0_1 (x * x * v) (2 * u) (- ((2 * u) * x * v + x))
                                        Lxxv L2u (SNo_minus_SNo ((2 * u) * x * v + x) (SNo_add_SNo ((2 * u) * x * v) x L2uxv Hx)).
              prove 2 * u + x * x * v + - ((2 * u) * x * v + x)
                  = u + u + - u * x * v + (- x + - x * u * v + x * x * v).
              rewrite <- add_SNo_1_1_2 at 1.
              rewrite mul_SNo_distrR 1 1 u SNo_1 SNo_1 Hua1.
              rewrite mul_SNo_oneL u Hua1.
              prove (u + u) + x * x * v + - ((2 * u) * x * v + x)
                  = u + u + - u * x * v + (- x + - x * u * v + x * x * v).
              transitivity u + u + x * x * v + - ((2 * u) * x * v + x).
              * { symmetry.
                  apply add_SNo_assoc u u (x * x * v + - ((2 * u) * x * v + x)) Hua1 Hua1.
                  prove SNo (x * x * v + - ((2 * u) * x * v + x)).
                  apply SNo_add_SNo.
                  - exact Lxxv.
                  - apply SNo_minus_SNo.
                    apply SNo_add_SNo.
                    + exact L2uxv.
                    + exact Hx.
                }
              * { f_equal. f_equal.
                  prove x * x * v + - ((2 * u) * x * v + x) = - u * x * v + (- x + - x * u * v + x * x * v).
                  transitivity x * x * v + - u * x * v + - x + - x * u * v.
                  - prove x * x * v + - ((2 * u) * x * v + x) = x * x * v + - u * x * v + - x + - x * u * v.
                    f_equal.
                    prove - ((2 * u) * x * v + x) = - u * x * v + - x + - x * u * v.
                    rewrite <- minus_add_SNo_distr_3 (u * x * v) x (x * u * v) Luxv Hx Lxuv.
                    prove - ((2 * u) * x * v + x) = - (u * x * v + x + x * u * v).
                    f_equal.
                    prove (2 * u) * x * v + x = u * x * v + x + x * u * v.
                    rewrite mul_SNo_com_3_0_1 x u v Hx Hua1 Hv.
                    prove (2 * u) * x * v + x = u * x * v + x + u * x * v.
                    rewrite add_SNo_com x (u * x * v) Hx Luxv.
                    rewrite add_SNo_assoc (u * x * v) (u * x * v) x Luxv Luxv Hx.
                    f_equal.
                    prove (2 * u) * x * v = u * x * v + u * x * v.
                    rewrite <- add_SNo_1_1_2 at 1.
                    rewrite mul_SNo_distrR 1 1 u SNo_1 SNo_1 Hua1.
                    rewrite mul_SNo_oneL u Hua1.
                    prove (u + u) * x * v = u * x * v + u * x * v.
                    exact mul_SNo_distrR u u (x * v) Hua1 Hua1 Lxv.
                  - prove x * x * v + - u * x * v + - x + - x * u * v = - u * x * v + (- x + - x * u * v + x * x * v).
                    rewrite add_SNo_com_3_0_1 (x * x * v) (- u * x * v) (- x + - x * u * v)
                                              Lxxv Lmuxv Lmxmxuv.
                    f_equal.
                    prove x * x * v + - x + - x * u * v = - x + - x * u * v + x * x * v.
                    rewrite add_SNo_com_3_0_1 (x * x * v) (- x) (- x * u * v) Lxxv Lmx Lmxuv.
                    f_equal.
                    prove x * x * v + - x * u * v = - x * u * v + x * x * v.
                    exact add_SNo_com (x * x * v) (- x * u * v) Lxxv Lmxuv.
                }
            + prove v * u * u + u + u + - u * x * v + (- x + - x * u * v + x * x * v)
                  = u + (v * u * u + u + - u * x * v) + (- x + - x * u * v + x * x * v).
              rewrite add_SNo_com_3_0_1 (v * u * u) u (u + - u * x * v + (- x + - x * u * v + x * x * v)) Lvuu Hua1.
              * { prove u + v * u * u + u + - u * x * v + (- x + - x * u * v + x * x * v)
                      = u + (v * u * u + u + - u * x * v) + (- x + - x * u * v + x * x * v).
                  f_equal.
                  prove v * u * u + u + - u * x * v + (- x + - x * u * v + x * x * v)
                      = (v * u * u + u + - u * x * v) + (- x + - x * u * v + x * x * v).
                  apply add_SNo_assoc_4.
                  - exact Lvuu.
                  - exact Hua1.
                  - exact Lmuxv.
                  - exact Lmxmxuvxxv.
                }
              * { apply SNo_add_SNo_3.
                  - exact Hua1.
                  - exact Lmuxv.
                  - exact Lmxmxuvxxv.
                }
            + prove u + (v * u * u + u + - u * x * v) + (- x + - x * u * v + x * x * v)
                  = u + u * (1 + (u + - x) * v) + - x * (1 + (u + - x) * v).
              f_equal. f_equal.
              * { prove v * u * u + u + - u * x * v = u * (1 + (u + - x) * v).
                  rewrite mul_SNo_distrL u 1 ((u + - x) * v) Hua1 SNo_1 Humxv.
                  prove v * u * u + u + - u * x * v = u * 1 + u * (u + - x) * v.
                  rewrite mul_SNo_oneR u Hua1.
                  prove v * u * u + u + - u * x * v = u + u * (u + - x) * v.
                  rewrite add_SNo_com_3_0_1 (v * u * u) u (- u * x * v) Lvuu Hua1 (SNo_minus_SNo (u * x * v) Luxv).
                  prove u + v * u * u + - u * x * v = u + u * (u + - x) * v.
                  f_equal.
                  prove v * u * u + - u * x * v = u * (u + - x) * v.
                  rewrite mul_SNo_distrR u (- x) v Hua1 Lmx Hv.
                  prove v * u * u + - u * x * v = u * (u * v + (- x) * v).
                  rewrite mul_SNo_distrL u (u * v) ((- x) * v) Hua1 Luv (SNo_mul_SNo (- x) v Lmx Hv).
                  prove v * u * u + - u * x * v = u * u * v + u * (- x) * v.
                  f_equal.
                  - prove v * u * u = u * u * v.
                    rewrite mul_SNo_com u v Hua1 Hv.
                    exact mul_SNo_com_3_0_1 v u u Hv Hua1 Hua1.
                  - prove - u * x * v = u * (- x) * v.
                    rewrite mul_SNo_minus_distrL x v Hx Hv.
                    symmetry.
                    exact mul_SNo_minus_distrR u (x * v) Hua1 Lxv.
                }
              * { prove - x + - x * u * v + x * x * v = - x * (1 + (u + - x) * v).
                  rewrite <- mul_SNo_minus_distrL x (1 + (u + - x) * v) Hx H1umxv.
                  prove - x + - x * u * v + x * x * v = (- x) * (1 + (u + - x) * v).
                  apply mul_SNo_distrL (- x) 1 ((u + - x) * v) Lmx SNo_1 Humxv (fun w z => - x + - x * u * v + x * x * v = z).
                  prove - x + - x * u * v + x * x * v = (- x) * 1 + (- x) * (u + - x) * v.
                  rewrite mul_SNo_oneR (- x) Lmx.
                  prove - x + - x * u * v + x * x * v = - x + (- x) * (u + - x) * v.
                  f_equal.
                  prove - x * u * v + x * x * v = (- x) * (u + - x) * v.
                  rewrite mul_SNo_distrR u (- x) v Hua1 Lmx Hv.
                  rewrite mul_SNo_distrL (- x) (u * v) ((- x) * v) Lmx Luv (SNo_mul_SNo (- x) v Lmx Hv).
                  prove - x * u * v + x * x * v = (- x) * u * v + (- x) * (- x) * v.
                  rewrite mul_SNo_minus_distrL x (u * v) Hx Luv.
                  prove - x * u * v + x * x * v = - x * u * v + (- x) * (- x) * v.
                  f_equal.
                  prove x * x * v = (- x) * (- x) * v.
                  rewrite mul_SNo_assoc (- x) (- x) v Lmx Lmx Hv.
                  rewrite mul_SNo_minus_minus x x Hx Hx.
                  exact mul_SNo_assoc x x v Hx Hx Hv.
                }
          - prove u + u * (1 + (u + - x) * v) + - x * (1 + (u + - x) * v)
                = u + u * u * v' + - x * u * v'.
            exact Luf v Hv (fun w z => u + u * w + - x * w = u + u * u * v' + - x * u * v') (fun q H => H).
          - prove u + u * u * v' + - x * u * v' = u * (1 + (u + - x) * v').
            apply mul_SNo_distrL u 1 ((u + - x) * v') Hua1 SNo_1 Humxv' (fun w z => u + u * u * v' + - x * u * v' = z).
            prove u + u * u * v' + - x * u * v' = u * 1 + u * (u + - x) * v'.
            rewrite mul_SNo_oneR u Hua1.
            f_equal.
            prove u * u * v' + - x * u * v' = u * (u + - x) * v'.
            apply mul_SNo_distrR u (- x) v' Hua1 Lmx Hv' (fun w z => u * u * v' + - x * u * v' = u * z).
            prove u * u * v' + - x * u * v' = u * (u * v' + (- x) * v').
            apply mul_SNo_distrL u (u * v') ((- x) * v') Hua1 (SNo_mul_SNo u v' Hua1 Hv') (SNo_mul_SNo (- x) v' Lmx Hv') (fun w z => u * u * v' + - x * u * v' = z).
            prove u * u * v' + - x * u * v' = u * u * v' + u * (- x) * v'.
            f_equal.
            prove - x * u * v' = u * (- x) * v'.
            apply mul_SNo_com_3_0_1 u (- x) v' Hua1 Lmx Hv' (fun w z => - x * u * v' = z).
            prove - x * u * v' = (- x) * u * v'.
            symmetry.
            exact mul_SNo_minus_distrL x (u * v') Hx (SNo_mul_SNo u v' Hua1 Hv').
          - f_equal. symmetry. exact Luf v' Hv'.
          - exact mul_SNo_assoc u u (f v') Hua1 Hua1 Hfv'.
        }
        claim L8: forall w :e L, exists w' :e L, w < w'.
        { let w. assume Hw.
          claim Lw: SNo w.
          { apply real_SNo. exact LLreal w Hw. }
          claim Lxw: SNo (x * w).
          { exact SNo_mul_SNo x w Hx Lw. }
          claim Lxxw: SNo (x * x * w).
          { exact SNo_mul_SNo x (x * w) Hx Lxw. }
          claim L2uxw: SNo ((2 * u) * x * w).
          { exact SNo_mul_SNo (2 * u) (x * w) L2u Lxw. }
          claim Lwuu: SNo (w * u * u).
          { exact SNo_mul_SNo w (u * u) Lw Luu. }
          witness f (f w). apply andI.
          - apply L6. apply L5. exact Hw.
          - prove w < f (f w).
            claim L8a: w < (w * u * u + x * x * w + 2 * u + - ((2 * u) * x * w + x)) :/: (u * u).
            { prove w < (w * u * u + x * x * w + 2 * u + - ((2 * u) * x * w + x)) :/: (u * u).
              apply div_SNo_pos_LtR (w * u * u + x * x * w + 2 * u + - ((2 * u) * x * w + x)) (u * u) w.
              + exact SNo_add_SNo_4 (w * u * u) (x * x * w) (2 * u) (- ((2 * u) * x * w + x))
                                    Lwuu Lxxw L2u
                                    (SNo_minus_SNo ((2 * u) * x * w + x) (SNo_add_SNo ((2 * u) * x * w) x L2uxw Hx)).
              + exact Luu.
              + exact Lw.
              + prove 0 < u * u. exact Luupos.
              + prove w * u * u < w * u * u + x * x * w + 2 * u + - ((2 * u) * x * w + x).
                rewrite <- add_SNo_0R (w * u * u) at 1.
                * { prove w * u * u + 0 < w * u * u + x * x * w + 2 * u + - ((2 * u) * x * w + x).
                    apply add_SNo_Lt2.
                    - exact Lwuu.
                    - exact SNo_0.
                    - exact SNo_add_SNo_3 (x * x * w) (2 * u) (- ((2 * u) * x * w + x))
                                    Lxxw L2u
                                    (SNo_minus_SNo ((2 * u) * x * w + x) (SNo_add_SNo ((2 * u) * x * w) x L2uxw Hx)).
                    - prove 0 < x * x * w + 2 * u + - ((2 * u) * x * w + x).
                      apply add_SNo_minus_Lt2b3.
                      + exact Lxxw.
                      + exact L2u.
                      + exact SNo_add_SNo ((2 * u) * x * w) x L2uxw Hx.
                      + exact SNo_0.
                      + prove 0 + (2 * u) * x * w + x < x * x * w + 2 * u.
                        rewrite add_SNo_0L.
                        * { prove (2 * u) * x * w + x < x * x * w + 2 * u.
                            rewrite add_SNo_com ((2 * u) * x * w) x (SNo_mul_SNo (2 * u) (x * w) L2u Lxw) Hx.
                            rewrite add_SNo_com (x * x * w) (2 * u) Lxxw L2u.
                            rewrite <- mul_SNo_oneR x Hx at 1.
                            prove x * 1 + (2 * u) * x * w < 2 * u + x * x * w.
                            rewrite <- mul_SNo_oneR (2 * u) L2u at 2.
                            prove x * 1 + (2 * u) * x * w < (2 * u) * 1 + x * x * w.
                            apply mul_SNo_Lt.
                            - exact L2u.
                            - exact SNo_1.
                            - exact Hx.
                            - exact Lxw.
                            - prove x < 2 * u. exact H3.
                            - prove x * w < 1.
                              rewrite mul_SNo_com x w Hx Lw.
                              apply div_SNo_pos_LtR'.
                              + exact SNo_1.
                              + exact Hx.
                              + exact Lw.
                              + prove 0 < x. exact Hxpos.
                              + prove w < 1 :/: x.
                                prove w < 1 * recip_SNo x.
                                rewrite mul_SNo_oneL (recip_SNo x) (SNo_recip_SNo x Hx).
                                rewrite recip_SNo_poscase x Hxpos.
                                prove w < recip_SNo_pos x.
                                rewrite LrxLR.
                                prove w < y.
                                apply HLR3. exact Hw.
                          }
                        * exact SNo_add_SNo ((2 * u) * x * w) x (SNo_mul_SNo (2 * u) (x * w) L2u Lxw) Hx.
                  }
                * exact Lwuu.
            }
            exact L7 w Lw (fun u v => w < v) L8a.
        }
        claim L9: forall z :e R, exists z' :e R, z' < z.
        { let z. assume Hz.
          claim Lz: SNo z.
          { apply real_SNo. exact LRreal z Hz. }
          claim Lxz: SNo (x * z).
          { exact SNo_mul_SNo x z Hx Lz. }
          claim Lxxz: SNo (x * x * z).
          { exact SNo_mul_SNo x (x * z) Hx Lxz. }
          claim L2uxz: SNo ((2 * u) * x * z).
          { exact SNo_mul_SNo (2 * u) (x * z) L2u Lxz. }
          claim Lzuu: SNo (z * u * u).
          { exact SNo_mul_SNo z (u * u) Lz Luu. }
          witness f (f z). apply andI.
          - apply L5. apply L6. exact Hz.
          - prove f (f z) < z.
            claim L9a: (z * u * u + x * x * z + 2 * u + - ((2 * u) * x * z + x)) :/: (u * u) < z.
            { apply div_SNo_pos_LtL (z * u * u + x * x * z + 2 * u + - ((2 * u) * x * z + x)) (u * u) z.
              + exact SNo_add_SNo_4 (z * u * u) (x * x * z) (2 * u) (- ((2 * u) * x * z + x))
                                    Lzuu Lxxz L2u
                                    (SNo_minus_SNo ((2 * u) * x * z + x) (SNo_add_SNo ((2 * u) * x * z) x L2uxz Hx)).
              + exact Luu.
              + exact Lz.
              + prove 0 < u * u. exact Luupos.
              + prove z * u * u + x * x * z + 2 * u + - ((2 * u) * x * z + x) < z * u * u.
                rewrite <- add_SNo_0R (z * u * u) at 2.
                * { prove z * u * u + x * x * z + 2 * u + - ((2 * u) * x * z + x) < z * u * u + 0.
                    apply add_SNo_Lt2.
                    - exact Lzuu.
                    - exact SNo_add_SNo_3 (x * x * z) (2 * u) (- ((2 * u) * x * z + x))
                                    Lxxz L2u
                                    (SNo_minus_SNo ((2 * u) * x * z + x) (SNo_add_SNo ((2 * u) * x * z) x L2uxz Hx)).
                    - exact SNo_0.
                    - prove x * x * z + 2 * u + - ((2 * u) * x * z + x) < 0.
                      apply add_SNo_minus_Lt1b3.
                      + exact Lxxz.
                      + exact L2u.
                      + exact SNo_add_SNo ((2 * u) * x * z) x L2uxz Hx.
                      + exact SNo_0.
                      + prove x * x * z + 2 * u < 0 + (2 * u) * x * z + x.
                        rewrite add_SNo_0L.
                        * { prove x * x * z + 2 * u < (2 * u) * x * z + x.
                            rewrite <- mul_SNo_oneR x Hx at 4.
                            prove x * x * z + 2 * u < (2 * u) * x * z + x * 1.
                            rewrite <- mul_SNo_oneR (2 * u) L2u at 1.
                            prove x * x * z + (2 * u) * 1 < (2 * u) * x * z + x * 1.
                            apply mul_SNo_Lt.
                            - exact L2u.
                            - exact Lxz.
                            - exact Hx.
                            - exact SNo_1.
                            - prove x < 2 * u. exact H3.
                            - prove 1 < x * z.
                              rewrite mul_SNo_com x z Hx Lz.
                              prove 1 < z * x.
                              apply div_SNo_pos_LtL'.
                              + exact SNo_1.
                              + exact Hx.
                              + exact Lz.
                              + prove 0 < x. exact Hxpos.
                              + prove 1 :/: x < z.
                                prove 1 * recip_SNo x < z.
                                rewrite mul_SNo_oneL (recip_SNo x) (SNo_recip_SNo x Hx).
                                rewrite recip_SNo_poscase x Hxpos.
                                prove recip_SNo_pos x < z.
                                rewrite LrxLR.
                                prove y < z.
                                apply HLR4. exact Hz.
                          }
                        * exact SNo_add_SNo ((2 * u) * x * z) x (SNo_mul_SNo (2 * u) (x * z) L2u Lxz) Hx.
                  }
                * exact Lzuu.
            }
            exact L7 z Lz (fun u v => v < z) L9a.
        }
        prove recip_SNo_pos x :e real.
        rewrite recip_SNo_pos_eq x Hx.
        prove SNoCut L R :e real.
        apply real_SNoCut.
        - exact LLreal.
        - exact LRreal.
        - exact LLR.
        - exact LL0.
        - prove R <> 0.
          assume H4: R = 0.
          apply EmptyE ((1 + (u + - x) * 0) * recip_SNo_pos u).
          prove (1 + (u + - x) * 0) * recip_SNo_pos u :e 0.
          rewrite <- H4 at 3.
          prove (1 + (u + - x) * 0) * recip_SNo_pos u :e R.
          apply L5 0.
          prove 0 :e L.
          apply LLI 0 (nat_p_omega 0 nat_0).
          prove 0 :e SNo_recipaux x recip_SNo_pos 0 0.
          rewrite SNo_recipaux_0 x recip_SNo_pos.
          rewrite tuple_2_0_eq.
          prove 0 :e {0}.
          apply SingI.
        - prove forall w :e L, exists w' :e L, w < w'.
          exact L8.
        - prove forall z :e R, exists z' :e R, z' < z.
          exact L9.
      }
- exact L2.
Qed.

Theorem real_recip_SNo_pos: forall x :e real, 0 < x -> recip_SNo_pos x :e real.
let x. assume Hx Hxpos.
apply real_recip_SNo_lem1 x (real_SNo x Hx) Hx Hxpos.
assume H _. exact H.
Qed.

Theorem real_recip_SNo: forall x :e real, recip_SNo x :e real.
let x. assume Hx.
claim Lx: SNo x.
{ exact real_SNo x Hx. }
apply SNoLt_trichotomy_or_impred x 0 Lx SNo_0.
- assume H1: x < 0.
  rewrite recip_SNo_negcase x Lx H1.
  prove - recip_SNo_pos (- x) :e real.
  apply real_minus_SNo (recip_SNo_pos (- x)).
  prove recip_SNo_pos (- x) :e real.
  apply real_recip_SNo_pos (- x).
  + prove - x :e real.
    exact real_minus_SNo x Hx.
  + prove 0 < - x.
    apply minus_SNo_Lt_contra2 x 0 Lx SNo_0.
    prove x < - 0.
    rewrite minus_SNo_0.
    exact H1.
- assume H1: x = 0. rewrite H1. rewrite recip_SNo_0.
  prove 0 :e real.
  exact real_0.
- assume H1: 0 < x.
  rewrite recip_SNo_poscase x H1.
  exact real_recip_SNo_pos x Hx H1.
Qed.

Theorem real_div_SNo: forall x y :e real, x :/: y :e real.
let x. assume Hx. let y. assume Hy.
prove x * recip_SNo y :e real.
apply real_mul_SNo.
- exact Hx.
- apply real_recip_SNo. exact Hy.
Qed.

End Reals.

Opaque real.

Section even_odd.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Theorem nat_le2_cases: forall m, nat_p m -> m c= 2 -> m = 0 \/ m = 1 \/ m = 2.
apply nat_inv_impred.
- assume _. apply orIL. apply orIL. reflexivity.
- apply nat_inv_impred.
  + assume _. apply orIL. apply orIR. reflexivity.
  + apply nat_inv_impred.
    * assume _. apply orIR. reflexivity.
    * let m. assume Hm.
      assume H1: ordsucc (ordsucc (ordsucc m)) c= 2.
      prove False.
      apply In_irref 2.
      prove 2 :e 2.
      apply H1.
      prove 2 :e ordsucc (ordsucc (ordsucc m)).
      apply nat_ordsucc_in_ordsucc (ordsucc (ordsucc m)) (nat_ordsucc (ordsucc m) (nat_ordsucc m Hm)).
      prove 1 :e ordsucc (ordsucc m).
      apply nat_ordsucc_in_ordsucc (ordsucc m) (nat_ordsucc m Hm).
      prove 0 :e ordsucc m.
      exact nat_0_in_ordsucc m Hm.
Qed.

Theorem prime_nat_2_lem: forall m, nat_p m -> forall n, nat_p n -> m * n = 2 -> m = 1 \/ m = 2.
let m. assume Hm. let n. assume Hn.
assume H1: m * n = 2.
claim L1: m c= 2.
{ apply mul_nat_0_or_Subq m Hm n Hn.
  - assume H2: n = 0. prove False.
    apply neq_2_0.
    prove 2 = 0.
    rewrite <- H1.
    prove m * n = 0.
    rewrite H2.
    prove m * 0 = 0.
    apply mul_nat_0R.
  - assume H2: m c= m * n.
    prove m c= 2.
    rewrite <- H1. exact H2.
}
apply nat_le2_cases m Hm L1.
- assume H. apply H.
  + assume H2: m = 0. prove False.
    apply neq_2_0.
    prove 2 = 0.
    rewrite <- H1.
    prove m * n = 0.
    rewrite H2.
    prove 0 * n = 0.
    exact mul_nat_0L n Hn.
  + assume H2: m = 1. apply orIL. exact H2.
- assume H2: m = 2. apply orIR. exact H2.
Qed.

Theorem prime_nat_2: prime_nat 2.
prove 2 :e omega /\ 1 :e 2 /\ forall k :e omega, divides_nat k 2 -> k = 1 \/ k = 2.
apply and3I.
- prove 2 :e omega. apply nat_p_omega. exact nat_2.
- exact In_1_2.
- let k. assume Hk: k :e omega.
  assume Hk2: divides_nat k 2.
  prove k = 1 \/ k = 2.
  apply Hk2. assume _.
  assume H. apply H.
  let n. assume H. apply H.
  assume Hn: n :e omega.
  assume Hkn: k * n = 2.
  exact prime_nat_2_lem k (omega_nat_p k Hk) n (omega_nat_p n Hn) Hkn.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Theorem not_eq_2m_2n1: forall m n :e int, 2 * m <> 2 * n + 1.
let m. assume Hm: m :e int.
let n. assume Hn: n :e int.
assume H1: 2 * m = 2 * n + 1.
apply prime_not_divides_int_1 2 prime_nat_2.
prove divides_int 2 1.
claim LmS: SNo m.
{ exact int_SNo m Hm. }
claim LnS: SNo n.
{ exact int_SNo n Hn. }
claim L2nS: SNo (2 * n).
{ exact SNo_mul_SNo 2 n SNo_2 LnS. }
claim L2mS: SNo (2 * m).
{ exact SNo_mul_SNo 2 m SNo_2 LmS. }
claim Lm2nS: SNo (- 2 * n).
{ exact SNo_minus_SNo (2 * n) L2nS. }
claim L1: 2 * n + 2 * m + - 2 * n = 2 * n + 1.
{ rewrite <- H1.
  prove 2 * n + 2 * m + - 2 * n = 2 * m.
  rewrite add_SNo_rotate_3_1 (2 * n) (2 * m) (- 2 * n) L2nS L2mS Lm2nS.
  prove - 2 * n + 2 * n + 2 * m = 2 * m.
  exact add_SNo_minus_L2 (2 * n) (2 * m) L2nS L2mS.
}
claim L2: 2 * (m + - n) = 1.
{ rewrite mul_SNo_distrL 2 m (- n) SNo_2 LmS (SNo_minus_SNo n LnS).
  rewrite mul_SNo_minus_distrR 2 n SNo_2 LnS.
  prove 2 * m + - 2 * n = 1.
  exact add_SNo_cancel_L (2 * n) (2 * m + - 2 * n) 1 L2nS (SNo_add_SNo (2 * m) (- 2 * n) L2mS Lm2nS) SNo_1 L1.
}
rewrite <- L2 at 2.
prove divides_int 2 (2 * (m + - n)).
apply divides_int_mul_SNo_L 2 2 (m + - n) (int_add_SNo m Hm (- n) (int_minus_SNo n Hn)).
prove divides_int 2 2.
apply divides_int_ref 2.
prove 2 :e int.
apply Subq_omega_int. apply nat_p_omega. exact nat_2.
Qed.

End even_odd.

Section form100_22b.

Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Theorem atleastp_SNoS_ordsucc_omega_Power_omega: atleastp (SNoS_ (ordsucc omega)) (Power omega).
set f:set->set := fun u => {2 * n|n :e omega, n :e u} :\/: {2 * n + 1|n :e omega, n ' :e u}.
claim L1: forall u v, SNoLev u c= omega -> u c= SNoElts_ (SNoLev u) -> f u = f v -> u c= v.
{ let u v.
  assume HLuo: SNoLev u c= omega.
  assume HuELu: u c= SNoElts_ (SNoLev u).
  assume Huv: f u = f v.
  let x. assume Hx: x :e u.
  prove x :e v.
  apply binunionE (SNoLev u) {n '|n :e SNoLev u} x (HuELu x Hx).
  - assume H1: x :e SNoLev u.
    claim Lx: x :e omega.
    { exact HLuo x H1. }
    claim L2x: 2 * x :e f v.
    { rewrite <- Huv.
      prove 2 * x :e f u.
      prove 2 * x :e {2 * n|n :e omega, n :e u} :\/: {2 * n + 1|n :e omega, n ' :e u}.
      apply binunionI1.
      apply ReplSepI.
      - prove x :e omega. exact Lx.
      - prove x :e u. exact Hx.
    }
    apply binunionE {2 * n|n :e omega, n :e v} {2 * n + 1|n :e omega, n ' :e v} (2 * x) L2x.
    + assume H2: 2 * x :e {2 * n|n :e omega, n :e v}.
      apply ReplSepE_impred omega (fun n => n :e v) (fun n => 2 * n) (2 * x) H2.
      let n.
      assume Hn: n :e omega.
      assume Hnv: n :e v.
      assume H2x2n: 2 * x = 2 * n.
      claim Lxn: x = n.
      { exact mul_SNo_nonzero_cancel_L 2 x n SNo_2 neq_2_0 (omega_SNo x Lx) (omega_SNo n Hn) H2x2n. }
      prove x :e v.
      rewrite Lxn. exact Hnv.
    + assume H2: 2 * x :e {2 * n + 1|n :e omega, n ' :e v}.
      prove False.
      apply ReplSepE_impred omega (fun n => n ' :e v) (fun n => 2 * n + 1) (2 * x) H2.
      let n.
      assume Hn: n :e omega.
      assume Hnv: n ' :e v.
      assume H2x2n1: 2 * x = 2 * n + 1.
      claim L2nomega: 2 * n :e omega.
      { exact mul_SNo_In_omega 2 (nat_p_omega 2 nat_2) n Hn. }
      claim L2no: ordinal (2 * n).
      { apply nat_p_ordinal. apply omega_nat_p. exact L2nomega. }
      prove False.
      exact not_eq_2m_2n1 x (Subq_omega_int x Lx) n (Subq_omega_int n Hn) H2x2n1.
  - assume H1: x :e {n '|n :e SNoLev u}.
    apply ReplE_impred (SNoLev u) (fun n => n ') x H1.
    let n.
    assume Hn: n :e SNoLev u.
    assume Hxn: x = n '.
    claim Lnomega: n :e omega.
    { exact HLuo n Hn. }
    claim L2nomega: 2 * n :e omega.
    { exact mul_SNo_In_omega 2 (nat_p_omega 2 nat_2) n Lnomega. }
    claim L2no: ordinal (2 * n).
    { apply nat_p_ordinal. apply omega_nat_p. exact L2nomega. }
    claim Ln'u: n ' :e u.
    { rewrite <- Hxn. exact Hx. }
    claim L2x1: 2 * n + 1 :e f v.
    { rewrite <- Huv.
      prove 2 * n + 1 :e {2 * n|n :e omega, n :e u} :\/: {2 * n + 1|n :e omega, n ' :e u}.
      apply binunionI2.
      prove 2 * n + 1 :e {2 * n + 1|n :e omega, n ' :e u}.
      exact ReplSepI omega (fun n => n ' :e u) (fun n => 2 * n + 1) n Lnomega Ln'u.
    }
    apply binunionE {2 * n|n :e omega, n :e v} {2 * n + 1|n :e omega, n ' :e v} (2 * n + 1) L2x1.
    + assume H2: 2 * n + 1 :e {2 * n|n :e omega, n :e v}. prove False.
      apply ReplSepE_impred omega (fun n => n :e v) (fun n => 2 * n) (2 * n + 1) H2.
      let m.
      assume Hm: m :e omega.
      assume Hmv: m :e v.
      assume H2n12m: 2 * n + 1 = 2 * m.
      prove False.
      apply not_eq_2m_2n1 m (Subq_omega_int m Hm) n (Subq_omega_int n Lnomega).
      prove 2 * m = 2 * n + 1.
      symmetry.
      exact H2n12m.
    + assume H2: 2 * n + 1 :e {2 * n + 1|n :e omega, n ' :e v}.
      apply ReplSepE_impred omega (fun n => n ' :e v) (fun n => 2 * n + 1) (2 * n + 1) H2.
      let m.
      assume Hm: m :e omega.
      assume Hmv: m ' :e v.
      assume H2n12m1: 2 * n + 1 = 2 * m + 1.
      claim Lnm: n = m.
      { apply mul_SNo_nonzero_cancel_L 2 n m SNo_2 neq_2_0 (omega_SNo n Lnomega) (omega_SNo m Hm).
        prove 2 * n = 2 * m.
        exact add_SNo_cancel_R (2 * n) 1 (2 * m) (omega_SNo (2 * n) L2nomega) SNo_1 (SNo_mul_SNo 2 m SNo_2 (omega_SNo m Hm)) H2n12m1.
      }
      prove x :e v.
      rewrite Hxn.
      prove n ' :e v.
      exact Lnm (fun _ u => u ' :e v) Hmv.
}
prove exists f:set->set, inj (SNoS_ (ordsucc omega)) (Power omega) f.
witness f.
prove (forall u :e SNoS_ (ordsucc omega), f u :e Power omega)
   /\ (forall u v :e SNoS_ (ordsucc omega), f u = f v -> u = v).
apply andI.
- let u. assume Hu: u :e SNoS_ (ordsucc omega).
  prove f u :e Power omega.
  apply PowerI.
  prove {2 * n|n :e omega, n :e u} :\/: {2 * n + 1|n :e omega, n ' :e u} c= omega.
  apply binunion_Subq_min.
  + prove {2 * n|n :e omega, n :e u} c= omega.
    let x. assume Hx.
    apply ReplSepE_impred omega (fun n => n :e u) (fun n => 2 * n) x Hx.
    let n.
    assume Hn: n :e omega.
    assume Hnu: n :e u.
    assume Hx2n: x = 2 * n.
    prove x :e omega.
    rewrite Hx2n.
    apply mul_SNo_In_omega.
    * apply nat_p_omega. exact nat_2.
    * exact Hn.
  + prove {2 * n + 1|n :e omega, n ' :e u} c= omega.
    let x. assume Hx.
    apply ReplSepE_impred omega (fun n => n ' :e u) (fun n => 2 * n + 1) x Hx.
    let n.
    assume Hn: n :e omega.
    assume Hnu: n ' :e u.
    assume Hx2n1: x = 2 * n + 1.
    prove x :e omega.
    rewrite Hx2n1.
    apply add_SNo_In_omega.
    * { prove 2 * n :e omega.
        apply mul_SNo_In_omega.
        - apply nat_p_omega. exact nat_2.
        - exact Hn.
      }
    * apply nat_p_omega. exact nat_1.
- let u. assume Hu: u :e SNoS_ (ordsucc omega).
  let v. assume Hv: v :e SNoS_ (ordsucc omega).
  assume Huv: f u = f v.
  apply SNoS_E2 (ordsucc omega) ordsucc_omega_ordinal u Hu.
  assume Hu1: SNoLev u :e ordsucc omega.
  assume Hu2: ordinal (SNoLev u).
  assume Hu3: SNo u.
  assume Hu4: SNo_ (SNoLev u) u.
  apply Hu4.
  assume Hu4a: u c= SNoElts_ (SNoLev u).
  assume _.
  apply SNoS_E2 (ordsucc omega) ordsucc_omega_ordinal v Hv.
  assume Hv1: SNoLev v :e ordsucc omega.
  assume Hv2: ordinal (SNoLev v).
  assume Hv3: SNo v.
  assume Hv4: SNo_ (SNoLev v) v.
  apply Hv4.
  assume Hv4a: v c= SNoElts_ (SNoLev v).
  assume _.
  claim LLuo: SNoLev u c= omega.
  { apply TransSet_In_ordsucc_Subq.
    - prove TransSet omega. exact omega_TransSet.
    - prove SNoLev u :e ordsucc omega. exact Hu1.
  }
  claim LLvo: SNoLev v c= omega.
  { apply TransSet_In_ordsucc_Subq.
    - prove TransSet omega. exact omega_TransSet.
    - prove SNoLev v :e ordsucc omega. exact Hv1.
  }
  prove u = v.
  apply set_ext.
  + prove u c= v. exact L1 u v LLuo Hu4a Huv.
  + prove v c= u. exact L1 v u LLvo Hv4a (fun q => Huv (fun x y => q y x)).
Qed.

Theorem Repl_finite: forall f:set -> set, forall X, finite X -> finite {f x|x :e X}.
let f. apply finite_ind.
- prove finite {f x|x :e 0}.
  rewrite Repl_Empty f.
  exact finite_Empty.
- let X y.
  assume HX: finite X.
  assume Hy: y /:e X.
  assume IH: finite {f x|x :e X}.
  prove finite {f x|x :e X :\/: {y}}.
  claim L1: {f x|x :e X :\/: {y}} = {f x|x :e X} :\/: {f y}.
  { apply set_ext.
    - let z. assume Hz: z :e {f x|x :e X :\/: {y}}.
      apply ReplE_impred (X :\/: {y}) f z Hz.
      let x.
      assume Hx: x :e X :\/: {y}.
      assume Hzx: z = f x.
      prove z :e {f x|x :e X} :\/: {f y}.
      apply binunionE X {y} x Hx.
      + assume H1: x :e X.
        apply binunionI1.
        rewrite Hzx.
        exact ReplI X f x H1.
      + assume H1: x :e {y}.
        apply binunionI2.
        rewrite Hzx.
        rewrite SingE y x H1.
        apply SingI.
    - let z. assume Hz: z :e {f x|x :e X} :\/: {f y}.
      apply binunionE {f x|x :e X} {f y} z Hz.
      + assume H1: z :e {f x|x :e X}.
        apply ReplE_impred X f z H1.
        let x. assume Hx: x :e X.
        assume Hzx: z = f x.
        rewrite Hzx.
        apply ReplI.
        prove x :e X :\/: {y}.
        apply binunionI1.
        exact Hx.
      + assume H1: z :e {f y}.
        rewrite SingE (f y) z H1.
        prove f y :e {f x|x :e X :\/: {y}}.
        apply ReplI.
        apply binunionI2.
        prove y :e {y}.
        apply SingI.
  }
  rewrite L1.
  apply binunion_finite.
  + exact IH.
  + apply Sing_finite.
Qed.

Theorem infinite_bigger: forall X c= omega, infinite X -> forall m :e omega, exists n :e X, m :e n.
let X. assume HX1 HX2.
let m. assume Hm: m :e omega.
apply dneg.
assume H1: ~(exists n :e X, m :e n).
claim L1: X c= ordsucc m.
{ let n. assume Hn: n :e X.
  apply ordinal_trichotomy_or_impred m n
             (nat_p_ordinal m (omega_nat_p m Hm))
             (nat_p_ordinal n (omega_nat_p n (HX1 n Hn))).
  - assume H2: m :e n. prove False.
    apply H1.
    witness n. apply andI.
    + exact Hn.
    + exact H2.
  - assume H2: m = n.
    prove n :e ordsucc m.
    rewrite <- H2.
    apply ordsuccI2.
  - assume H2: n :e m.
    prove n :e ordsucc m.
    apply ordsuccI1.
    exact H2.
}
apply HX2.
prove finite X.
exact Subq_finite (ordsucc m) (nat_finite (ordsucc m) (nat_ordsucc m (omega_nat_p m Hm))) X L1.
Qed.

Theorem equip_real_Power_omega: equip real (Power omega).
apply atleastp_antisym_equip.
- prove atleastp real (Power omega).
  apply atleastp_tra real (SNoS_ (ordsucc omega)) (Power omega).
  + prove atleastp real (SNoS_ (ordsucc omega)).
    apply Subq_atleastp.
    prove real c= SNoS_ (ordsucc omega).
    let u. assume Hu: u :e real.
    apply real_E u Hu.
    assume Hu1: SNo u.
    assume Hu2: SNoLev u :e ordsucc omega.
    assume Hu3: u :e SNoS_ (ordsucc omega).
    assume Hu4: - omega < u.
    assume Hu5: u < omega.
    assume Hu6: forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - u) < eps_ k) -> q = u.
    assume Hu7: forall k :e omega, exists q :e SNoS_ omega, q < u /\ u < q + eps_ k.
    prove u :e SNoS_ (ordsucc omega).
    apply SNoS_I (ordsucc omega) ordsucc_omega_ordinal u (SNoLev u) Hu2.
    prove SNo_ (SNoLev u) u.
    exact SNoLev_ u Hu1.
  + exact atleastp_SNoS_ordsucc_omega_Power_omega.
- prove atleastp (Power omega) real.
  set L_ : set -> set -> set := fun X n => nat_primrec {0} (fun n r => if n :e X then r :\/: {x + eps_ (ordsucc n)|x :e r} else r) n.
  set R_ : set -> set -> set := fun X n => nat_primrec {1} (fun n r => if n :e X then r else r :\/: {x + - eps_ (ordsucc n)|x :e r}) n.
  claim L_0: forall X, L_ X 0 = {0}.
  { let X. exact nat_primrec_0 {0} (fun n r => if n :e X then r :\/: {x + eps_ (ordsucc n)|x :e r} else r). }
  claim R_0: forall X, R_ X 0 = {1}.
  { let X. exact nat_primrec_0 {1} (fun n r => if n :e X then r else r :\/: {x + - eps_ (ordsucc n)|x :e r}). }
  claim L_ordsucc: forall X, forall n :e omega, L_ X (ordsucc n) = if n :e X then L_ X n :\/: {x + eps_ (ordsucc n)|x :e L_ X n} else L_ X n.
  { let X n. assume Hn.
    exact nat_primrec_S {0} (fun n r => if n :e X then r :\/: {x + eps_ (ordsucc n)|x :e r} else r)
                        n (omega_nat_p n Hn).
  }
  claim R_ordsucc: forall X, forall n :e omega, R_ X (ordsucc n) = if n :e X then R_ X n else R_ X n :\/: {x + - eps_ (ordsucc n)|x :e R_ X n}.
  { let X n. assume Hn.
    exact nat_primrec_S {1} (fun n r => if n :e X then r else r :\/: {x + - eps_ (ordsucc n)|x :e r})
                        n (omega_nat_p n Hn).
  }
  claim L_ordsucc_pos: forall X, forall n :e omega, n :e X -> L_ X (ordsucc n) = L_ X n :\/: {x + eps_ (ordsucc n)|x :e L_ X n}.
  { let X n. assume Hn HnX.
    exact If_i_1 (n :e X) (L_ X n :\/: {x + eps_ (ordsucc n)|x :e L_ X n}) (L_ X n) HnX
            (fun u _ => L_ X (ordsucc n) = u)
            (L_ordsucc X n Hn).
  }
  claim L_ordsucc_neg: forall X, forall n :e omega, n /:e X -> L_ X (ordsucc n) = L_ X n.
  { let X n. assume Hn HnX.
    exact If_i_0 (n :e X) (L_ X n :\/: {x + eps_ (ordsucc n)|x :e L_ X n}) (L_ X n) HnX
            (fun u _ => L_ X (ordsucc n) = u)
            (L_ordsucc X n Hn).
  }
  claim R_ordsucc_pos: forall X, forall n :e omega, n :e X -> R_ X (ordsucc n) = R_ X n.
  { let X n. assume Hn HnX.
    exact If_i_1 (n :e X) (R_ X n) (R_ X n :\/: {x + - eps_ (ordsucc n)|x :e R_ X n}) HnX
            (fun u _ => R_ X (ordsucc n) = u)
            (R_ordsucc X n Hn).
  }
  claim R_ordsucc_neg: forall X, forall n :e omega, n /:e X -> R_ X (ordsucc n) = R_ X n :\/: {x + - eps_ (ordsucc n)|x :e R_ X n}.
  { let X n. assume Hn HnX.
    exact If_i_0 (n :e X) (R_ X n) (R_ X n :\/: {x + - eps_ (ordsucc n)|x :e R_ X n}) HnX
            (fun u _ => R_ X (ordsucc n) = u)
            (R_ordsucc X n Hn).
  }
  claim L_SNo1: forall X, forall n, nat_p n -> forall u :e L_ X n, SNo u.
  { let X. apply nat_ind.
    - prove forall u :e L_ X 0, SNo u.
      apply L_0 X (fun _ v => forall u :e v, SNo u).
      let u. assume Hu: u :e {0}.
      rewrite SingE 0 u Hu.
      prove SNo 0. exact SNo_0.
    - let n. assume Hn.
      assume IHn: forall u :e L_ X n, SNo u.
      prove forall u :e L_ X (ordsucc n), SNo u.
      apply xm (n :e X).
      + assume H1: n :e X.
        apply L_ordsucc_pos X n (nat_p_omega n Hn) H1 (fun _ v => forall u :e v, SNo u).
        let u. assume Hu: u :e L_ X n :\/: {w + eps_ (ordsucc n)|w :e L_ X n}.
        apply binunionE (L_ X n) {w + eps_ (ordsucc n)|w :e L_ X n} u Hu.
        * exact IHn u.
        * assume H2: u :e {w + eps_ (ordsucc n)|w :e L_ X n}.
          apply ReplE_impred (L_ X n) (fun w => w + eps_ (ordsucc n)) u H2.
          let w.
          assume Hw: w :e L_ X n.
          assume Huw: u = w + eps_ (ordsucc n).
          prove SNo u.
          rewrite Huw.
          prove SNo (w + eps_ (ordsucc n)).
          exact SNo_add_SNo w (eps_ (ordsucc n)) (IHn w Hw) (SNo_eps_ (ordsucc n) (omega_ordsucc n (nat_p_omega n Hn))).
      + assume H1: n /:e X.
        apply L_ordsucc_neg X n (nat_p_omega n Hn) H1 (fun _ v => forall u :e v, SNo u).
        exact IHn.
  }
  claim R_SNo1: forall X, forall n, nat_p n -> forall u :e R_ X n, SNo u.
  { let X. apply nat_ind.
    - prove forall u :e R_ X 0, SNo u.
      apply R_0 X (fun _ v => forall u :e v, SNo u).
      let u. assume Hu: u :e {1}.
      rewrite SingE 1 u Hu.
      exact SNo_1.
    - let n. assume Hn.
      assume IHn: forall u :e R_ X n, SNo u.
      prove forall u :e R_ X (ordsucc n), SNo u.
      apply xm (n :e X).
      + assume H1: n :e X.
        apply R_ordsucc_pos X n (nat_p_omega n Hn) H1 (fun _ v => forall u :e v, SNo u).
        exact IHn.
      + assume H1: n /:e X.
        apply R_ordsucc_neg X n (nat_p_omega n Hn) H1 (fun _ v => forall u :e v, SNo u).
        let u. assume Hu: u :e R_ X n :\/: {w + - eps_ (ordsucc n)|w :e R_ X n}.
        apply binunionE (R_ X n) {w + - eps_ (ordsucc n)|w :e R_ X n} u Hu.
        * exact IHn u.
        * assume H2: u :e {w + - eps_ (ordsucc n)|w :e R_ X n}.
          apply ReplE_impred (R_ X n) (fun w => w + - eps_ (ordsucc n)) u H2.
          let w.
          assume Hw: w :e R_ X n.
          assume Huw: u = w + - eps_ (ordsucc n).
          prove SNo u.
          rewrite Huw.
          prove SNo (w + - eps_ (ordsucc n)).
          exact SNo_add_SNo w (- eps_ (ordsucc n)) (IHn w Hw) (SNo_minus_SNo (eps_ (ordsucc n)) (SNo_eps_ (ordsucc n) (omega_ordsucc n (nat_p_omega n Hn)))).
  }
  claim L_fin: forall X, forall n, nat_p n -> finite (L_ X n).
  { let X. apply nat_ind.
    - prove finite (L_ X 0).
      apply L_0 X (fun _ v => finite v).
      prove finite {0}.
      apply Sing_finite.
    - let n. assume Hn.
      assume IHn: finite (L_ X n).
      prove finite (L_ X (ordsucc n)).
      apply xm (n :e X).
      + assume H1: n :e X.
        apply L_ordsucc_pos X n (nat_p_omega n Hn) H1 (fun _ v => finite v).
        prove finite (L_ X n :\/: {x + eps_ (ordsucc n)|x :e L_ X n}).
        apply binunion_finite.
        - exact IHn.
        - prove finite {x + eps_ (ordsucc n)|x :e L_ X n}.
          apply Repl_finite.
          exact IHn.
      + assume H1: n /:e X.
        apply L_ordsucc_neg X n (nat_p_omega n Hn) H1 (fun _ v => finite v).
        exact IHn.
  }
  claim R_fin: forall X, forall n, nat_p n -> finite (R_ X n).
  { let X. apply nat_ind.
    - prove finite (R_ X 0).
      apply R_0 X (fun _ v => finite v).
      prove finite {1}.
      apply Sing_finite.
    - let n. assume Hn.
      assume IHn: finite (R_ X n).
      prove finite (R_ X (ordsucc n)).
      apply xm (n :e X).
      + assume H1: n :e X.
        apply R_ordsucc_pos X n (nat_p_omega n Hn) H1 (fun _ v => finite v).
        exact IHn.
      + assume H1: n /:e X.
        apply R_ordsucc_neg X n (nat_p_omega n Hn) H1 (fun _ v => finite v).
        prove finite (R_ X n :\/: {x + - eps_ (ordsucc n)|x :e R_ X n}).
        apply binunion_finite.
        - exact IHn.
        - prove finite {x + - eps_ (ordsucc n)|x :e R_ X n}.
          apply Repl_finite.
          exact IHn.
  }
  claim L_ordsucc_Subq: forall X, forall n, nat_p n -> L_ X n c= L_ X (ordsucc n).
  { let X n. assume Hn.
    apply xm (n :e X).
    - assume H1: n :e X.
      apply L_ordsucc_pos X n (nat_p_omega n Hn) H1 (fun _ v => L_ X n c= v).
      prove L_ X n c= L_ X n :\/: {x + eps_ (ordsucc n)|x :e L_ X n}.
      apply binunion_Subq_1.
    - assume H1: n /:e X.
      apply L_ordsucc_neg X n (nat_p_omega n Hn) H1 (fun _ v => L_ X n c= v).
      prove L_ X n c= L_ X n.
      apply Subq_ref.
  }
  claim R_ordsucc_Subq: forall X, forall n, nat_p n -> R_ X n c= R_ X (ordsucc n).
  { let X n. assume Hn.
    apply xm (n :e X).
    - assume H1: n :e X.
      apply R_ordsucc_pos X n (nat_p_omega n Hn) H1 (fun _ v => R_ X n c= v).
      prove R_ X n c= R_ X n.
      apply Subq_ref.
    - assume H1: n /:e X.
      apply R_ordsucc_neg X n (nat_p_omega n Hn) H1 (fun _ v => R_ X n c= v).
      prove R_ X n c= R_ X n :\/: {x + - eps_ (ordsucc n)|x :e R_ X n}.
      apply binunion_Subq_1.
  }
  claim L_Subq: forall X, forall n, nat_p n -> forall m :e n, L_ X m c= L_ X n.
  { let X.
    apply nat_ind.
    - let m. assume Hm: m :e 0. prove False. exact EmptyE m Hm.
    - let n. assume Hn.
      assume IHn: forall m :e n, L_ X m c= L_ X n.
      let m. assume Hm: m :e ordsucc n.
      apply ordsuccE n m Hm.
      + assume H1: m :e n.
        prove L_ X m c= L_ X (ordsucc n).
        apply Subq_tra (L_ X m) (L_ X n) (L_ X (ordsucc n)).
        * exact IHn m H1.
        * exact L_ordsucc_Subq X n Hn.
      + assume H1: m = n.
        rewrite H1.
        exact L_ordsucc_Subq X n Hn.
  }
  claim R_Subq: forall X, forall n, nat_p n -> forall m :e n, R_ X m c= R_ X n.
  { let X.
    apply nat_ind.
    - let m. assume Hm: m :e 0. prove False. exact EmptyE m Hm.
    - let n. assume Hn.
      assume IHn: forall m :e n, R_ X m c= R_ X n.
      let m. assume Hm: m :e ordsucc n.
      apply ordsuccE n m Hm.
      + assume H1: m :e n.
        prove R_ X m c= R_ X (ordsucc n).
        apply Subq_tra (R_ X m) (R_ X n) (R_ X (ordsucc n)).
        * exact IHn m H1.
        * exact R_ordsucc_Subq X n Hn.
      + assume H1: m = n.
        rewrite H1.
        exact R_ordsucc_Subq X n Hn.
  }
  claim L_0_In: forall X, forall n, nat_p n -> 0 :e L_ X n.
  { let X.
    claim L_0_In_0: 0 :e L_ X 0.
    { exact L_0 X (fun _ v => 0 :e v) (SingI 0). }
    apply nat_inv_impred.
    - exact L_0_In_0.
    - let n. assume Hn.
      prove 0 :e L_ X (ordsucc n).
      exact L_Subq X (ordsucc n) (nat_ordsucc n Hn) 0 (nat_0_in_ordsucc n Hn) 0 L_0_In_0.
  }
  claim R_1_In: forall X, forall n, nat_p n -> 1 :e R_ X n.
  { let X.
    claim R_1_In_0: 1 :e R_ X 0.
    { exact R_0 X (fun _ v => 1 :e v) (SingI 1). }
    apply nat_inv_impred.
    - exact R_1_In_0.
    - let n. assume Hn.
      prove 1 :e R_ X (ordsucc n).
      exact R_Subq X (ordsucc n) (nat_ordsucc n Hn) 0 (nat_0_in_ordsucc n Hn) 1 R_1_In_0.
  }
  claim L_ne: forall X, forall n, nat_p n -> L_ X n <> 0.
  { let X n. assume Hn.
    assume H1: L_ X n = 0.
    apply EmptyE 0.
    prove 0 :e 0.
    rewrite <- H1 at 2.
    exact L_0_In X n Hn.
  }
  claim R_ne: forall X, forall n, nat_p n -> R_ X n <> 0.
  { let X n. assume Hn.
    assume H1: R_ X n = 0.
    apply EmptyE 1.
    prove 1 :e 0.
    rewrite <- H1 at 2.
    exact R_1_In X n Hn.
  }
  claim L_R_dist: forall X, forall n, nat_p n -> forall w z, SNo_max_of (L_ X n) w -> SNo_min_of (R_ X n) z -> z = w + eps_ n.
  { let X. apply nat_ind.
    - let w z.
      prove SNo_max_of (L_ X 0) w -> SNo_min_of (R_ X 0) z -> z = w + eps_ 0.
      apply L_0 X (fun _ v => SNo_max_of v w -> SNo_min_of (R_ X 0) z -> z = w + eps_ 0).
      assume Hw: SNo_max_of {0} w.
      apply R_0 X (fun _ v => SNo_min_of v z -> z = w + eps_ 0).
      assume Hz: SNo_min_of {1} z.
      apply Hw. assume H. apply H.
      assume Hw1: w :e {0}.
      assume _ _.
      apply Hz. assume H. apply H.
      assume Hz1: z :e {1}.
      assume _ _.
      rewrite SingE 0 w Hw1.
      rewrite SingE 1 z Hz1.
      prove 1 = 0 + eps_ 0.
      rewrite eps_0_1.
      symmetry. exact add_SNo_0L 1 SNo_1.
    - let n. assume Hn.
      assume IHn: forall w z, SNo_max_of (L_ X n) w -> SNo_min_of (R_ X n) z -> z = w + eps_ n.
      claim LSn: ordsucc n :e omega.
      { exact omega_ordsucc n (nat_p_omega n Hn). }
      claim Len: SNo (eps_ n).
      { exact SNo_eps_ n (nat_p_omega n Hn). }
      claim LeSn: SNo (eps_ (ordsucc n)).
      { exact SNo_eps_ (ordsucc n) LSn. }
      claim LmeSn: SNo (- eps_ (ordsucc n)).
      { exact SNo_minus_SNo (eps_ (ordsucc n)) LeSn. }
      let w z.
      apply xm (n :e X).
      + assume H1: n :e X.
        apply L_ordsucc_pos X n (nat_p_omega n Hn) H1
                  (fun _ v => SNo_max_of v w -> SNo_min_of (R_ X (ordsucc n)) z -> z = w + eps_ (ordsucc n)).
        assume Hw: SNo_max_of (L_ X n :\/: {w + eps_ (ordsucc n)|w :e L_ X n}) w.
        apply R_ordsucc_pos X n (nat_p_omega n Hn) H1
                  (fun _ v => SNo_min_of v z -> z = w + eps_ (ordsucc n)).
        assume Hz: SNo_min_of (R_ X n) z.
        apply finite_max_exists (L_ X n) (L_SNo1 X n Hn) (L_fin X n Hn) (L_ne X n Hn).
        let w'.
        assume Hw': SNo_max_of (L_ X n) w'.
        apply Hw'. assume H. apply H.
        assume Hw'1: w' :e L_ X n.
        assume Hw'2: SNo w'.
        assume Hw'3: forall y :e L_ X n, SNo y -> y <= w'.
        claim Lww': w = w' + eps_ (ordsucc n).
        { apply Hw. assume H. apply H.
          assume Hw1: w :e L_ X n :\/: {w + eps_ (ordsucc n)|w :e L_ X n}.
          assume Hw2: SNo w.
          assume Hw3: forall y :e L_ X n :\/: {w + eps_ (ordsucc n)|w :e L_ X n}, SNo y -> y <= w.
          apply binunionE (L_ X n) {w + eps_ (ordsucc n)|w :e L_ X n} w Hw1.
          - assume H2: w :e L_ X n. prove False.
            apply SNoLt_irref w.
            prove w < w.
            apply SNoLtLe_tra w (w + eps_ (ordsucc n)) w Hw2 (SNo_add_SNo w (eps_ (ordsucc n)) Hw2 LeSn) Hw2.
            + prove w < w + eps_ (ordsucc n).
              exact add_SNo_eps_Lt w Hw2 (ordsucc n) LSn.
            + prove w + eps_ (ordsucc n) <= w.
              apply Hw3.
              * prove w + eps_ (ordsucc n) :e L_ X n :\/: {w + eps_ (ordsucc n)|w :e L_ X n}.
                apply binunionI2.
                prove w + eps_ (ordsucc n) :e {w + eps_ (ordsucc n)|w :e L_ X n}.
                exact ReplI (L_ X n) (fun w => w + eps_ (ordsucc n)) w H2.
              * prove SNo (w + eps_ (ordsucc n)).
                exact SNo_add_SNo w (eps_ (ordsucc n)) Hw2 LeSn.
          - assume H2: w :e {w + eps_ (ordsucc n)|w :e L_ X n}.
            apply ReplE_impred (L_ X n) (fun w => w + eps_ (ordsucc n)) w H2.
            let w''.
            assume Hw'': w'' :e L_ X n.
            assume Hww'': w = w'' + eps_ (ordsucc n).
            prove w = w' + eps_ (ordsucc n).
            claim Lw'': SNo w''.
            { exact L_SNo1 X n Hn w'' Hw''. }
            apply SNoLe_antisym w (w' + eps_ (ordsucc n)) Hw2 (SNo_add_SNo w' (eps_ (ordsucc n)) Hw'2 LeSn).
            + prove w <= w' + eps_ (ordsucc n).
              rewrite Hww''.
              prove w'' + eps_ (ordsucc n) <= w' + eps_ (ordsucc n).
              apply add_SNo_Le1 w'' (eps_ (ordsucc n)) w' Lw'' LeSn Hw'2.
              prove w'' <= w'.
              apply Hw'3.
              * prove w'' :e L_ X n. exact Hw''.
              * prove SNo w''. exact Lw''.
            + prove w' + eps_ (ordsucc n) <= w.
              apply Hw3.
              * prove w' + eps_ (ordsucc n) :e L_ X n :\/: {w + eps_ (ordsucc n)|w :e L_ X n}.
                apply binunionI2.
                exact ReplI (L_ X n) (fun w => w + eps_ (ordsucc n)) w' Hw'1.
              * prove SNo (w' + eps_ (ordsucc n)).
                exact SNo_add_SNo w' (eps_ (ordsucc n)) Hw'2 LeSn.
        }
        prove z = w + eps_ (ordsucc n).
        transitivity w' + eps_ n,
                     w' + eps_ (ordsucc n) + eps_ (ordsucc n),
                     (w' + eps_ (ordsucc n)) + eps_ (ordsucc n).
        * prove z = w' + eps_ n. exact IHn w' z Hw' Hz.
        * prove w' + eps_ n = w' + eps_ (ordsucc n) + eps_ (ordsucc n).
          f_equal.
          symmetry. exact eps_ordsucc_half_add n Hn.
        * prove w' + eps_ (ordsucc n) + eps_ (ordsucc n) = (w' + eps_ (ordsucc n)) + eps_ (ordsucc n).
          exact add_SNo_assoc w' (eps_ (ordsucc n)) (eps_ (ordsucc n)) Hw'2 LeSn LeSn.
        * prove (w' + eps_ (ordsucc n)) + eps_ (ordsucc n) = w + eps_ (ordsucc n).
          f_equal. symmetry.
          exact Lww'.
      + assume H1: n /:e X.
        apply L_ordsucc_neg X n (nat_p_omega n Hn) H1
                  (fun _ v => SNo_max_of v w -> SNo_min_of (R_ X (ordsucc n)) z -> z = w + eps_ (ordsucc n)).
        assume Hw: SNo_max_of (L_ X n) w.
        apply R_ordsucc_neg X n (nat_p_omega n Hn) H1
                  (fun _ v => SNo_min_of v z -> z = w + eps_ (ordsucc n)).
        assume Hz: SNo_min_of (R_ X n :\/: {w + - eps_ (ordsucc n)|w :e R_ X n}) z.
        apply finite_min_exists (R_ X n) (R_SNo1 X n Hn) (R_fin X n Hn) (R_ne X n Hn).
        let z'.
        assume Hz': SNo_min_of (R_ X n) z'.
        apply Hz'. assume H. apply H.
        assume Hz'1: z' :e R_ X n.
        assume Hz'2: SNo z'.
        assume Hz'3: forall y :e R_ X n, SNo y -> z' <= y.
        claim Lzz': z = z' + - eps_ (ordsucc n).
        { apply Hz. assume H. apply H.
          assume Hz1: z :e R_ X n :\/: {z + - eps_ (ordsucc n)|z :e R_ X n}.
          assume Hz2: SNo z.
          assume Hz3: forall y :e R_ X n :\/: {z + - eps_ (ordsucc n)|z :e R_ X n}, SNo y -> z <= y.
          apply binunionE (R_ X n) {z + - eps_ (ordsucc n)|z :e R_ X n} z Hz1.
          - assume H2: z :e R_ X n. prove False.
            apply SNoLt_irref z.
            prove z < z.
            apply SNoLeLt_tra z (z + - eps_ (ordsucc n)) z Hz2 (SNo_add_SNo z (- eps_ (ordsucc n)) Hz2 LmeSn) Hz2.
            + prove z <= z + - eps_ (ordsucc n).
              apply Hz3.
              * prove z + - eps_ (ordsucc n) :e R_ X n :\/: {z + - eps_ (ordsucc n)|z :e R_ X n}.
                apply binunionI2.
                prove z + - eps_ (ordsucc n) :e {z + - eps_ (ordsucc n)|z :e R_ X n}.
                exact ReplI (R_ X n) (fun z => z + - eps_ (ordsucc n)) z H2.
              * prove SNo (z + - eps_ (ordsucc n)).
                exact SNo_add_SNo z (- eps_ (ordsucc n)) Hz2 LmeSn.
            + prove z + - eps_ (ordsucc n) < z.
              rewrite <- add_SNo_0R z Hz2 at 2.
              prove z + - eps_ (ordsucc n) < z + 0.
              apply add_SNo_Lt2 z (- eps_ (ordsucc n)) 0 Hz2 LmeSn SNo_0.
              prove - eps_ (ordsucc n) < 0.
              rewrite <- minus_SNo_0.
              prove - eps_ (ordsucc n) < - 0.
              exact minus_SNo_Lt_contra 0 (eps_ (ordsucc n)) SNo_0 LeSn (SNo_eps_pos (ordsucc n) (omega_ordsucc n (nat_p_omega n Hn))).
          - assume H2: z :e {z + - eps_ (ordsucc n)|z :e R_ X n}.
            apply ReplE_impred (R_ X n) (fun z => z + - eps_ (ordsucc n)) z H2.
            let z''.
            assume Hz'': z'' :e R_ X n.
            assume Hzz'': z = z'' + - eps_ (ordsucc n).
            prove z = z' + - eps_ (ordsucc n).
            claim Lz'': SNo z''.
            { exact R_SNo1 X n Hn z'' Hz''. }
            apply SNoLe_antisym z (z' + - eps_ (ordsucc n)) Hz2 (SNo_add_SNo z' (- eps_ (ordsucc n)) Hz'2 LmeSn).
            + prove z <= z' + - eps_ (ordsucc n).
              apply Hz3.
              * prove z' + - eps_ (ordsucc n) :e R_ X n :\/: {z + - eps_ (ordsucc n)|z :e R_ X n}.
                apply binunionI2.
                exact ReplI (R_ X n) (fun z => z + - eps_ (ordsucc n)) z' Hz'1.
              * prove SNo (z' + - eps_ (ordsucc n)).
                exact SNo_add_SNo z' (- eps_ (ordsucc n)) Hz'2 LmeSn.
            + prove z' + - eps_ (ordsucc n) <= z.
              rewrite Hzz''.
              prove z' + - eps_ (ordsucc n) <= z'' + - eps_ (ordsucc n).
              apply add_SNo_Le1 z' (- eps_ (ordsucc n)) z'' Hz'2 LmeSn Lz''.
              prove z' <= z''.
              apply Hz'3.
              * prove z'' :e R_ X n. exact Hz''.
              * prove SNo z''. exact Lz''.
        }
        apply Hw. assume H. apply H.
        assume Hw1: w :e L_ X n.
        assume Hw2: SNo w.
        assume Hw3: forall y :e L_ X n, SNo y -> y <= w.
        prove z = w + eps_ (ordsucc n).
        transitivity z' + - eps_ (ordsucc n),
                     (w + eps_ n) + - eps_ (ordsucc n),
                     w + (eps_ n + - eps_ (ordsucc n)).
        * exact Lzz'.
        * f_equal. exact IHn w z' Hw Hz'.
        * prove (w + eps_ n) + - eps_ (ordsucc n) = w + (eps_ n + - eps_ (ordsucc n)).
          symmetry.
          exact add_SNo_assoc w (eps_ n) (- eps_ (ordsucc n)) Hw2 Len LmeSn.
        * f_equal.
          prove eps_ n + - eps_ (ordsucc n) = eps_ (ordsucc n).
          rewrite <- eps_ordsucc_half_add n Hn.
          exact add_SNo_minus_R2 (eps_ (ordsucc n)) (eps_ (ordsucc n)) LeSn LeSn.
  }
  claim L_SNo: forall X, forall n, nat_p n -> L_ X n c= SNoS_ omega.
  { let X. apply nat_ind.
    - prove L_ X 0 c= SNoS_ omega.
      apply L_0 X (fun _ v => v c= SNoS_ omega).
      prove {0} c= SNoS_ omega.
      let u. assume Hu. rewrite SingE 0 u Hu.
      prove 0 :e SNoS_ omega.
      apply SNoS_I omega omega_ordinal 0 0 (nat_p_omega 0 nat_0).
      prove SNo_ 0 0.
      exact ordinal_SNo_ Empty ordinal_Empty.
    - let n. assume Hn.
      assume IHn: L_ X n c= SNoS_ omega.
      prove L_ X (ordsucc n) c= SNoS_ omega.
      apply xm (n :e X).
      + assume H1: n :e X.
        apply L_ordsucc_pos X n (nat_p_omega n Hn) H1
                  (fun _ v => v c= SNoS_ omega).
        prove L_ X n :\/: {w + eps_ (ordsucc n)|w :e L_ X n} c= SNoS_ omega.
        apply binunion_Subq_min.
        * exact IHn.
        * { prove {w + eps_ (ordsucc n)|w :e L_ X n} c= SNoS_ omega.
            let u. assume Hu.
            apply ReplE_impred (L_ X n) (fun w => w + eps_ (ordsucc n)) u Hu.
            let w.
            assume Hw: w :e L_ X n.
            assume Huw: u = w + eps_ (ordsucc n).
            rewrite Huw.
            prove w + eps_ (ordsucc n) :e SNoS_ omega.
            apply add_SNo_SNoS_omega.
            - exact IHn w Hw.
            - prove eps_ (ordsucc n) :e SNoS_ omega.
              exact SNo_eps_SNoS_omega (ordsucc n) (omega_ordsucc n (nat_p_omega n Hn)).
          }
      + assume H1: n /:e X.
        apply L_ordsucc_neg X n (nat_p_omega n Hn) H1
                  (fun _ v => v c= SNoS_ omega).
        exact IHn.
  }
  claim R_SNo: forall X, forall n, nat_p n -> R_ X n c= SNoS_ omega.
  { let X. apply nat_ind.
    - prove R_ X 0 c= SNoS_ omega.
      apply R_0 X (fun _ v => v c= SNoS_ omega).
      prove {1} c= SNoS_ omega.
      let u. assume Hu. rewrite SingE 1 u Hu.
      prove 1 :e SNoS_ omega.
      apply SNoS_I omega omega_ordinal 1 1 (nat_p_omega 1 nat_1).
      prove SNo_ 1 1.
      exact ordinal_SNo_ 1 (nat_p_ordinal 1 nat_1).
    - let n. assume Hn.
      assume IHn: R_ X n c= SNoS_ omega.
      prove R_ X (ordsucc n) c= SNoS_ omega.
      apply xm (n :e X).
      + assume H1: n :e X.
        apply R_ordsucc_pos X n (nat_p_omega n Hn) H1
                  (fun _ v => v c= SNoS_ omega).
        exact IHn.
      + assume H1: n /:e X.
        apply R_ordsucc_neg X n (nat_p_omega n Hn) H1
                  (fun _ v => v c= SNoS_ omega).
        prove R_ X n :\/: {w + - eps_ (ordsucc n)|w :e R_ X n} c= SNoS_ omega.
        apply binunion_Subq_min.
        * exact IHn.
        * { prove {w + - eps_ (ordsucc n)|w :e R_ X n} c= SNoS_ omega.
            let u. assume Hu.
            apply ReplE_impred (R_ X n) (fun w => w + - eps_ (ordsucc n)) u Hu.
            let w.
            assume Hw: w :e R_ X n.
            assume Huw: u = w + - eps_ (ordsucc n).
            rewrite Huw.
            prove w + - eps_ (ordsucc n) :e SNoS_ omega.
            apply add_SNo_SNoS_omega.
            - exact IHn w Hw.
            - prove - eps_ (ordsucc n) :e SNoS_ omega.
              apply minus_SNo_SNoS_omega.
              prove eps_ (ordsucc n) :e SNoS_ omega.
              exact SNo_eps_SNoS_omega (ordsucc n) (omega_ordsucc n (nat_p_omega n Hn)).
          }
  }
  set L : set -> set := fun X => \/_ n :e omega, L_ X n.
  set R : set -> set := fun X => \/_ n :e omega, R_ X n.
  claim LSo: forall X, L X c= SNoS_ omega.
  { let X u.
    assume Hu: u :e \/_ n :e omega, L_ X n.
    apply famunionE_impred omega (L_ X) u Hu.
    let n.
    assume Hn: n :e omega.
    assume Hu: u :e L_ X n.
    prove u :e SNoS_ omega.
    exact L_SNo X n (omega_nat_p n Hn) u Hu.
  }
  claim RSo: forall X, R X c= SNoS_ omega.
  { let X u.
    assume Hu: u :e \/_ n :e omega, R_ X n.
    apply famunionE_impred omega (R_ X) u Hu.
    let n.
    assume Hn: n :e omega.
    assume Hu: u :e R_ X n.
    prove u :e SNoS_ omega.
    exact R_SNo X n (omega_nat_p n Hn) u Hu.
  }
  claim LSNo: forall X, forall w :e L X, SNo w.
  { let X w. assume Hw.
    apply famunionE_impred omega (L_ X) w Hw.
    let n.
    assume Hn: n :e omega.
    assume Hw': w :e L_ X n.
    exact L_SNo1 X n (omega_nat_p n Hn) w Hw'.
  }
  claim RSNo: forall X, forall z :e R X, SNo z.
  { let X z. assume Hz.
    apply famunionE_impred omega (R_ X) z Hz.
    let n.
    assume Hn: n :e omega.
    assume Hz': z :e R_ X n.
    exact R_SNo1 X n (omega_nat_p n Hn) z Hz'.
  }
  claim LLR: forall X, SNoCutP (L X) (R X).
  { let X.
    prove (forall w :e L X, SNo w)
       /\ (forall z :e R X, SNo z)
       /\ (forall w :e L X, forall z :e R X, w < z).
    apply and3I.
    - exact LSNo X.
    - exact RSNo X.
    - let w. assume Hw.
      let z. assume Hz.
      claim Lw: SNo w.
      { exact LSNo X w Hw. }
      claim Lz: SNo z.
      { exact RSNo X z Hz. }
      claim Lwzn: forall n, nat_p n -> w :e L_ X n -> z :e R_ X n -> w < z.
      { let n. assume Hn.
        assume H1: w :e L_ X n.
        assume H2: z :e R_ X n.
        prove w < z.
        apply finite_max_exists (L_ X n) (L_SNo1 X n Hn) (L_fin X n Hn) (L_ne X n Hn).
        let w'.
        assume Hw': SNo_max_of (L_ X n) w'.
        apply Hw'. assume H. apply H.
        assume Hw'1: w' :e L_ X n.
        assume Hw'2: SNo w'.
        assume Hw'3: forall y :e L_ X n, SNo y -> y <= w'.
        apply finite_min_exists (R_ X n) (R_SNo1 X n Hn) (R_fin X n Hn) (R_ne X n Hn).
        let z'.
        assume Hz': SNo_min_of (R_ X n) z'.
        apply Hz'. assume H. apply H.
        assume Hz'1: z' :e R_ X n.
        assume Hz'2: SNo z'.
        assume Hz'3: forall y :e R_ X n, SNo y -> z' <= y.
        prove w < z.
        apply SNoLeLt_tra w w' z Lw Hw'2 Lz (Hw'3 w H1 Lw).
        prove w' < z.
        apply SNoLtLe_tra w' z' z Hw'2 Hz'2 Lz.
        - prove w' < z'.
          rewrite L_R_dist X n Hn w' z' Hw' Hz'.
          prove w' < w' + eps_ n.
          exact add_SNo_eps_Lt w' Hw'2 n (nat_p_omega n Hn).
        - prove z' <= z. exact Hz'3 z H2 Lz.
      }
      apply famunionE_impred omega (L_ X) w Hw.
      let n.
      assume Hn: n :e omega.
      assume Hw': w :e L_ X n.
      apply famunionE_impred omega (R_ X) z Hz.
      let m.
      assume Hm: m :e omega.
      assume Hz': z :e R_ X m.
      prove w < z.
      apply ordinal_trichotomy_or_impred m n (nat_p_ordinal m (omega_nat_p m Hm)) (nat_p_ordinal n (omega_nat_p n Hn)).
      + assume H1: m :e n.
        apply Lwzn n (omega_nat_p n Hn).
        * prove w :e L_ X n. exact Hw'.
        * prove z :e R_ X n.
          exact R_Subq X n (omega_nat_p n Hn) m H1 z Hz'.
      + assume H1: m = n.
        apply Lwzn n (omega_nat_p n Hn).
        * prove w :e L_ X n. exact Hw'.
        * prove z :e R_ X n. rewrite <- H1. exact Hz'.
      + assume H1: n :e m.
        apply Lwzn m (omega_nat_p m Hm).
        * prove w :e L_ X m.
          exact L_Subq X m (omega_nat_p m Hm) n H1 w Hw'.
        * prove z :e R_ X m. exact Hz'.
  }
  claim L0_In: forall X, 0 :e L X.
  { let X.
    prove 0 :e \/_ n :e omega, L_ X n.
    apply famunionI omega (L_ X) 0 0.
    - prove 0 :e omega. apply nat_p_omega. prove nat_p 0. exact nat_0.
    - prove 0 :e L_ X 0. exact L_0_In X 0 nat_0.
  }
  claim R1_In: forall X, 1 :e R X.
  { let X.
    prove 1 :e \/_ n :e omega, R_ X n.
    apply famunionI omega (R_ X) 0 1.
    - prove 0 :e omega. apply nat_p_omega. prove nat_p 0. exact nat_0.
    - prove 1 :e R_ X 0. exact R_1_In X 0 nat_0.
  }
  claim Lne: forall X, L X <> 0.
  { let X.
    assume H1: L X = 0.
    apply EmptyE 0.
    prove 0 :e 0.
    rewrite <- H1 at 2.
    exact L0_In X.
  }
  claim Rne: forall X, R X <> 0.
  { let X.
    assume H1: R X = 0.
    apply EmptyE 1.
    prove 1 :e 0.
    rewrite <- H1 at 2.
    exact R1_In X.
  }
  claim L_nomax: forall X c= omega, infinite X ->
          forall w :e L X, exists w' :e L X, w < w'.
  { let X. assume HX1 HX2.
    let w. assume Hw.
    claim Lw: SNo w.
    { exact LSNo X w Hw. }
    apply famunionE_impred omega (L_ X) w Hw.
    let n.
    assume Hn: n :e omega.
    assume Hw': w :e L_ X n.
    apply infinite_bigger X HX1 HX2 n Hn.
    let m. assume H. apply H.
    assume Hm: m :e X.
    assume Hnm: n :e m.
    claim Lwm: w :e L_ X m.
    { exact L_Subq X m (omega_nat_p m (HX1 m Hm)) n Hnm w Hw'. }
    claim LweSm1: w + eps_ (ordsucc m) :e L_ X m :\/: {w + eps_ (ordsucc m)|w :e L_ X m}.
    { apply binunionI2.
      prove w + eps_ (ordsucc m) :e {w + eps_ (ordsucc m)|w :e L_ X m}.
      exact ReplI (L_ X m) (fun w => w + eps_ (ordsucc m)) w Lwm.
    }
    claim LweSm2: w + eps_ (ordsucc m) :e L_ X (ordsucc m).
    { exact L_ordsucc_pos X m (HX1 m Hm) Hm (fun _ v => w + eps_ (ordsucc m) :e v) LweSm1. }
    witness (w + eps_ (ordsucc m)).
    apply andI.
    - prove w + eps_ (ordsucc m) :e L X.
      prove w + eps_ (ordsucc m) :e \/_ n :e omega, L_ X n.
      exact famunionI omega (L_ X) (ordsucc m) (w + eps_ (ordsucc m)) (omega_ordsucc m (HX1 m Hm)) LweSm2.
    - prove w < w + eps_ (ordsucc m).
      exact add_SNo_eps_Lt w Lw (ordsucc m) (omega_ordsucc m (HX1 m Hm)).
  }
  claim R_nomin: forall X c= omega, infinite (omega :\: X) ->
       forall z :e R X, exists z' :e R X, z' < z.
  { let X. assume HX1 HX2.
    let z. assume Hz.
    claim Lz: SNo z.
    { exact RSNo X z Hz. }
    apply famunionE_impred omega (R_ X) z Hz.
    let n.
    assume Hn: n :e omega.
    assume Hz': z :e R_ X n.
    apply infinite_bigger (omega :\: X) (setminus_Subq omega X) HX2 n Hn.
    let m. assume H. apply H.
    assume Hm: m :e omega :\: X.
    assume Hnm: n :e m.
    apply setminusE omega X m Hm.
    assume Hm1: m :e omega.
    assume Hm2: m /:e X.
    claim Lzm: z :e R_ X m.
    { exact R_Subq X m (omega_nat_p m Hm1) n Hnm z Hz'. }
    claim LzmeSm1: z + - eps_ (ordsucc m) :e R_ X m :\/: {z + - eps_ (ordsucc m)|z :e R_ X m}.
    { apply binunionI2.
      prove z + - eps_ (ordsucc m) :e {z + - eps_ (ordsucc m)|z :e R_ X m}.
      exact ReplI (R_ X m) (fun z => z + - eps_ (ordsucc m)) z Lzm.
    }
    claim LzmeSm2: z + - eps_ (ordsucc m) :e R_ X (ordsucc m).
    { exact R_ordsucc_neg X m Hm1 Hm2 (fun _ v => z + - eps_ (ordsucc m) :e v) LzmeSm1. }
    witness (z + - eps_ (ordsucc m)).
    apply andI.
    - prove z + - eps_ (ordsucc m) :e R X.
      prove z + - eps_ (ordsucc m) :e \/_ n :e omega, R_ X n.
      exact famunionI omega (R_ X) (ordsucc m) (z + - eps_ (ordsucc m)) (omega_ordsucc m Hm1) LzmeSm2.
    - prove z + - eps_ (ordsucc m) < z.
      rewrite <- add_SNo_0R z Lz at 2.
      prove z + - eps_ (ordsucc m) < z + 0.
      apply add_SNo_Lt2 z (- eps_ (ordsucc m)) 0 Lz
                     (SNo_minus_SNo (eps_ (ordsucc m)) (SNo_eps_ (ordsucc m) (omega_ordsucc m Hm1)))
                     SNo_0.
      prove - eps_ (ordsucc m) < 0.
      rewrite <- minus_SNo_0.
      prove - eps_ (ordsucc m) < - 0.
      exact minus_SNo_Lt_contra 0 (eps_ (ordsucc m)) SNo_0 (SNo_eps_ (ordsucc m) (omega_ordsucc m Hm1)) (SNo_eps_pos (ordsucc m) (omega_ordsucc m Hm1)).
  }
  claim L_R_real: forall X c= omega, infinite X -> infinite (omega :\: X) -> SNoCut (L X) (R X) :e real.
  { let X. assume HXo HXinf HXcoinf.
    exact real_SNoCut_SNoS_omega (L X) (LSo X) (R X) (RSo X) (LLR X) (Lne X) (Rne X) (L_nomax X HXo HXinf) (R_nomin X HXo HXcoinf).
  }
  claim L_R_pos: forall X, 0 < SNoCut (L X) (R X).
  { let X.
    apply SNoCutP_SNoCut_impred (L X) (R X) (LLR X).
    assume HLR1: SNo (SNoCut (L X) (R X)).
    assume _.
    assume HLR3: forall w :e L X, w < SNoCut (L X) (R X).
    assume HLR4: forall z :e R X, SNoCut (L X) (R X) < z.
    assume _.
    apply HLR3. exact L0_In X.
  }
  claim L_R_lt1: forall X, SNoCut (L X) (R X) < 1.
  { let X.
    apply SNoCutP_SNoCut_impred (L X) (R X) (LLR X).
    assume HLR1: SNo (SNoCut (L X) (R X)).
    assume _.
    assume HLR3: forall w :e L X, w < SNoCut (L X) (R X).
    assume HLR4: forall z :e R X, SNoCut (L X) (R X) < z.
    assume _.
    apply HLR4. exact R1_In X.
  }
  claim L_R_inj: forall X Y c= omega,
          SNoCut (L X) (R X) = SNoCut (L Y) (R Y)
       -> forall n, nat_p n -> L_ X n = L_ Y n /\ R_ X n = R_ Y n /\ (forall i :e n, i :e X <-> i :e Y).
  { let X. assume HX. let Y. assume HY.
    assume HXY: SNoCut (L X) (R X) = SNoCut (L Y) (R Y).
    prove forall n, nat_p n -> L_ X n = L_ Y n /\ R_ X n = R_ Y n /\ (forall i :e n, i :e X <-> i :e Y).
    apply SNoCutP_SNoCut_impred (L X) (R X) (LLR X).
    assume HLRX1: SNo (SNoCut (L X) (R X)).
    assume HLRX2.
    assume HLRX3: forall w :e L X, w < SNoCut (L X) (R X).
    assume HLRX4: forall z :e R X, SNoCut (L X) (R X) < z.
    assume HLRX5.
    apply SNoCutP_SNoCut_impred (L Y) (R Y) (LLR Y).
    assume HLRY1: SNo (SNoCut (L Y) (R Y)).
    assume HLRY2.
    assume HLRY3: forall w :e L Y, w < SNoCut (L Y) (R Y).
    assume HLRY4: forall z :e R Y, SNoCut (L Y) (R Y) < z.
    assume HLRY5.
    apply nat_ind.
    - prove L_ X 0 = L_ Y 0 /\ R_ X 0 = R_ Y 0 /\ (forall i :e 0, i :e X <-> i :e Y).
      apply and3I.
      + prove L_ X 0 = L_ Y 0.
        transitivity {0}.
        * exact L_0 X.
        * symmetry. exact L_0 Y. 
      + prove R_ X 0 = R_ Y 0.
        transitivity {1}.
        * exact R_0 X.
        * symmetry. exact R_0 Y.
      + let i. assume Hi: i :e 0. prove False. exact EmptyE i Hi.
    - let n. assume Hn. assume IHn. apply IHn. assume H. apply H.
      assume IHLn: L_ X n = L_ Y n.
      assume IHRn: R_ X n = R_ Y n.
      assume IHnXY: forall i :e n, i :e X <-> i :e Y.
      prove L_ X (ordsucc n) = L_ Y (ordsucc n) /\ R_ X (ordsucc n) = R_ Y (ordsucc n) /\ (forall i :e ordsucc n, i :e X <-> i :e Y).
      claim Ln: n :e omega.
      { exact nat_p_omega n Hn. }
      claim Len: SNo (eps_ n).
      { exact SNo_eps_ n Ln. }
      claim LSn: ordsucc n :e omega.
      { exact omega_ordsucc n Ln. }
      claim LeSn: SNo (eps_ (ordsucc n)).
      { exact SNo_eps_ (ordsucc n) LSn. }
      apply xm (n :e X).
      + assume H1: n :e X.
        apply xm (n :e Y).
        * { assume H2: n :e Y.
            apply and3I.
            - prove L_ X (ordsucc n) = L_ Y (ordsucc n).
              transitivity L_ X n :\/: {x + eps_ (ordsucc n)|x :e L_ X n},
                           L_ Y n :\/: {x + eps_ (ordsucc n)|x :e L_ Y n}.
              + exact L_ordsucc_pos X n Ln H1.
              + prove L_ X n :\/: {x + eps_ (ordsucc n)|x :e L_ X n}
                    = L_ Y n :\/: {x + eps_ (ordsucc n)|x :e L_ Y n}.
                rewrite IHLn.
                reflexivity.
              + symmetry. exact L_ordsucc_pos Y n Ln H2.
            - prove R_ X (ordsucc n) = R_ Y (ordsucc n).
              transitivity R_ X n, R_ Y n.
              + exact R_ordsucc_pos X n Ln H1.
              + prove R_ X n = R_ Y n.
                exact IHRn.
              + symmetry. exact R_ordsucc_pos Y n Ln H2.
            - let i. assume Hi: i :e ordsucc n.
              apply ordsuccE n i Hi.
              + assume Hi': i :e n. exact IHnXY i Hi'.
              + assume Hi': i = n. rewrite Hi'.
                prove n :e X <-> n :e Y.
                apply iffI.
                * assume _. exact H2.
                * assume _. exact H1.
          }
        * { assume H2: n /:e Y. prove False.
            apply finite_max_exists (L_ X n) (L_SNo1 X n Hn) (L_fin X n Hn) (L_ne X n Hn).
            let w.
            assume Hw: SNo_max_of (L_ X n) w.
            apply Hw. assume H. apply H.
            assume Hw1: w :e L_ X n.
            assume Hw2: SNo w.
            assume Hw3: forall y :e L_ X n, SNo y -> y <= w.
            apply finite_min_exists (R_ X n) (R_SNo1 X n Hn) (R_fin X n Hn) (R_ne X n Hn).
            let z.
            assume Hz: SNo_min_of (R_ X n) z.
            apply Hz. assume H. apply H.
            assume Hz1: z :e R_ X n.
            assume Hz2: SNo z.
            assume Hz3: forall y :e R_ X n, SNo y -> z <= y.
            claim LweSn: SNo (w + eps_ (ordsucc n)).
            { exact SNo_add_SNo w (eps_ (ordsucc n)) Hw2 LeSn. }
            apply SNoLt_irref (w + eps_ (ordsucc n)).
            prove w + eps_ (ordsucc n) < w + eps_ (ordsucc n).
            apply SNoLt_tra (w + eps_ (ordsucc n)) (SNoCut (L X) (R X)) (w + eps_ (ordsucc n)) ?? ?? ??.
            - prove w + eps_ (ordsucc n) < SNoCut (L X) (R X).
              apply HLRX3.
              prove w + eps_ (ordsucc n) :e L X.
              prove w + eps_ (ordsucc n) :e \/_ n :e omega, L_ X n.
              apply famunionI omega (L_ X) (ordsucc n) (w + eps_ (ordsucc n)) LSn.
              prove w + eps_ (ordsucc n) :e L_ X (ordsucc n).
              claim LwLSn: w + eps_ (ordsucc n) :e L_ X n :\/: {x + eps_ (ordsucc n)|x :e L_ X n}.
              { apply binunionI2.
                exact ReplI (L_ X n) (fun x => x + eps_ (ordsucc n)) w Hw1.
              }
              exact L_ordsucc_pos X n Ln H1 (fun _ u => w + eps_ (ordsucc n) :e u) LwLSn.
            - prove SNoCut (L X) (R X) < w + eps_ (ordsucc n).
              rewrite HXY.
              prove SNoCut (L Y) (R Y) < w + eps_ (ordsucc n).
              apply HLRY4.
              prove w + eps_ (ordsucc n) :e R Y.
              prove w + eps_ (ordsucc n) :e \/_ n :e omega, R_ Y n.
              apply famunionI omega (R_ Y) (ordsucc n) (w + eps_ (ordsucc n)) LSn.
              prove w + eps_ (ordsucc n) :e R_ Y (ordsucc n).
              claim Lwz: w + eps_ (ordsucc n) = z + - eps_ (ordsucc n).
              { rewrite L_R_dist X n Hn w z Hw Hz.
                prove w + eps_ (ordsucc n) = (w + eps_ n) + - eps_ (ordsucc n).
                rewrite <- eps_ordsucc_half_add n Hn.
                prove w + eps_ (ordsucc n) = (w + eps_ (ordsucc n) + eps_ (ordsucc n)) + - eps_ (ordsucc n).
                rewrite add_SNo_assoc w (eps_ (ordsucc n)) (eps_ (ordsucc n)) Hw2 LeSn LeSn.
                prove w + eps_ (ordsucc n) = ((w + eps_ (ordsucc n)) + eps_ (ordsucc n)) + - eps_ (ordsucc n).
                symmetry.
                exact add_SNo_minus_R2 (w + eps_ (ordsucc n)) (eps_ (ordsucc n)) LweSn LeSn.
              }
              rewrite Lwz.
              prove z + - eps_ (ordsucc n) :e R_ Y (ordsucc n).
              claim Lz1: z :e R_ Y n.
              { rewrite <- IHRn. exact Hz1. }
              claim LzRSn: z + - eps_ (ordsucc n) :e R_ Y n :\/: {x + - eps_ (ordsucc n)|x :e R_ Y n}.
              { apply binunionI2.
                exact ReplI (R_ Y n) (fun x => x + - eps_ (ordsucc n)) z Lz1.
              }
              exact R_ordsucc_neg Y n Ln H2 (fun _ u => z + - eps_ (ordsucc n) :e u) LzRSn.
          }
      + assume H1: n /:e X.
        apply xm (n :e Y).
        * { assume H2: n :e Y. prove False.
            apply finite_max_exists (L_ X n) (L_SNo1 X n Hn) (L_fin X n Hn) (L_ne X n Hn).
            let w.
            assume Hw: SNo_max_of (L_ X n) w.
            apply Hw. assume H. apply H.
            assume Hw1: w :e L_ X n.
            assume Hw2: SNo w.
            assume Hw3: forall y :e L_ X n, SNo y -> y <= w.
            apply finite_min_exists (R_ X n) (R_SNo1 X n Hn) (R_fin X n Hn) (R_ne X n Hn).
            let z.
            assume Hz: SNo_min_of (R_ X n) z.
            apply Hz. assume H. apply H.
            assume Hz1: z :e R_ X n.
            assume Hz2: SNo z.
            assume Hz3: forall y :e R_ X n, SNo y -> z <= y.
            claim LweSn: SNo (w + eps_ (ordsucc n)).
            { exact SNo_add_SNo w (eps_ (ordsucc n)) Hw2 LeSn. }
            apply SNoLt_irref (w + eps_ (ordsucc n)).
            prove w + eps_ (ordsucc n) < w + eps_ (ordsucc n).
            apply SNoLt_tra (w + eps_ (ordsucc n)) (SNoCut (L X) (R X)) (w + eps_ (ordsucc n)) ?? ?? ??.
            - prove w + eps_ (ordsucc n) < SNoCut (L X) (R X).
              rewrite HXY.
              prove w + eps_ (ordsucc n) < SNoCut (L Y) (R Y).
              apply HLRY3.
              prove w + eps_ (ordsucc n) :e L Y.
              prove w + eps_ (ordsucc n) :e \/_ n :e omega, L_ Y n.
              apply famunionI omega (L_ Y) (ordsucc n) (w + eps_ (ordsucc n)) LSn.
              prove w + eps_ (ordsucc n) :e L_ Y (ordsucc n).
                    claim Lw1: w :e L_ Y n.
              { rewrite <- IHLn. exact Hw1. }
              claim LwLSn: w + eps_ (ordsucc n) :e L_ Y n :\/: {x + eps_ (ordsucc n)|x :e L_ Y n}.
              { apply binunionI2.
                exact ReplI (L_ Y n) (fun x => x + eps_ (ordsucc n)) w Lw1.
              }
              exact L_ordsucc_pos Y n Ln H2 (fun _ u => w + eps_ (ordsucc n) :e u) LwLSn.
            - prove SNoCut (L X) (R X) < w + eps_ (ordsucc n).
              apply HLRX4.
              prove w + eps_ (ordsucc n) :e R X.
              prove w + eps_ (ordsucc n) :e \/_ n :e omega, R_ X n.
              apply famunionI omega (R_ X) (ordsucc n) (w + eps_ (ordsucc n)) LSn.
              prove w + eps_ (ordsucc n) :e R_ X (ordsucc n).
              claim Lwz: w + eps_ (ordsucc n) = z + - eps_ (ordsucc n).
              { rewrite L_R_dist X n Hn w z Hw Hz.
                prove w + eps_ (ordsucc n) = (w + eps_ n) + - eps_ (ordsucc n).
                rewrite <- eps_ordsucc_half_add n Hn.
                prove w + eps_ (ordsucc n) = (w + eps_ (ordsucc n) + eps_ (ordsucc n)) + - eps_ (ordsucc n).
                rewrite add_SNo_assoc w (eps_ (ordsucc n)) (eps_ (ordsucc n)) Hw2 LeSn LeSn.
                prove w + eps_ (ordsucc n) = ((w + eps_ (ordsucc n)) + eps_ (ordsucc n)) + - eps_ (ordsucc n).
                symmetry.
                exact add_SNo_minus_R2 (w + eps_ (ordsucc n)) (eps_ (ordsucc n)) LweSn LeSn.
              }
              rewrite Lwz.
              prove z + - eps_ (ordsucc n) :e R_ X (ordsucc n).
              claim LzRSn: z + - eps_ (ordsucc n) :e R_ X n :\/: {x + - eps_ (ordsucc n)|x :e R_ X n}.
              { apply binunionI2.
                exact ReplI (R_ X n) (fun x => x + - eps_ (ordsucc n)) z Hz1.
              }
              exact R_ordsucc_neg X n Ln H1 (fun _ u => z + - eps_ (ordsucc n) :e u) LzRSn.
          }
        * { assume H2: n /:e Y.
            apply and3I.
            - prove L_ X (ordsucc n) = L_ Y (ordsucc n).
              transitivity L_ X n, L_ Y n.
              + exact L_ordsucc_neg X n Ln H1.
              + prove L_ X n = L_ Y n. exact IHLn.
              + symmetry. exact L_ordsucc_neg Y n Ln H2.
            - prove R_ X (ordsucc n) = R_ Y (ordsucc n).
              transitivity R_ X n :\/: {x + - eps_ (ordsucc n)|x :e R_ X n},
                           R_ Y n :\/: {x + - eps_ (ordsucc n)|x :e R_ Y n}.
              + exact R_ordsucc_neg X n Ln H1.
              + rewrite IHRn. reflexivity.
              + symmetry. exact R_ordsucc_neg Y n Ln H2.
            - let i. assume Hi: i :e ordsucc n.
              apply ordsuccE n i Hi.
              + assume Hi': i :e n. exact IHnXY i Hi'.
              + assume Hi': i = n. rewrite Hi'.
                prove n :e X <-> n :e Y.
                apply iffI.
                * assume H3. prove False. exact H1 H3.
                * assume H4. prove False. exact H2 H4.
          }
  }
  set s:set->set := fun X => {0} :\/: {ordsucc n|n :e X}.
  claim Ls: forall X :e Power omega, s X :e Power omega.
  { let X. assume HX.
    apply PowerI.
    prove {0} :\/: {ordsucc n|n :e X} c= omega.
    apply binunion_Subq_min.
    - prove {0} c= omega.
      let u. assume Hu: u :e {0}.
      rewrite SingE 0 u Hu.
      prove 0 :e omega.
      exact nat_p_omega 0 nat_0.
    - prove {ordsucc n|n :e X} c= omega.
      let u. assume Hu.
      apply ReplE_impred X ordsucc u Hu.
      let n. assume Hn: n :e X.
      assume Hun: u = ordsucc n.
      rewrite Hun.
      apply omega_ordsucc n.
      prove n :e omega.
      exact PowerE omega X HX n Hn.
  }
  claim Lsinj: forall X Y, s X = s Y -> X = Y.
  { let X Y.
    assume HXY: s X = s Y.
    apply set_ext.
    - let u. assume Hu: u :e X.
      claim LSu: ordsucc u :e s Y.
      { rewrite <- HXY.
        prove ordsucc u :e {0} :\/: {ordsucc n|n :e X}.
        apply binunionI2.
        exact ReplI X ordsucc u Hu.
      }
      apply binunionE {0} {ordsucc n|n :e Y} (ordsucc u) LSu.
      + assume H1: ordsucc u :e {0}. prove False.
        apply neq_ordsucc_0 u.
        exact SingE 0 (ordsucc u) H1.
      + assume H1: ordsucc u :e {ordsucc n|n :e Y}.
        apply ReplE_impred Y ordsucc (ordsucc u) H1.
        let n. assume Hn: n :e Y.
        assume HSun: ordsucc u = ordsucc n.
        prove u :e Y.
        rewrite ordsucc_inj u n HSun.
        exact Hn.
    - let u. assume Hu: u :e Y.
      claim LSu: ordsucc u :e s X.
      { rewrite HXY.
        prove ordsucc u :e {0} :\/: {ordsucc n|n :e Y}.
        apply binunionI2.
        exact ReplI Y ordsucc u Hu.
      }
      apply binunionE {0} {ordsucc n|n :e X} (ordsucc u) LSu.
      + assume H1: ordsucc u :e {0}. prove False.
        apply neq_ordsucc_0 u.
        exact SingE 0 (ordsucc u) H1.
      + assume H1: ordsucc u :e {ordsucc n|n :e X}.
        apply ReplE_impred X ordsucc (ordsucc u) H1.
        let n. assume Hn: n :e X.
        assume HSun: ordsucc u = ordsucc n.
        prove u :e X.
        rewrite ordsucc_inj u n HSun.
        exact Hn.
  }
  claim Ls0: forall X, 0 :e s X.
  { let X. exact binunionI1 {0} {ordsucc n|n :e X} 0 (SingI 0). }
  claim Lsfin: forall X, finite X -> finite (s X).
  { let X. assume HX.
    prove finite ({0} :\/: {ordsucc n|n :e X}).
    apply binunion_finite.
    - apply Sing_finite.
    - apply Repl_finite. exact HX.
  }
  set h:set->set := fun X => X :\/: \/_ i :e X, {n '|n :e i, n /:e X}.
  claim Lh0: h 0 = 0.
  { prove 0 :\/: (\/_ i :e 0, {n '|n :e i, n /:e 0}) = 0.
    rewrite famunion_Empty (fun i => {n '|n :e i, n /:e 0}).
    prove 0 :\/: 0 = 0.
    exact binunion_idl 0.
  }
  claim LhSa: forall X :e Power omega,
              forall alpha, ordinal alpha -> X c= alpha -> (forall n :e alpha, ~(X c= n))
           -> SNo_ alpha (h X).
  { let X. assume HX: X :e Power omega.
    let alpha.
    assume Ha1: ordinal alpha.
    assume Ha2: X c= alpha.
    assume Ha3: forall n :e alpha, ~(X c= n).
    apply Ha1.
    assume Ha1a Ha1b.
    prove SNo_ alpha (h X).
    prove h X c= SNoElts_ alpha
       /\ forall n :e alpha, exactly1of2 (n ' :e h X) (n :e h X).
    apply andI.
    - let u. assume Hu: u :e h X.
      prove u :e SNoElts_ alpha.
      apply binunionE X (\/_ i :e X, {n '|n :e i, n /:e X}) u Hu.
      + assume H1: u :e X.
        prove u :e alpha :\/: {n '|n :e alpha}.
        apply binunionI1.
        exact Ha2 u H1.
      + assume H1: u :e \/_ i :e X, {n '|n :e i, n /:e X}.
        prove u :e alpha :\/: {n '|n :e alpha}.
        apply binunionI2.
        prove u :e {n '|n :e alpha}.
        apply famunionE_impred X (fun i => {n '|n :e i, n /:e X}) u H1.
        let i. assume Hi: i :e X.
        assume H2: u :e {n '|n :e i, n /:e X}.
        apply ReplSepE_impred i (fun n => n /:e X) (fun n => n ') u H2.
        let n. assume Hn: n :e i.
        assume H3: n /:e X.
        assume H4: u = n '.
        prove u :e {n '|n :e alpha}.
        rewrite H4.
        claim Lna: n :e alpha.
        { exact Ha1a i (Ha2 i Hi) n Hn. }
        exact ReplI alpha (fun n => n ') n Lna.
    - let n. assume Hn: n :e alpha.
      prove exactly1of2 (n ' :e h X) (n :e h X).
      claim Lno: ordinal n.
      { exact ordinal_Hered alpha Ha1 n Hn. }
      apply xm (n :e X).
      + assume H1: n :e X.
        apply exactly1of2_I2.
        * { prove n ' /:e h X.
            assume H2: n ' :e X :\/: \/_ i :e X, {n '|n :e i, n /:e X}.
            apply binunionE X (\/_ i :e X, {n '|n :e i, n /:e X}) (n ') H2.
            - assume H3: n ' :e X.
              apply tagged_not_ordinal n.
              prove ordinal (n ').
              apply ordinal_Hered alpha Ha1 (n ').
              prove n ' :e alpha.
              exact Ha2 (n ') H3.
            - assume H3: n ' :e \/_ i :e X, {n '|n :e i, n /:e X}.
              apply famunionE_impred X (fun i => {n '|n :e i, n /:e X}) (n ') H3.
              let i. assume Hi: i :e X.
              assume H4: n ' :e {n '|n :e i, n /:e X}.
              apply ReplSepE_impred i (fun n => n /:e X) (fun n => n ') (n ') H4.
              let m. assume Hm: m :e i.
              assume H5: m /:e X.
              assume H6: n ' = m '.
              apply H5.
              claim Lmo: ordinal m.
              { apply ordinal_Hered alpha Ha1 m.
                prove m :e alpha.
                exact Ha1a i (Ha2 i Hi) m Hm.
              }
              rewrite <- tagged_eqE_eq n m Lno Lmo H6.
              exact H1.
          }
        * prove n :e h X.
          prove n :e X :\/: \/_ i :e X, {n '|n :e i, n /:e X}.
          apply binunionI1.
          exact H1.
      + assume H1: n /:e X.
        apply exactly1of2_I1.
        * { prove n ' :e h X.
            prove n ' :e X :\/: \/_ i :e X, {n '|n :e i, n /:e X}.
            apply binunionI2.
            prove n ' :e \/_ i :e X, {n '|n :e i, n /:e X}.
            apply xm (exists i :e X, n :e i).
            - assume H3: exists i :e X, n :e i.
              apply H3.
              let i. assume H. apply H.
              assume Hi: i :e X.
              assume Hni: n :e i.
              claim Ln': n ' :e {n '|n :e i, n /:e X}.
              { exact ReplSepI i (fun n => n /:e X) (fun n => n ') n Hni H1. }
              exact famunionI X (fun i => {n '|n :e i, n /:e X}) i (n ') Hi Ln'.
            - assume H3: ~exists i :e X, n :e i. prove False.
              apply Ha3 n Hn.
              prove X c= n.
              let i. assume Hi: i :e X.
              prove i :e n.
              claim Lio: ordinal i.
              { exact ordinal_Hered alpha Ha1 i (Ha2 i Hi). }
              apply ordinal_trichotomy_or_impred i n Lio Lno.
              + assume H4: i :e n. exact H4.
              + assume H4: i = n. prove False.
                apply H1.
                prove n :e X.
                rewrite <- H4. exact Hi.
              + assume H4: n :e i. prove False.
                apply H3. witness i. apply andI.
                * exact Hi.
                * exact H4.
          }
        * { prove n /:e h X.
            assume H2: n :e X :\/: \/_ i :e X, {n '|n :e i, n /:e X}.
            apply binunionE X (\/_ i :e X, {n '|n :e i, n /:e X}) n H2.
            - assume H3: n :e X. prove False. exact H1 H3.
            - assume H3: n :e \/_ i :e X, {n '|n :e i, n /:e X}.
              apply famunionE_impred X (fun i => {n '|n :e i, n /:e X}) n H3.
              let i. assume Hi: i :e X.
              assume H4: n :e {n '|n :e i, n /:e X}.
              apply ReplSepE_impred i (fun n => n /:e X) (fun n => n ') n H4.
              let m. assume Hm: m :e i.
              assume H5: m /:e X.
              assume H6: n = m '.
              prove False.
              apply tagged_not_ordinal m.
              prove ordinal (m ').
              rewrite <- H6. exact Lno.
          }
  }
  claim LhS: forall X :e Power omega, SNo (h X).
  { let X. assume HX: X :e Power omega.
    claim LhS': exists alpha, ordinal alpha /\ X c= alpha.
    { witness omega. apply andI.
      - exact omega_ordinal.
      - prove X c= omega. apply PowerE. exact HX.
    }
    apply least_ordinal_ex (fun alpha => X c= alpha) LhS'.
    let alpha. assume H. apply H. assume H. apply H.
    assume Ha1: ordinal alpha.
    assume Ha2: X c= alpha.
    assume Ha3: forall n :e alpha, ~(X c= n).
    apply SNo_SNo alpha Ha1 (h X).
    prove SNo_ alpha (h X).
    exact LhSa X HX alpha Ha1 Ha2 Ha3.
  }
  claim Lh: forall X :e Power omega, finite X -> h X :e SNoS_ omega.
  { let X. assume HX: X :e Power omega.
    assume HXfin: finite X.
    prove h X :e SNoS_ omega.
    apply xm (X = 0).
    - assume H1: X = 0. rewrite H1.
      prove h 0 :e SNoS_ omega.
      rewrite Lh0.
      prove 0 :e SNoS_ omega.
      apply SNoS_I omega omega_ordinal 0 0 (nat_p_omega 0 nat_0).
      prove SNo_ 0 0.
      exact ordinal_SNo_ Empty ordinal_Empty.
    - assume H1: X <> 0.
      claim LXS: forall x :e X, SNo x.
      { let x. assume Hx.
        apply nat_p_SNo.
        apply omega_nat_p.
        prove x :e omega.
        exact PowerE omega X HX x Hx.
      }
      apply finite_max_exists X LXS HXfin H1.
      let n. assume Hn: SNo_max_of X n.
      apply Hn. assume H. apply H.
      assume Hn1: n :e X.
      assume Hn2: SNo n.
      assume Hn3: forall x :e X, SNo x -> x <= n.
      claim Ln: n :e omega.
      { exact PowerE omega X HX n Hn1. }
      claim Lno: ordinal n.
      { apply nat_p_ordinal. apply omega_nat_p. exact Ln. }
      claim LSn: ordsucc n :e omega.
      { apply omega_ordsucc. exact Ln. }
      claim LSno: ordinal (ordsucc n).
      { apply nat_p_ordinal. apply omega_nat_p. exact LSn. }
      claim LSnhX: SNo_ (ordsucc n) (h X).
      { apply LhSa X HX (ordsucc n) LSno.
        - prove X c= ordsucc n.
          let i. assume Hi: i :e X.
          claim Lio: ordinal i.
          { exact ordinal_Hered omega omega_ordinal i (PowerE omega X HX i Hi). }
          claim LiS: SNo i.
          { exact ordinal_SNo i Lio. }
          apply ordinal_In_Or_Subq i (ordsucc n) Lio LSno.
          + assume H2: i :e ordsucc n. exact H2.
          + assume H2: ordsucc n c= i. prove False.
            apply SNoLt_irref i.
            prove i < i.
            apply SNoLeLt_tra i n i LiS Hn2 LiS (Hn3 i Hi LiS).
            prove n < i.
            apply SNoLtLe_tra n (ordsucc n) i (ordinal_SNo n Lno) (ordinal_SNo (ordsucc n) LSno) LiS.
            * prove n < ordsucc n.
              exact ordinal_In_SNoLt (ordsucc n) LSno n (ordsuccI2 n).
            * prove ordsucc n <= i.
              exact ordinal_Subq_SNoLe (ordsucc n) i LSno Lio H2.
        - prove forall m :e ordsucc n, ~(X c= m).
          let m. assume Hm.
          assume H2: X c= m.
          apply ordsuccE n m Hm.
          + assume H3: m :e n.
            exact In_no2cycle m n H3 (H2 n Hn1).
          + assume H3: m = n.
            apply In_irref n. rewrite <- H3 at 2.
            prove n :e m.
            exact H2 n Hn1.
      }
      prove h X :e SNoS_ omega.
      exact SNoS_I omega omega_ordinal (h X) (ordsucc n) LSn LSnhX.
  }
  claim Lh0pos: forall X :e Power omega, 0 :e X -> 0 < h X.
  { let X. assume HX HX0.
    prove 0 < h X.
    claim L0hX: 0 :e h X.
    { prove 0 :e X :\/: \/_ i :e X, {n '|n :e i, n /:e X}.
      apply binunionI1.
      exact HX0.
    }
    apply SNoLtI2 0 (h X).
    - prove SNoLev 0 :e SNoLev (h X).
      rewrite SNoLev_0.
      prove 0 :e SNoLev (h X).
      apply SNoLev_ (h X) (LhS X HX).
      assume H1: h X c= SNoElts_ (SNoLev (h X)).
      assume _.
      apply binunionE (SNoLev (h X)) {beta '|beta :e SNoLev (h X)} 0 (H1 0 L0hX).
      + assume H2: 0 :e SNoLev (h X). exact H2.
      + assume H2: 0 :e {beta '|beta :e SNoLev (h X)}. prove False.
        apply ReplE_impred (SNoLev (h X)) (fun beta => beta ') 0 H2.
        let beta.
        assume Hb1: beta :e SNoLev (h X).
        assume Hb2: 0 = beta '.
        apply tagged_not_ordinal beta.
        prove ordinal (beta ').
        rewrite <- Hb2.
        exact ordinal_Empty.
    - prove SNoEq_ (SNoLev 0) 0 (h X).
      rewrite SNoLev_0.
      let i. assume Hi: i :e 0. prove False.
      exact EmptyE i Hi.
    - prove SNoLev 0 :e h X.
      rewrite SNoLev_0.
      exact L0hX.
  }
  claim Lhinj1: forall X Y :e Power omega, h X = h Y -> X c= Y.
  { let X. assume HX. let Y. assume HY HXY.
    let x. assume Hx: x :e X.
    claim Lxo: ordinal x.
    { exact nat_p_ordinal x (omega_nat_p x (PowerE omega X HX x Hx)). }
    claim LxhY: x :e h Y.
    { rewrite <- HXY.
      prove x :e X :\/: \/_ i :e X, {n '|n :e i, n /:e X}.
      apply binunionI1.
      exact Hx.
    }
    apply binunionE Y (\/_ i :e Y, {n '|n :e i, n /:e Y}) x LxhY.
    - assume H1: x :e Y. exact H1.
    - assume H1: x :e \/_ i :e Y, {n '|n :e i, n /:e Y}.
      apply famunionE_impred Y (fun i => {n '|n :e i, n /:e Y}) x H1.
      let i. assume Hi: i :e Y.
      assume H2: x :e {n '|n :e i, n /:e Y}.
      apply ReplSepE_impred i (fun n => n /:e Y) (fun n => n ') x H2.
      let m. assume Hm: m :e i.
      assume H3: m /:e Y.
      assume H4: x = m '.
      prove False.
      apply tagged_not_ordinal m.
      prove ordinal (m ').
      rewrite <- H4.
      exact Lxo.
  }
  claim Lhinj: forall X Y :e Power omega, h X = h Y -> X = Y.
  { let X. assume HX. let Y. assume HY HXY.
    apply set_ext.
    - exact Lhinj1 X HX Y HY HXY.
    - exact Lhinj1 Y HY X HX (fun q => HXY (fun x y => q y x)).
  }
  set g:set->set := fun X => if finite X then h (s X) + 1 else if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X).
  prove exists g:set->set, inj (Power omega) real g.
  witness g.  
  prove (forall u :e Power omega, g u :e real)
     /\ (forall u v :e Power omega, g u = g v -> u = v).
  apply andI.
  + let X. assume HX: X :e Power omega.
    apply xm (finite X).
    * assume H1: finite X.
      prove (if finite X then h (s X) + 1 else if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X)) :e real.
      claim LhsX: h (s X) + 1 :e real.
      { apply real_add_SNo.
        - apply SNoS_omega_real.
          apply Lh.
          + prove s X :e Power omega.
            apply Ls.
            exact HX.
          + prove finite (s X). apply Lsfin.
            exact H1.
        - prove 1 :e real.
          apply SNoS_omega_real.
          apply omega_SNoS_omega.
          apply nat_p_omega.
          exact nat_1.
      }
      exact If_i_1 (finite X) (h (s X) + 1) (if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X)) H1 (fun _ u => u :e real) LhsX.
    * { assume H1: infinite X.
        apply xm (finite (omega :\: X)).
        - assume H2: finite (omega :\: X).
          claim LmhsX: - h (s (omega :\: X)) :e real.
          { apply real_minus_SNo.
            apply SNoS_omega_real.
            apply Lh.
            - prove s (omega :\: X) :e Power omega.
              apply Ls.
              apply PowerI.
              exact setminus_Subq omega X.
            - prove finite (s (omega :\: X)). apply Lsfin.
              exact H2.
          }
          claim LmhsX': (if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X)) :e real.
          { exact If_i_1 (finite (omega :\: X)) (- h (s (omega :\: X))) (SNoCut (L X) (R X)) H2 (fun _ u => u :e real) LmhsX. }
          exact If_i_0 (finite X) (h (s X) + 1) (if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X)) H1 (fun _ u => u :e real) LmhsX'.
        - assume H2: infinite (omega :\: X).
          claim LLRX: SNoCut (L X) (R X) :e real.
          { exact L_R_real X (PowerE omega X HX) H1 H2. }
          claim LLRX': (if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X)) :e real.
          { exact If_i_0 (finite (omega :\: X)) (- h (s (omega :\: X))) (SNoCut (L X) (R X)) H2 (fun _ u => u :e real) LLRX. }
          exact If_i_0 (finite X) (h (s X) + 1) (if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X)) H1 (fun _ u => u :e real) LLRX'.
      }
  + let X. assume HX: X :e Power omega.
    let Y. assume HY: Y :e Power omega.
    claim LX: X c= omega.
    { exact PowerE omega X HX. }
    claim LY: Y c= omega.
    { exact PowerE omega Y HY. }
    claim LoX: omega :\: X :e Power omega.
    { apply PowerI. exact setminus_Subq omega X. }
    claim LoY: omega :\: Y :e Power omega.
    { apply PowerI. exact setminus_Subq omega Y. }
    apply xm (finite X).
    * { assume H1: finite X.
        apply SNoS_E2 omega omega_ordinal (h (s X)) (Lh (s X) (Ls X HX) (Lsfin X H1)).
        assume HhsX1: SNoLev (h (s X)) :e omega.
        assume HhsX2: ordinal (SNoLev (h (s X))).
        assume HhsX3: SNo (h (s X)).
        assume HhsX4: SNo_ (SNoLev (h (s X))) (h (s X)).
        prove (if finite X then h (s X) + 1 else if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X))
            = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y))
         -> X = Y.
        apply If_i_1 (finite X) (h (s X) + 1) (if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X)) H1
           (fun _ u =>
              u = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)) -> X = Y).
        prove h (s X) + 1 = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y))
         -> X = Y.
        apply xm (finite Y).
        - assume H2: finite Y.
          apply SNoS_E2 omega omega_ordinal (h (s Y)) (Lh (s Y) (Ls Y HY) (Lsfin Y H2)).
          assume HhsY1: SNoLev (h (s Y)) :e omega.
          assume HhsY2: ordinal (SNoLev (h (s Y))).
          assume HhsY3: SNo (h (s Y)).
          assume HhsY4: SNo_ (SNoLev (h (s Y))) (h (s Y)).
          apply If_i_1 (finite Y) (h (s Y) + 1) (if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)) H2
           (fun _ u => h (s X) + 1 = u -> X = Y).
          prove h (s X) + 1 = h (s Y) + 1 -> X = Y.
          assume H3: h (s X) + 1 = h (s Y) + 1.
          apply Lsinj.
          prove s X = s Y.
          exact Lhinj (s X) (Ls X HX) (s Y) (Ls Y HY)
                  (add_SNo_cancel_R (h (s X)) 1 (h (s Y)) HhsX3 SNo_1 HhsY3 H3).
        - assume H2: infinite Y.
          apply xm (finite (omega :\: Y)).
          + assume H3: finite (omega :\: Y).
            assume H4: h (s X) + 1 = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)).
            apply SNoS_E2 omega omega_ordinal (h (s (omega :\: Y))) (Lh (s (omega :\: Y)) (Ls (omega :\: Y) LoY) (Lsfin (omega :\: Y) H3)).
            assume HhsY1: SNoLev (h (s (omega :\: Y))) :e omega.
            assume HhsY2: ordinal (SNoLev (h (s (omega :\: Y)))).
            assume HhsY3: SNo (h (s (omega :\: Y))).
            assume HhsY4: SNo_ (SNoLev (h (s (omega :\: Y)))) (h (s (omega :\: Y))).
            claim LhsXmhsY: h (s X) + 1 = - h (s (omega :\: Y)).
            { rewrite H4.
              transitivity (if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)).
              - exact If_i_0 (finite Y) (h (s Y) + 1) (if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)) H2.
              - exact If_i_1 (finite (omega :\: Y)) (- h (s (omega :\: Y))) (SNoCut (L Y) (R Y)) H3.
            }
            prove False.
            apply SNoLt_irref 0.
            prove 0 < 0.
            apply SNoLt_tra 0 (h (s X)) 0 SNo_0 HhsX3 SNo_0.
            * { prove 0 < h (s X).
                apply Lh0pos.
                - prove s X :e Power omega.
                  apply Ls.
                  exact HX.
                - prove 0 :e s X.
                  prove 0 :e {0} :\/: {ordsucc n|n :e X}.
                  apply binunionI1.
                  apply SingI.
              }
            * { prove h (s X) < 0.
                claim LhsXhsX1: h (s X) < h (s X) + 1.
                { exact add_SNo_0R (h (s X)) HhsX3
                          (fun u _ => u < h (s X) + 1)
                          (add_SNo_Lt2 (h (s X)) 0 1 HhsX3 SNo_0 SNo_1 SNoLt_0_1).
                }
                claim LhsX10: h (s X) + 1 < 0.
                { rewrite LhsXmhsY.
                  prove - h (s (omega :\: Y)) < 0.
                  claim LhsYpos: - 0 < h (s (omega :\: Y)).
                  { rewrite minus_SNo_0.
                    apply Lh0pos.
                    - prove s (omega :\: Y) :e Power omega.
                      apply Ls.
                      exact LoY.
                    - prove 0 :e s (omega :\: Y).
                      prove 0 :e {0} :\/: {ordsucc n|n :e omega :\: Y}.
                      apply binunionI1.
                      apply SingI.
                  }
                  exact minus_SNo_Lt_contra1 0 (h (s (omega :\: Y))) SNo_0 HhsY3 LhsYpos.
                }
                exact SNoLt_tra (h (s X)) (h (s X) + 1) 0 HhsX3 (SNo_add_SNo (h (s X)) 1 HhsX3 SNo_1) SNo_0 LhsXhsX1 LhsX10.
                    }
          + assume H3: infinite (omega :\: Y).
            assume H4: h (s X) + 1 = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)).
            claim LhsXSLRY: h (s X) + 1 = SNoCut (L Y) (R Y).
            { rewrite H4.
              transitivity (if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)).
              - exact If_i_0 (finite Y) (h (s Y) + 1) (if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)) H2.
              - exact If_i_0 (finite (omega :\: Y)) (- h (s (omega :\: Y))) (SNoCut (L Y) (R Y)) H3.
            }
            prove False.
            apply SNoLt_irref 1.
            prove 1 < 1.
            apply SNoLt_tra 1 (h (s X) + 1) 1 SNo_1 (SNo_add_SNo (h (s X)) 1 HhsX3 SNo_1) SNo_1.
            * prove 1 < h (s X) + 1.
              claim LhsXpos: 0 < h (s X).
              { apply Lh0pos.
                - prove s X :e Power omega.
                  apply Ls.
                  exact HX.
                - prove 0 :e s X.
                  prove 0 :e {0} :\/: {ordsucc n|n :e X}.
                  apply binunionI1.
                  apply SingI.
              }
              rewrite <- add_SNo_0L 1 SNo_1 at 1.
              prove 0 + 1 < h (s X) + 1.
              exact add_SNo_Lt1 0 1 (h (s X)) SNo_0 SNo_1 HhsX3 LhsXpos.
            * prove h (s X) + 1 < 1.
              rewrite LhsXSLRY.
              exact L_R_lt1 Y.
      }
    * { assume H1: infinite X.
        prove (if finite X then h (s X) + 1 else if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X))
            = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y))
         -> X = Y.
        apply If_i_0 (finite X) (h (s X) + 1) (if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X)) H1
           (fun _ u =>
              u = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)) -> X = Y).
        prove (if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X))
            = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y))
         -> X = Y.
        apply xm (finite (omega :\: X)).
        - assume H2: finite (omega :\: X).
          apply SNoS_E2 omega omega_ordinal (h (s (omega :\: X))) (Lh (s (omega :\: X)) (Ls (omega :\: X) LoX) (Lsfin (omega :\: X) H2)).
          assume HhsX1: SNoLev (h (s (omega :\: X))) :e omega.
          assume HhsX2: ordinal (SNoLev (h (s (omega :\: X)))).
          assume HhsX3: SNo (h (s (omega :\: X))).
          assume HhsX4: SNo_ (SNoLev (h (s (omega :\: X)))) (h (s (omega :\: X))).
          prove (if finite (omega :\: X) then - h (s (omega :\: X)) else SNoCut (L X) (R X))
              = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y))
           -> X = Y.
          apply If_i_1 (finite (omega :\: X)) (- h (s (omega :\: X))) (SNoCut (L X) (R X)) H2
                    (fun _ u =>
                       u = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)) -> X = Y).
          prove (- h (s (omega :\: X)))
              = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y))
           -> X = Y.
          apply xm (finite Y).
          + assume H3: finite Y.
            assume H4: (- h (s (omega :\: X))) = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)).
            apply SNoS_E2 omega omega_ordinal (h (s Y)) (Lh (s Y) (Ls Y HY) (Lsfin Y H3)).
            assume HhsY1: SNoLev (h (s Y)) :e omega.
            assume HhsY2: ordinal (SNoLev (h (s Y))).
            assume HhsY3: SNo (h (s Y)).
            assume HhsY4: SNo_ (SNoLev (h (s Y))) (h (s Y)).
            claim LmhsXhsY: - h (s (omega :\: X)) = h (s Y) + 1.
            { rewrite H4.
              exact If_i_1 (finite Y) (h (s Y) + 1) (if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)) H3.
            }
            prove False.
            apply SNoLt_irref 0.
            prove 0 < 0.
            apply SNoLt_tra 0 (h (s Y) + 1) 0 SNo_0 (SNo_add_SNo (h (s Y)) 1 HhsY3 SNo_1) SNo_0.
            * { prove 0 < h (s Y) + 1.
                claim LhsYpos: 0 < h (s Y).
                { prove 0 < h (s Y).
                  apply Lh0pos.
                  - prove s Y :e Power omega.
                    apply Ls.
                    exact HY.
                  - prove 0 :e s Y.
                    prove 0 :e {0} :\/: {ordsucc n|n :e Y}.
                    apply binunionI1.
                    apply SingI.
                }
                exact SNoLt_tra 0 (h (s Y)) (h (s Y) + 1) SNo_0 HhsY3 (SNo_add_SNo (h (s Y)) 1 HhsY3 SNo_1) LhsYpos
                        (add_SNo_0R (h (s Y)) HhsY3
                          (fun u _ => u < h (s Y) + 1)
                          (add_SNo_Lt2 (h (s Y)) 0 1 HhsY3 SNo_0 SNo_1 SNoLt_0_1)).
              }
            * { prove h (s Y) + 1 < 0.
                rewrite <- LmhsXhsY.
                prove - h (s (omega :\: X)) < 0.
                claim LhsXpos: - 0 < h (s (omega :\: X)).
                { rewrite minus_SNo_0.
                  apply Lh0pos.
                  - prove s (omega :\: X) :e Power omega.
                    apply Ls.
                    exact LoX.
                  - prove 0 :e s (omega :\: X).
                    prove 0 :e {0} :\/: {ordsucc n|n :e omega :\: X}.
                    apply binunionI1.
                    apply SingI.
                }
                exact minus_SNo_Lt_contra1 0 (h (s (omega :\: X))) SNo_0 HhsX3 LhsXpos.
              }
          + assume H3: infinite Y.
            apply If_i_0 (finite Y) (h (s Y) + 1) (if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)) H3 (fun _ u => - h (s (omega :\: X)) = u -> X = Y).
            prove (- h (s (omega :\: X)))
                = (if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y))
             -> X = Y.
            apply xm (finite (omega :\: Y)).
            * { assume H4: finite (omega :\: Y).
                apply SNoS_E2 omega omega_ordinal (h (s (omega :\: Y))) (Lh (s (omega :\: Y)) (Ls (omega :\: Y) (PowerI omega (omega :\: Y) (setminus_Subq omega Y))) (Lsfin (omega :\: Y) H4)).
                assume HhsY1: SNoLev (h (s (omega :\: Y))) :e omega.
                assume HhsY2: ordinal (SNoLev (h (s (omega :\: Y)))).
                assume HhsY3: SNo (h (s (omega :\: Y))).
                assume HhsY4: SNo_ (SNoLev (h (s (omega :\: Y)))) (h (s (omega :\: Y))).
                apply If_i_1 (finite (omega :\: Y)) (- h (s (omega :\: Y))) (SNoCut (L Y) (R Y)) H4
                       (fun _ u => - h (s (omega :\: X)) = u -> X = Y).
                assume H5: - h (s (omega :\: X)) = - h (s (omega :\: Y)).
                prove X = Y.
                claim LoXoY: omega :\: X = omega :\: Y.
                { apply Lsinj.
                  prove s (omega :\: X) = s (omega :\: Y).
                  apply Lhinj (s (omega :\: X)) (Ls (omega :\: X) LoX) (s (omega :\: Y)) (Ls (omega :\: Y) LoY).
                  prove h (s (omega :\: X)) = h (s (omega :\: Y)).
                  transitivity - - h (s (omega :\: X)), - - h (s (omega :\: Y)).
                  - symmetry. exact minus_SNo_invol (h (s (omega :\: X))) HhsX3.
                  - f_equal. exact H5.
                  - exact minus_SNo_invol (h (s (omega :\: Y))) HhsY3.
                }
                prove X = Y.
                apply set_ext.
                - let u. assume HuX: u :e X.
                  apply dneg.
                  assume HuY: u /:e Y.
                  apply setminusE2 omega X u.
                  + prove u :e omega :\: X.
                    rewrite LoXoY.
                    prove u :e omega :\: Y.
                    apply setminusI.
                    * prove u :e omega. exact LX u HuX.
                    * exact HuY.
                  + prove u :e X. exact HuX.
                - let u. assume HuY: u :e Y.
                  apply dneg.
                  assume HuX: u /:e X.
                  apply setminusE2 omega Y u.
                  + prove u :e omega :\: Y.
                    rewrite <- LoXoY.
                    prove u :e omega :\: X.
                    apply setminusI.
                    * prove u :e omega. exact LY u HuY.
                    * exact HuX.
                  + prove u :e Y. exact HuY.
              }
            * { assume H4: infinite (omega :\: Y).
                apply If_i_0 (finite (omega :\: Y)) (- h (s (omega :\: Y))) (SNoCut (L Y) (R Y)) H4
                       (fun _ u => - h (s (omega :\: X)) = u -> X = Y).
                assume H5: - h (s (omega :\: X)) = SNoCut (L Y) (R Y).
                prove False.
                apply SNoLt_irref 0.
                prove 0 < 0.
                apply SNoLt_tra 0 (- h (s (omega :\: X))) 0 SNo_0 (SNo_minus_SNo (h (s (omega :\: X))) HhsX3) SNo_0.
                - prove 0 < - h (s (omega :\: X)).
                  rewrite H5.
                  exact L_R_pos Y.
                - prove - h (s (omega :\: X)) < 0.
                  claim LhsXpos: - 0 < h (s (omega :\: X)).
                  { rewrite minus_SNo_0.
                    apply Lh0pos.
                    - prove s (omega :\: X) :e Power omega.
                      apply Ls.
                      exact LoX.
                    - prove 0 :e s (omega :\: X).
                      prove 0 :e {0} :\/: {ordsucc n|n :e omega :\: X}.
                      apply binunionI1.
                      apply SingI.
                  }
                  exact minus_SNo_Lt_contra1 0 (h (s (omega :\: X))) SNo_0 HhsX3 LhsXpos.
              }
        - assume H2: infinite (omega :\: X).
          apply If_i_0 (finite (omega :\: X)) (- h (s (omega :\: X))) (SNoCut (L X) (R X)) H2
                    (fun _ u =>
                       u = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)) -> X = Y).
          prove (SNoCut (L X) (R X))
              = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y))
           -> X = Y.
          apply xm (finite Y).
          + assume H3: finite Y.
            assume H4: SNoCut (L X) (R X) = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)).
            apply SNoS_E2 omega omega_ordinal (h (s Y)) (Lh (s Y) (Ls Y HY) (Lsfin Y H3)).
            assume HhsY1: SNoLev (h (s Y)) :e omega.
            assume HhsY2: ordinal (SNoLev (h (s Y))).
            assume HhsY3: SNo (h (s Y)).
            assume HhsY4: SNo_ (SNoLev (h (s Y))) (h (s Y)).
            claim LLRXhsY: SNoCut (L X) (R X) = h (s Y) + 1.
            { rewrite H4.
              exact If_i_1 (finite Y) (h (s Y) + 1) (if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)) H3.
            }
            prove False.
            apply SNoLt_irref 1.
            prove 1 < 1.
            apply SNoLt_tra 1 (h (s Y) + 1) 1 SNo_1 (SNo_add_SNo (h (s Y)) 1 HhsY3 SNo_1) SNo_1.
            * prove 1 < h (s Y) + 1.
              claim LhsYpos: 0 < h (s Y).
              { apply Lh0pos.
                - prove s Y :e Power omega.
                  apply Ls.
                  exact HY.
                - prove 0 :e s Y.
                  prove 0 :e {0} :\/: {ordsucc n|n :e Y}.
                  apply binunionI1.
                  apply SingI.
              }
              rewrite <- add_SNo_0L 1 SNo_1 at 1.
              prove 0 + 1 < h (s Y) + 1.
              exact add_SNo_Lt1 0 1 (h (s Y)) SNo_0 SNo_1 HhsY3 LhsYpos.
            * prove h (s Y) + 1 < 1.
              rewrite <- LLRXhsY.
              exact L_R_lt1 X.
          + assume H3: infinite Y.
            prove (SNoCut (L X) (R X))
                = (if finite Y then h (s Y) + 1 else if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y))
             -> X = Y.
            apply If_i_0 (finite Y) (h (s Y) + 1) (if finite (omega :\: Y) then - h (s (omega :\: Y)) else SNoCut (L Y) (R Y)) H3 (fun _ u => SNoCut (L X) (R X) = u -> X = Y).
            apply xm (finite (omega :\: Y)).
            * { assume H4: finite (omega :\: Y).
                apply SNoS_E2 omega omega_ordinal (h (s (omega :\: Y))) (Lh (s (omega :\: Y)) (Ls (omega :\: Y) (PowerI omega (omega :\: Y) (setminus_Subq omega Y))) (Lsfin (omega :\: Y) H4)).
                assume HhsY1: SNoLev (h (s (omega :\: Y))) :e omega.
                assume HhsY2: ordinal (SNoLev (h (s (omega :\: Y)))).
                assume HhsY3: SNo (h (s (omega :\: Y))).
                assume HhsY4: SNo_ (SNoLev (h (s (omega :\: Y)))) (h (s (omega :\: Y))).
                apply If_i_1 (finite (omega :\: Y)) (- h (s (omega :\: Y))) (SNoCut (L Y) (R Y)) H4
                       (fun _ u => SNoCut (L X) (R X) = u -> X = Y).
                assume H5: SNoCut (L X) (R X) = - h (s (omega :\: Y)).
                prove False.
                apply SNoLt_irref 0.
                prove 0 < 0.
                apply SNoLt_tra 0 (- h (s (omega :\: Y))) 0 SNo_0 (SNo_minus_SNo (h (s (omega :\: Y))) HhsY3) SNo_0.
                - prove 0 < - h (s (omega :\: Y)).
                  rewrite <- H5.
                  exact L_R_pos X.
                - prove - h (s (omega :\: Y)) < 0.
                  claim LhsYpos: - 0 < h (s (omega :\: Y)).
                  { rewrite minus_SNo_0.
                    apply Lh0pos.
                    - prove s (omega :\: Y) :e Power omega.
                      apply Ls.
                      exact LoY.
                    - prove 0 :e s (omega :\: Y).
                      prove 0 :e {0} :\/: {ordsucc n|n :e omega :\: Y}.
                      apply binunionI1.
                      apply SingI.
                  }
                  exact minus_SNo_Lt_contra1 0 (h (s (omega :\: Y))) SNo_0 HhsY3 LhsYpos.
              }
            * { assume H4: infinite (omega :\: Y).
                apply If_i_0 (finite (omega :\: Y)) (- h (s (omega :\: Y))) (SNoCut (L Y) (R Y)) H4
                       (fun _ u => SNoCut (L X) (R X) = u -> X = Y).
                assume H5: SNoCut (L X) (R X) = SNoCut (L Y) (R Y).
                prove X = Y.
                apply set_ext.
                - let n. assume HnX: n :e X.
                  apply L_R_inj X LX Y LY H5 (ordsucc n) (nat_ordsucc n (omega_nat_p n (LX n HnX))).
                  assume _.
                  assume H6: forall i :e ordsucc n, i :e X <-> i :e Y.
                  apply H6 n (ordsuccI2 n).
                  assume H7: n :e X -> n :e Y.
                  assume _.
                  exact H7 HnX.
                - let n. assume HnY: n :e Y.
                  apply L_R_inj X LX Y LY H5 (ordsucc n) (nat_ordsucc n (omega_nat_p n (LY n HnY))).
                  assume _.
                  assume H6: forall i :e ordsucc n, i :e X <-> i :e Y.
                  apply H6 n (ordsuccI2 n).
                  assume _.
                  assume H7: n :e Y -> n :e X.
                  exact H7 HnY.
              }
      }
Qed.

Theorem form100_22_real_uncountable_atleastp: ~atleastp real omega.
assume H1: atleastp real omega.
apply equip_sym real (Power omega) equip_real_Power_omega.
let f.
assume Hf: bij (Power omega) real f.
apply H1.
let g.
assume Hg: inj real omega g.
apply form100_22_v2 (fun x => g (f x)).
prove inj (Power omega) omega (fun x => g (f x)).
exact inj_comp (Power omega) real omega f g (bij_inj (Power omega) real f Hf) Hg.
Qed.

Theorem form100_22_real_uncountable_equip: ~equip real omega.
assume H1: equip real omega.
apply form100_22_real_uncountable_atleastp.
prove atleastp real omega.
apply equip_atleastp real omega.
exact H1.
Qed.

Theorem form100_22_real_uncountable: atleastp omega real /\ ~equip real omega.
apply andI.
- prove atleastp omega real.
  apply Subq_atleastp.
  prove omega c= real.
  apply Subq_tra omega (SNoS_ omega) real.
  + prove omega c= SNoS_ omega.
    exact omega_SNoS_omega.
  + prove SNoS_ omega c= real.
    exact SNoS_omega_real.
- exact form100_22_real_uncountable_equip.
Qed.

End form100_22b.

Section rational.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix :/: 353 := div_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Definition rational : set := {x :e real | exists m :e int, exists n :e omega :\: {0}, x = m :/: n}.

End rational.

Section form100_3.

(** The Denumerability of the Rational Numbers **)

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix ^ 342 right := exp_SNo_nat.

Theorem Subq_int_SNoS_omega: int c= SNoS_ omega.
let k. assume Hk.
prove k :e SNoS_ omega.
apply diadic_rational_p_SNoS_omega.
prove diadic_rational_p k.
apply int_diadic_rational_p.
exact Hk.
Qed.

Theorem Subq_SNoS_omega_rational: SNoS_ omega c= rational.
let q. assume Hq: q :e SNoS_ omega.
apply SNoS_omega_diadic_rational_p q Hq.
let k. assume H. apply H.
assume Hk: k :e omega. assume H. apply H.
let m. assume H. apply H.
assume Hm: m :e int.
assume Hqkm: q = eps_ k * m.
claim LkN: nat_p k.
{ exact omega_nat_p k Hk. }
prove q :e {x :e real | exists m :e int, exists n :e omega :\: {0}, x = m :/: n}.
apply SepI.
- prove q :e real.
  apply SNoS_omega_real.
  exact Hq.
- prove exists m :e int, exists n :e omega :\: {0}, q = m :/: n.
  witness m. apply andI.
  + exact Hm.
  + prove exists n :e omega :\: {0}, q = m :/: n.
    claim L2kN: nat_p (2 ^ k).
    { exact nat_exp_SNo_nat 2 nat_2 k LkN. }
    claim L2kS: SNo (2 ^ k).
    { exact nat_p_SNo (2 ^ k) L2kN. }
    claim L2knz: 2 ^ k <> 0.
    { assume H1: 2 ^ k = 0.
      apply neq_1_0.
      prove 1 = 0.
      rewrite <- mul_SNo_eps_power_2 k LkN.
      prove eps_ k * 2 ^ k = 0.
      rewrite H1.
      prove eps_ k * 0 = 0.
      exact mul_SNo_zeroR (eps_ k) (SNo_eps_ k Hk).
    }
    witness 2 ^ k. apply andI.
    * { prove 2 ^ k :e omega :\: {0}. apply setminusI.
        - apply nat_p_omega. exact L2kN.
        - assume H1: 2 ^ k :e {0}. apply L2knz.
          prove 2 ^ k = 0.
          exact SingE 0 (2 ^ k) H1.
      }
    * prove q = m :/: (2 ^ k).
      prove q = m * recip_SNo (2 ^ k).
      rewrite Hqkm.
      prove eps_ k * m = m * recip_SNo (2 ^ k).
      rewrite recip_SNo_pow_2 k LkN.
      exact mul_SNo_com (eps_ k) m (SNo_eps_ k Hk) (int_SNo m Hm).
Qed.

Theorem Subq_rational_real: rational c= real.
exact Sep_Subq real (fun q => exists m :e int, exists n :e omega :\: {0}, q = m :/: n).
Qed.

Theorem rational_minus_SNo: forall q :e rational, - q :e rational.
let q. assume Hq.
apply SepE real (fun q => exists m :e int, exists n :e omega :\: {0}, q = m :/: n) q Hq.
assume HqR: q :e real.
assume HqQ. apply HqQ.
let m. assume H. apply H.
assume Hm: m :e int. assume H. apply H.
let n. assume H. apply H.
assume Hn: n :e omega :\: {0}.
assume H1: q = m :/: n.
apply setminusE omega {0} n Hn.
assume Hno: n :e omega.
assume Hnnz: n /:e {0}.
claim LqS: SNo q.
{ exact real_SNo q HqR. }
claim LnS: SNo n.
{ exact omega_SNo n Hno. }
claim LmqR: - q :e real.
{ exact real_minus_SNo q HqR. }
claim LmqS: SNo (- q).
{ exact real_SNo (- q) LmqR. }
claim LmqQ: exists m :e int, exists n :e omega :\: {0}, - q = m :/: n.
{ witness (- m).
  claim LmmZ: - m :e int.
  { exact int_minus_SNo m Hm. }
  claim LmmS: SNo (- m).
  { exact int_SNo (- m) LmmZ. }
  claim LmmnS: SNo ((- m) :/: n).
  { exact SNo_div_SNo (- m) n ?? ??. }
  apply andI.
  - exact LmmZ.
  - witness n. apply andI.
    + exact Hn.
    + prove - q = (- m) :/: n.
      claim Lnnz: n <> 0.
      { assume H2: n = 0.
        apply Hnnz.
        prove n :e {0}.
        rewrite H2.
        apply SingI.
      }
      apply mul_SNo_nonzero_cancel_L n (- q) ((- m) :/: n) ?? ?? ?? ??.
      prove n * (- q) = n * ((- m) :/: n).
      transitivity - (n * q), - m.
      - prove n * (- q) = - (n * q).
        exact mul_SNo_minus_distrR n q ?? ??.
      - prove - (n * q) = - m.
        f_equal.
        prove n * q = m.
        rewrite H1.
        prove n * (m :/: n) = m.
        exact mul_div_SNo_invR m n (int_SNo m Hm) ?? ??.
      - prove - m = n * ((- m) :/: n).
        symmetry.
        exact mul_div_SNo_invR (- m) n ?? ?? ??.
}
exact SepI real (fun q => exists m :e int, exists n :e omega :\: {0}, q = m :/: n) (- q) LmqR LmqQ.
Qed.

Definition nat_pair : set -> set -> set := fun m n => 2 ^ m * (2 * n + 1).

Theorem nat_pair_In_omega: forall m n :e omega, nat_pair m n :e omega.
let m. assume Hm. let n. assume Hn.
prove (2 ^ m) * (2 * n + 1) :e omega.
apply mul_SNo_In_omega.
- apply nat_p_omega. exact nat_exp_SNo_nat 2 nat_2 m (omega_nat_p m Hm).
- apply add_SNo_In_omega.
  + apply mul_SNo_In_omega.
    * exact nat_p_omega 2 nat_2.
    * exact Hn.
  + exact nat_p_omega 1 nat_1.
Qed.

Theorem nat_pair_0: forall m n m' n' :e omega, nat_pair m n = nat_pair m' n' -> m = m'.
claim L1: forall m n k, nat_p m -> nat_p n -> nat_p k -> 2 ^ (ordsucc m) * (2 * n + 1) <> 2 ^ 0 * (2 * k + 1).
{ let m n k. assume Hm Hn Hk.
  assume H1: 2 ^ (ordsucc m) * (2 * n + 1) = 2 ^ 0 * (2 * k + 1).
  claim L1a: 2 ^ m :e omega.
  { prove 2 ^ m :e omega.
    apply nat_p_omega.
    exact nat_exp_SNo_nat 2 nat_2 m Hm.
  }
  claim L1b: 2 * n :e omega.
  { apply mul_SNo_In_omega.
    - apply nat_p_omega. exact nat_2.
    - apply nat_p_omega. exact Hn.
  }
  claim L1c: 2 * n + 1 :e omega.
  { apply add_SNo_In_omega.
    - exact L1b.
    - apply nat_p_omega. exact nat_1.
  }
  claim L1d: 2 ^ m * (2 * n + 1) :e int.
  { apply Subq_omega_int. apply mul_SNo_In_omega.
    - exact L1a.
    - exact L1c.
  }
  apply not_eq_2m_2n1 (2 ^ m * (2 * n + 1)) L1d
                      k (Subq_omega_int k (nat_p_omega k Hk)).
  transitivity (2 * (2 ^ m)) * (2 * n + 1),
               2 ^ (ordsucc m) * (2 * n + 1),
               2 ^ 0 * (2 * k + 1).
  - prove 2 * (2 ^ m * (2 * n + 1)) = (2 * (2 ^ m)) * (2 * n + 1).
    exact mul_SNo_assoc 2 (2 ^ m) (2 * n + 1) SNo_2 (omega_SNo (2 ^ m) L1a) (omega_SNo (2 * n + 1) L1c).
  - prove (2 * (2 ^ m)) * (2 * n + 1) = 2 ^ (ordsucc m) * (2 * n + 1).
    f_equal.
    prove 2 * (2 ^ m) = 2 ^ (ordsucc m).
    symmetry.
    exact exp_SNo_nat_S 2 SNo_2 m Hm.
  - prove 2 ^ (ordsucc m) * (2 * n + 1) = 2 ^ 0 * (2 * k + 1).
    exact H1.
  - prove 2 ^ 0 * (2 * k + 1) = 2 * k + 1.
    rewrite exp_SNo_nat_0 2 SNo_2.
    prove 1 * (2 * k + 1) = 2 * k + 1.
    apply mul_SNo_oneL (2 * k + 1).
    prove SNo (2 * k + 1).
    apply SNo_add_SNo.
    + apply SNo_mul_SNo.
      * exact SNo_2.
      * exact nat_p_SNo k Hk.
    + exact SNo_1.
}
claim L2: forall k, nat_p k ->
          forall m, nat_p m ->
          forall m', nat_p m' ->
          forall n, nat_p n ->
          forall n', nat_p n' ->
             nat_pair m n = k -> nat_pair m' n' = k -> m = m'.
{ apply nat_complete_ind.
  let k. assume Hk.
  assume IHk: forall k' :e k,
          forall m, nat_p m ->
          forall m', nat_p m' ->
          forall n, nat_p n ->
          forall n', nat_p n' ->
             nat_pair m n = k' -> nat_pair m' n' = k' -> m = m'.
  apply nat_inv_impred.
  - apply nat_inv_impred.
    + let n. assume Hn. let n'. assume Hn'.
      assume H1: 2 ^ 0 * (2 * n + 1) = k.
      assume H2: 2 ^ 0 * (2 * n' + 1) = k.
      prove 0 = 0.
      reflexivity.
    + let m'. assume Hm'. let n. assume Hn. let n'. assume Hn'.
      assume H1: 2 ^ 0 * (2 * n + 1) = k.
      assume H2: 2 ^ (ordsucc m') * (2 * n' + 1) = k.
      prove False.
      claim L1a: 2 ^ m' * (2 * n' + 1) :e int.
      { apply Subq_omega_int. apply mul_SNo_In_omega.
        - prove 2 ^ m' :e omega.
	  apply nat_p_omega.
	  exact nat_exp_SNo_nat 2 nat_2 m' Hm'.
	- prove 2 * n' + 1 :e omega.
	  apply add_SNo_In_omega.
	  + apply mul_SNo_In_omega.
	    * apply nat_p_omega. exact nat_2.
	    * apply nat_p_omega. exact Hn'.
	  + apply nat_p_omega. exact nat_1.
      }
      apply L1 m' n' n Hm' Hn' Hn.
      prove 2 ^ (ordsucc m') * (2 * n' + 1) = 2 ^ 0 * (2 * n + 1).
      rewrite H1.
      exact H2.
  - let m. assume Hm.
    apply nat_inv_impred.
    + let n. assume Hn. let n'. assume Hn'.
      assume H1: 2 ^ (ordsucc m) * (2 * n + 1) = k.
      assume H2: 2 ^ 0 * (2 * n' + 1) = k.
      prove False.
      claim L1b: 2 ^ m * (2 * n + 1) :e int.
      { apply Subq_omega_int. apply mul_SNo_In_omega.
        - prove 2 ^ m :e omega.
	  apply nat_p_omega.
	  exact nat_exp_SNo_nat 2 nat_2 m Hm.
	- prove 2 * n + 1 :e omega.
	  apply add_SNo_In_omega.
	  + apply mul_SNo_In_omega.
	    * apply nat_p_omega. exact nat_2.
	    * apply nat_p_omega. exact Hn.
	  + apply nat_p_omega. exact nat_1.
      }
      apply L1 m n n' Hm Hn Hn'.
      prove 2 ^ (ordsucc m) * (2 * n + 1) = 2 ^ 0 * (2 * n' + 1).
      rewrite H2.
      exact H1.
    + let m'. assume Hm'. let n. assume Hn. let n'. assume Hn'.
      assume H1: 2 ^ (ordsucc m) * (2 * n + 1) = k.
      assume H2: 2 ^ (ordsucc m') * (2 * n' + 1) = k.
      prove ordsucc m = ordsucc m'.
      f_equal.
      set k' := 2 ^ m * (2 * n + 1).
      claim L2mS: SNo (2 ^ m).
      { exact SNo_exp_SNo_nat 2 SNo_2 m Hm. }
      claim L2m'S: SNo (2 ^ m').
      { exact SNo_exp_SNo_nat 2 SNo_2 m' Hm'. }
      claim L2mpos: 0 < 2 ^ m.
      { exact exp_SNo_nat_pos 2 SNo_2 SNoLt_0_2 m Hm. }
      claim L2SmS: SNo (2 ^ ordsucc m).
      { exact SNo_exp_SNo_nat 2 SNo_2 (ordsucc m) (nat_ordsucc m Hm). }
      claim L2nS: SNo (2 * n).
      { exact SNo_mul_SNo 2 n SNo_2 (nat_p_SNo n Hn). }
      claim L2n1S: SNo (2 * n + 1).
      { exact SNo_add_SNo (2 * n) 1 ?? SNo_1. }
      claim L2n'S: SNo (2 * n').
      { exact SNo_mul_SNo 2 n' SNo_2 (nat_p_SNo n' Hn'). }
      claim L2n'1S: SNo (2 * n' + 1).
      { exact SNo_add_SNo (2 * n') 1 ?? SNo_1. }
      claim L2n1pos: 0 < 2 * n + 1.
      { apply SNoLeLt_tra 0 (2 * n) (2 * n + 1) SNo_0 ?? ??.
        - prove 0 <= 2 * n.
          apply mul_SNo_nonneg_nonneg 2 n SNo_2 (nat_p_SNo n Hn).
          + prove 0 <= 2. apply SNoLtLe. exact SNoLt_0_2.
          + prove 0 <= n. exact omega_nonneg n (nat_p_omega n Hn).
        - prove 2 * n < 2 * n + 1.
          rewrite <- add_SNo_0R (2 * n) ?? at 1.
          prove 2 * n + 0 < 2 * n + 1.
          exact add_SNo_Lt2 (2 * n) 0 1 ?? SNo_0 SNo_1 SNoLt_0_1.
      }
      claim L2: k' < k.
      { prove 2 ^ m * (2 * n + 1) < k.
        rewrite <- H1.
        prove 2 ^ m * (2 * n + 1) < 2 ^ (ordsucc m) * (2 * n + 1).
        apply pos_mul_SNo_Lt' (2 ^ m) (2 ^ (ordsucc m)) (2 * n + 1) ?? ?? ?? ??.
        prove 2 ^ m < 2 ^ (ordsucc m).
        rewrite exp_SNo_nat_S 2 SNo_2 m Hm.
        prove 2 ^ m < 2 * 2 ^ m.
        rewrite <- mul_SNo_oneL (2 ^ m) ?? at 1.
        prove 1 * 2 ^ m < 2 * 2 ^ m.
        apply pos_mul_SNo_Lt' 1 2 (2 ^ m) SNo_1 SNo_2 ?? ??.
        prove 1 < 2.
        exact SNoLt_1_2.
      }
      claim L3: k' :e k.
      { apply ordinal_SNoLt_In k' k.
        - prove ordinal k'.
          apply nat_p_ordinal.
          apply omega_nat_p.
          prove 2 ^ m * (2 * n + 1) :e omega.
          prove nat_pair m n :e omega.
          exact nat_pair_In_omega m (nat_p_omega m Hm) n (nat_p_omega n Hn).
        - prove ordinal k. apply nat_p_ordinal. exact Hk.
        - prove k' < k. exact L2.
      }
      claim L4: 2 ^ m * (2 * n + 1) = k'.
      { reflexivity. }
      claim L5: 2 ^ m' * (2 * n' + 1) = k'.
      { prove 2 ^ m' * (2 * n' + 1) = 2 ^ m * (2 * n + 1).
        apply mul_SNo_nonzero_cancel_L 2 (2 ^ m' * (2 * n' + 1)) (2 ^ m * (2 * n + 1))
                               SNo_2
                               neq_2_0
                               (SNo_mul_SNo (2 ^ m') (2 * n' + 1) ?? ??)
                               (SNo_mul_SNo (2 ^ m) (2 * n + 1) ?? ??).
        prove 2 * (2 ^ m' * (2 * n' + 1)) = 2 * (2 ^ m * (2 * n + 1)).
        transitivity (2 * (2 ^ m')) * (2 * n' + 1),
                     (2 ^ (ordsucc m')) * (2 * n' + 1),
                     k,
                     (2 ^ (ordsucc m)) * (2 * n + 1),
                     (2 * (2 ^ m)) * (2 * n + 1).
        - exact mul_SNo_assoc 2 (2 ^ m') (2 * n' + 1) SNo_2 ?? ??.
        - f_equal. symmetry. exact exp_SNo_nat_S 2 SNo_2 m' Hm'.
        - exact H2.
        - symmetry. exact H1.
        - f_equal. exact exp_SNo_nat_S 2 SNo_2 m Hm.
        - symmetry. exact mul_SNo_assoc 2 (2 ^ m) (2 * n + 1) SNo_2 ?? ??.
      }
      prove m = m'.
      exact IHk k' L3 m Hm m' Hm' n Hn n' Hn' L4 L5.
}
let m. assume Hm. let n. assume Hn.
let m'. assume Hm'. let n'. assume Hn'.
assume H1: nat_pair m n = nat_pair m' n'.
apply L2 (nat_pair m' n') (omega_nat_p (nat_pair m' n') (nat_pair_In_omega m' Hm' n' Hn'))
         m (omega_nat_p m Hm)
         m' (omega_nat_p m' Hm')
         n (omega_nat_p n Hn)
         n' (omega_nat_p n' Hn').
- prove nat_pair m n = nat_pair m' n'.
  exact H1.
- prove nat_pair m' n' = nat_pair m' n'.
  reflexivity.
Qed.

Theorem nat_pair_1: forall m n m' n' :e omega, nat_pair m n = nat_pair m' n' -> n = n'.
let m. assume Hm. let n. assume Hn.
let m'. assume Hm'. let n'. assume Hn'.
assume H1: nat_pair m n = nat_pair m' n'.
claim L1: m = m'.
{ exact nat_pair_0 m Hm n Hn m' Hm' n' Hn' H1. }
claim L2nS: SNo (2 * n).
{ exact SNo_mul_SNo 2 n SNo_2 (omega_SNo n Hn). }
claim L2n1S: SNo (2 * n + 1).
{ exact SNo_add_SNo (2 * n) 1 ?? SNo_1. }
claim L2n'S: SNo (2 * n').
{ exact SNo_mul_SNo 2 n' SNo_2 (omega_SNo n' Hn'). }
claim L2n'1S: SNo (2 * n' + 1).
{ exact SNo_add_SNo (2 * n') 1 ?? SNo_1. }
prove n = n'.
apply mul_SNo_nonzero_cancel_L 2 n n' SNo_2 neq_2_0 (omega_SNo n Hn) (omega_SNo n' Hn').
prove 2 * n = 2 * n'.
apply add_SNo_cancel_R (2 * n) 1 (2 * n') ?? SNo_1 ??.
prove 2 * n + 1 = 2 * n' + 1.
claim L2mS: SNo (2 ^ m).
{ exact SNo_exp_SNo_nat 2 SNo_2 m (omega_nat_p m Hm). }
claim L2mn0: 2 ^ m <> 0.
{ assume H2: 2 ^ m = 0.
  apply neq_1_0.
  prove 1 = 0.
  rewrite <- mul_SNo_eps_power_2 m (omega_nat_p m Hm).
  prove eps_ m * 2 ^ m = 0.
  rewrite H2.
  prove eps_ m * 0 = 0.
  exact mul_SNo_zeroR (eps_ m) (SNo_eps_ m Hm).
}
apply mul_SNo_nonzero_cancel_L (2 ^ m) (2 * n + 1) (2 * n' + 1) ?? ?? ?? ??.
prove (2 ^ m) * (2 * n + 1) = (2 ^ m) * (2 * n' + 1).
rewrite L1 at 2.
exact H1.
Qed.

Theorem form100_3: equip omega rational.
apply atleastp_antisym_equip.
- prove atleastp omega rational.
  apply Subq_atleastp.
  prove omega c= rational.
  apply Subq_tra omega int rational Subq_omega_int.
  prove int c= rational.
  apply Subq_tra int (SNoS_ omega) rational Subq_int_SNoS_omega.
  prove SNoS_ omega c= rational.
  exact Subq_SNoS_omega_rational.
- prove atleastp rational omega.
  set denom:set->set := fun q => Eps_i (fun n => n :e omega /\ exists m :e omega, q = m :/: n).
  set num:set->set := fun q => Eps_i (fun m => m :e omega /\ q = m :/: denom q).
  claim L1: forall q :e rational, 0 <= q -> exists n :e omega, exists m :e omega, q = m :/: n.
  { let q. assume Hq Hqnn.
    apply SepE real (fun q => exists m :e int, exists n :e omega :\: {0}, q = m :/: n) q Hq.
    assume HqR: q :e real.
    assume HqQ. apply HqQ.
    let m. assume H. apply H.
    assume Hm: m :e int. assume H. apply H.
    let n. assume H. apply H.
    assume Hn: n :e omega :\: {0}.
    assume H1: q = m :/: n.
    apply setminusE omega {0} n Hn.
    assume Hno: n :e omega.
    assume Hnz: n /:e {0}.
    claim LnS: SNo n.
    { exact omega_SNo n Hno. }
    claim LqS: SNo q.
    { exact real_SNo q HqR. }
    claim Lnpos: 0 < n.
    { apply SNoLeE 0 n SNo_0 LnS (omega_nonneg n Hno).
      - assume H2: 0 < n. exact H2.
      - assume H2: 0 = n. prove False.
        apply Hnz.
        prove n :e {0}.
        rewrite <- H2.
        apply SingI.
    }
    claim Lrnpos: 0 < recip_SNo n.
    { exact recip_SNo_of_pos_is_pos n LnS Lnpos. }
    apply int_3_cases m Hm.
    - let m'. assume Hm': m' :e omega.
      assume H2: m = - ordsucc m'.
      prove False.
      apply SNoLt_irref 0.
      prove 0 < 0.
      apply SNoLeLt_tra 0 q 0 SNo_0 LqS SNo_0 Hqnn.
      prove q < 0.
      rewrite H1.
      prove m :/: n < 0.
      prove m * recip_SNo n < 0.
      rewrite <- mul_SNo_zeroL (recip_SNo n) (SNo_recip_SNo n LnS).
      prove m * recip_SNo n < 0 * recip_SNo n.
      apply pos_mul_SNo_Lt' m 0 (recip_SNo n) (int_SNo m Hm) SNo_0 (SNo_recip_SNo n LnS) Lrnpos.
      prove m < 0.
      rewrite H2.
      prove - ordsucc m' < 0.
      apply minus_SNo_Lt_contra1 0 (ordsucc m') SNo_0 (omega_SNo (ordsucc m') (omega_ordsucc m' Hm')).
      prove - 0 < ordsucc m'.
      rewrite minus_SNo_0.
      prove 0 < ordsucc m'.
      apply ordinal_In_SNoLt (ordsucc m') (nat_p_ordinal (ordsucc m') (nat_ordsucc m' (omega_nat_p m' Hm'))) 0.
      prove 0 :e ordsucc m'.
      exact nat_0_in_ordsucc m' (omega_nat_p m' Hm').
    - assume H2: m = 0.
      prove exists n :e omega, exists m :e omega, q = m :/: n.
      witness n. apply andI.
      + exact Hno.
      + prove exists m :e omega, q = m :/: n.
        witness m. apply andI.
        * prove m :e omega. rewrite H2. apply nat_p_omega. exact nat_0.
        * prove q = m :/: n. exact H1.      
    - let m'. assume Hm': m' :e omega.
      assume H2: m = ordsucc m'.
      prove exists n :e omega, exists m :e omega, q = m :/: n.
      witness n. apply andI.
      + exact Hno.
      + prove exists m :e omega, q = m :/: n.
        witness m. apply andI.
        * prove m :e omega. rewrite H2.
          prove ordsucc m' :e omega.
          apply omega_ordsucc.
          exact Hm'.
        * prove q = m :/: n. exact H1.      
  }
  claim L2: forall q :e rational, 0 <= q -> denom q :e omega /\ exists n :e omega, q = n :/: denom q.
  { let q. assume Hq Hqnn.
    exact Eps_i_ex (fun n => n :e omega /\ exists m :e omega, q = m :/: n) (L1 q Hq Hqnn).
  }
  claim L3: forall q :e rational, 0 <= q -> num q :e omega /\ q = num q :/: denom q.
  { let q. assume Hq Hqnn.
    apply L2 q Hq Hqnn.
    assume H2: denom q :e omega.
    assume H3: exists n :e omega, q = n :/: denom q.
    exact Eps_i_ex (fun m => m :e omega /\ q = m :/: denom q) H3.
  }
  claim Lnum: forall q :e rational, 0 <= q -> num q :e omega.
  { let q. assume Hq Hqnn. apply L3 q Hq Hqnn. assume H _. exact H. }
  claim Ldenom: forall q :e rational, 0 <= q -> denom q :e omega.
  { let q. assume Hq Hqnn. apply L2 q Hq Hqnn. assume H _. exact H. }
  set g:set->set := fun q => if 0 <= q then nat_pair 0 (nat_pair (num q) (denom q)) else nat_pair 1 (nat_pair (num (- q)) (denom (- q))).
  claim Lgnneg: forall q, 0 <= q -> g q = nat_pair 0 (nat_pair (num q) (denom q)).
  { let q. assume Hqnn.
    exact If_i_1 (0 <= q) (nat_pair 0 (nat_pair (num q) (denom q))) (nat_pair 1 (nat_pair (num (- q)) (denom (- q)))) Hqnn.
  }
  claim Lgneg: forall q, SNo q -> q < 0 -> g q = nat_pair 1 (nat_pair (num (- q)) (denom (- q))).
  { let q. assume Hq Hqneg.
    apply If_i_0 (0 <= q) (nat_pair 0 (nat_pair (num q) (denom q))) (nat_pair 1 (nat_pair (num (- q)) (denom (- q)))).
    prove ~(0 <= q).
    assume H1: 0 <= q.
    apply SNoLt_irref q.
    exact SNoLtLe_tra q 0 q Hq SNo_0 Hq Hqneg H1.
  }
  claim L_nat_pair_3: forall k m n :e omega, nat_pair k (nat_pair m n) :e omega.
  { let k. assume Hk. let m. assume Hm. let n. assume Hn.
    exact nat_pair_In_omega k Hk (nat_pair m n) (nat_pair_In_omega m Hm n Hn).
  }
  claim L_nat_pair_3_inj: forall k m n k' m' n' :e omega, nat_pair k (nat_pair m n) = nat_pair k' (nat_pair m' n')
     -> forall p:prop,
            (k = k' -> m = m' -> n = n' -> p)
         -> p.
  { let k. assume Hk. let m. assume Hm. let n. assume Hn.
    let k'. assume Hk'. let m'. assume Hm'. let n'. assume Hn'.
    assume H1. let p. assume Hp.
    claim Lmnm'n': nat_pair m n = nat_pair m' n'.
    { exact nat_pair_1 k Hk (nat_pair m n) (nat_pair_In_omega m Hm n Hn)
                       k' Hk' (nat_pair m' n') (nat_pair_In_omega m' Hm' n' Hn')
                       H1.
    }
    apply Hp.
    - exact nat_pair_0 k Hk (nat_pair m n) (nat_pair_In_omega m Hm n Hn)
                       k' Hk' (nat_pair m' n') (nat_pair_In_omega m' Hm' n' Hn')
                       H1.
    - exact nat_pair_0 m Hm n Hn m' Hm' n' Hn' Lmnm'n'.
    - exact nat_pair_1 m Hm n Hn m' Hm' n' Hn' Lmnm'n'.
  }
  prove exists g:set->set, inj rational omega g.
  witness g.
  prove inj rational omega g.
  apply injI.
  + let q. assume Hq: q :e rational.
    claim LqS: SNo q.
    { exact real_SNo q (Subq_rational_real q Hq). }
    prove g q :e omega.
    apply SNoLtLe_or q 0 LqS SNo_0.
    * { assume H1: q < 0.
        claim LmqQ: - q :e rational.
        { exact rational_minus_SNo q Hq. }
        claim Lmqnn: 0 <= - q.
        { apply SNoLtLe.
          prove 0 < - q.
          apply minus_SNo_Lt_contra2 q 0 LqS SNo_0.
          prove q < - 0.
          rewrite minus_SNo_0.
          exact H1.
        }
        prove g q :e omega.
        exact Lgneg q LqS H1 (fun _ u => u :e omega)
                     (L_nat_pair_3
                       1 (nat_p_omega 1 nat_1)
                       (num (- q)) (Lnum (- q) LmqQ Lmqnn)
                       (denom (- q)) (Ldenom (- q) LmqQ Lmqnn)).
      }
    * { assume H1: 0 <= q.
        prove g q :e omega.
        exact Lgnneg q H1 (fun _ u => u :e omega)
                     (L_nat_pair_3
                       0 (nat_p_omega 0 nat_0)
                       (num q) (Lnum q Hq H1)
                       (denom q) (Ldenom q Hq H1)).
      }
  + let q. assume Hq: q :e rational.
    let q'. assume Hq': q' :e rational.
    claim LqS: SNo q.
    { exact real_SNo q (Subq_rational_real q Hq). }
    claim Lq'S: SNo q'.
    { exact real_SNo q' (Subq_rational_real q' Hq'). }
    assume H1: g q = g q'.
    prove q = q'.
    apply SNoLtLe_or q 0 LqS SNo_0.
    * { assume H2: q < 0.
        claim LmqQ: - q :e rational.
        { exact rational_minus_SNo q Hq. }
        claim Lmqnn: 0 <= - q.
        { apply SNoLtLe.
          prove 0 < - q.
          apply minus_SNo_Lt_contra2 q 0 LqS SNo_0.
          prove q < - 0.
          rewrite minus_SNo_0.
          exact H2.
        }
        apply SNoLtLe_or q' 0 Lq'S SNo_0.
        - assume H3: q' < 0.
          claim Lmq'Q: - q' :e rational.
          { exact rational_minus_SNo q' Hq'. }
          claim Lmq'nn: 0 <= - q'.
          { apply SNoLtLe.
            prove 0 < - q'.
            apply minus_SNo_Lt_contra2 q' 0 Lq'S SNo_0.
            prove q' < - 0.
            rewrite minus_SNo_0.
            exact H3.
          }
          claim L4a: nat_pair 1 (nat_pair (num (- q)) (denom (- q)))
                  = nat_pair 1 (nat_pair (num (- q')) (denom (- q'))).
          { transitivity g q, g q'.
            - symmetry.
              exact Lgneg q LqS H2.
            - exact H1.
            - exact Lgneg q' Lq'S H3.
          }
          apply L_nat_pair_3_inj 1 (nat_p_omega 1 nat_1)
                                 (num (- q)) (Lnum (- q) LmqQ Lmqnn)
                                 (denom (- q)) (Ldenom (- q) LmqQ Lmqnn)
                                 1 (nat_p_omega 1 nat_1)
                                 (num (- q')) (Lnum (- q') Lmq'Q Lmq'nn)
                                 (denom (- q')) (Ldenom (- q') Lmq'Q Lmq'nn)
                                 L4a.
          assume _.
          assume Hnmqq': num (- q) = num (- q').
          assume Hdmqq': denom (- q) = denom (- q').
          prove q = q'.
          rewrite <- minus_SNo_invol q LqS.
          rewrite <- minus_SNo_invol q' Lq'S.
          prove - - q = - - q'.
          f_equal.
          prove - q = - q'.
          apply L3 (- q) LmqQ Lmqnn.
          assume _.
          assume Hmqnd: - q = num (- q) :/: denom (- q).
          apply L3 (- q') Lmq'Q Lmq'nn.
          assume _.
          assume Hmq'nd: - q' = num (- q') :/: denom (- q').
          rewrite Hmqnd. rewrite Hmq'nd.
          f_equal.
          + exact Hnmqq'.
          + exact Hdmqq'.
        - assume H3: 0 <= q'. prove False.
          claim L4b: nat_pair 1 (nat_pair (num (- q)) (denom (- q)))
                  = nat_pair 0 (nat_pair (num q') (denom q')).
          { transitivity g q, g q'.
            - symmetry.
              exact Lgneg q LqS H2.
            - exact H1.
            - exact Lgnneg q' H3.
          }
          apply L_nat_pair_3_inj 1 (nat_p_omega 1 nat_1)
                                 (num (- q)) (Lnum (- q) LmqQ Lmqnn)
                                 (denom (- q)) (Ldenom (- q) LmqQ Lmqnn)
                                 0 (nat_p_omega 0 nat_0)
                                 (num q') (Lnum q' Hq' H3)
                                 (denom q') (Ldenom q' Hq' H3)
                                 L4b.
          assume H4: 1 = 0. prove False.
          apply neq_1_0.
          exact H4.
      }
    * { assume H2: 0 <= q.
        apply SNoLtLe_or q' 0 Lq'S SNo_0.
        - assume H3: q' < 0. prove False.
          claim Lmq'Q: - q' :e rational.
          { exact rational_minus_SNo q' Hq'. }
          claim Lmq'nn: 0 <= - q'.
          { apply SNoLtLe.
            prove 0 < - q'.
            apply minus_SNo_Lt_contra2 q' 0 Lq'S SNo_0.
            prove q' < - 0.
            rewrite minus_SNo_0.
            exact H3.
          }
          claim L4c: nat_pair 0 (nat_pair (num q) (denom q))
                  = nat_pair 1 (nat_pair (num (- q')) (denom (- q'))).
          { transitivity g q, g q'.
            - symmetry.
              exact Lgnneg q H2.
            - exact H1.
            - exact Lgneg q' Lq'S H3.
          }
          apply L_nat_pair_3_inj 0 (nat_p_omega 0 nat_0)
                                 (num q) (Lnum q Hq H2)
                                 (denom q) (Ldenom q Hq H2)
                                 1 (nat_p_omega 1 nat_1)
                                 (num (- q')) (Lnum (- q') Lmq'Q Lmq'nn)
                                 (denom (- q')) (Ldenom (- q') Lmq'Q Lmq'nn)
                                 L4c.
          assume H4: 0 = 1. prove False.
          apply neq_0_1.
          exact H4.
        - assume H3: 0 <= q'.
          claim L4d: nat_pair 0 (nat_pair (num q) (denom q))
                  = nat_pair 0 (nat_pair (num q') (denom q')).
          { transitivity g q, g q'.
            - symmetry.
              exact Lgnneg q H2.
            - exact H1.
            - exact Lgnneg q' H3.
          }
          apply L_nat_pair_3_inj 0 (nat_p_omega 0 nat_0)
                                 (num q) (Lnum q Hq H2)
                                 (denom q) (Ldenom q Hq H2)
                                 0 (nat_p_omega 0 nat_0)
                                 (num q') (Lnum q' Hq' H3)
                                 (denom q') (Ldenom q' Hq' H3)
                                 L4d.
          assume _.
          assume Hnqq': num q = num q'.
          assume Hdqq': denom q = denom q'.
          prove q = q'.
          apply L3 q Hq H2.
          assume _.
          assume Hqnd: q = num q :/: denom q.
          apply L3 q' Hq' H3.
          assume _.
          assume Hq'nd: q' = num q' :/: denom q'.
          rewrite Hqnd. rewrite Hq'nd.
          f_equal.
          + exact Hnqq'.
          + exact Hdqq'.
      }
Qed.

End form100_3.

Section SurrealSqrt.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.
Definition SNoL_nonneg : set -> set := fun x => {w :e SNoL x|0 <= w}.

Theorem SNoL_nonneg_0: SNoL_nonneg 0 = 0.
prove {w :e SNoL 0|0 <= w} = 0.
rewrite SNoL_0.
exact Sep_Empty (fun w => 0 <= w).
Qed.

Theorem SNoL_nonneg_1: SNoL_nonneg 1 = 1.
prove {w :e SNoL 1|0 <= w} = 1.
rewrite SNoL_1.
prove {w :e 1|0 <= w} = 1.
apply set_ext.
- exact Sep_Subq 1 (fun w => 0 <= w).
- let w. assume Hw: w :e 1.
  apply cases_1 w Hw.
  prove 0 :e {w :e 1|0 <= w}.
  apply SepI.
  + exact In_0_1.
  + prove 0 <= 0. apply SNoLe_ref.
Qed.

Definition SNo_sqrtauxset : set -> set -> set -> set := fun Y Z x => \/_ y :e Y, {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}.

Theorem SNo_sqrtauxset_I : forall Y Z x,
 forall y :e Y, forall z :e Z, 0 < y + z -> (x + y * z) :/: (y + z) :e SNo_sqrtauxset Y Z x.
let Y Z x y. assume Hy. let z. assume Hz.
assume H1.
prove (x + y * z) :/: (y + z) :e \/_ y :e Y, {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}.
apply famunionI Y (fun y => {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}) y ((x + y * z) :/: (y + z)) Hy.
prove (x + y * z) :/: (y + z) :e {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}.
exact ReplSepI Z (fun z => 0 < y + z) (fun z => (x + y * z) :/: (y + z)) z Hz H1.
Qed.

Theorem SNo_sqrtauxset_E : forall Y Z x,
 forall u :e SNo_sqrtauxset Y Z x, forall p:prop,
     (forall y :e Y, forall z :e Z, 0 < y + z -> u = (x + y * z) :/: (y + z) -> p)
  -> p.
let Y Z x u. assume Hu. let p. assume H1.
apply famunionE_impred Y (fun y => {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}) u Hu.
let y. assume Hy: y :e Y. assume Hu1.
apply ReplSepE_impred Z (fun z => 0 < y + z) (fun z => (x + y * z) :/: (y + z)) u Hu1.
let z. assume Hz: z :e Z.
assume Hyz: 0 < y + z.
assume Hu2: u = (x + y * z) :/: (y + z).
exact H1 y Hy z Hz Hyz Hu2.
Qed.

Theorem SNo_sqrtauxset_0: forall Z x, SNo_sqrtauxset 0 Z x = 0.
let Z x. apply Empty_eq.
let u. assume Hu.
apply SNo_sqrtauxset_E 0 Z x u Hu.
let y. assume Hy: y :e 0.
prove False. exact EmptyE y Hy.
Qed.

Theorem SNo_sqrtauxset_0': forall Y x, SNo_sqrtauxset Y 0 x = 0.
let Y x. apply Empty_eq.
let u. assume Hu.
apply SNo_sqrtauxset_E Y 0 x u Hu.
let y. assume Hy: y :e Y.
let z. assume Hz: z :e 0.
prove False. exact EmptyE z Hz.
Qed.

Definition SNo_sqrtaux : set -> (set -> set) -> set -> set :=
 fun x g =>
  nat_primrec ({g w|w :e SNoL_nonneg x},{g z|z :e SNoR x})
   (fun k p => (p 0 :\/: SNo_sqrtauxset (p 0) (p 1) x,
                p 1 :\/: SNo_sqrtauxset (p 0) (p 0) x
                    :\/: SNo_sqrtauxset (p 1) (p 1) x)).

Theorem SNo_sqrtaux_0: forall x, forall g:set -> set, SNo_sqrtaux x g 0 = ({g w|w :e SNoL_nonneg x},{g z|z :e SNoR x}).
let x g.
exact nat_primrec_0 ({g w|w :e SNoL_nonneg x},{g z|z :e SNoR x})
   (fun k p => (p 0 :\/: SNo_sqrtauxset (p 0) (p 1) x,
                p 1 :\/: SNo_sqrtauxset (p 0) (p 0) x
                    :\/: SNo_sqrtauxset (p 1) (p 1) x)).
Qed.

Theorem SNo_sqrtaux_S: forall x, forall g:set -> set, forall n, nat_p n
 -> SNo_sqrtaux x g (ordsucc n)
  = (SNo_sqrtaux x g n 0
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 0) (SNo_sqrtaux x g n 1) x,
     SNo_sqrtaux x g n 1
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 0) (SNo_sqrtaux x g n 0) x
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 1) (SNo_sqrtaux x g n 1) x).
let x g n. assume Hn.
exact nat_primrec_S ({g w|w :e SNoL_nonneg x},{g z|z :e SNoR x})
   (fun k p => (p 0 :\/: SNo_sqrtauxset (p 0) (p 1) x,
                p 1 :\/: SNo_sqrtauxset (p 0) (p 0) x
                    :\/: SNo_sqrtauxset (p 1) (p 1) x)) n Hn.
Qed.

Theorem SNo_sqrtaux_mon_lem: forall x, forall g:set -> set,
  forall m, nat_p m -> forall n, nat_p n
   -> SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g (add_nat m n) 0
   /\ SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g (add_nat m n) 1.
let x g m. assume Hm.
apply nat_ind.
- prove SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g (add_nat m 0) 0
     /\ SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g (add_nat m 0) 1.
  rewrite add_nat_0R m.
  prove SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g m 0
     /\ SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g m 1.
  apply andI.
  + apply Subq_ref.
  + apply Subq_ref.
- let n. assume Hn IH. apply IH.
  assume IH0: SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g (add_nat m n) 0.
  assume IH1: SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g (add_nat m n) 1.
  rewrite add_nat_SR m n Hn.
  prove SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g (ordsucc (add_nat m n)) 0
     /\ SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g (ordsucc (add_nat m n)) 1.
  rewrite SNo_sqrtaux_S x g (add_nat m n) (add_nat_p m Hm n Hn).
  rewrite tuple_2_0_eq.
  rewrite tuple_2_1_eq.
  apply andI.
  + prove SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g (add_nat m n) 0 :\/: SNo_sqrtauxset (SNo_sqrtaux x g (add_nat m n) 0) (SNo_sqrtaux x g (add_nat m n) 1) x.
    apply Subq_tra (SNo_sqrtaux x g m 0)
                   (SNo_sqrtaux x g (add_nat m n) 0)
                   (SNo_sqrtaux x g (add_nat m n) 0 :\/: SNo_sqrtauxset (SNo_sqrtaux x g (add_nat m n) 0) (SNo_sqrtaux x g (add_nat m n) 1) x)
                   IH0.
    apply binunion_Subq_1.
  + prove SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g (add_nat m n) 1 :\/: SNo_sqrtauxset (SNo_sqrtaux x g (add_nat m n) 0) (SNo_sqrtaux x g (add_nat m n) 0) x :\/: SNo_sqrtauxset (SNo_sqrtaux x g (add_nat m n) 1) (SNo_sqrtaux x g (add_nat m n) 1) x.
    apply Subq_tra (SNo_sqrtaux x g m 1)
                   (SNo_sqrtaux x g (add_nat m n) 1)
                   (SNo_sqrtaux x g (add_nat m n) 1 :\/: SNo_sqrtauxset (SNo_sqrtaux x g (add_nat m n) 0) (SNo_sqrtaux x g (add_nat m n) 0) x :\/: SNo_sqrtauxset (SNo_sqrtaux x g (add_nat m n) 1) (SNo_sqrtaux x g (add_nat m n) 1) x)
                   IH1.
    apply Subq_tra (SNo_sqrtaux x g (add_nat m n) 1)
                   (SNo_sqrtaux x g (add_nat m n) 1 :\/: SNo_sqrtauxset (SNo_sqrtaux x g (add_nat m n) 0) (SNo_sqrtaux x g (add_nat m n) 0) x)
                   (SNo_sqrtaux x g (add_nat m n) 1 :\/: SNo_sqrtauxset (SNo_sqrtaux x g (add_nat m n) 0) (SNo_sqrtaux x g (add_nat m n) 0) x :\/: SNo_sqrtauxset (SNo_sqrtaux x g (add_nat m n) 1) (SNo_sqrtaux x g (add_nat m n) 1) x).
    * apply binunion_Subq_1.
    * apply binunion_Subq_1.
Qed.

Theorem SNo_sqrtaux_mon: forall x, forall g:set -> set,
  forall m, nat_p m -> forall n, nat_p n -> m c= n
   -> SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g n 0
   /\ SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g n 1.
let x g m. assume Hm. let n. assume Hn Hmn.
apply nat_Subq_add_ex m Hm n Hn Hmn.
let k. assume H. apply H.
assume Hk: nat_p k.
rewrite add_nat_com k Hk m Hm.
assume H1: n = add_nat m k.
rewrite H1.
exact SNo_sqrtaux_mon_lem x g m Hm k Hk.
Qed.

Theorem SNo_sqrtaux_ext: forall x, SNo x -> forall g h:set -> set, (forall x' :e SNoS_ (SNoLev x), g x' = h x') -> forall k, nat_p k -> SNo_sqrtaux x g k = SNo_sqrtaux x h k.
let x. assume Hx. let g h.
assume Hgh.
apply nat_ind.
- prove SNo_sqrtaux x g 0 = SNo_sqrtaux x h 0.
  rewrite SNo_sqrtaux_0 x g.
  rewrite SNo_sqrtaux_0 x h.
  prove ({g w|w :e SNoL_nonneg x},{g z|z :e SNoR x}) = ({h w|w :e SNoL_nonneg x},{h z|z :e SNoR x}).
  claim L1: {g w|w :e SNoL_nonneg x} = {h w|w :e SNoL_nonneg x}.
  { apply ReplEq_ext (SNoL_nonneg x) g h.
    let w. assume Hw: w :e SNoL_nonneg x.
    prove g w = h w.
    apply SNoL_E x Hx w (SepE1 (SNoL x) (fun w => 0 <= w) w Hw).
    assume Hw1 Hw2 Hw3.
    apply Hgh.
    prove w :e SNoS_ (SNoLev x).
    exact SNoS_I2 w x Hw1 Hx Hw2.
  }
  claim L2: {g w|w :e SNoR x} = {h w|w :e SNoR x}.
  { apply ReplEq_ext (SNoR x) g h.
    let w. assume Hw: w :e SNoR x.
    prove g w = h w.
    apply SNoR_E x Hx w Hw.
    assume Hw1 Hw2 Hw3.
    apply Hgh.
    prove w :e SNoS_ (SNoLev x).
    exact SNoS_I2 w x Hw1 Hx Hw2.
  }
  rewrite L1. rewrite L2. reflexivity.
- let k.
  assume Hk: nat_p k.
  assume IH: SNo_sqrtaux x g k = SNo_sqrtaux x h k.
  prove SNo_sqrtaux x g (ordsucc k) = SNo_sqrtaux x h (ordsucc k).
  rewrite SNo_sqrtaux_S x g k Hk.
  rewrite SNo_sqrtaux_S x h k Hk.
  rewrite IH.
  reflexivity.
Qed.

Section sqrt_SNo_nonneg.
Let G : set -> (set -> set) -> set := fun x g => SNoCut (\/_ k :e omega, SNo_sqrtaux x g k 0) (\/_ k :e omega, SNo_sqrtaux x g k 1).
Definition sqrt_SNo_nonneg : set -> set := SNo_rec_i G.

Theorem sqrt_SNo_nonneg_eq: forall x, SNo x -> sqrt_SNo_nonneg x = G x sqrt_SNo_nonneg.
apply SNo_rec_i_eq G.
let x. assume Hx.
let g h. assume Hgh.
prove SNoCut (\/_ k :e omega, SNo_sqrtaux x g k 0) (\/_ k :e omega, SNo_sqrtaux x g k 1)
    = SNoCut (\/_ k :e omega, SNo_sqrtaux x h k 0) (\/_ k :e omega, SNo_sqrtaux x h k 1).
f_equal.
- apply famunion_ext.
  let k. assume Hk.
  prove SNo_sqrtaux x g k 0 = SNo_sqrtaux x h k 0.
  f_equal.
  apply SNo_sqrtaux_ext x Hx g h.
  + prove forall w :e SNoS_ (SNoLev x), g w = h w.
    exact Hgh.
  + exact omega_nat_p k Hk.
- apply famunion_ext.
  let k. assume Hk.
  prove SNo_sqrtaux x g k 1 = SNo_sqrtaux x h k 1.
  f_equal.
  apply SNo_sqrtaux_ext x Hx g h.
  + prove forall w :e SNoS_ (SNoLev x), g w = h w.
    exact Hgh.
  + exact omega_nat_p k Hk.
Qed.

Theorem sqrt_SNo_nonneg_prop1a: forall x, SNo x -> 0 <= x ->
    (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
 -> forall k, nat_p k ->
              (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y).
let x. assume Hx Hxnonneg IH.
set L_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 0.
set R_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 1.
set L := \/_ k :e omega, L_ k.
set R := \/_ k :e omega, R_ k.
apply nat_ind.
- prove (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg 0 0, SNo y /\ 0 <= y /\ y * y < x)
     /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg 0 1, SNo y /\ 0 <= y /\ x < y * y).
  rewrite SNo_sqrtaux_0 x sqrt_SNo_nonneg. apply andI.
  + let y. rewrite tuple_2_0_eq.
    assume Hy: y :e {sqrt_SNo_nonneg w|w :e SNoL_nonneg x}.
    prove SNo y /\ 0 <= y /\ y * y < x.
    apply ReplE_impred (SNoL_nonneg x) sqrt_SNo_nonneg y Hy.
    let w. assume Hw: w :e SNoL_nonneg x.
    assume Hyw: y = sqrt_SNo_nonneg w.
    apply SepE (SNoL x) (fun w => 0 <= w) w Hw.
    assume Hw: w :e SNoL x.
    assume Hwnonneg: 0 <= w.
    apply SNoL_E x Hx w Hw.
    assume Hw1 Hw2 Hw3.
    claim Lw: w :e SNoS_ (SNoLev x).
    { exact SNoS_I2 w x Hw1 Hx Hw2. }
    apply IH w Lw Hwnonneg. assume H. apply H.
    assume IHa: SNo (sqrt_SNo_nonneg w).
    assume IHb: 0 <= sqrt_SNo_nonneg w.
    assume IHc: sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w.
    apply and3I.
    * rewrite Hyw. exact IHa.
    * rewrite Hyw. exact IHb.
    * rewrite Hyw.
      prove sqrt_SNo_nonneg w * sqrt_SNo_nonneg w < x.
      rewrite IHc.
      exact Hw3.
  + let y. rewrite tuple_2_1_eq.
    assume Hy: y :e {sqrt_SNo_nonneg z|z :e SNoR x}.
    prove SNo y /\ 0 <= y /\ x < y * y.
    apply ReplE_impred (SNoR x) sqrt_SNo_nonneg y Hy.
    let z. assume Hz: z :e SNoR x.
    assume Hyz: y = sqrt_SNo_nonneg z.
    apply SNoR_E x Hx z Hz.
    assume Hz1 Hz2 Hz3.
    claim Lz: z :e SNoS_ (SNoLev x).
    { exact SNoS_I2 z x Hz1 Hx Hz2. }
    claim Lznonneg: 0 <= z.
    { exact SNoLe_tra 0 x z SNo_0 Hx Hz1 Hxnonneg (SNoLtLe x z Hz3). }
    apply IH z Lz Lznonneg. assume H. apply H.
    assume IHa: SNo (sqrt_SNo_nonneg z).
    assume IHb: 0 <= sqrt_SNo_nonneg z.
    assume IHc: sqrt_SNo_nonneg z * sqrt_SNo_nonneg z = z.
    apply and3I.
    * rewrite Hyz. exact IHa.
    * rewrite Hyz. exact IHb.
    * rewrite Hyz.
      prove x < sqrt_SNo_nonneg z * sqrt_SNo_nonneg z.
      rewrite IHc.
      exact Hz3.
- let k. assume Hk: nat_p k.
  assume IHk: (forall y :e L_ k, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e R_ k, SNo y /\ 0 <= y /\ x < y * y).
  apply IHk.
  assume IHk0 IHk1.
  prove (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc k) 0, SNo y /\ 0 <= y /\ y * y < x)
     /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc k) 1, SNo y /\ 0 <= y /\ x < y * y).
  rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k Hk. apply andI.
  + let y. rewrite tuple_2_0_eq.
    apply binunionE'.
    * exact IHk0 y.
    * { assume Hy: y :e SNo_sqrtauxset (L_ k) (R_ k) x.
        apply SNo_sqrtauxset_E (L_ k) (R_ k) x y Hy.
        let w. assume Hw: w :e L_ k.
        let z. assume Hz: z :e R_ k.
        assume Hwpzpos: 0 < w + z.
        assume Hywz: y = (x + w * z) :/: (w + z).
        apply IHk0 w Hw. assume H. apply H.
        assume Hw1: SNo w.
        assume Hw2: 0 <= w.
        assume Hw3: w * w < x.
        apply IHk1 z Hz. assume H. apply H.
        assume Hz1: SNo z.
        assume Hz2: 0 <= z.
        assume Hz3: x < z * z.
        prove SNo y /\ 0 <= y /\ y * y < x.
        claim Lwz: SNo (w * z).
        { exact SNo_mul_SNo w z Hw1 Hz1. }
        claim Lxpwz: SNo (x + w * z).
        { exact SNo_add_SNo x (w * z) Hx Lwz. }
        claim Lwpz: SNo (w + z).
        { exact SNo_add_SNo w z Hw1 Hz1. }
        claim Ly: SNo y.
        { rewrite Hywz.
          exact SNo_div_SNo (x + w * z) (w + z) Lxpwz Lwpz.
        }
        claim Lxpwznonneg: 0 <= x + w * z.
        { rewrite <- add_SNo_0L 0 SNo_0.
          apply add_SNo_Le3 0 0 x (w * z) SNo_0 SNo_0 Hx Lwz Hxnonneg.
          prove 0 <= w * z.
          exact mul_SNo_nonneg_nonneg w z Hw1 Hz1 Hw2 Hz2.
        }
        claim Lynonneg: 0 <= y.
        { prove 0 <= y. rewrite Hywz.
          prove 0 <= (x + w * z) :/: (w + z).
          apply SNoLeE 0 (x + w * z) SNo_0 Lxpwz Lxpwznonneg.
          - assume H1: 0 < x + w * z.
            apply SNoLtLe.
            apply div_SNo_pos_pos (x + w * z) (w + z) Lxpwz Lwpz.
            + prove 0 < x + w * z. exact H1.
            + prove 0 < w + z. exact Hwpzpos.
          - assume H1: 0 = x + w * z. rewrite <- H1.
            prove 0 <= 0 :/: (w + z).
            rewrite div_SNo_0_num (w + z) Lwpz.
            apply SNoLe_ref.
        }
        apply and3I.
        - exact Ly.
        - exact Lynonneg.
        - prove y * y < x.
          rewrite Hywz.
          prove ((x + w * z) :/: (w + z)) * ((x + w * z) :/: (w + z)) < x.
          rewrite mul_div_SNo_both (x + w * z) (w + z) (x + w * z) (w + z) Lxpwz Lwpz Lxpwz Lwpz.
          prove ((x + w * z) * (x + w * z)) :/: ((w + z) * (w + z)) < x.
          apply div_SNo_pos_LtL ((x + w * z) * (x + w * z)) ((w + z) * (w + z)) x (SNo_mul_SNo (x + w * z) (x + w * z) Lxpwz Lxpwz) (SNo_mul_SNo (w + z) (w + z) Lwpz Lwpz) Hx.
          + prove 0 < (w + z) * (w + z).
            exact mul_SNo_pos_pos (w + z) (w + z) Lwpz Lwpz Hwpzpos Hwpzpos.
          + prove ((x + w * z) * (x + w * z)) < x * ((w + z) * (w + z)).
            rewrite SNo_foil x (w * z) x (w * z) Hx Lwz.
            rewrite SNo_foil w z w z Hw1 Hz1 Hw1 Hz1.
            prove x * x + x * w * z + (w * z) * x + (w * z) * w * z
                < x * (w * w + w * z + z * w + z * z).
            rewrite mul_SNo_com z w Hz1 Hw1.
            rewrite <- add_SNo_rotate_4_1 (w * z) (w * z) (z * z) (w * w) Lwz Lwz (SNo_mul_SNo z z Hz1 Hz1) (SNo_mul_SNo w w Hw1 Hw1).
            prove x * x + x * w * z + (w * z) * x + (w * z) * w * z
                < x * (w * z + w * z + z * z + w * w).
            rewrite mul_SNo_com (w * z) x Lwz Hx.
            prove x * x + x * w * z + x * w * z + (w * z) * w * z
                < x * (w * z + w * z + z * z + w * w).
            claim Lxwz: SNo (x * w * z).
            { exact SNo_mul_SNo x (w * z) Hx Lwz. }
            rewrite <- add_SNo_rotate_4_1 (x * w * z) (x * w * z) ((w * z) * w * z) (x * x) Lxwz Lxwz (SNo_mul_SNo (w * z) (w * z) Lwz Lwz) (SNo_mul_SNo x x Hx Hx).
            prove x * w * z + x * w * z + (w * z) * w * z + x * x
                < x * (w * z + w * z + z * z + w * w).
            rewrite mul_SNo_distrL x (w * z) (w * z + z * z + w * w) Hx Lwz (SNo_add_SNo_3 (w * z) (z * z) (w * w) Lwz (SNo_mul_SNo z z Hz1 Hz1) (SNo_mul_SNo w w Hw1 Hw1)).
            prove x * w * z + x * w * z + (w * z) * w * z + x * x
                < x * w * z + x * (w * z + z * z + w * w).
            rewrite mul_SNo_distrL x (w * z) (z * z + w * w) Hx Lwz (SNo_add_SNo (z * z) (w * w) (SNo_mul_SNo z z Hz1 Hz1) (SNo_mul_SNo w w Hw1 Hw1)).
            prove x * w * z + x * w * z + (w * z) * w * z + x * x
                < x * w * z + x * w * z + x * (z * z + w * w).
            claim Lxwz: SNo (x * w * z).
            { exact SNo_mul_SNo_3 x w z Hx Hw1 Hz1. }
            apply add_SNo_Lt2 (x * w * z) (x * w * z + (w * z) * w * z + x * x) (x * w * z + x * (z * z + w * w)) Lxwz (SNo_add_SNo_3 (x * w * z) ((w * z) * w * z) (x * x) Lxwz (SNo_mul_SNo (w * z) (w * z) Lwz Lwz) (SNo_mul_SNo x x Hx Hx)) (SNo_add_SNo (x * w * z) (x * (z * z + w * w)) Lxwz (SNo_mul_SNo x (z * z + w * w) Hx (SNo_add_SNo (z * z) (w * w) (SNo_mul_SNo z z Hz1 Hz1) (SNo_mul_SNo w w Hw1 Hw1)))).
            prove x * w * z + (w * z) * w * z + x * x
                < x * w * z + x * (z * z + w * w).
            apply add_SNo_Lt2 (x * w * z) ((w * z) * w * z + x * x) (x * (z * z + w * w)) Lxwz (SNo_add_SNo ((w * z) * w * z) (x * x) (SNo_mul_SNo (w * z) (w * z) Lwz Lwz) (SNo_mul_SNo x x Hx Hx)) (SNo_mul_SNo x (z * z + w * w) Hx (SNo_add_SNo (z * z) (w * w) (SNo_mul_SNo z z Hz1 Hz1) (SNo_mul_SNo w w Hw1 Hw1))).
            prove (w * z) * w * z + x * x < x * (z * z + w * w).
            rewrite mul_SNo_distrL x (z * z) (w * w) Hx (SNo_mul_SNo z z Hz1 Hz1) (SNo_mul_SNo w w Hw1 Hw1).
            prove (w * z) * w * z + x * x < x * z * z + x * w * w.
            rewrite mul_SNo_com x (w * w) Hx (SNo_mul_SNo w w Hw1 Hw1).
            prove (w * z) * w * z + x * x < x * z * z + (w * w) * x.
            rewrite <- add_SNo_0L ((w * z) * w * z + x * x) (SNo_add_SNo ((w * z) * w * z) (x * x) (SNo_mul_SNo (w * z) (w * z) Lwz Lwz) (SNo_mul_SNo x x Hx Hx)).
            prove 0 + (w * z) * w * z + x * x < x * z * z + (w * w) * x.
            apply add_SNo_minus_Lt2 (x * z * z + (w * w) * x) ((w * z) * w * z + x * x) 0 (SNo_add_SNo (x * z * z) ((w * w) * x) (SNo_mul_SNo x (z * z) Hx (SNo_mul_SNo z z Hz1 Hz1)) (SNo_mul_SNo (w * w) x (SNo_mul_SNo w w Hw1 Hw1) Hx)) (SNo_add_SNo ((w * z) * w * z) (x * x) (SNo_mul_SNo (w * z) (w * z) Lwz Lwz) (SNo_mul_SNo x x Hx Hx)) SNo_0.
            prove 0 < (x * z * z + (w * w) * x) + - ((w * z) * w * z + x * x).
            rewrite <- add_SNo_assoc (x * z * z) ((w * w) * x) (- ((w * z) * w * z + x * x)) (SNo_mul_SNo x (z * z) Hx (SNo_mul_SNo z z Hz1 Hz1)) (SNo_mul_SNo (w * w) x (SNo_mul_SNo w w Hw1 Hw1) Hx) (SNo_minus_SNo ((w * z) * w * z + x * x) (SNo_add_SNo ((w * z) * w * z) (x * x) (SNo_mul_SNo (w * z) (w * z) Lwz Lwz) (SNo_mul_SNo x x Hx Hx))).
            rewrite minus_add_SNo_distr ((w * z) * w * z) (x * x) (SNo_mul_SNo (w * z) (w * z) Lwz Lwz) (SNo_mul_SNo x x Hx Hx).
            prove 0 < x * z * z + (w * w) * x + - (w * z) * w * z + - x * x.
            rewrite add_SNo_rotate_3_1 ((w * w) * x) (- (w * z) * w * z) (- x * x) (SNo_mul_SNo (w * w) x (SNo_mul_SNo w w Hw1 Hw1) Hx) (SNo_minus_SNo ((w * z) * w * z) (SNo_mul_SNo (w * z) (w * z) Lwz Lwz)) (SNo_minus_SNo (x * x) (SNo_mul_SNo x x Hx Hx)).
            prove 0 < x * z * z + - x * x + (w * w) * x + - (w * z) * w * z.
            rewrite add_SNo_com ((w * w) * x) (- (w * z) * w * z) (SNo_mul_SNo (w * w) x (SNo_mul_SNo w w Hw1 Hw1) Hx) (SNo_minus_SNo ((w * z) * w * z) (SNo_mul_SNo (w * z) (w * z) Lwz Lwz)).
            prove 0 < x * z * z + - x * x + - (w * z) * w * z + (w * w) * x.
            rewrite <- mul_SNo_assoc w z (w * z) Hw1 Hz1 Lwz.
            prove 0 < x * z * z + - x * x + - w * z * w * z + (w * w) * x.
            rewrite mul_SNo_com_3_0_1 z w z Hz1 Hw1 Hz1.
            prove 0 < x * z * z + - x * x + - w * w * z * z + (w * w) * x.
            rewrite mul_SNo_assoc w w (z * z) Hw1 Hw1 (SNo_mul_SNo z z Hz1 Hz1).
            rewrite <- SNo_foil_mm x (w * w) (z * z) x Hx (SNo_mul_SNo w w Hw1 Hw1) (SNo_mul_SNo z z Hz1 Hz1) Hx.
            prove 0 < (x + - w * w) * (z * z + - x).
            apply mul_SNo_pos_pos (x + - w * w) (z * z + - x) (SNo_add_SNo x (- w * w) Hx (SNo_minus_SNo (w * w) (SNo_mul_SNo w w Hw1 Hw1))) (SNo_add_SNo (z * z) (- x) (SNo_mul_SNo z z Hz1 Hz1) (SNo_minus_SNo x Hx)).
            * prove 0 < x + - w * w.
              exact SNoLt_minus_pos (w * w) x (SNo_mul_SNo w w Hw1 Hw1) Hx Hw3.
            * prove 0 < z * z + - x.
              exact SNoLt_minus_pos x (z * z) Hx (SNo_mul_SNo z z Hz1 Hz1) Hz3.
            * exact Hx.
            * prove SNo (w * z). exact Lwz.
      }
  + let y. rewrite tuple_2_1_eq.
    apply binunionE'.
    * { apply binunionE'.
        - exact IHk1 y.
        - assume Hy: y :e SNo_sqrtauxset (L_ k) (L_ k) x.
          prove SNo y /\ 0 <= y /\ x < y * y.
          apply SNo_sqrtauxset_E (L_ k) (L_ k) x y Hy.
          let w. assume Hw: w :e L_ k.
          let w'. assume Hw': w' :e L_ k.
          assume Hww'pos: 0 < w + w'.
          assume Hyww': y = (x + w * w') :/: (w + w').
          apply IHk0 w Hw. assume H. apply H.
          assume Hw1: SNo w.
          assume Hw2: 0 <= w.
          assume Hw3: w * w < x.
          apply IHk0 w' Hw'. assume H. apply H.
          assume Hw'1: SNo w'.
          assume Hw'2: 0 <= w'.
          assume Hw'3: w' * w' < x.
          prove SNo y /\ 0 <= y /\ x < y * y.
          claim Lww': SNo (w * w').
          { exact SNo_mul_SNo w w' Hw1 Hw'1. }
          claim Lxpww': SNo (x + w * w').
          { exact SNo_add_SNo x (w * w') Hx Lww'. }
          claim Lwpw': SNo (w + w').
          { exact SNo_add_SNo w w' Hw1 Hw'1. }
          claim Ly: SNo y.
          { rewrite Hyww'.
            exact SNo_div_SNo (x + w * w') (w + w') Lxpww' Lwpw'.
          }
          claim Lxpww'nonneg: 0 <= x + w * w'.
          { rewrite <- add_SNo_0L 0 SNo_0.
            apply add_SNo_Le3 0 0 x (w * w') SNo_0 SNo_0 Hx Lww' Hxnonneg.
            prove 0 <= w * w'.
            exact mul_SNo_nonneg_nonneg w w' Hw1 Hw'1 Hw2 Hw'2.
          }
          claim Lynonneg: 0 <= y.
          { prove 0 <= y. rewrite Hyww'.
            prove 0 <= (x + w * w') :/: (w + w').
            apply SNoLeE 0 (x + w * w') SNo_0 Lxpww' Lxpww'nonneg.
            - assume H1: 0 < x + w * w'.
              apply SNoLtLe.
              apply div_SNo_pos_pos (x + w * w') (w + w') Lxpww' Lwpw'.
              + prove 0 < x + w * w'.
                exact H1.
              + prove 0 < w + w'. exact Hww'pos.
            - assume H1: 0 = x + w * w'. rewrite <- H1.
              prove 0 <= 0 :/: (w + w').
              rewrite div_SNo_0_num (w + w') Lwpw'.
              apply SNoLe_ref.
          }
          apply and3I.
          + exact Ly.
          + exact Lynonneg.
          + prove x < y * y.
            rewrite Hyww'.
            prove x < ((x + w * w') :/: (w + w')) * ((x + w * w') :/: (w + w')).
            rewrite mul_div_SNo_both (x + w * w') (w + w') (x + w * w') (w + w') Lxpww' Lwpw' Lxpww' Lwpw'.
            prove x < ((x + w * w') * (x + w * w')) :/: ((w + w') * (w + w')).
            apply div_SNo_pos_LtR ((x + w * w') * (x + w * w')) ((w + w') * (w + w')) x (SNo_mul_SNo (x + w * w') (x + w * w') Lxpww' Lxpww') (SNo_mul_SNo (w + w') (w + w') Lwpw' Lwpw') Hx.
            * prove 0 < (w + w') * (w + w').
              exact mul_SNo_pos_pos (w + w') (w + w') Lwpw' Lwpw' Hww'pos Hww'pos.
            * { prove x * ((w + w') * (w + w')) < ((x + w * w') * (x + w * w')).
                rewrite SNo_foil x (w * w') x (w * w') Hx Lww'.
                rewrite SNo_foil w w' w w' Hw1 Hw'1 Hw1 Hw'1.
                prove x * (w * w + w * w' + w' * w + w' * w')
                    < x * x + x * w * w' + (w * w') * x + (w * w') * w * w'.
                rewrite mul_SNo_com w' w Hw'1 Hw1.
                rewrite <- add_SNo_rotate_4_1 (w * w') (w * w') (w' * w') (w * w) Lww' Lww' (SNo_mul_SNo w' w' Hw'1 Hw'1) (SNo_mul_SNo w w Hw1 Hw1).
                prove x * (w * w' + w * w' + w' * w' + w * w)
                    < x * x + x * w * w' + (w * w') * x + (w * w') * w * w'.
                rewrite mul_SNo_com (w * w') x Lww' Hx.
                prove x * (w * w' + w * w' + w' * w' + w * w)
                    < x * x + x * w * w' + x * w * w' + (w * w') * w * w'.
                claim Lxww': SNo (x * w * w').
                { exact SNo_mul_SNo x (w * w') Hx Lww'. }
                rewrite <- add_SNo_rotate_4_1 (x * w * w') (x * w * w') ((w * w') * w * w') (x * x) Lxww' Lxww' (SNo_mul_SNo (w * w') (w * w') Lww' Lww') (SNo_mul_SNo x x Hx Hx).
                prove x * (w * w' + w * w' + w' * w' + w * w)
                    < x * w * w' + x * w * w' + (w * w') * w * w' + x * x.
                rewrite mul_SNo_distrL x (w * w') (w * w' + w' * w' + w * w) Hx Lww' (SNo_add_SNo_3 (w * w') (w' * w') (w * w) Lww' (SNo_mul_SNo w' w' Hw'1 Hw'1) (SNo_mul_SNo w w Hw1 Hw1)).
                prove x * w * w' + x * (w * w' + w' * w' + w * w)
                    < x * w * w' + x * w * w' + (w * w') * w * w' + x * x.
                rewrite mul_SNo_distrL x (w * w') (w' * w' + w * w) Hx Lww' (SNo_add_SNo (w' * w') (w * w) (SNo_mul_SNo w' w' Hw'1 Hw'1) (SNo_mul_SNo w w Hw1 Hw1)).
                prove x * w * w' + x * w * w' + x * (w' * w' + w * w)
                    < x * w * w' + x * w * w' + (w * w') * w * w' + x * x.
                claim Lxww': SNo (x * w * w').
                { exact SNo_mul_SNo_3 x w w' Hx Hw1 Hw'1. }
                apply add_SNo_Lt2 (x * w * w') (x * w * w' + x * (w' * w' + w * w)) (x * w * w' + (w * w') * w * w' + x * x) Lxww' (SNo_add_SNo (x * w * w') (x * (w' * w' + w * w)) Lxww' (SNo_mul_SNo x (w' * w' + w * w) Hx (SNo_add_SNo (w' * w') (w * w) (SNo_mul_SNo w' w' Hw'1 Hw'1) (SNo_mul_SNo w w Hw1 Hw1)))) (SNo_add_SNo_3 (x * w * w') ((w * w') * w * w') (x * x) Lxww' (SNo_mul_SNo (w * w') (w * w') Lww' Lww') (SNo_mul_SNo x x Hx Hx)).
                prove x * w * w' + x * (w' * w' + w * w)
                    < x * w * w' + (w * w') * w * w' + x * x.
                apply add_SNo_Lt2 (x * w * w') (x * (w' * w' + w * w)) ((w * w') * w * w' + x * x) Lxww' (SNo_mul_SNo x (w' * w' + w * w) Hx (SNo_add_SNo (w' * w') (w * w) (SNo_mul_SNo w' w' Hw'1 Hw'1) (SNo_mul_SNo w w Hw1 Hw1))) (SNo_add_SNo ((w * w') * w * w') (x * x) (SNo_mul_SNo (w * w') (w * w') Lww' Lww') (SNo_mul_SNo x x Hx Hx)).
                prove x * (w' * w' + w * w) < (w * w') * w * w' + x * x.
                rewrite mul_SNo_distrL x (w' * w') (w * w) Hx (SNo_mul_SNo w' w' Hw'1 Hw'1) (SNo_mul_SNo w w Hw1 Hw1).
                prove x * w' * w' + x * w * w < (w * w') * w * w' + x * x.
                rewrite mul_SNo_com x (w * w) Hx (SNo_mul_SNo w w Hw1 Hw1).
                prove x * w' * w' + (w * w) * x < (w * w') * w * w' + x * x.
                rewrite <- add_SNo_0L ((w * w') * w * w' + x * x) (SNo_add_SNo ((w * w') * w * w') (x * x) (SNo_mul_SNo (w * w') (w * w') Lww' Lww') (SNo_mul_SNo x x Hx Hx)).
                prove x * w' * w' + (w * w) * x < 0 + (w * w') * w * w' + x * x.
                apply add_SNo_minus_Lt1 (x * w' * w' + (w * w) * x) ((w * w') * w * w' + x * x) 0 (SNo_add_SNo (x * w' * w') ((w * w) * x) (SNo_mul_SNo x (w' * w') Hx (SNo_mul_SNo w' w' Hw'1 Hw'1)) (SNo_mul_SNo (w * w) x (SNo_mul_SNo w w Hw1 Hw1) Hx)) (SNo_add_SNo ((w * w') * w * w') (x * x) (SNo_mul_SNo (w * w') (w * w') Lww' Lww') (SNo_mul_SNo x x Hx Hx)) SNo_0.
                prove (x * w' * w' + (w * w) * x) + - ((w * w') * w * w' + x * x) < 0.
                rewrite <- add_SNo_assoc (x * w' * w') ((w * w) * x) (- ((w * w') * w * w' + x * x)) (SNo_mul_SNo x (w' * w') Hx (SNo_mul_SNo w' w' Hw'1 Hw'1)) (SNo_mul_SNo (w * w) x (SNo_mul_SNo w w Hw1 Hw1) Hx) (SNo_minus_SNo ((w * w') * w * w' + x * x) (SNo_add_SNo ((w * w') * w * w') (x * x) (SNo_mul_SNo (w * w') (w * w') Lww' Lww') (SNo_mul_SNo x x Hx Hx))).
                rewrite minus_add_SNo_distr ((w * w') * w * w') (x * x) (SNo_mul_SNo (w * w') (w * w') Lww' Lww') (SNo_mul_SNo x x Hx Hx).
                prove x * w' * w' + (w * w) * x + - (w * w') * w * w' + - x * x < 0.
                rewrite add_SNo_rotate_3_1 ((w * w) * x) (- (w * w') * w * w') (- x * x) (SNo_mul_SNo (w * w) x (SNo_mul_SNo w w Hw1 Hw1) Hx) (SNo_minus_SNo ((w * w') * w * w') (SNo_mul_SNo (w * w') (w * w') Lww' Lww')) (SNo_minus_SNo (x * x) (SNo_mul_SNo x x Hx Hx)).
                prove x * w' * w' + - x * x + (w * w) * x + - (w * w') * w * w' < 0.
                rewrite add_SNo_com ((w * w) * x) (- (w * w') * w * w') (SNo_mul_SNo (w * w) x (SNo_mul_SNo w w Hw1 Hw1) Hx) (SNo_minus_SNo ((w * w') * w * w') (SNo_mul_SNo (w * w') (w * w') Lww' Lww')).
                prove x * w' * w' + - x * x + - (w * w') * w * w' + (w * w) * x < 0.
                rewrite <- mul_SNo_assoc w w' (w * w') Hw1 Hw'1 Lww'.
                prove x * w' * w' + - x * x + - w * w' * w * w' + (w * w) * x < 0.
                rewrite mul_SNo_com_3_0_1 w' w w' Hw'1 Hw1 Hw'1.
                prove x * w' * w' + - x * x + - w * w * w' * w' + (w * w) * x < 0.
                rewrite mul_SNo_assoc w w (w' * w') Hw1 Hw1 (SNo_mul_SNo w' w' Hw'1 Hw'1).
                rewrite <- SNo_foil_mm x (w * w) (w' * w') x Hx (SNo_mul_SNo w w Hw1 Hw1) (SNo_mul_SNo w' w' Hw'1 Hw'1) Hx.
                prove (x + - w * w) * (w' * w' + - x) < 0.
                apply mul_SNo_pos_neg (x + - w * w) (w' * w' + - x) (SNo_add_SNo x (- w * w) Hx (SNo_minus_SNo (w * w) (SNo_mul_SNo w w Hw1 Hw1))) (SNo_add_SNo (w' * w') (- x) (SNo_mul_SNo w' w' Hw'1 Hw'1) (SNo_minus_SNo x Hx)).
                - prove 0 < x + - w * w.
                  exact SNoLt_minus_pos (w * w) x (SNo_mul_SNo w w Hw1 Hw1) Hx Hw3.
                - prove w' * w' + - x < 0.
                  apply add_SNo_minus_Lt1b (w' * w') x 0 (SNo_mul_SNo w' w' Hw'1 Hw'1) Hx SNo_0.
                  prove w' * w' < 0 + x.
                  rewrite add_SNo_0L x Hx.
                  prove w' * w' < x.
                  exact Hw'3.
                - exact Hx.
                - prove SNo (w * w'). exact Lww'.
              }
      }
    * { assume Hy: y :e SNo_sqrtauxset (R_ k) (R_ k) x.
        prove SNo y /\ 0 <= y /\ x < y * y.
        apply SNo_sqrtauxset_E (R_ k) (R_ k) x y Hy.
        let z. assume Hz: z :e R_ k.
        let z'. assume Hz': z' :e R_ k.
        assume Hzz'pos: 0 < z + z'.
        assume Hyzz': y = (x + z * z') :/: (z + z').
        apply IHk1 z Hz. assume H. apply H.
        assume Hz1: SNo z.
        assume Hz2: 0 <= z.
        assume Hz3: x < z * z.
        apply IHk1 z' Hz'. assume H. apply H.
        assume Hz'1: SNo z'.
        assume Hz'2: 0 <= z'.
        assume Hz'3: x < z' * z'.
        prove SNo y /\ 0 <= y /\ x < y * y.
        claim Lzz': SNo (z * z').
        { exact SNo_mul_SNo z z' Hz1 Hz'1. }
        claim Lxpzz': SNo (x + z * z').
        { exact SNo_add_SNo x (z * z') Hx Lzz'. }
        claim Lzpz': SNo (z + z').
        { exact SNo_add_SNo z z' Hz1 Hz'1. }
        claim Ly: SNo y.
        { rewrite Hyzz'.
          exact SNo_div_SNo (x + z * z') (z + z') Lxpzz' Lzpz'.
        }
        claim Lxpzz'nonneg: 0 <= x + z * z'.
        { rewrite <- add_SNo_0L 0 SNo_0.
          apply add_SNo_Le3 0 0 x (z * z') SNo_0 SNo_0 Hx Lzz' Hxnonneg.
          prove 0 <= z * z'.
          exact mul_SNo_nonneg_nonneg z z' Hz1 Hz'1 Hz2 Hz'2.
        }
        claim Lynonneg: 0 <= y.
        { prove 0 <= y. rewrite Hyzz'.
          prove 0 <= (x + z * z') :/: (z + z').
          apply SNoLeE 0 (x + z * z') SNo_0 Lxpzz' Lxpzz'nonneg.
          - assume H1: 0 < x + z * z'.
            apply SNoLtLe.
            apply div_SNo_pos_pos (x + z * z') (z + z') Lxpzz' Lzpz'.
            + prove 0 < x + z * z'. exact H1.
            + prove 0 < z + z'. exact Hzz'pos.
          - assume H1: 0 = x + z * z'. rewrite <- H1.
            prove 0 <= 0 :/: (z + z').
            rewrite div_SNo_0_num (z + z') Lzpz'.
            apply SNoLe_ref.
        }
        apply and3I.
        - exact Ly.
        - exact Lynonneg.
        - prove x < y * y.
          rewrite Hyzz'.
          prove x < ((x + z * z') :/: (z + z')) * ((x + z * z') :/: (z + z')).
          rewrite mul_div_SNo_both (x + z * z') (z + z') (x + z * z') (z + z') Lxpzz' Lzpz' Lxpzz' Lzpz'.
          prove x < ((x + z * z') * (x + z * z')) :/: ((z + z') * (z + z')).
          apply div_SNo_pos_LtR ((x + z * z') * (x + z * z')) ((z + z') * (z + z')) x (SNo_mul_SNo (x + z * z') (x + z * z') Lxpzz' Lxpzz') (SNo_mul_SNo (z + z') (z + z') Lzpz' Lzpz') Hx.
          + prove 0 < (z + z') * (z + z').
            exact mul_SNo_pos_pos (z + z') (z + z') Lzpz' Lzpz' Hzz'pos Hzz'pos.
          + prove x * ((z + z') * (z + z')) < ((x + z * z') * (x + z * z')).
            rewrite SNo_foil x (z * z') x (z * z') Hx Lzz'.
            rewrite SNo_foil z z' z z' Hz1 Hz'1 Hz1 Hz'1.
            prove x * (z * z + z * z' + z' * z + z' * z')
                < x * x + x * z * z' + (z * z') * x + (z * z') * z * z'.
            rewrite mul_SNo_com z' z Hz'1 Hz1.
            rewrite <- add_SNo_rotate_4_1 (z * z') (z * z') (z' * z') (z * z) Lzz' Lzz' (SNo_mul_SNo z' z' Hz'1 Hz'1) (SNo_mul_SNo z z Hz1 Hz1).
            prove x * (z * z' + z * z' + z' * z' + z * z)
                < x * x + x * z * z' + (z * z') * x + (z * z') * z * z'.
            rewrite mul_SNo_com (z * z') x Lzz' Hx.
            prove x * (z * z' + z * z' + z' * z' + z * z)
                < x * x + x * z * z' + x * z * z' + (z * z') * z * z'.
            claim Lxzz': SNo (x * z * z').
            { exact SNo_mul_SNo x (z * z') Hx Lzz'. }
            rewrite <- add_SNo_rotate_4_1 (x * z * z') (x * z * z') ((z * z') * z * z') (x * x) Lxzz' Lxzz' (SNo_mul_SNo (z * z') (z * z') Lzz' Lzz') (SNo_mul_SNo x x Hx Hx).
            prove x * (z * z' + z * z' + z' * z' + z * z)
                < x * z * z' + x * z * z' + (z * z') * z * z' + x * x.
            rewrite mul_SNo_distrL x (z * z') (z * z' + z' * z' + z * z) Hx Lzz' (SNo_add_SNo_3 (z * z') (z' * z') (z * z) Lzz' (SNo_mul_SNo z' z' Hz'1 Hz'1) (SNo_mul_SNo z z Hz1 Hz1)).
            prove x * z * z' + x * (z * z' + z' * z' + z * z)
                < x * z * z' + x * z * z' + (z * z') * z * z' + x * x.
            rewrite mul_SNo_distrL x (z * z') (z' * z' + z * z) Hx Lzz' (SNo_add_SNo (z' * z') (z * z) (SNo_mul_SNo z' z' Hz'1 Hz'1) (SNo_mul_SNo z z Hz1 Hz1)).
            prove x * z * z' + x * z * z' + x * (z' * z' + z * z)
                < x * z * z' + x * z * z' + (z * z') * z * z' + x * x.
            claim Lxzz': SNo (x * z * z').
            { exact SNo_mul_SNo_3 x z z' Hx Hz1 Hz'1. }
            apply add_SNo_Lt2 (x * z * z') (x * z * z' + x * (z' * z' + z * z)) (x * z * z' + (z * z') * z * z' + x * x) Lxzz' (SNo_add_SNo (x * z * z') (x * (z' * z' + z * z)) Lxzz' (SNo_mul_SNo x (z' * z' + z * z) Hx (SNo_add_SNo (z' * z') (z * z) (SNo_mul_SNo z' z' Hz'1 Hz'1) (SNo_mul_SNo z z Hz1 Hz1)))) (SNo_add_SNo_3 (x * z * z') ((z * z') * z * z') (x * x) Lxzz' (SNo_mul_SNo (z * z') (z * z') Lzz' Lzz') (SNo_mul_SNo x x Hx Hx)).
            prove x * z * z' + x * (z' * z' + z * z)
                < x * z * z' + (z * z') * z * z' + x * x.
            apply add_SNo_Lt2 (x * z * z') (x * (z' * z' + z * z)) ((z * z') * z * z' + x * x) Lxzz' (SNo_mul_SNo x (z' * z' + z * z) Hx (SNo_add_SNo (z' * z') (z * z) (SNo_mul_SNo z' z' Hz'1 Hz'1) (SNo_mul_SNo z z Hz1 Hz1))) (SNo_add_SNo ((z * z') * z * z') (x * x) (SNo_mul_SNo (z * z') (z * z') Lzz' Lzz') (SNo_mul_SNo x x Hx Hx)).
            prove x * (z' * z' + z * z) < (z * z') * z * z' + x * x.
            rewrite mul_SNo_distrL x (z' * z') (z * z) Hx (SNo_mul_SNo z' z' Hz'1 Hz'1) (SNo_mul_SNo z z Hz1 Hz1).
            prove x * z' * z' + x * z * z < (z * z') * z * z' + x * x.
            rewrite mul_SNo_com x (z * z) Hx (SNo_mul_SNo z z Hz1 Hz1).
            prove x * z' * z' + (z * z) * x < (z * z') * z * z' + x * x.
            rewrite <- add_SNo_0L ((z * z') * z * z' + x * x) (SNo_add_SNo ((z * z') * z * z') (x * x) (SNo_mul_SNo (z * z') (z * z') Lzz' Lzz') (SNo_mul_SNo x x Hx Hx)).
            prove x * z' * z' + (z * z) * x < 0 + (z * z') * z * z' + x * x.
            apply add_SNo_minus_Lt1 (x * z' * z' + (z * z) * x) ((z * z') * z * z' + x * x) 0 (SNo_add_SNo (x * z' * z') ((z * z) * x) (SNo_mul_SNo x (z' * z') Hx (SNo_mul_SNo z' z' Hz'1 Hz'1)) (SNo_mul_SNo (z * z) x (SNo_mul_SNo z z Hz1 Hz1) Hx)) (SNo_add_SNo ((z * z') * z * z') (x * x) (SNo_mul_SNo (z * z') (z * z') Lzz' Lzz') (SNo_mul_SNo x x Hx Hx)) SNo_0.
            prove (x * z' * z' + (z * z) * x) + - ((z * z') * z * z' + x * x) < 0.
            rewrite <- add_SNo_assoc (x * z' * z') ((z * z) * x) (- ((z * z') * z * z' + x * x)) (SNo_mul_SNo x (z' * z') Hx (SNo_mul_SNo z' z' Hz'1 Hz'1)) (SNo_mul_SNo (z * z) x (SNo_mul_SNo z z Hz1 Hz1) Hx) (SNo_minus_SNo ((z * z') * z * z' + x * x) (SNo_add_SNo ((z * z') * z * z') (x * x) (SNo_mul_SNo (z * z') (z * z') Lzz' Lzz') (SNo_mul_SNo x x Hx Hx))).
            rewrite minus_add_SNo_distr ((z * z') * z * z') (x * x) (SNo_mul_SNo (z * z') (z * z') Lzz' Lzz') (SNo_mul_SNo x x Hx Hx).
            prove x * z' * z' + (z * z) * x + - (z * z') * z * z' + - x * x < 0.
            rewrite add_SNo_rotate_3_1 ((z * z) * x) (- (z * z') * z * z') (- x * x) (SNo_mul_SNo (z * z) x (SNo_mul_SNo z z Hz1 Hz1) Hx) (SNo_minus_SNo ((z * z') * z * z') (SNo_mul_SNo (z * z') (z * z') Lzz' Lzz')) (SNo_minus_SNo (x * x) (SNo_mul_SNo x x Hx Hx)).
            prove x * z' * z' + - x * x + (z * z) * x + - (z * z') * z * z' < 0.
            rewrite add_SNo_com ((z * z) * x) (- (z * z') * z * z') (SNo_mul_SNo (z * z) x (SNo_mul_SNo z z Hz1 Hz1) Hx) (SNo_minus_SNo ((z * z') * z * z') (SNo_mul_SNo (z * z') (z * z') Lzz' Lzz')).
            prove x * z' * z' + - x * x + - (z * z') * z * z' + (z * z) * x < 0.
            rewrite <- mul_SNo_assoc z z' (z * z') Hz1 Hz'1 Lzz'.
            prove x * z' * z' + - x * x + - z * z' * z * z' + (z * z) * x < 0.
            rewrite mul_SNo_com_3_0_1 z' z z' Hz'1 Hz1 Hz'1.
            prove x * z' * z' + - x * x + - z * z * z' * z' + (z * z) * x < 0.
            rewrite mul_SNo_assoc z z (z' * z') Hz1 Hz1 (SNo_mul_SNo z' z' Hz'1 Hz'1).
            rewrite <- SNo_foil_mm x (z * z) (z' * z') x Hx (SNo_mul_SNo z z Hz1 Hz1) (SNo_mul_SNo z' z' Hz'1 Hz'1) Hx.
            prove (x + - z * z) * (z' * z' + - x) < 0.
            apply mul_SNo_neg_pos (x + - z * z) (z' * z' + - x) (SNo_add_SNo x (- z * z) Hx (SNo_minus_SNo (z * z) (SNo_mul_SNo z z Hz1 Hz1))) (SNo_add_SNo (z' * z') (- x) (SNo_mul_SNo z' z' Hz'1 Hz'1) (SNo_minus_SNo x Hx)).
            * prove x + - z * z < 0.
              apply add_SNo_minus_Lt1b x (z * z) 0 Hx (SNo_mul_SNo z z Hz1 Hz1) SNo_0.
              prove x < 0 + z * z.
              rewrite add_SNo_0L (z * z) (SNo_mul_SNo z z Hz1 Hz1).
              prove x < z * z.
              exact Hz3.
            * prove 0 < z' * z' + - x.
              exact SNoLt_minus_pos x (z' * z') Hx (SNo_mul_SNo z' z' Hz'1 Hz'1) Hz'3.
            * exact Hx.
            * prove SNo (z * z'). exact Lzz'.
      }
Qed.

Theorem sqrt_SNo_nonneg_prop1b: forall x, SNo x -> 0 <= x
 -> (forall k, nat_p k ->
              (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y))
 -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1).
let x. assume Hx Hxnonneg.
set L_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 0.
set R_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 1.
set L := \/_ k :e omega, L_ k.
set R := \/_ k :e omega, R_ k.
assume H0: forall k, nat_p k ->
              (forall y :e L_ k, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e R_ k, SNo y /\ 0 <= y /\ x < y * y).
prove (forall x :e L, SNo x)
   /\ (forall y :e R, SNo y)
   /\ (forall x :e L, forall y :e R, x < y).
apply and3I.
- let w. assume Hw: w :e L.
  apply famunionE_impred omega L_ w Hw.
  let k. assume Hk: k :e omega.
  assume H1: w :e L_ k.
  apply H0 k (omega_nat_p k Hk).
  assume H2 _.
  apply H2 w H1.
  assume H3 _. apply H3. assume H3 _.
  exact H3.
- let z. assume Hz: z :e R.
  apply famunionE_impred omega R_ z Hz.
  let k. assume Hk: k :e omega.
  assume H1: z :e R_ k.
  apply H0 k (omega_nat_p k Hk).
  assume _ H2.
  apply H2 z H1.
  assume H3 _. apply H3. assume H3 _. exact H3.
- let w. assume Hw: w :e L.
  let z. assume Hz: z :e R.
  prove w < z.
  apply famunionE_impred omega L_ w Hw.
  let k. assume Hk: k :e omega.
  assume H1: w :e L_ k.
  apply H0 k (omega_nat_p k Hk).
  assume H2 _.
  apply H2 w H1. assume H. apply H.
  assume Hw1: SNo w.
  assume Hw2: 0 <= w.
  assume Hw3: w * w < x.
  apply famunionE_impred omega R_ z Hz.
  let k'. assume Hk': k' :e omega.
  assume H3: z :e R_ k'.
  apply H0 k' (omega_nat_p k' Hk').
  assume _ H4.
  apply H4 z H3. assume H. apply H.
  assume Hz1: SNo z.
  assume Hz2: 0 <= z.
  assume Hz3: x < z * z.
  prove w < z.
  apply SNoLtLe_or w z Hw1 Hz1.
  + assume H5: w < z. exact H5.
  + assume H5: z <= w. prove False.
    apply SNoLt_irref x.
    prove x < x.
    apply SNoLt_tra x (z * z) x Hx (SNo_mul_SNo z z Hz1 Hz1) Hx Hz3.
    prove z * z < x.
    apply SNoLeLt_tra (z * z) (w * w) x (SNo_mul_SNo z z Hz1 Hz1) (SNo_mul_SNo w w Hw1 Hw1) Hx.
    * prove z * z <= w * w.
      exact nonneg_mul_SNo_Le2 z z w w Hz1 Hz1 Hw1 Hw1 Hz2 Hz2 H5 H5.
    * exact Hw3.
Qed.

Theorem sqrt_SNo_nonneg_prop1c: forall x, SNo x -> 0 <= x ->
    SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
 -> (forall z :e (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1), forall p:prop, (SNo z -> 0 <= z -> x < z * z -> p) -> p)
 -> 0 <= G x sqrt_SNo_nonneg.
let x. assume Hx Hxnonneg H1 H1R.
rewrite <- SNoCut_0_0 at 1.
set L_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 0.
set R_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 1.
set L := \/_ k :e omega, L_ k.
set R := \/_ k :e omega, R_ k.
prove SNoCut 0 0 <= SNoCut L R.
apply SNoCut_Le 0 0 L R.
- prove SNoCutP 0 0. exact SNoCutP_0_0.
- exact H1.
- let w. assume Hw: w :e 0. prove False. exact EmptyE w Hw.
- let z. assume Hz: z :e R.
  prove SNoCut 0 0 < z.
  rewrite SNoCut_0_0.
  prove 0 < z.
  apply H1R z Hz.
  assume Hz1: SNo z.
  assume Hz2: 0 <= z.
  assume Hz3: x < z * z.
  apply SNoLeE 0 z SNo_0 Hz1 Hz2.
  + assume H6: 0 < z. exact H6.
  + assume H6: 0 = z. prove False.
    apply SNoLt_irref x.
    prove x < x.
    apply SNoLtLe_tra x 0 x Hx SNo_0 Hx.
    * prove x < 0.
      rewrite <- mul_SNo_zeroR 0 SNo_0.
      prove x < 0 * 0.
      rewrite H6. exact Hz3.
    * prove 0 <= x. exact Hxnonneg.
Qed.

Theorem sqrt_SNo_nonneg_prop1d: forall x, SNo x -> 0 <= x
  -> (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
  -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
  -> 0 <= G x sqrt_SNo_nonneg
  -> G x sqrt_SNo_nonneg * G x sqrt_SNo_nonneg < x
  -> False.
let x.
assume Hx Hxnonneg IH HLR.
set L_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 0.
set R_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 1.
set L := \/_ k :e omega, L_ k.
set R := \/_ k :e omega, R_ k.
set y := SNoCut L R.
assume Hynn: 0 <= y.
assume H6: y * y < x.
apply HLR.
assume HLHR. apply HLHR.
assume HL: forall w :e L, SNo w.
assume HR: forall z :e R, SNo z.
assume HLR': forall w :e L, forall z :e R, w < z.
apply SNoCutP_SNoCut_impred L R HLR.
assume H1: SNo y.
assume H2: SNoLev y :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume H3: forall w :e L, w < y.
assume H4: forall z :e R, y < z.
assume H5: forall u, SNo u -> (forall w :e L, w < u) -> (forall z :e R, u < z) -> SNoLev y c= SNoLev u /\ SNoEq_ (SNoLev y) y u.
claim Lyy: SNo (y * y).
{ exact SNo_mul_SNo y y H1 H1. }
claim Lyynn: 0 <= y * y.
{ exact mul_SNo_nonneg_nonneg y y H1 H1 Hynn Hynn. }
claim LL_mon: forall k k', nat_p k -> nat_p k' -> k c= k' -> L_ k c= L_ k'.
{ let k k'. assume Hk Hk' Hkk'.
  apply SNo_sqrtaux_mon x sqrt_SNo_nonneg k Hk k' Hk' Hkk'.
  assume H _. exact H.
}
claim LR_mon: forall k k', nat_p k -> nat_p k' -> k c= k' -> R_ k c= R_ k'.
{ let k k'. assume Hk Hk' Hkk'.
  apply SNo_sqrtaux_mon x sqrt_SNo_nonneg k Hk k' Hk' Hkk'.
  assume _ H. exact H.
}
claim L1: forall k, nat_p k ->
              (forall y :e L_ k, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e R_ k, SNo y /\ 0 <= y /\ x < y * y).
{ exact sqrt_SNo_nonneg_prop1a x Hx Hxnonneg IH. }
claim L1L: forall w :e L, forall p:prop, (SNo w -> 0 <= w -> w * w < x -> p) -> p.
{ let w. assume Hw. let p. assume Hp.
  apply famunionE_impred omega L_ w Hw.
  let k. assume Hk: k :e omega.
  assume H1: w :e L_ k.
  apply L1 k (omega_nat_p k Hk).
  assume H2 _.
  apply H2 w H1.
  assume H3. apply H3.
  exact Hp.
}
claim L1R: forall z :e R, forall p:prop, (SNo z -> 0 <= z -> x < z * z -> p) -> p.
{ let z. assume Hz. let p. assume Hp.
  apply famunionE_impred omega R_ z Hz.
  let k. assume Hk: k :e omega.
  assume H1: z :e R_ k.
  apply L1 k (omega_nat_p k Hk).
  assume _ H2.
  apply H2 z H1.
  assume H3. apply H3.
  exact Hp.
}
apply SNoLtE (y * y) x Lyy Hx H6.
- let u.
  assume Hu1: SNo u.
  assume Hu2: SNoLev u :e SNoLev (y * y) :/\: SNoLev x.
  assume Hu3: SNoEq_ (SNoLev u) u (y * y).
  assume Hu4: SNoEq_ (SNoLev u) u x.
  assume Hu5: y * y < u.
  assume Hu6: u < x.
  prove False.
(** In this case u is in SNoL x. And 0 <= y times y < u.
    So u is in SNoL_nonneg x.
    So sqrt u in L and sqrt u < y.
    u = sqrt u times sqrt u < y times y, contradiction to Hu5.
 **)
  claim Lunn: 0 <= u.
  { apply SNoLtLe.
    exact SNoLeLt_tra 0 (y * y) u SNo_0 Lyy Hu1 Lyynn Hu5.
  }
  claim LuSx: u :e SNoS_ (SNoLev x).
  { apply SNoS_I2 u x Hu1 Hx.
    prove SNoLev u :e SNoLev x.
    exact binintersectE2 (SNoLev (y * y)) (SNoLev x) (SNoLev u) Hu2.
  }
  apply IH u LuSx Lunn. assume H. apply H.
  assume H7: SNo (sqrt_SNo_nonneg u).
  assume H8: 0 <= sqrt_SNo_nonneg u.
  assume H9: sqrt_SNo_nonneg u * sqrt_SNo_nonneg u = u.
  claim Lsruy: sqrt_SNo_nonneg u <= y.
  { apply SNoLtLe.
    prove sqrt_SNo_nonneg u < y.
    apply H3.
    prove sqrt_SNo_nonneg u :e L.
    claim Lsruy0: sqrt_SNo_nonneg u :e L_ 0.
    { prove sqrt_SNo_nonneg u :e SNo_sqrtaux x sqrt_SNo_nonneg 0 0.
      rewrite SNo_sqrtaux_0.
      rewrite tuple_2_0_eq.
      prove sqrt_SNo_nonneg u :e {sqrt_SNo_nonneg w|w :e SNoL_nonneg x}.
      apply ReplI.
      prove u :e {w :e SNoL x|0 <= w}.
      apply SepI.
      - apply SNoL_I x Hx u Hu1.
        + exact binintersectE2 (SNoLev (y * y)) (SNoLev x) (SNoLev u) Hu2.
        + prove u < x. exact Hu6.
      - exact Lunn.
    }
    exact famunionI omega L_ 0 (sqrt_SNo_nonneg u) (nat_p_omega 0 nat_0) Lsruy0.
  }
  claim Luyy: u <= y * y.
  { rewrite <- H9.
    prove sqrt_SNo_nonneg u * sqrt_SNo_nonneg u <= y * y.
    exact nonneg_mul_SNo_Le2 (sqrt_SNo_nonneg u) (sqrt_SNo_nonneg u) y y H7 H7 H1 H1 H8 H8 Lsruy Lsruy.
  }
  apply SNoLt_irref (y * y).
  prove y * y < y * y.
  exact SNoLtLe_tra (y * y) u (y * y) Lyy Hu1 Lyy Hu5 Luyy.
- assume H7: SNoLev (y * y) :e SNoLev x.
  prove False.
  (** In this case y times y is in SNoL x.
      Also 0 <= y times y so y times y is in SNoL_nonneg x.
      Hence y = sqrt (y times y) is in L giving y < y.
   **)
  claim Lsryy: sqrt_SNo_nonneg (y * y) = y.
  { apply IH (y * y) (SNoS_I2 (y * y) x Lyy Hx H7) Lyynn.
    assume H. apply H.
    assume H10: SNo (sqrt_SNo_nonneg (y * y)).
    assume H11: 0 <= sqrt_SNo_nonneg (y * y).
    assume H12: sqrt_SNo_nonneg (y * y) * sqrt_SNo_nonneg (y * y) = y * y.
    exact SNo_nonneg_sqr_uniq (sqrt_SNo_nonneg (y * y)) y H10 H1 H11 Hynn H12.
  }
  apply SNoLt_irref y.
  prove y < y.
  rewrite <- Lsryy at 1.
  prove sqrt_SNo_nonneg (y * y) < y.
  apply H3.
  prove sqrt_SNo_nonneg (y * y) :e \/_ k :e omega, L_ k.
  claim LyyL0: sqrt_SNo_nonneg (y * y) :e L_ 0.
  { prove sqrt_SNo_nonneg (y * y) :e SNo_sqrtaux x sqrt_SNo_nonneg 0 0.
    rewrite SNo_sqrtaux_0.
    rewrite tuple_2_0_eq.
    prove sqrt_SNo_nonneg (y * y) :e {sqrt_SNo_nonneg w|w :e SNoL_nonneg x}.
    apply ReplI.
    prove y * y :e SNoL_nonneg x.
    prove y * y :e {w :e SNoL x|0 <= w}.
    apply SepI.
    - exact SNoL_I x Hx (y * y) Lyy H7 H6.
    - prove 0 <= y * y. exact Lyynn.
  }
  exact famunionI omega L_ 0 (sqrt_SNo_nonneg (y * y)) (nat_p_omega 0 nat_0) LyyL0.
- assume H7: SNoLev x :e SNoLev (y * y).
  assume H8: SNoEq_ (SNoLev x) (y * y) x.
  assume H9: SNoLev x /:e y * y.
  claim L3: x :e SNoR (y * y).
  { exact SNoR_I (y * y) Lyy x Hx H7 H6. }
  claim L4: forall p:prop, (forall v :e L, forall w :e R, v * y + y * w <= x + v * w -> p) -> p.
  { let p. assume Hp.
    apply mul_SNo_SNoCut_SNoR_interpolate_impred L R L R HLR HLR y y (fun q H => H) (fun q H => H) x L3.
    - let v. assume Hv: v :e L.
      let w. assume Hw: w :e R.
      assume H10: v * y + y * w <= x + v * w.
      exact Hp v Hv w Hw H10.
    - let v. assume Hv: v :e R.
      let w. assume Hw: w :e L.
      assume H10: v * y + y * w <= x + v * w.
      apply Hp w Hw v Hv.
      prove w * y + y * v <= x + w * v.
      claim Lv1: SNo v.
      { exact HR v Hv. }
      claim Lw1: SNo w.
      { exact HL w Hw. }
      rewrite mul_SNo_com w v Lw1 Lv1.
      prove w * y + y * v <= x + v * w.
      apply mul_SNo_com w y Lw1 H1 (fun _ u => u + y * v <= x + v * w).
      prove y * w + y * v <= x + v * w.
      apply mul_SNo_com y v H1 Lv1 (fun _ u => y * w + u <= x + v * w).
      prove y * w + v * y <= x + v * w.
      apply add_SNo_com (y * w) (v * y) (SNo_mul_SNo y w H1 Lw1) (SNo_mul_SNo v y Lv1 H1) (fun _ u => u <= x + v * w).
      exact H10.
  }
  apply L4.
  let v. assume Hv: v :e L.
  let w. assume Hw: w :e R.
  assume H10: v * y + y * w <= x + v * w.
  apply L1L v Hv.
  assume Hv1: SNo v.
  assume Hv2: 0 <= v.
  assume Hv3: v * v < x.
  apply L1R w Hw.
  assume Hw1: SNo w.
  assume Hw2: 0 <= w.
  assume Hw3: x < w * w.
  claim L5: exists k, nat_p k /\ v :e L_ k /\ w :e R_ k.
  { apply famunionE omega L_ v Hv.
    let k'. assume H. apply H.
    assume Hk'1: k' :e omega.
    assume Hk'2: v :e L_ k'.
    apply famunionE omega R_ w Hw.
    let k''. assume H. apply H.
    assume Hk''1: k'' :e omega.
    assume Hk''2: w :e R_ k''.
    apply ordinal_linear k' k'' (nat_p_ordinal k' (omega_nat_p k' Hk'1)) (nat_p_ordinal k'' (omega_nat_p k'' Hk''1)).
    - assume H1: k' c= k''.
      witness k''.
      apply and3I.
      + exact omega_nat_p k'' Hk''1.
      + prove v :e L_ k''.
        exact LL_mon k' k'' (omega_nat_p k' Hk'1) (omega_nat_p k'' Hk''1) H1 v Hk'2.
      + exact Hk''2.
    - assume H1: k'' c= k'.
      witness k'.
      apply and3I.
      + exact omega_nat_p k' Hk'1.
      + exact Hk'2.
      + prove w :e R_ k'.
        exact LR_mon k'' k' (omega_nat_p k'' Hk''1) (omega_nat_p k' Hk'1) H1 w Hk''2.
  }
  apply L5. let k. assume H. apply H. assume H. apply H.
  assume Hk: nat_p k.
  assume Hvk: v :e L_ k.
  assume Hwk: w :e R_ k.
  claim Lvwpos: 0 < v + w.
  { apply SNoLeLt_tra 0 v (v + w) SNo_0 Hv1 (SNo_add_SNo v w Hv1 Hw1) Hv2.
    prove v < v + w.
    rewrite <- add_SNo_0R v Hv1 at 1.
    prove v + 0 < v + w.
    apply add_SNo_Lt2 v 0 w Hv1 SNo_0 Hw1.
    prove 0 < w.
    apply SNoLeLt_tra 0 y w SNo_0 H1 Hw1 Hynn.
    prove y < w. apply H4.
    prove w :e R.
    exact famunionI omega R_ k w (nat_p_omega k Hk) Hwk.
  }
  claim Lvw0: v + w <> 0.
  { assume H. apply SNoLt_irref 0. rewrite <- H at 2. exact Lvwpos. }
  claim L6: (x + v * w) :/: (v + w) :e L_ (ordsucc k).
  { prove (x + v * w) :/: (v + w) :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc k) 0.
    rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k Hk.
    rewrite tuple_2_0_eq.
    prove (x + v * w) :/: (v + w) :e L_ k :\/: SNo_sqrtauxset (L_ k) (R_ k) x.
    apply binunionI2.
    exact SNo_sqrtauxset_I (L_ k) (R_ k) x v Hvk w Hwk Lvwpos.
  }
  claim L7: (x + v * w) :/: (v + w) :e L.
  { exact famunionI omega L_ (ordsucc k) ((x + v * w) :/: (v + w)) (nat_p_omega (ordsucc k) (nat_ordsucc k Hk)) L6. }
  claim L8: (x + v * w) :/: (v + w) < y.
  { exact H3 ((x + v * w) :/: (v + w)) L7. }
  claim L9: v * y + y * w = y * (v + w).
  { transitivity y * v + y * w.
    - f_equal. prove v * y = y * v. exact mul_SNo_com v y Hv1 H1.
    - prove y * v + y * w = y * (v + w).
      symmetry.
      exact mul_SNo_distrL y v w H1 Hv1 Hw1.
  }
  prove False.
  apply SNoLt_irref (v * y + y * w).
  apply SNoLeLt_tra (v * y + y * w) (x + v * w) (v * y + y * w)
                    (SNo_add_SNo (v * y) (y * w) (SNo_mul_SNo v y Hv1 H1) (SNo_mul_SNo y w H1 Hw1))
                    (SNo_add_SNo x (v * w) Hx (SNo_mul_SNo v w Hv1 Hw1))
                    (SNo_add_SNo (v * y) (y * w) (SNo_mul_SNo v y Hv1 H1) (SNo_mul_SNo y w H1 Hw1))
                    H10.
  prove x + v * w < v * y + y * w.
  rewrite L9.
  prove x + v * w < y * (v + w).
  rewrite <- mul_div_SNo_invL (x + v * w) (v + w)
                    (SNo_add_SNo x (v * w) Hx (SNo_mul_SNo v w Hv1 Hw1))
                    (SNo_add_SNo v w Hv1 Hw1)
                    Lvw0.
  prove ((x + v * w) :/: (v + w)) * (v + w) < y * (v + w).
  exact pos_mul_SNo_Lt' ((x + v * w) :/: (v + w)) y (v + w)
                        (SNo_div_SNo (x + v * w) (v + w)
                          (SNo_add_SNo x (v * w) Hx (SNo_mul_SNo v w Hv1 Hw1))
                          (SNo_add_SNo v w Hv1 Hw1))
                        H1
                        (SNo_add_SNo v w Hv1 Hw1)
                        Lvwpos
                        L8.
Qed.

Theorem sqrt_SNo_nonneg_prop1e: forall x, SNo x -> 0 <= x
  -> (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
  -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
  -> 0 <= G x sqrt_SNo_nonneg
  -> x < G x sqrt_SNo_nonneg * G x sqrt_SNo_nonneg
  -> False.
let x.
assume Hx Hxnonneg IH HLR.
set L_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 0.
set R_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 1.
set L := \/_ k :e omega, L_ k.
set R := \/_ k :e omega, R_ k.
set y := SNoCut L R.
assume Hynn: 0 <= y.
assume H6: x < y * y.
apply HLR.
assume HLHR. apply HLHR.
assume HL: forall w :e L, SNo w.
assume HR: forall z :e R, SNo z.
assume HLR': forall w :e L, forall z :e R, w < z.
apply SNoCutP_SNoCut_impred L R HLR.
assume H1: SNo y.
assume H2: SNoLev y :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume H3: forall w :e L, w < y.
assume H4: forall z :e R, y < z.
assume H5: forall u, SNo u -> (forall w :e L, w < u) -> (forall z :e R, u < z) -> SNoLev y c= SNoLev u /\ SNoEq_ (SNoLev y) y u.
claim Lyy: SNo (y * y).
{ exact SNo_mul_SNo y y H1 H1. }
claim Lyynn: 0 <= y * y.
{ exact mul_SNo_nonneg_nonneg y y H1 H1 Hynn Hynn. }
claim LL_mon: forall k k', nat_p k -> nat_p k' -> k c= k' -> L_ k c= L_ k'.
{ let k k'. assume Hk Hk' Hkk'.
  apply SNo_sqrtaux_mon x sqrt_SNo_nonneg k Hk k' Hk' Hkk'.
  assume H _. exact H.
}
claim LR_mon: forall k k', nat_p k -> nat_p k' -> k c= k' -> R_ k c= R_ k'.
{ let k k'. assume Hk Hk' Hkk'.
  apply SNo_sqrtaux_mon x sqrt_SNo_nonneg k Hk k' Hk' Hkk'.
  assume _ H. exact H.
}
claim L1: forall k, nat_p k ->
              (forall y :e L_ k, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e R_ k, SNo y /\ 0 <= y /\ x < y * y).
{ exact sqrt_SNo_nonneg_prop1a x Hx Hxnonneg IH. }
claim L1L: forall w :e L, forall p:prop, (SNo w -> 0 <= w -> w * w < x -> p) -> p.
{ let w. assume Hw. let p. assume Hp.
  apply famunionE_impred omega L_ w Hw.
  let k. assume Hk: k :e omega.
  assume H1: w :e L_ k.
  apply L1 k (omega_nat_p k Hk).
  assume H2 _.
  apply H2 w H1.
  assume H3. apply H3.
  exact Hp.
}
claim L1R: forall z :e R, forall p:prop, (SNo z -> 0 <= z -> x < z * z -> p) -> p.
{ let z. assume Hz. let p. assume Hp.
  apply famunionE_impred omega R_ z Hz.
  let k. assume Hk: k :e omega.
  assume H1: z :e R_ k.
  apply L1 k (omega_nat_p k Hk).
  assume _ H2.
  apply H2 z H1.
  assume H3. apply H3.
  exact Hp.
}
apply SNoLtE x (y * y) Hx Lyy H6.
- let u.
  assume Hu1: SNo u.
  assume Hu2: SNoLev u :e SNoLev x :/\: SNoLev (y * y).
  assume Hu3: SNoEq_ (SNoLev u) u x.
  assume Hu4: SNoEq_ (SNoLev u) u (y * y).
  assume Hu5: x < u.
  assume Hu6: u < y * y.
  prove False.
  claim Lunn: 0 <= u.
  { apply SNoLtLe.
    exact SNoLeLt_tra 0 x u SNo_0 Hx Hu1 Hxnonneg Hu5.
  }
  claim LuSx: u :e SNoS_ (SNoLev x).
  { apply SNoS_I2 u x Hu1 Hx.
    prove SNoLev u :e SNoLev x.
    exact binintersectE1 (SNoLev x) (SNoLev (y * y)) (SNoLev u) Hu2.
  }
  apply IH u LuSx Lunn. assume H. apply H.
  assume H7: SNo (sqrt_SNo_nonneg u).
  assume H8: 0 <= sqrt_SNo_nonneg u.
  assume H9: sqrt_SNo_nonneg u * sqrt_SNo_nonneg u = u.
  claim Lysru: y <= sqrt_SNo_nonneg u.
  { apply SNoLtLe.
    prove y < sqrt_SNo_nonneg u.
    apply H4.
    prove sqrt_SNo_nonneg u :e R.
    claim Lysru0: sqrt_SNo_nonneg u :e R_ 0.
    { prove sqrt_SNo_nonneg u :e SNo_sqrtaux x sqrt_SNo_nonneg 0 1.
      rewrite SNo_sqrtaux_0.
      rewrite tuple_2_1_eq.
      prove sqrt_SNo_nonneg u :e {sqrt_SNo_nonneg w|w :e SNoR x}.
      apply ReplI.
      apply SNoR_I x Hx u Hu1.
      - exact binintersectE1 (SNoLev x) (SNoLev (y * y)) (SNoLev u) Hu2.
      - prove x < u. exact Hu5.
    }
    exact famunionI omega R_ 0 (sqrt_SNo_nonneg u) (nat_p_omega 0 nat_0) Lysru0.
  }
  apply SNoLt_irref u.
  prove u < u.
  apply SNoLtLe_tra u (y * y) u Hu1 Lyy Hu1 Hu6.
  prove y * y <= u.
  rewrite <- H9.
  prove y * y <= sqrt_SNo_nonneg u * sqrt_SNo_nonneg u.
  exact nonneg_mul_SNo_Le2 y y (sqrt_SNo_nonneg u) (sqrt_SNo_nonneg u) H1 H1 H7 H7 Hynn Hynn Lysru Lysru.
- assume H7: SNoLev x :e SNoLev (y * y).
  assume H8: SNoEq_ (SNoLev x) x (y * y).
  assume H9: SNoLev x :e y * y.
  claim L10: x :e SNoL (y * y).
  { exact SNoL_I (y * y) Lyy x Hx H7 H6. }
  apply mul_SNo_SNoCut_SNoL_interpolate_impred L R L R HLR HLR y y (fun q H => H) (fun q H => H) x L10.
  + let v. assume Hv: v :e L.
    let w. assume Hw: w :e L.
    assume H10: x + v * w <= v * y + y * w.
    apply L1L v Hv.
    assume Hv1: SNo v.
    assume Hv2: 0 <= v.
    assume Hv3: v * v < x.
    apply L1L w Hw.
    assume Hw1: SNo w.
    assume Hw2: 0 <= w.
    assume Hw3: w * w < x.
    apply SNoLtLe_or 0 (v + w) SNo_0 (SNo_add_SNo v w Hv1 Hw1).
    * assume H11: 0 < v + w.
      claim L11: exists k, nat_p k /\ v :e L_ k /\ w :e L_ k.
      { apply famunionE omega L_ v Hv.
        let k'. assume H. apply H.
        assume Hk'1: k' :e omega.
        assume Hk'2: v :e L_ k'.
        apply famunionE omega L_ w Hw.
        let k''. assume H. apply H.
        assume Hk''1: k'' :e omega.
        assume Hk''2: w :e L_ k''.
        apply ordinal_linear k' k'' (nat_p_ordinal k' (omega_nat_p k' Hk'1)) (nat_p_ordinal k'' (omega_nat_p k'' Hk''1)).
        - assume H1: k' c= k''.
          witness k''.
          apply and3I.
          + exact omega_nat_p k'' Hk''1.
          + prove v :e L_ k''.
            exact LL_mon k' k'' (omega_nat_p k' Hk'1) (omega_nat_p k'' Hk''1) H1 v Hk'2.
          + exact Hk''2.
        - assume H1: k'' c= k'.
          witness k'.
          apply and3I.
          + exact omega_nat_p k' Hk'1.
          + exact Hk'2.
          + prove w :e L_ k'.
            exact LL_mon k'' k' (omega_nat_p k'' Hk''1) (omega_nat_p k' Hk'1) H1 w Hk''2.
      }
      apply L11. let k. assume H. apply H. assume H. apply H.
      assume Hk: nat_p k.
      assume Hvk: v :e L_ k.
      assume Hwk: w :e L_ k.
      claim Lvw0: v + w <> 0.
      { assume H. apply SNoLt_irref 0. rewrite <- H at 2. exact H11. }
      claim L12: (x + v * w) :/: (v + w) :e R_ (ordsucc k).
      { prove (x + v * w) :/: (v + w) :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc k) 1.
        rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k Hk.
        rewrite tuple_2_1_eq.
        prove (x + v * w) :/: (v + w) :e R_ k :\/: SNo_sqrtauxset (L_ k) (L_ k) x :\/: SNo_sqrtauxset (R_ k) (R_ k) x.
        apply binunionI1.
        apply binunionI2.
        exact SNo_sqrtauxset_I (L_ k) (L_ k) x v Hvk w Hwk H11.
      }
      claim L13: (x + v * w) :/: (v + w) :e R.
      { exact famunionI omega R_ (ordsucc k) ((x + v * w) :/: (v + w)) (nat_p_omega (ordsucc k) (nat_ordsucc k Hk)) L12. }
      claim L14: y < (x + v * w) :/: (v + w).
      { exact H4 ((x + v * w) :/: (v + w)) L13. }
      claim L15: v * y + y * w = y * (v + w).
      { transitivity y * v + y * w.
        - f_equal. prove v * y = y * v. exact mul_SNo_com v y Hv1 H1.
        - prove y * v + y * w = y * (v + w).
          symmetry.
          exact mul_SNo_distrL y v w H1 Hv1 Hw1.
      }
      prove False.
      apply SNoLt_irref (x + v * w).
      apply SNoLeLt_tra (x + v * w) (v * y + y * w) (x + v * w)
                        (SNo_add_SNo x (v * w) Hx (SNo_mul_SNo v w Hv1 Hw1))
                        (SNo_add_SNo (v * y) (y * w) (SNo_mul_SNo v y Hv1 H1) (SNo_mul_SNo y w H1 Hw1))
                        (SNo_add_SNo x (v * w) Hx (SNo_mul_SNo v w Hv1 Hw1))
                        H10.
      prove v * y + y * w < x + v * w.
      rewrite L15.
      prove y * (v + w) < x + v * w.
      rewrite <- mul_div_SNo_invL (x + v * w) (v + w)
                        (SNo_add_SNo x (v * w) Hx (SNo_mul_SNo v w Hv1 Hw1))
                        (SNo_add_SNo v w Hv1 Hw1)
                        Lvw0.
      prove y * (v + w) < ((x + v * w) :/: (v + w)) * (v + w).
      exact pos_mul_SNo_Lt' y ((x + v * w) :/: (v + w)) (v + w)
                            H1
                            (SNo_div_SNo (x + v * w) (v + w)
                              (SNo_add_SNo x (v * w) Hx (SNo_mul_SNo v w Hv1 Hw1))
                              (SNo_add_SNo v w Hv1 Hw1))
                            (SNo_add_SNo v w Hv1 Hw1)
                            H11
                            L14.
    * assume H11: v + w <= 0.
      claim L16: v = 0 /\ w = 0.
      { apply SNoLtLe_or 0 v SNo_0 Hv1.
        - assume H12: 0 < v. prove False.
          apply SNoLt_irref 0.
          apply SNoLtLe_tra 0 v 0 SNo_0 Hv1 SNo_0 H12.
          prove v <= 0.
          apply SNoLe_tra v (v + w) 0 Hv1 (SNo_add_SNo v w Hv1 Hw1) SNo_0.
          + prove v <= v + w.
            rewrite <- add_SNo_0R v Hv1 at 1.
            prove v + 0 <= v + w.
            exact add_SNo_Le2 v 0 w Hv1 SNo_0 Hw1 Hw2.
          + prove v + w <= 0. exact H11.
        - assume H12: v <= 0.
          apply SNoLtLe_or 0 w SNo_0 Hw1.
          + assume H13: 0 < w. prove False.
            apply SNoLt_irref 0.
            apply SNoLtLe_tra 0 w 0 SNo_0 Hw1 SNo_0 H13.
            prove w <= 0.
            apply SNoLe_tra w (v + w) 0 Hw1 (SNo_add_SNo v w Hv1 Hw1) SNo_0.
            * prove w <= v + w.
              rewrite <- add_SNo_0L w Hw1 at 1.
              prove 0 + w <= v + w.
              exact add_SNo_Le1 0 w v SNo_0 Hw1 Hv1 Hv2.
            * prove v + w <= 0. exact H11.
          + assume H13: w <= 0.
            apply andI.
            * exact SNoLe_antisym v 0 Hv1 SNo_0 H12 Hv2.
            * exact SNoLe_antisym w 0 Hw1 SNo_0 H13 Hw2.
      }
      apply L16.
      assume Hv0: v = 0.
      assume Hw0: w = 0.
      claim L17: x + v * w = x.
      { rewrite Hv0. rewrite mul_SNo_zeroL w Hw1. exact add_SNo_0R x Hx. }
      claim L18: v * y + y * w = 0.
      { rewrite Hv0.
        prove 0 * y + y * w = 0.
        apply mul_SNo_zeroL y H1 (fun _ u => u + y * w = 0).
        rewrite Hw0.
        prove 0 + y * 0 = 0.
        apply mul_SNo_zeroR y H1 (fun _ u => 0 + u = 0).
        exact add_SNo_0L 0 SNo_0.
      }
      claim L19: x <= 0.
      { rewrite <- L17. rewrite <- L18. exact H10. }
      claim L20: x = 0.
      { exact SNoLe_antisym x 0 Hx SNo_0 L19 Hxnonneg. }
      apply SNoLt_irref (v * v).
      prove v * v < v * v.
      rewrite Hv0 at 3.
      prove v * v < 0 * v.
      rewrite mul_SNo_zeroL v Hv1.
      prove v * v < 0.
      rewrite <- L20. exact Hv3.
  + let v. assume Hv: v :e R.
    let w. assume Hw: w :e R.
    assume H10: x + v * w <= v * y + y * w.
    apply L1R v Hv.
    assume Hv1: SNo v.
    assume Hv2: 0 <= v.
    assume Hv3: x < v * v.
    apply L1R w Hw.
    assume Hw1: SNo w.
    assume Hw2: 0 <= w.
    assume Hw3: x < w * w.
    claim L21: exists k, nat_p k /\ v :e R_ k /\ w :e R_ k.
    { apply famunionE omega R_ v Hv.
      let k'. assume H. apply H.
      assume Hk'1: k' :e omega.
      assume Hk'2: v :e R_ k'.
      apply famunionE omega R_ w Hw.
      let k''. assume H. apply H.
      assume Hk''1: k'' :e omega.
      assume Hk''2: w :e R_ k''.
      apply ordinal_linear k' k'' (nat_p_ordinal k' (omega_nat_p k' Hk'1)) (nat_p_ordinal k'' (omega_nat_p k'' Hk''1)).
      - assume H1: k' c= k''.
        witness k''.
        apply and3I.
        + exact omega_nat_p k'' Hk''1.
        + prove v :e R_ k''.
          exact LR_mon k' k'' (omega_nat_p k' Hk'1) (omega_nat_p k'' Hk''1) H1 v Hk'2.
        + exact Hk''2.
      - assume H1: k'' c= k'.
        witness k'.
        apply and3I.
        + exact omega_nat_p k' Hk'1.
        + exact Hk'2.
        + prove w :e R_ k'.
          exact LR_mon k'' k' (omega_nat_p k'' Hk''1) (omega_nat_p k' Hk'1) H1 w Hk''2.
    }
    apply L21. let k. assume H. apply H. assume H. apply H.
    assume Hk: nat_p k.
    assume Hvk: v :e R_ k.
    assume Hwk: w :e R_ k.
    claim Lvwpos: 0 < v + w.
    { apply SNoLeLt_tra 0 v (v + w) SNo_0 Hv1 (SNo_add_SNo v w Hv1 Hw1) Hv2.
      prove v < v + w.
      rewrite <- add_SNo_0R v Hv1 at 1.
      prove v + 0 < v + w.
      apply add_SNo_Lt2 v 0 w Hv1 SNo_0 Hw1.
      prove 0 < w.
      apply SNoLeLt_tra 0 y w SNo_0 H1 Hw1 Hynn.
      prove y < w. apply H4.
      prove w :e R.
      exact famunionI omega R_ k w (nat_p_omega k Hk) Hwk.
    }
    claim Lvw0: v + w <> 0.
    { assume H. apply SNoLt_irref 0. rewrite <- H at 2. exact Lvwpos. }
    claim L22: (x + v * w) :/: (v + w) :e R_ (ordsucc k).
    { prove (x + v * w) :/: (v + w) :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc k) 1.
      rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k Hk.
      rewrite tuple_2_1_eq.
      prove (x + v * w) :/: (v + w) :e R_ k :\/: SNo_sqrtauxset (L_ k) (L_ k) x :\/: SNo_sqrtauxset (R_ k) (R_ k) x.
      apply binunionI2.
      exact SNo_sqrtauxset_I (R_ k) (R_ k) x v Hvk w Hwk Lvwpos.
    }
    claim L23: (x + v * w) :/: (v + w) :e R.
    { exact famunionI omega R_ (ordsucc k) ((x + v * w) :/: (v + w)) (nat_p_omega (ordsucc k) (nat_ordsucc k Hk)) L22. }
    claim L24: y < (x + v * w) :/: (v + w).
    { exact H4 ((x + v * w) :/: (v + w)) L23. }
    claim L25: v * y + y * w = y * (v + w).
    { transitivity y * v + y * w.
      - f_equal. prove v * y = y * v. exact mul_SNo_com v y Hv1 H1.
      - prove y * v + y * w = y * (v + w).
        symmetry.
        exact mul_SNo_distrL y v w H1 Hv1 Hw1.
    }
    prove False.
    apply SNoLt_irref (x + v * w).
    apply SNoLeLt_tra (x + v * w) (v * y + y * w) (x + v * w)
                      (SNo_add_SNo x (v * w) Hx (SNo_mul_SNo v w Hv1 Hw1))
                      (SNo_add_SNo (v * y) (y * w) (SNo_mul_SNo v y Hv1 H1) (SNo_mul_SNo y w H1 Hw1))
                      (SNo_add_SNo x (v * w) Hx (SNo_mul_SNo v w Hv1 Hw1))
                      H10.
    prove v * y + y * w < x + v * w.
    rewrite L25.
    prove y * (v + w) < x + v * w.
    rewrite <- mul_div_SNo_invL (x + v * w) (v + w)
                      (SNo_add_SNo x (v * w) Hx (SNo_mul_SNo v w Hv1 Hw1))
                      (SNo_add_SNo v w Hv1 Hw1)
                      Lvw0.
    prove y * (v + w) < ((x + v * w) :/: (v + w)) * (v + w).
    exact pos_mul_SNo_Lt' y ((x + v * w) :/: (v + w)) (v + w)
                          H1
                          (SNo_div_SNo (x + v * w) (v + w)
                            (SNo_add_SNo x (v * w) Hx (SNo_mul_SNo v w Hv1 Hw1))
                            (SNo_add_SNo v w Hv1 Hw1))
                          (SNo_add_SNo v w Hv1 Hw1)
                          Lvwpos
                          L24.
- assume H7: SNoLev (y * y) :e SNoLev x.
  prove False.
  claim Lsryy: sqrt_SNo_nonneg (y * y) = y.
  { apply IH (y * y) (SNoS_I2 (y * y) x Lyy Hx H7) Lyynn.
    assume H. apply H.
    assume H10: SNo (sqrt_SNo_nonneg (y * y)).
    assume H11: 0 <= sqrt_SNo_nonneg (y * y).
    assume H12: sqrt_SNo_nonneg (y * y) * sqrt_SNo_nonneg (y * y) = y * y.
    exact SNo_nonneg_sqr_uniq (sqrt_SNo_nonneg (y * y)) y H10 H1 H11 Hynn H12.
  }
  apply SNoLt_irref y.
  prove y < y.
  rewrite <- Lsryy at 2.
  prove y < sqrt_SNo_nonneg (y * y).
  apply H4.
  prove sqrt_SNo_nonneg (y * y) :e R.
  claim LyyR0: sqrt_SNo_nonneg (y * y) :e R_ 0.
  { prove sqrt_SNo_nonneg (y * y) :e SNo_sqrtaux x sqrt_SNo_nonneg 0 1.
    rewrite SNo_sqrtaux_0.
    rewrite tuple_2_1_eq.
    prove sqrt_SNo_nonneg (y * y) :e {sqrt_SNo_nonneg w|w :e SNoR x}.
    apply ReplI.
    prove y * y :e SNoR x.
    exact SNoR_I x Hx (y * y) Lyy H7 H6.
  }
  exact famunionI omega R_ 0 (sqrt_SNo_nonneg (y * y)) (nat_p_omega 0 nat_0) LyyR0.
Qed.

Theorem sqrt_SNo_nonneg_prop1: forall x, SNo x -> 0 <= x -> SNo (sqrt_SNo_nonneg x) /\ 0 <= sqrt_SNo_nonneg x /\ sqrt_SNo_nonneg x * sqrt_SNo_nonneg x = x.
apply SNoLev_ind.
let x. assume Hx: SNo x.
assume IH: forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w.
assume Hxnonneg: 0 <= x.
prove SNo (sqrt_SNo_nonneg x) /\ 0 <= sqrt_SNo_nonneg x /\ sqrt_SNo_nonneg x * sqrt_SNo_nonneg x = x.
rewrite sqrt_SNo_nonneg_eq x Hx.
prove SNo (G x sqrt_SNo_nonneg) /\ 0 <= G x sqrt_SNo_nonneg /\ G x sqrt_SNo_nonneg * G x sqrt_SNo_nonneg = x.
set L_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 0.
set R_ : set -> set := fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 1.
set L := \/_ k :e omega, L_ k.
set R := \/_ k :e omega, R_ k.
claim LL_mon: forall k k', nat_p k -> nat_p k' -> k c= k' -> L_ k c= L_ k'.
{ let k k'. assume Hk Hk' Hkk'.
  apply SNo_sqrtaux_mon x sqrt_SNo_nonneg k Hk k' Hk' Hkk'.
  assume H _. exact H.
}
claim LR_mon: forall k k', nat_p k -> nat_p k' -> k c= k' -> R_ k c= R_ k'.
{ let k k'. assume Hk Hk' Hkk'.
  apply SNo_sqrtaux_mon x sqrt_SNo_nonneg k Hk k' Hk' Hkk'.
  assume _ H. exact H.
}
claim L1: forall k, nat_p k ->
              (forall y :e L_ k, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e R_ k, SNo y /\ 0 <= y /\ x < y * y).
{ exact sqrt_SNo_nonneg_prop1a x Hx Hxnonneg IH. }
claim L1L: forall w :e L, forall p:prop, (SNo w -> 0 <= w -> w * w < x -> p) -> p.
{ let w. assume Hw. let p. assume Hp.
  apply famunionE_impred omega L_ w Hw.
  let k. assume Hk: k :e omega.
  assume H1: w :e L_ k.
  apply L1 k (omega_nat_p k Hk).
  assume H2 _.
  apply H2 w H1.
  assume H3. apply H3.
  exact Hp.
}
claim L1R: forall z :e R, forall p:prop, (SNo z -> 0 <= z -> x < z * z -> p) -> p.
{ let z. assume Hz. let p. assume Hp.
  apply famunionE_impred omega R_ z Hz.
  let k. assume Hk: k :e omega.
  assume H1: z :e R_ k.
  apply L1 k (omega_nat_p k Hk).
  assume _ H2.
  apply H2 z H1.
  assume H3. apply H3.
  exact Hp.
}
claim L2: SNoCutP L R.
{ exact sqrt_SNo_nonneg_prop1b x Hx Hxnonneg L1. }
apply L2.
assume HLHR. apply HLHR.
assume HL: forall w :e L, SNo w.
assume HR: forall z :e R, SNo z.
assume HLR: forall w :e L, forall z :e R, w < z.
set y := SNoCut L R.
apply SNoCutP_SNoCut_impred L R L2.
assume H1: SNo y.
assume H2: SNoLev y :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y))).
assume H3: forall w :e L, w < y.
assume H4: forall z :e R, y < z.
assume H5: forall u, SNo u -> (forall w :e L, w < u) -> (forall z :e R, u < z) -> SNoLev y c= SNoLev u /\ SNoEq_ (SNoLev y) y u.
claim Lynn: 0 <= y.
{ exact sqrt_SNo_nonneg_prop1c x Hx Hxnonneg L2 L1R. }
prove SNo y /\ 0 <= y /\ y * y = x.
apply and3I.
- prove SNo y. exact H1.
- prove 0 <= y. exact Lynn.
- prove y * y = x.
  claim Lyy: SNo (y * y).
  { exact SNo_mul_SNo y y H1 H1. }
  claim Lyynn: 0 <= y * y.
  { exact mul_SNo_nonneg_nonneg y y H1 H1 Lynn Lynn. }
  apply SNoLt_trichotomy_or_impred (y * y) x Lyy Hx.
  + assume H6: y * y < x. prove False.
    exact sqrt_SNo_nonneg_prop1d x Hx Hxnonneg IH L2 Lynn H6.
  + assume H6: y * y = x. exact H6.
  + assume H6: x < y * y. prove False.
    exact sqrt_SNo_nonneg_prop1e x Hx Hxnonneg IH L2 Lynn H6.
Qed.

End sqrt_SNo_nonneg.

Theorem SNo_sqrtaux_0_1_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
      (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
   /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y).
let x. assume Hx Hxnonneg.
apply sqrt_SNo_nonneg_prop1a x Hx Hxnonneg.
let w. assume Hw Hwnonneg.
apply SNoS_E2 (SNoLev x) (SNoLev_ordinal x Hx) w Hw. assume Hw1 Hw2 Hw3 Hw4.
exact sqrt_SNo_nonneg_prop1 w Hw3 Hwnonneg.
Qed.

Theorem SNo_sqrtaux_0_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
  forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x.
let x. assume Hx Hxnonneg.
let k. assume Hk.
apply SNo_sqrtaux_0_1_prop x Hx Hxnonneg k Hk.
assume H _. exact H.
Qed.

Theorem SNo_sqrtaux_1_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
  forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y.
let x. assume Hx Hxnonneg.
let k. assume Hk.
apply SNo_sqrtaux_0_1_prop x Hx Hxnonneg k Hk.
assume _ H. exact H.
Qed.

Theorem SNo_sqrt_SNo_SNoCutP: forall x, SNo x -> 0 <= x ->
  SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0)
          (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1).
let x. assume Hx Hxnonneg.
apply sqrt_SNo_nonneg_prop1b x Hx Hxnonneg.
exact SNo_sqrtaux_0_1_prop x Hx Hxnonneg.
Qed.

Theorem SNo_sqrt_SNo_nonneg: forall x, SNo x -> 0 <= x -> SNo (sqrt_SNo_nonneg x).
let x. assume Hx Hxnonneg.
apply sqrt_SNo_nonneg_prop1 x Hx Hxnonneg.
assume H _. apply H. assume H _. exact H.
Qed.

Theorem sqrt_SNo_nonneg_nonneg: forall x, SNo x -> 0 <= x -> 0 <= sqrt_SNo_nonneg x.
let x. assume Hx Hxnonneg.
apply sqrt_SNo_nonneg_prop1 x Hx Hxnonneg.
assume H _. apply H. assume _ H. exact H.
Qed.

Theorem sqrt_SNo_nonneg_sqr: forall x, SNo x -> 0 <= x -> sqrt_SNo_nonneg x * sqrt_SNo_nonneg x = x.
let x. assume Hx Hxnonneg.
apply sqrt_SNo_nonneg_prop1 x Hx Hxnonneg.
assume _ H. exact H.
Qed.

Theorem sqrt_SNo_nonneg_0 : sqrt_SNo_nonneg 0 = 0.
rewrite sqrt_SNo_nonneg_eq 0 SNo_0.
set L_ := fun k:set => SNo_sqrtaux 0 sqrt_SNo_nonneg k 0.
set R_ := fun k:set => SNo_sqrtaux 0 sqrt_SNo_nonneg k 1.
set L := \/_ k :e omega, L_ k.
set R := \/_ k :e omega, R_ k.
prove SNoCut L R = 0.
claim L1: forall k, nat_p k -> L_ k = 0 /\ R_ k = 0.
{ apply nat_ind.
  - apply andI.
    + prove L_ 0 = 0.
      prove SNo_sqrtaux 0 sqrt_SNo_nonneg 0 0 = 0.
      rewrite SNo_sqrtaux_0.
      rewrite tuple_2_0_eq.
      prove {sqrt_SNo_nonneg w|w :e SNoL_nonneg 0} = 0.
      rewrite SNoL_nonneg_0.
      exact Repl_Empty sqrt_SNo_nonneg.
    + prove R_ 0 = 0.
      prove SNo_sqrtaux 0 sqrt_SNo_nonneg 0 1 = 0.
      rewrite SNo_sqrtaux_0.
      rewrite tuple_2_1_eq.
      prove {sqrt_SNo_nonneg w|w :e SNoR 0} = 0.
      rewrite SNoR_0.
      exact Repl_Empty sqrt_SNo_nonneg.
  - let k. assume Hk.
    assume IHk. apply IHk.
    assume IHLk: L_ k = 0.
    assume IHRk: R_ k = 0.
    apply andI.
    + prove L_ (ordsucc k) = 0.
      prove SNo_sqrtaux 0 sqrt_SNo_nonneg (ordsucc k) 0 = 0.
      rewrite SNo_sqrtaux_S 0 sqrt_SNo_nonneg k Hk.
      rewrite tuple_2_0_eq.
      prove L_ k :\/: SNo_sqrtauxset (L_ k) (R_ k) 0 = Empty.
      rewrite IHLk.
      prove 0 :\/: SNo_sqrtauxset 0 (R_ k) 0 = Empty.
      apply SNo_sqrtauxset_0 (R_ k) 0 (fun _ u => 0 :\/: u = 0).
      prove 0 :\/: 0 = Empty.
      apply binunion_idl.
    + prove R_ (ordsucc k) = 0.
      prove SNo_sqrtaux 0 sqrt_SNo_nonneg (ordsucc k) 1 = 0.
      rewrite SNo_sqrtaux_S 0 sqrt_SNo_nonneg k Hk.
      rewrite tuple_2_1_eq.
      prove R_ k :\/: SNo_sqrtauxset (L_ k) (L_ k) 0 :\/: SNo_sqrtauxset (R_ k) (R_ k) 0 = Empty.
      rewrite IHLk. rewrite IHRk.
      prove 0 :\/: SNo_sqrtauxset 0 0 0 :\/: SNo_sqrtauxset 0 0 0 = Empty.
      rewrite SNo_sqrtauxset_0 0 0.
      prove 0 :\/: 0 :\/: 0 = Empty.
      rewrite binunion_idl 0.
      prove 0 :\/: 0 = Empty.
      apply binunion_idl.
}
claim L2: L = 0.
{ apply Empty_eq.
  let x. assume Hx: x :e L.
  apply famunionE_impred omega L_ x Hx.
  let k. assume Hk: k :e omega.
  apply L1 k (omega_nat_p k Hk).
  assume H1: L_ k = 0.
  assume _.
  prove x /:e L_ k.
  rewrite H1.
  exact EmptyE x.
}
claim L3: R = 0.
{ apply Empty_eq.
  let x. assume Hx: x :e R.
  apply famunionE_impred omega R_ x Hx.
  let k. assume Hk: k :e omega.
  apply L1 k (omega_nat_p k Hk).
  assume _.
  assume H1: R_ k = 0.
  prove x /:e R_ k.
  rewrite H1.
  exact EmptyE x.
}
rewrite L2. rewrite L3.
exact SNoCut_0_0.
Qed.

Theorem sqrt_SNo_nonneg_1 : sqrt_SNo_nonneg 1 = 1.
rewrite sqrt_SNo_nonneg_eq 1 SNo_1.
set L_ := fun k:set => SNo_sqrtaux 1 sqrt_SNo_nonneg k 0.
set R_ := fun k:set => SNo_sqrtaux 1 sqrt_SNo_nonneg k 1.
set L := \/_ k :e omega, L_ k.
set R := \/_ k :e omega, R_ k.
prove SNoCut L R = 1.
claim L1: forall k, nat_p k -> L_ k = 1 /\ R_ k = 0.
{ apply nat_ind.
  - apply andI.
    + prove L_ 0 = 1.
      prove SNo_sqrtaux 1 sqrt_SNo_nonneg 0 0 = 1.
      rewrite SNo_sqrtaux_0.
      rewrite tuple_2_0_eq.
      prove {sqrt_SNo_nonneg w|w :e SNoL_nonneg 1} = 1.
      rewrite SNoL_nonneg_1.
      prove {sqrt_SNo_nonneg w|w :e 1} = 1.
      apply set_ext.
      * let u. assume Hu: u :e {sqrt_SNo_nonneg w|w :e 1}.
        prove u :e 1.
        apply ReplE_impred 1 sqrt_SNo_nonneg u Hu.
        let w. assume Hw: w :e 1.
        apply cases_1 w Hw.
        rewrite sqrt_SNo_nonneg_0.
        assume Hu0: u = 0.
        rewrite Hu0. exact In_0_1.
      * let u. assume Hu: u :e 1.
        apply cases_1 u Hu.
        prove 0 :e {sqrt_SNo_nonneg w|w :e 1}.
        rewrite <- sqrt_SNo_nonneg_0 at 1.
        apply ReplI. exact In_0_1.
    + prove R_ 0 = 0.
      prove SNo_sqrtaux 1 sqrt_SNo_nonneg 0 1 = 0.
      rewrite SNo_sqrtaux_0.
      rewrite tuple_2_1_eq.
      prove {sqrt_SNo_nonneg w|w :e SNoR 1} = 0.
      rewrite SNoR_1.
      exact Repl_Empty sqrt_SNo_nonneg.
  - let k. assume Hk.
    assume IHk. apply IHk.
    assume IHLk: L_ k = 1.
    assume IHRk: R_ k = 0.
    apply andI.
    + prove L_ (ordsucc k) = 1.
      prove SNo_sqrtaux 1 sqrt_SNo_nonneg (ordsucc k) 0 = 1.
      rewrite SNo_sqrtaux_S 1 sqrt_SNo_nonneg k Hk.
      rewrite tuple_2_0_eq.
      prove L_ k :\/: SNo_sqrtauxset (L_ k) (R_ k) 1 = 1.
      rewrite IHLk. rewrite IHRk.
      prove 1 :\/: SNo_sqrtauxset 1 0 1 = 1.
      rewrite SNo_sqrtauxset_0' 1 1.
      apply binunion_idr.
    + prove R_ (ordsucc k) = 0.
      prove SNo_sqrtaux 1 sqrt_SNo_nonneg (ordsucc k) 1 = 0.
      rewrite SNo_sqrtaux_S 1 sqrt_SNo_nonneg k Hk.
      rewrite tuple_2_1_eq.
      prove R_ k :\/: SNo_sqrtauxset (L_ k) (L_ k) 1 :\/: SNo_sqrtauxset (R_ k) (R_ k) 1 = 0.
      rewrite IHLk. rewrite IHRk.
      prove 0 :\/: SNo_sqrtauxset 1 1 1 :\/: SNo_sqrtauxset 0 0 1 = 0.
      rewrite SNo_sqrtauxset_0 0 1.
      prove 0 :\/: SNo_sqrtauxset 1 1 1 :\/: 0 = 0.
      rewrite binunion_idl (SNo_sqrtauxset 1 1 1).
      rewrite binunion_idr (SNo_sqrtauxset 1 1 1).
      prove SNo_sqrtauxset 1 1 1 = 0.
      apply Empty_eq.
      let u. assume Hu: u :e SNo_sqrtauxset 1 1 1.
      apply SNo_sqrtauxset_E 1 1 1 u Hu.
      let w. assume Hw: w :e 1.
      let z. assume Hz: z :e 1.
      apply cases_1 w Hw.
      apply cases_1 z Hz.
      rewrite add_SNo_0R 0 SNo_0.
      assume H1: 0 < 0.
      prove False.
      apply SNoLt_irref 0.
      exact H1.
}
claim L2: L = 1.
{ apply set_ext.
  - prove L c= 1.
    let x. assume Hx: x :e L.
    apply famunionE_impred omega L_ x Hx.
    let k. assume Hk: k :e omega.
    apply L1 k (omega_nat_p k Hk).
    assume H1: L_ k = 1.
    assume _.
    prove x :e L_ k -> x :e 1.
    rewrite H1.
    assume H2: x :e 1.
    prove x :e 1.
    exact H2.
  - let x. assume Hx: x :e 1.
    apply cases_1 x Hx.
    prove 0 :e L.
    claim L2a: 0 :e L_ 0.
    { apply L1 0 nat_0.
      assume H1: L_ 0 = 1.
      assume _.
      rewrite H1. exact In_0_1.
    }
    prove 0 :e \/_ k :e omega, L_ k.
    exact famunionI omega L_ 0 0 (nat_p_omega 0 nat_0) L2a.
}
claim L3: R = 0.
{ apply Empty_eq.
  let x. assume Hx: x :e R.
  apply famunionE_impred omega R_ x Hx.
  let k. assume Hk: k :e omega.
  apply L1 k (omega_nat_p k Hk).
  assume _.
  assume H1: R_ k = 0.
  prove x /:e R_ k.
  rewrite H1.
  exact EmptyE x.
}
rewrite L2. rewrite L3.
prove SNoCut 1 0 = 1.
rewrite <- SNoL_1 at 1.
rewrite <- SNoR_1 at 2.
prove SNoCut (SNoL 1) (SNoR 1) = 1.
symmetry.
exact SNo_eta 1 SNo_1.
Qed.

Theorem sqrt_SNo_nonneg_0inL0: forall x, SNo x -> 0 <= x -> 0 :e SNoLev x -> 0 :e SNo_sqrtaux x sqrt_SNo_nonneg 0 0.
let x. assume Hx Hxnn H1.
set L_ := fun k:set => SNo_sqrtaux x sqrt_SNo_nonneg k 0.
prove 0 :e L_ 0.
rewrite <- sqrt_SNo_nonneg_0 at 1.
prove sqrt_SNo_nonneg 0 :e SNo_sqrtaux x sqrt_SNo_nonneg 0 0.
rewrite SNo_sqrtaux_0 x sqrt_SNo_nonneg.
rewrite tuple_2_0_eq.
prove sqrt_SNo_nonneg 0 :e {sqrt_SNo_nonneg w|w :e SNoL_nonneg x}.
apply ReplI.
prove 0 :e SNoL_nonneg x.
prove 0 :e {w :e SNoL x|0 <= w}.
apply SepI.
- prove 0 :e SNoL x.
  apply SNoL_I x Hx 0 SNo_0.
  + prove SNoLev 0 :e SNoLev x.
    rewrite SNoLev_0. exact H1.
  + prove 0 < x.
    apply SNoLeE 0 x SNo_0 Hx Hxnn.
    * assume H3: 0 < x. exact H3.
    * assume H3: 0 = x. prove False.
      apply EmptyE 0.
      rewrite <- SNoLev_0 at 2.
      rewrite H3 at 2.
      exact H1.
- prove 0 <= 0. apply SNoLe_ref.
Qed.

Theorem sqrt_SNo_nonneg_Lnonempty: forall x, SNo x -> 0 <= x -> 0 :e SNoLev x -> (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) <> 0.
let x. assume Hx Hxnn H1.
set L_ := fun k:set => SNo_sqrtaux x sqrt_SNo_nonneg k 0.
set R_ := fun k:set => SNo_sqrtaux x sqrt_SNo_nonneg k 1.
set L := \/_ k :e omega, L_ k.
set R := \/_ k :e omega, R_ k.
prove L <> 0.
assume H2: L = 0.
claim L1: sqrt_SNo_nonneg 0 :e L_ 0.
{ rewrite sqrt_SNo_nonneg_0.
  exact sqrt_SNo_nonneg_0inL0 x Hx Hxnn H1.
}
apply EmptyE (sqrt_SNo_nonneg 0).
prove sqrt_SNo_nonneg 0 :e 0.
rewrite <- H2 at 2.
exact famunionI omega L_ 0 (sqrt_SNo_nonneg 0) (nat_p_omega 0 nat_0) L1.
Qed.

Theorem sqrt_SNo_nonneg_Rnonempty: forall x, SNo x -> 0 <= x -> 1 :e SNoLev x -> (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1) <> 0.
let x. assume Hx Hxnn H1.
set L_ := fun k:set => SNo_sqrtaux x sqrt_SNo_nonneg k 0.
set R_ := fun k:set => SNo_sqrtaux x sqrt_SNo_nonneg k 1.
set L := \/_ k :e omega, L_ k.
set R := \/_ k :e omega, R_ k.
prove R <> 0.
assume H2: R = 0.
apply SNoLt_trichotomy_or_impred x 1 Hx SNo_1.
- assume H3: x < 1.
  claim L1: 1 :e SNoR x.
  { apply SNoR_I x Hx 1 SNo_1.
    - prove SNoLev 1 :e SNoLev x.
      rewrite ordinal_SNoLev 1 (nat_p_ordinal 1 nat_1).
      exact H1.
    - exact H3.
  }
  claim L2: sqrt_SNo_nonneg 1 :e R_ 0.
  { prove sqrt_SNo_nonneg 1 :e SNo_sqrtaux x sqrt_SNo_nonneg 0 1.
    rewrite SNo_sqrtaux_0 x sqrt_SNo_nonneg.
    rewrite tuple_2_1_eq.
    prove sqrt_SNo_nonneg 1 :e {sqrt_SNo_nonneg z|z :e SNoR x}.
    apply ReplI.
    exact L1.
  }
  apply EmptyE (sqrt_SNo_nonneg 1).
  rewrite <- H2 at 2.
  prove sqrt_SNo_nonneg 1 :e R.
  exact famunionI omega R_ 0 (sqrt_SNo_nonneg 1) (nat_p_omega 0 nat_0) L2.
- assume H3: x = 1. prove False.
  apply In_irref 1.
  prove 1 :e 1.
  rewrite <- ordinal_SNoLev 1 (nat_p_ordinal 1 nat_1) at 2.
  rewrite <- H3 at 2.
  exact H1.
- assume H3: 1 < x.
  claim L3: 1 :e SNoL_nonneg x.
  { prove 1 :e {w :e SNoL x|0 <= w}.
    apply SepI.
    - apply SNoL_I x Hx 1 SNo_1.
      + prove SNoLev 1 :e SNoLev x.
        rewrite ordinal_SNoLev 1 (nat_p_ordinal 1 nat_1).
        exact H1.
      + exact H3.
    - prove 0 <= 1. apply SNoLtLe. exact SNoLt_0_1.
  }
  claim L4: (x + 1 * 0) :/: (1 + 0) :e R_ 1.
  { prove (x + 1 * 0) :/: (1 + 0) :e SNo_sqrtaux x sqrt_SNo_nonneg 1 1.
    rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg 0 nat_0.
    rewrite tuple_2_1_eq.
    apply binunionI1.
    apply binunionI2.
    apply SNo_sqrtauxset_I.
    - prove 1 :e L_ 0.
      prove 1 :e SNo_sqrtaux x sqrt_SNo_nonneg 0 0.
      rewrite SNo_sqrtaux_0.
      rewrite tuple_2_0_eq.
      prove 1 :e {sqrt_SNo_nonneg w|w :e SNoL_nonneg x}.
      rewrite <- sqrt_SNo_nonneg_1.
      apply ReplI.
      prove 1 :e SNoL_nonneg x.
      exact L3.
    - prove 0 :e L_ 0.
      exact sqrt_SNo_nonneg_0inL0 x Hx Hxnn (ordinal_TransSet (SNoLev x) (SNoLev_ordinal x Hx) 1 H1 0 In_0_1).
    - prove 0 < 1 + 0.
      rewrite add_SNo_0R 1 SNo_1.
      exact SNoLt_0_1.
  }
  apply EmptyE ((x + 1 * 0) :/: (1 + 0)).
  rewrite <- H2 at 5.
  prove ((x + 1 * 0) :/: (1 + 0)) :e R.
  exact famunionI omega R_ 1 ((x + 1 * 0) :/: (1 + 0)) (nat_p_omega 1 nat_1) L4.
Qed.

Theorem SNo_sqrtauxset_real: forall Y Z x, Y c= real -> Z c= real -> x :e real -> SNo_sqrtauxset Y Z x c= real.
let Y Z x. assume HY HZ Hx.
prove (\/_ y :e Y, {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}) c= real.
let w. assume Hw.
apply famunionE_impred Y (fun y => {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}) w Hw.
let y.
assume Hy: y :e Y.
assume Hw2: w :e {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}.
apply ReplSepE_impred Z (fun z => 0 < y + z) (fun z => (x + y * z) :/: (y + z)) w Hw2.
let z.
assume Hz: z :e Z.
assume Hyz: 0 < y + z.
assume Hw3: w = (x + y * z) :/: (y + z).
prove w :e real.
rewrite Hw3.
apply real_div_SNo.
- prove x + y * z :e real. apply real_add_SNo.
  + exact Hx.
  + apply real_mul_SNo.
    * exact HY y Hy.
    * exact HZ z Hz.
- prove y + z :e real.
  apply real_add_SNo.
  + exact HY y Hy.
  + exact HZ z Hz.
Qed.

Theorem SNo_sqrtauxset_real_nonneg: forall Y Z x, Y c= {w :e real|0 <= w} -> Z c= {z :e real|0 <= z} -> x :e real -> 0 <= x -> SNo_sqrtauxset Y Z x c= {w :e real|0 <= w}.
let Y Z x. assume HY HZ Hx Hxnneg.
prove (\/_ y :e Y, {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}) c= {w :e real|0 <= w}.
claim LY: Y c= real.
{ let y. assume Hy. exact SepE1 real (fun w => 0 <= w) y (HY y Hy). }
claim LZ: Z c= real.
{ let z. assume Hz. exact SepE1 real (fun w => 0 <= w) z (HZ z Hz). }
claim LxS: SNo x.
{ exact real_SNo x Hx. }
let w. assume Hw.
apply SepI.
- apply SNo_sqrtauxset_real Y Z x LY LZ Hx w Hw.
- prove 0 <= w.
  apply famunionE_impred Y (fun y => {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}) w Hw.
  let y.
  assume Hy: y :e Y.
  assume Hw2: w :e {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}.
  apply ReplSepE_impred Z (fun z => 0 < y + z) (fun z => (x + y * z) :/: (y + z)) w Hw2.
  let z.
  assume Hz: z :e Z.
  assume Hyz: 0 < y + z.
  assume Hw3: w = (x + y * z) :/: (y + z).
  apply SepE real (fun w => 0 <= w) y (HY y Hy).
  assume HyR: y :e real.
  assume Hynneg: 0 <= y.
  claim LyS: SNo y.
  { exact real_SNo y HyR. }
  apply SepE real (fun z => 0 <= z) z (HZ z Hz).
  assume HzR: z :e real.
  assume Hznneg: 0 <= z.
  claim LzS: SNo z.
  { exact real_SNo z HzR. }
  rewrite Hw3.
  prove 0 <= (x + y * z) :/: (y + z).
  claim L1: 0 <= x + y * z.
  { rewrite <- add_SNo_0R 0 SNo_0.
    apply add_SNo_Le3 0 0 x (y * z) SNo_0 SNo_0 (real_SNo x Hx) (SNo_mul_SNo y z LyS LzS).
    - prove 0 <= x. exact Hxnneg.
    - prove 0 <= y * z.
      apply SNoLeE 0 y SNo_0 LyS Hynneg.
      + assume H1: 0 < y.
        apply SNoLeE 0 z SNo_0 LzS Hznneg.
        * assume H2: 0 < z.
          apply SNoLtLe.
          prove 0 < y * z.
          exact mul_SNo_pos_pos y z LyS LzS H1 H2.
        * assume H2: 0 = z.
          rewrite <- H2.
          rewrite mul_SNo_zeroR y LyS.
          apply SNoLe_ref.
      + assume H1: 0 = y.
        rewrite <- H1.
        rewrite mul_SNo_zeroL z LzS.
        apply SNoLe_ref.
  }
  apply SNoLeE 0 (x + y * z) SNo_0 (SNo_add_SNo x (y * z) LxS (SNo_mul_SNo y z LyS LzS)) L1.
  - assume H1: 0 < x + y * z.
    prove 0 <= (x + y * z) :/: (y + z).
    apply SNoLtLe.
    prove 0 < (x + y * z) :/: (y + z).
    exact div_SNo_pos_pos (x + y * z) (y + z)
                          (SNo_add_SNo x (y * z) LxS (SNo_mul_SNo y z LyS LzS))
                          (SNo_add_SNo y z LyS LzS)
                          H1
                          Hyz.
  - assume H1: 0 = x + y * z.
    rewrite <- H1.
    rewrite div_SNo_0_num (y + z) (SNo_add_SNo y z LyS LzS).
    apply SNoLe_ref.
Qed.

Theorem sqrt_SNo_nonneg_SNoS_omega: forall x :e SNoS_ omega, 0 <= x -> sqrt_SNo_nonneg x :e real.
claim L1: forall x, SNo x -> SNoLev x :e omega -> 0 <= x -> sqrt_SNo_nonneg x :e real.
{ apply SNoLev_ind.
  let x. assume Hx: SNo x.
  assume IH: forall w :e SNoS_ (SNoLev x), SNoLev w :e omega -> 0 <= w -> sqrt_SNo_nonneg w :e real.
  assume Hx1: SNoLev x :e omega.
  assume Hx2: 0 <= x.
  claim Lx: x :e real.
  { apply SNoS_omega_real.
    apply SNoS_I omega omega_ordinal x (SNoLev x) Hx1.
    prove SNo_ (SNoLev x) x.
    exact SNoLev_ x Hx.
  }
  prove sqrt_SNo_nonneg x :e real.
  apply ordinal_In_Or_Subq 0 (SNoLev x) ordinal_Empty (SNoLev_ordinal x Hx).
  - assume H1: 0 :e SNoLev x.
    apply ordinal_In_Or_Subq 1 (SNoLev x) ordinal_1 (SNoLev_ordinal x Hx).
    + assume H2: 1 :e SNoLev x.
      prove sqrt_SNo_nonneg x :e real.
      rewrite sqrt_SNo_nonneg_eq x Hx.
      set L_ := fun k:set => SNo_sqrtaux x sqrt_SNo_nonneg k 0.
      set R_ := fun k:set => SNo_sqrtaux x sqrt_SNo_nonneg k 1.
      set L := \/_ k :e omega, L_ k.
      set R := \/_ k :e omega, R_ k.
      prove SNoCut L R :e real.
      claim L_L_R_real: forall k, nat_p k -> L_ k c= real /\ R_ k c= real.
      { prove forall k, nat_p k ->
                   SNo_sqrtaux x sqrt_SNo_nonneg k 0 c= real
                /\ SNo_sqrtaux x sqrt_SNo_nonneg k 1 c= real.
        apply nat_ind.
        - rewrite SNo_sqrtaux_0. rewrite tuple_2_0_eq. rewrite tuple_2_1_eq.
          apply andI.
          + prove {sqrt_SNo_nonneg w|w :e SNoL_nonneg x} c= real.
            let w'. assume Hw'.
            apply ReplE_impred (SNoL_nonneg x) sqrt_SNo_nonneg w' Hw'.
            let w. assume Hw: w :e SNoL_nonneg x.
            assume Hw'w: w' = sqrt_SNo_nonneg w.
            rewrite Hw'w.
            prove sqrt_SNo_nonneg w :e real.
            apply SepE (SNoL x) (fun w => 0 <= w) w Hw.
            assume Hw1: w :e SNoL x.
            assume Hwnneg: 0 <= w.
            apply SNoL_E x Hx w Hw1.
            assume Hw1a Hw1b Hw1c.
            apply IH.
            * prove w :e SNoS_ (SNoLev x).
              exact SNoS_I2 w x Hw1a Hx Hw1b.
            * prove SNoLev w :e omega.
              exact omega_TransSet (SNoLev x) Hx1 (SNoLev w) Hw1b.
            * prove 0 <= w. exact Hwnneg.
          + prove {sqrt_SNo_nonneg z|z :e SNoR x} c= real.
            let z'. assume Hz'.
            apply ReplE_impred (SNoR x) sqrt_SNo_nonneg z' Hz'.
            let z. assume Hz: z :e SNoR x.
            assume Hz'z: z' = sqrt_SNo_nonneg z.
            rewrite Hz'z.
            prove sqrt_SNo_nonneg z :e real.
            apply SNoR_E x Hx z Hz.
            assume Hz1 Hz2 Hz3.
            apply IH.
            * prove z :e SNoS_ (SNoLev x).
              exact SNoS_I2 z x Hz1 Hx Hz2.
            * prove SNoLev z :e omega.
              exact omega_TransSet (SNoLev x) Hx1 (SNoLev z) Hz2.
            * prove 0 <= z. apply SNoLtLe.
              prove 0 < z.
              apply SNoLeLt_tra 0 x z SNo_0 Hx Hz1 Hx2.
              prove x < z. exact Hz3.
        - let k. assume Hk.
          assume IHk. apply IHk.
          assume IHk0: SNo_sqrtaux x sqrt_SNo_nonneg k 0 c= real.
          assume IHk1: SNo_sqrtaux x sqrt_SNo_nonneg k 1 c= real.
          rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k Hk.
          rewrite tuple_2_0_eq. rewrite tuple_2_1_eq.
          apply andI.
          + prove SNo_sqrtaux x sqrt_SNo_nonneg k 0 :\/: SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 0) (SNo_sqrtaux x sqrt_SNo_nonneg k 1) x c= real.
            apply binunion_Subq_min.
            * exact IHk0.
            * { prove SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 0) (SNo_sqrtaux x sqrt_SNo_nonneg k 1) x c= real.
                apply SNo_sqrtauxset_real.
                - exact IHk0.
                - exact IHk1.
                - exact Lx.
              }
          + prove SNo_sqrtaux x sqrt_SNo_nonneg k 1 :\/: SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 0) (SNo_sqrtaux x sqrt_SNo_nonneg k 0) x :\/: SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 1) (SNo_sqrtaux x sqrt_SNo_nonneg k 1) x c= real.
            apply binunion_Subq_min.
            * { apply binunion_Subq_min.
                - exact IHk1.
                - prove SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 0) (SNo_sqrtaux x sqrt_SNo_nonneg k 0) x c= real.
                  apply SNo_sqrtauxset_real.
                  + exact IHk0.
                  + exact IHk0.
                  + exact Lx.
              }
            * { prove SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 1) (SNo_sqrtaux x sqrt_SNo_nonneg k 1) x c= real.
                apply SNo_sqrtauxset_real.
                - exact IHk1.
                - exact IHk1.
                - exact Lx.
              }
      }
      claim L1L: forall w :e L, forall p:prop, (SNo w -> 0 <= w -> w * w < x -> p) -> p.
      { let w. assume Hw. let p. assume Hp.
        apply famunionE_impred omega L_ w Hw.
        let k. assume Hk: k :e omega.
        assume H1: w :e L_ k.
        apply SNo_sqrtaux_0_prop x Hx Hx2 k (omega_nat_p k Hk) w H1.
        assume H2. apply H2.
        exact Hp.
      }
      claim L1R: forall z :e R, forall p:prop, (SNo z -> 0 <= z -> x < z * z -> p) -> p.
      { let z. assume Hz. let p. assume Hp.
        apply famunionE_impred omega R_ z Hz.
        let k. assume Hk: k :e omega.
        assume H1: z :e R_ k.
        apply SNo_sqrtaux_1_prop x Hx Hx2 k (omega_nat_p k Hk) z H1.
        assume H3. apply H3.
        exact Hp.
      }
      claim LLR: SNoCutP L R.
      { exact SNo_sqrt_SNo_SNoCutP x Hx Hx2. }
      apply LLR.
      assume HLHR. apply HLHR.
      assume HL: forall w :e L, SNo w.
      assume HR: forall z :e R, SNo z.
      assume HLR: forall w :e L, forall z :e R, w < z.
      apply real_SNoCut.
      * prove L c= real.
        let w. assume Hw: w :e L.
        apply famunionE_impred omega L_ w Hw.
        let k. assume Hk: k :e omega.
        assume H1: w :e L_ k.
        apply L_L_R_real k (omega_nat_p k Hk).
        assume H2 _. exact H2 w H1.
      * prove R c= real.
        let z. assume Hz: z :e R.
        apply famunionE_impred omega R_ z Hz.
        let k. assume Hk: k :e omega.
        assume H1: z :e R_ k.
        apply L_L_R_real k (omega_nat_p k Hk).
        assume _ H2. exact H2 z H1.
      * prove SNoCutP L R. exact LLR.
      * prove L <> 0.
        exact sqrt_SNo_nonneg_Lnonempty x Hx Hx2 H1.
      * prove R <> 0.
        exact sqrt_SNo_nonneg_Rnonempty x Hx Hx2 H2.
      * prove forall w :e L, exists w' :e L, w < w'.
        let w. assume Hw.
        apply famunionE_impred omega L_ w Hw.
        let k. assume Hk: k :e omega.
        assume H3: w :e L_ k.
        apply L1L w Hw.
        assume Hw1: SNo w.
        assume Hw2: 0 <= w.
        assume Hw3: w * w < x.
        claim Lwmw: SNo (w * w).
        { exact SNo_mul_SNo w w Hw1 Hw1. }
        claim Lwpw: SNo (w + w).
        { exact SNo_add_SNo w w Hw1 Hw1. }
        claim L1a: exists z, z :e R_ (ordsucc k).
        { apply SNoLt_trichotomy_or_impred x 1 Hx SNo_1.
          - assume H4: x < 1.
            witness 1.
            prove 1 :e R_ (ordsucc k).
            apply SNo_sqrtaux_mon x sqrt_SNo_nonneg 0 nat_0 (ordsucc k) (nat_ordsucc k (omega_nat_p k Hk)) (Subq_Empty (ordsucc k)).
            assume _.
            assume H5: forall z :e R_ 0, z :e R_ (ordsucc k).
            prove 1 :e R_ (ordsucc k).
            apply H5.
            prove 1 :e R_ 0.
            prove 1 :e SNo_sqrtaux x sqrt_SNo_nonneg 0 1.
            rewrite SNo_sqrtaux_0.
            rewrite tuple_2_1_eq.
            prove 1 :e {sqrt_SNo_nonneg z|z :e SNoR x}.
            rewrite <- sqrt_SNo_nonneg_1.
            apply ReplI.
            prove 1 :e SNoR x.
            prove 1 :e {z :e SNoS_ (SNoLev x)|x < z}.
            apply SepI.
            + prove 1 :e SNoS_ (SNoLev x).
              apply SNoS_I2 1 x SNo_1 Hx.
              prove SNoLev 1 :e SNoLev x.
              rewrite ordinal_SNoLev 1 ordinal_1.
              exact H2.
            + prove x < 1. exact H4.
          - assume H4: x = 1. prove False.
            apply In_irref 1.
            prove 1 :e 1.
            rewrite <- ordinal_SNoLev 1 ordinal_1 at 2.
            prove 1 :e SNoLev 1.
            rewrite <- H4 at 2.
            exact H2.
          - assume H4: 1 < x.
            claim L1a1: 1 :e L_ k.
            { apply SNo_sqrtaux_mon x sqrt_SNo_nonneg 0 nat_0 k (omega_nat_p k Hk) (Subq_Empty k).
              assume H5: forall z :e L_ 0, z :e L_ k.
              assume _.
              prove 1 :e L_ k.
              apply H5.
              prove 1 :e L_ 0.
              prove 1 :e SNo_sqrtaux x sqrt_SNo_nonneg 0 0.
              rewrite SNo_sqrtaux_0.
              rewrite tuple_2_0_eq.
              prove 1 :e {sqrt_SNo_nonneg z|z :e SNoL_nonneg x}.
              rewrite <- sqrt_SNo_nonneg_1.
              apply ReplI.
              prove 1 :e SNoL_nonneg x.
              prove 1 :e {w :e SNoL x|0 <= w}.
              apply SepI.
              - prove 1 :e {z :e SNoS_ (SNoLev x)|z < x}.
                apply SepI.
                + prove 1 :e SNoS_ (SNoLev x).
                  apply SNoS_I2 1 x SNo_1 Hx.
                  prove SNoLev 1 :e SNoLev x.
                  rewrite ordinal_SNoLev 1 ordinal_1.
                  exact H2.
                + prove 1 < x. exact H4.
              - prove 0 <= 1. apply SNoLtLe. exact SNoLt_0_1.
            }
            claim L1a2: 0 < 1 + 1.
            { rewrite add_SNo_1_1_2. exact SNoLt_0_2. }
            set z := (x + 1 * 1) :/: (1 + 1).
            witness z.
            prove z :e R_ (ordsucc k).
            prove z :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc k) 1.
            rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k (omega_nat_p k Hk).
            rewrite tuple_2_1_eq.
            prove z :e R_ k :\/: SNo_sqrtauxset (L_ k) (L_ k) x :\/: SNo_sqrtauxset (R_ k) (R_ k) x.
            apply binunionI1. apply binunionI2.
            prove z :e SNo_sqrtauxset (L_ k) (L_ k) x.
            exact SNo_sqrtauxset_I (L_ k) (L_ k) x 1 L1a1 1 L1a1 L1a2.
        }
        apply L1a.
        let z. assume Hz: z :e R_ (ordsucc k).
        claim Lz: z :e R.
        { exact famunionI omega R_ (ordsucc k) z (omega_ordsucc k Hk) Hz. }
        apply L1R z Lz.
        assume Hz1: SNo z.
        assume Hz2: 0 <= z.
        assume Hz3: x < z * z.
        claim Lwmz: SNo (w * z).
        { exact SNo_mul_SNo w z Hw1 Hz1. }
        claim Lwpz: SNo (w + z).
        { exact SNo_add_SNo w z Hw1 Hz1. }
        claim Lzpos: 0 < z.
        { apply SNoLeE 0 z SNo_0 Hz1 Hz2.
          - assume H4: 0 < z. exact H4.
          - assume H4: 0 = z. prove False.
            apply SNoLt_irref 0.
            prove 0 < 0.
            apply SNoLeLt_tra 0 x 0 SNo_0 Hx SNo_0 Hx2.
            prove x < 0.
            rewrite <- mul_SNo_zeroR 0 SNo_0.
            rewrite H4.
            prove x < z * z.
            exact Hz3.
        }
        claim Lwpzpos: 0 < w + z.
        { apply SNoLtLe_tra 0 z (w + z) SNo_0 Hz1 Lwpz Lzpos.
          prove z <= w + z.
          rewrite <- add_SNo_0L z Hz1 at 1.
          prove 0 + z <= w + z.
          exact add_SNo_Le1 0 z w SNo_0 Hz1 Hw1 Hw2.
        }
        claim Lwpzn0: w + z <> 0.
        { assume H4: w + z = 0.
          apply SNoLt_irref 0.
          rewrite <- H4 at 2.
          exact Lwpzpos.
        }
        set w' := (x + w * z) :/: (w + z).
        claim Lw': w' :e L_ (ordsucc (ordsucc k)).
        { prove w' :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc (ordsucc k)) 0.
          rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg (ordsucc k) (nat_ordsucc k (omega_nat_p k Hk)).
          rewrite tuple_2_0_eq.
          prove w' :e L_ (ordsucc k) :\/: SNo_sqrtauxset (L_ (ordsucc k)) (R_ (ordsucc k)) x.
          apply binunionI2.
          prove w' :e SNo_sqrtauxset (L_ (ordsucc k)) (R_ (ordsucc k)) x.
          prove (x + w * z) :/: (w + z) :e SNo_sqrtauxset (L_ (ordsucc k)) (R_ (ordsucc k)) x.
          claim LwLk: w :e L_ (ordsucc k).
          { prove w :e L_ (ordsucc k).
            apply SNo_sqrtaux_mon x sqrt_SNo_nonneg k (omega_nat_p k Hk) (ordsucc k) (nat_ordsucc k (omega_nat_p k Hk)) (ordsuccI1 k).
            assume H5: forall u :e L_ k, u :e L_ (ordsucc k).
            assume _.
            apply H5.
            prove w :e L_ k.
            exact H3.
          }
          exact SNo_sqrtauxset_I (L_ (ordsucc k)) (R_ (ordsucc k)) x w LwLk z Hz Lwpzpos.
        }
        witness w'. apply andI.
        + prove w' :e L.
          exact famunionI omega L_ (ordsucc (ordsucc k)) w' (omega_ordsucc (ordsucc k) (omega_ordsucc k Hk)) Lw'.
        + prove w < w'.
          rewrite <- div_mul_SNo_invL w (w + z) Hw1 Lwpz Lwpzn0 at 1.
          prove (w * (w + z)) :/: (w + z) < w'.
          prove (w * (w + z)) * recip_SNo (w + z) < (x + w * z) * recip_SNo (w + z).
          apply pos_mul_SNo_Lt' (w * (w + z)) (x + w * z) (recip_SNo (w + z))
                                (SNo_mul_SNo w (w + z) Hw1 Lwpz)
                                (SNo_add_SNo x (w * z) Hx Lwmz)
                                (SNo_recip_SNo (w + z) Lwpz)
                                (recip_SNo_of_pos_is_pos (w + z) Lwpz Lwpzpos).
          prove w * (w + z) < x + w * z.
          rewrite mul_SNo_distrL w w z Hw1 Hw1 Hz1.
          prove w * w + w * z < x + w * z.
          apply add_SNo_Lt1 (w * w) (w * z) x Lwmw Lwmz Hx.
          prove w * w < x.
          exact Hw3.
      * { prove forall z :e R, exists z' :e R, z' < z.
          let z. assume Hz.
          apply famunionE_impred omega R_ z Hz.
          let k. assume Hk: k :e omega.
          assume H3: z :e R_ k.
          apply L1R z Hz.
          assume Hz1: SNo z.
          assume Hz2: 0 <= z.
          assume Hz3: x < z * z.
          claim Lzmz: SNo (z * z).
          { exact SNo_mul_SNo z z Hz1 Hz1. }
          claim Lzpz: SNo (z + z).
          { exact SNo_add_SNo z z Hz1 Hz1. }
          claim Lzpos: 0 < z.
          { apply SNoLeE 0 z SNo_0 Hz1 Hz2.
            - assume H4: 0 < z. exact H4.
            - assume H4: 0 = z. prove False.
              apply SNoLt_irref 0.
              prove 0 < 0.
              apply SNoLeLt_tra 0 x 0 SNo_0 Hx SNo_0 Hx2.
              prove x < 0.
              rewrite <- mul_SNo_zeroR 0 SNo_0.
              rewrite H4.
              prove x < z * z.
              exact Hz3.
          }
          claim Lzpzpos: 0 < z + z.
          { rewrite <- add_SNo_0L 0 SNo_0.
            exact add_SNo_Lt3 0 0 z z SNo_0 SNo_0 Hz1 Hz1 Lzpos Lzpos.
          }
          claim Lzpzn0: z + z <> 0.
          { assume H4: z + z = 0.
            apply SNoLt_irref 0.
            rewrite <- H4 at 2.
            exact Lzpzpos.
          }
          set z' := (x + z * z) :/: (z + z).
          claim Lz': z' :e R_ (ordsucc k).
          { prove z' :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc k) 1.
            rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k (omega_nat_p k Hk).
            rewrite tuple_2_1_eq.
            prove z' :e R_ k :\/: SNo_sqrtauxset (L_ k) (L_ k) x :\/: SNo_sqrtauxset (R_ k) (R_ k) x.
            apply binunionI2.
            prove z' :e SNo_sqrtauxset (R_ k) (R_ k) x.
            apply SNo_sqrtauxset_I.
            - prove z :e R_ k. exact H3.
            - prove z :e R_ k. exact H3.
            - prove 0 < z + z. exact Lzpzpos.
          }
          witness z'. apply andI.
          - prove z' :e R.
            exact famunionI omega R_ (ordsucc k) z' (omega_ordsucc k Hk) Lz'.
          - prove z' < z.
            rewrite <- div_mul_SNo_invL z (z + z) Hz1 Lzpz Lzpzn0 at 5.
            prove z' < (z * (z + z)) :/: (z + z).
            prove (x + z * z) * recip_SNo (z + z) < (z * (z + z)) * recip_SNo (z + z).
            apply pos_mul_SNo_Lt' (x + z * z) (z * (z + z)) (recip_SNo (z + z))
                                  (SNo_add_SNo x (z * z) Hx Lzmz)
                                  (SNo_mul_SNo z (z + z) Hz1 Lzpz)
                                  (SNo_recip_SNo (z + z) Lzpz)
                                  (recip_SNo_of_pos_is_pos (z + z) Lzpz Lzpzpos).
            prove x + z * z < z * (z + z).
            rewrite mul_SNo_distrL z z z Hz1 Hz1 Hz1.
            prove x + z * z < z * z + z * z.
            apply add_SNo_Lt1 x (z * z) (z * z) Hx Lzmz Lzmz.
            prove x < z * z.
            exact Hz3.
          }
    + assume H2: SNoLev x c= 1.
      claim L1_1: x = 1.
      { symmetry. apply SNo_eq 1 x SNo_1 Hx.
        - prove SNoLev 1 = SNoLev x. rewrite ordinal_SNoLev 1 ordinal_1.
          prove 1 = SNoLev x.
          apply set_ext.
          + let u. assume Hu: u :e 1.
            apply cases_1 u Hu.
            prove 0 :e SNoLev x.
            exact H1.
          + exact H2.
        - prove SNoEq_ (SNoLev 1) 1 x.
          rewrite ordinal_SNoLev 1 ordinal_1.
          prove SNoEq_ 1 1 x.
          let u. assume Hu: u :e 1.
          prove u :e 1 <-> u :e x.
          apply iffI.
          + assume _. apply cases_1 u Hu.
            prove 0 :e x. apply dneg.
            assume H3: 0 /:e x.
            apply SNoLt_irref 0.
            prove 0 < 0.
            apply SNoLeLt_tra 0 x 0 SNo_0 Hx SNo_0 Hx2.
            prove x < 0.
            apply SNoLtI3.
            * prove SNoLev 0 :e SNoLev x. rewrite SNoLev_0. exact H1.
            * prove SNoEq_ (SNoLev 0) x 0. rewrite SNoLev_0.
              let u. assume Hu: u :e 0. prove False. exact EmptyE u Hu.
            * rewrite SNoLev_0. exact H3.
          + assume _. exact Hu.
      }
      rewrite L1_1. rewrite sqrt_SNo_nonneg_1.
      prove 1 :e real. exact real_1.
  - assume H1: SNoLev x c= 0.
    claim L1_0: x = 0.
    { apply SNoLev_0_eq_0 x Hx. prove SNoLev x = 0. apply Empty_Subq_eq. exact H1. }
    rewrite L1_0. rewrite sqrt_SNo_nonneg_0.
    prove 0 :e real. exact real_0.
}
let x. assume Hx.
apply SNoS_E2 omega omega_ordinal x Hx.
assume Hx1: SNoLev x :e omega.
assume Hx2: ordinal (SNoLev x).
assume Hx3: SNo x.
assume Hx4: SNo_ (SNoLev x) x.
exact L1 x Hx3 Hx1.
Qed.

Theorem sqrt_SNo_nonneg_real: forall x :e real, 0 <= x -> sqrt_SNo_nonneg x :e real.
let x. assume Hx Hxnn.
apply real_E x Hx.
assume Hx1: SNo x.
assume Hx2: SNoLev x :e ordsucc omega.
assume Hx3: x :e SNoS_ (ordsucc omega).
assume Hx4: - omega < x.
assume Hx5: x < omega.
assume Hx6: forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x.
assume Hx7: forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
apply sqrt_SNo_nonneg_prop1 x Hx1 Hxnn. assume H. apply H.
assume H1: SNo (sqrt_SNo_nonneg x).
assume H2: 0 <= sqrt_SNo_nonneg x.
assume H3: sqrt_SNo_nonneg x * sqrt_SNo_nonneg x = x.
apply ordsuccE omega (SNoLev x) Hx2.
- assume H4: SNoLev x :e omega.
  prove sqrt_SNo_nonneg x :e real.
  apply sqrt_SNo_nonneg_SNoS_omega.
  + prove x :e SNoS_ omega.
    apply SNoS_I omega omega_ordinal x (SNoLev x) H4.
    prove SNo_ (SNoLev x) x.
    apply SNoLev_. exact Hx1.
  + prove 0 <= x. exact Hxnn.
- assume H4: SNoLev x = omega.
  prove sqrt_SNo_nonneg x :e real.
  rewrite sqrt_SNo_nonneg_eq x Hx1.
  set L_ := fun k:set => SNo_sqrtaux x sqrt_SNo_nonneg k 0.
  set R_ := fun k:set => SNo_sqrtaux x sqrt_SNo_nonneg k 1.
  set L := \/_ k :e omega, L_ k.
  set R := \/_ k :e omega, R_ k.
  prove SNoCut L R :e real.
  claim LLI: forall k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0 c= L.
  { let k. assume Hk.
    let w. assume Hw.
    prove w :e \/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0.
    exact famunionI omega (fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 0) k w Hk Hw.
  }
  claim LRI: forall k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1 c= R.
  { let k. assume Hk.
    let z. assume Hz.
    prove z :e \/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1.
    exact famunionI omega (fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 1) k z Hk Hz.
  }
  claim LLE: forall w :e L, forall p:prop, (forall k :e omega, w :e SNo_sqrtaux x sqrt_SNo_nonneg k 0 -> p) -> p.
  { let w. assume Hw: w :e L.
    let p. assume Hp.
    apply famunionE_impred omega (fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 0) w Hw.
    let k. assume Hk: k :e omega.
    assume Hwk: w :e SNo_sqrtaux x sqrt_SNo_nonneg k 0.
    exact Hp k Hk Hwk.
  }
  claim LRE: forall z :e R, forall p:prop, (forall k :e omega, z :e SNo_sqrtaux x sqrt_SNo_nonneg k 1 -> p) -> p.
  { let z. assume Hz: z :e R.
    let p. assume Hp.
    apply famunionE_impred omega (fun k => SNo_sqrtaux x sqrt_SNo_nonneg k 1) z Hz.
    let k. assume Hk: k :e omega.
    assume Hzk: z :e SNo_sqrtaux x sqrt_SNo_nonneg k 1.
    exact Hp k Hk Hzk.
  }
  claim L_L_Subq: forall k, nat_p k -> L_ k c= L_ (ordsucc k).
  { let k. assume Hk.
    let w. assume Hw: w :e L_ k.
    prove w :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc k) 0.
    rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k Hk.
    rewrite tuple_2_0_eq.
    apply binunionI1. exact Hw.
  }
  claim L_R_Subq: forall k, nat_p k -> R_ k c= R_ (ordsucc k).
  { let k. assume Hk.
    let w. assume Hw: w :e R_ k.
    prove w :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc k) 1.
    rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k Hk.
    rewrite tuple_2_1_eq.
    apply binunionI1. apply binunionI1.
    exact Hw.
  }
  claim L_L_R_Subq: forall k, nat_p k -> forall k' :e k, L_ k' c= L_ k /\ R_ k' c= R_ k.
  { prove forall k, nat_p k ->
          forall k' :e k,
               SNo_sqrtaux x sqrt_SNo_nonneg k' 0 c= SNo_sqrtaux x sqrt_SNo_nonneg k 0
            /\ SNo_sqrtaux x sqrt_SNo_nonneg k' 1 c= SNo_sqrtaux x sqrt_SNo_nonneg k 1.
    apply nat_ind.
    - let k'. assume Hk': k' :e 0. prove False. exact EmptyE k' Hk'.
    - let k. assume Hk.
      assume IHk: forall k' :e k, L_ k' c= L_ k /\ R_ k' c= R_ k.
      let k'. assume Hk': k' :e ordsucc k.
      apply ordsuccE k k' Hk'.
      + assume Hk'2: k' :e k. apply IHk k' Hk'2.
        assume IHkL IHkR.
        apply andI.
        * prove L_ k' c= L_ (ordsucc k).
          apply Subq_tra (L_ k') (L_ k) (L_ (ordsucc k)) IHkL.
          prove L_ k c= L_ (ordsucc k).
          exact L_L_Subq k Hk.
        * prove R_ k' c= R_ (ordsucc k).
          apply Subq_tra (R_ k') (R_ k) (R_ (ordsucc k)) IHkR.
          prove R_ k c= R_ (ordsucc k).
          exact L_R_Subq k Hk.
      + assume Hk'2: k' = k. rewrite Hk'2. apply andI.
        * prove L_ k c= L_ (ordsucc k).
          exact L_L_Subq k Hk.
        * prove R_ k c= R_ (ordsucc k).
          exact L_R_Subq k Hk.
  }
  claim L_L_R_real: forall k, nat_p k -> L_ k c= {w :e real|0 <= w} /\ R_ k c= {w :e real|0 <= w}.
  { prove forall k, nat_p k ->
               SNo_sqrtaux x sqrt_SNo_nonneg k 0 c= {w :e real|0 <= w}
            /\ SNo_sqrtaux x sqrt_SNo_nonneg k 1 c= {w :e real|0 <= w}.
    apply nat_ind.
    - rewrite SNo_sqrtaux_0. rewrite tuple_2_0_eq. rewrite tuple_2_1_eq.
      apply andI.
      + prove {sqrt_SNo_nonneg w|w :e SNoL_nonneg x} c= {w :e real|0 <= w}.
        let w'. assume Hw'.
        apply ReplE_impred (SNoL_nonneg x) sqrt_SNo_nonneg w' Hw'.
        let w. assume Hw: w :e SNoL_nonneg x.
        assume Hw'w: w' = sqrt_SNo_nonneg w.
        rewrite Hw'w.
        prove sqrt_SNo_nonneg w :e {w :e real|0 <= w}.
        apply SepE (SNoL x) (fun w => 0 <= w) w Hw.
        assume Hw1: w :e SNoL x.
        assume Hwnneg: 0 <= w.
        apply SNoL_E x Hx1 w Hw1.
        assume Hw1a Hw1b Hw1c.
        apply SepI.
        * { apply sqrt_SNo_nonneg_SNoS_omega.
            - prove w :e SNoS_ omega.
              apply SNoS_I omega omega_ordinal w (SNoLev w).
              + prove SNoLev w :e omega.
                rewrite <- H4. exact Hw1b.
              + prove SNo_ (SNoLev w) w.
                apply SNoLev_. exact Hw1a.
            - prove 0 <= w. exact Hwnneg.
          }
        * prove 0 <= sqrt_SNo_nonneg w.
          exact sqrt_SNo_nonneg_nonneg w Hw1a Hwnneg.
      + prove {sqrt_SNo_nonneg z|z :e SNoR x} c= {w :e real|0 <= w}.
        let z'. assume Hz'.
        apply ReplE_impred (SNoR x) sqrt_SNo_nonneg z' Hz'.
        let z. assume Hz: z :e SNoR x.
        assume Hz'z: z' = sqrt_SNo_nonneg z.
        rewrite Hz'z.
        prove sqrt_SNo_nonneg z :e {z :e real|0 <= z}.
        apply SNoR_E x Hx1 z Hz.
        assume Hz1 Hz2 Hz3.
        apply SepI.
        * { apply sqrt_SNo_nonneg_SNoS_omega.
            - prove z :e SNoS_ omega.
              apply SNoS_I omega omega_ordinal z (SNoLev z).
              + prove SNoLev z :e omega.
                rewrite <- H4. exact Hz2.
              + prove SNo_ (SNoLev z) z.
                apply SNoLev_. exact Hz1.
            - prove 0 <= z. apply SNoLtLe.
              prove 0 < z.
              exact SNoLeLt_tra 0 x z SNo_0 Hx1 Hz1 Hxnn Hz3.
          }
        * prove 0 <= sqrt_SNo_nonneg z.
          apply sqrt_SNo_nonneg_nonneg z Hz1.
          prove 0 <= z.
          apply SNoLtLe.
          prove 0 < z.
          exact SNoLeLt_tra 0 x z SNo_0 Hx1 Hz1 Hxnn Hz3.
    - let k. assume Hk.
      assume IHk. apply IHk.
      assume IHk0: SNo_sqrtaux x sqrt_SNo_nonneg k 0 c= {w :e real|0 <= w}.
      assume IHk1: SNo_sqrtaux x sqrt_SNo_nonneg k 1 c= {w :e real|0 <= w}.
      rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k Hk.
      rewrite tuple_2_0_eq. rewrite tuple_2_1_eq.
      apply andI.
      + prove SNo_sqrtaux x sqrt_SNo_nonneg k 0 :\/: SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 0) (SNo_sqrtaux x sqrt_SNo_nonneg k 1) x c= {w :e real|0 <= w}.
        apply binunion_Subq_min.
        * exact IHk0.
        * { prove SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 0) (SNo_sqrtaux x sqrt_SNo_nonneg k 1) x c= {w :e real|0 <= w}.
            apply SNo_sqrtauxset_real_nonneg.
            - exact IHk0.
            - exact IHk1.
            - exact Hx.
            - exact Hxnn.
          }
      + prove SNo_sqrtaux x sqrt_SNo_nonneg k 1 :\/: SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 0) (SNo_sqrtaux x sqrt_SNo_nonneg k 0) x :\/: SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 1) (SNo_sqrtaux x sqrt_SNo_nonneg k 1) x c= {w :e real|0 <= w}.
        apply binunion_Subq_min.
        * { apply binunion_Subq_min.
            - exact IHk1.
            - prove SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 0) (SNo_sqrtaux x sqrt_SNo_nonneg k 0) x c= {w :e real|0 <= w}.
              apply SNo_sqrtauxset_real_nonneg.
              + exact IHk0.
              + exact IHk0.
              + exact Hx.
              + exact Hxnn.
          }
        * { prove SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 1) (SNo_sqrtaux x sqrt_SNo_nonneg k 1) x c= {w :e real|0 <= w}.
            apply SNo_sqrtauxset_real_nonneg.
            - exact IHk1.
            - exact IHk1.
            - exact Hx.
            - exact Hxnn.
          }
  }
  claim LLsR: L c= real.
  { let w. assume Hw. apply LLE w Hw.
    let k. assume Hk: k :e omega.
    assume Hwk: w :e L_ k.
    apply L_L_R_real k (omega_nat_p k Hk).
    assume H _.
    exact SepE1 real (fun w => 0 <= w) w (H w Hwk).
  }
  claim LRsR: R c= real.
  { let z. assume Hz. apply LRE z Hz.
    let k. assume Hk: k :e omega.
    assume Hzk: z :e R_ k.
    apply L_L_R_real k (omega_nat_p k Hk).
    assume _ H.
    exact SepE1 real (fun w => 0 <= w) z (H z Hzk).
  }
  claim LLR: SNoCutP L R.
  { exact SNo_sqrt_SNo_SNoCutP x Hx1 Hxnn. }
  apply SNoCutP_SNoCut_impred L R LLR.
  rewrite <- sqrt_SNo_nonneg_eq x Hx1.
  assume HLR1 HLR2.
  assume HLR3: forall w :e L, w < sqrt_SNo_nonneg x.
  assume HLR4: forall z :e R, sqrt_SNo_nonneg x < z.
  assume HLR5.
  claim L0Lx: 0 :e SNoLev x.
  { rewrite H4. exact nat_p_omega 0 nat_0. }
  claim L1Lx: 1 :e SNoLev x.
  { rewrite H4. exact nat_p_omega 1 nat_1. }
  claim LLne: L <> 0.
  { exact sqrt_SNo_nonneg_Lnonempty x Hx1 Hxnn L0Lx. }
  claim LRne: R <> 0.
  { exact sqrt_SNo_nonneg_Rnonempty x Hx1 Hxnn L1Lx. }
  prove SNoCut L R :e real.
  claim LRE': forall z :e R, SNo z /\ 0 < z.
  { let z. assume Hz.
    claim LzS: SNo z.
    { exact real_SNo z (LRsR z Hz). }
    apply andI.
    - exact LzS.
    - apply SNoLeLt_tra 0 (sqrt_SNo_nonneg x) z SNo_0 H1 LzS.
      + prove 0 <= sqrt_SNo_nonneg x.
        exact H2.
      + prove sqrt_SNo_nonneg x < z.
        exact HLR4 z Hz.
  }
  claim LLnomax: forall w :e L, exists w' :e L, w < w'.
  { let w. assume Hw. apply LLE w Hw.
    let k. assume Hk.
    assume Hwk: w :e L_ k.
    apply L_L_R_real k (omega_nat_p k Hk).
    assume H _.
    apply SepE real (fun w => 0 <= w) w (H w Hwk).
    assume HwR: w :e real.
    assume Hwnn: 0 <= w.
    claim Lw: SNo w.
    { exact real_SNo w HwR. }
    apply xm (exists z, z :e R).
    - assume H5. apply H5.
      let z. assume Hz: z :e R.
      apply LRE z Hz.
      let k'. assume Hk'.
      assume Hzk': z :e R_ k'.
      apply LRE' z Hz.
      assume HzS: SNo z.
      assume Hzpos: 0 < z.
      apply L_L_R_real k' (omega_nat_p k' Hk').
      assume _ H.
      claim LzR: z :e real.
      { exact SepE1 real (fun w => 0 <= w) z (H z Hzk'). }
      claim Lz: SNo z.
      { exact real_SNo z LzR. }
      claim Lzpos: 0 < z.
      { apply SNoLeLt_tra 0 (sqrt_SNo_nonneg x) z SNo_0 H1 Lz.
        - prove 0 <= sqrt_SNo_nonneg x.
          exact H2.
        - prove sqrt_SNo_nonneg x < z.
          exact HLR4 z Hz.
      }
      claim Lwz: SNo (w + z).
      { exact SNo_add_SNo w z Lw Lz. }
      claim Lwmz: SNo (w * z).
      { exact SNo_mul_SNo w z Lw Lz. }
      claim Lwzpos: 0 < w + z.
      { rewrite <- add_SNo_0R 0 SNo_0.
        apply add_SNo_Lt3b 0 0 w z SNo_0 SNo_0 Lw Lz Hwnn.
        prove 0 < z.
        exact Lzpos.
      }
      set w' := (x + w * z) :/: (w + z).
      witness w'. apply andI.
      + prove w' :e L.
        claim Lwzk'': exists k'' :e omega, w :e L_ k'' /\ z :e R_ k''.
        { apply ordinal_trichotomy_or_impred k k' (nat_p_ordinal k (omega_nat_p k Hk)) (nat_p_ordinal k' (omega_nat_p k' Hk')).
          - assume H6: k :e k'. witness k'. apply andI.
            + exact Hk'.
            + apply andI.
              * prove w :e L_ k'.
                apply L_L_R_Subq k' (omega_nat_p k' Hk') k H6.
                assume H _. exact H w Hwk.
              * exact Hzk'.
          - assume H6: k = k'. witness k. apply andI.
            + exact Hk.
            + apply andI.
              * exact Hwk.
              * prove z :e R_ k. rewrite H6. exact Hzk'.
          - assume H6: k' :e k. witness k. apply andI.
            + exact Hk.
            + apply andI.
              * exact Hwk.
              * prove z :e R_ k.
                apply L_L_R_Subq k (omega_nat_p k Hk) k' H6.
                assume _ H. exact H z Hzk'.
        }
        apply Lwzk''.
        let k''. assume H. apply H.
        assume Hk'': k'' :e omega. assume H. apply H.
        assume Hwk'': w :e L_ k''.
        assume Hzk'': z :e R_ k''.
        claim Lw'LSk'': w' :e L_ (ordsucc k'').
        { prove w' :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc k'') 0.
          rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k'' (omega_nat_p k'' Hk'').
          rewrite tuple_2_0_eq.
          apply binunionI2.
          prove w' :e SNo_sqrtauxset (L_ k'') (R_ k'') x.
          apply SNo_sqrtauxset_I.
          - exact Hwk''.
          - exact Hzk''.
          - prove 0 < w + z. exact Lwzpos.
        }
        exact famunionI omega L_ (ordsucc k'') w' (omega_ordsucc k'' Hk'') Lw'LSk''.
      + prove w < w'.
        prove w < (x + w * z) :/: (w + z).
        apply div_SNo_pos_LtR (x + w * z) (w + z) w (SNo_add_SNo x (w * z) Hx1 Lwmz) Lwz Lw Lwzpos.
        prove w * (w + z) < x + w * z.
        rewrite mul_SNo_distrL w w z Lw Lw HzS.
        prove w * w + w * z < x + w * z.
        apply add_SNo_Lt1 (w * w) (w * z) x (SNo_mul_SNo w w Lw Lw) (SNo_mul_SNo w z Lw HzS) Hx1.
        prove w * w < x.
        rewrite <- H3.
        prove w * w < sqrt_SNo_nonneg x * sqrt_SNo_nonneg x.
        claim Lwsx: w < sqrt_SNo_nonneg x.
        { exact HLR3 w Hw. }
        apply SNoLeE 0 w SNo_0 Lw Hwnn.
        * assume H6: 0 < w.
          exact pos_mul_SNo_Lt2 w w (sqrt_SNo_nonneg x) (sqrt_SNo_nonneg x)
                                Lw Lw H1 H1 H6 H6
                                Lwsx Lwsx.
        * { assume H6: 0 = w. rewrite <- H6.
            rewrite mul_SNo_zeroR 0 SNo_0.
            prove 0 < sqrt_SNo_nonneg x * sqrt_SNo_nonneg x.
            claim Lsxpos: 0 < sqrt_SNo_nonneg x.
            { rewrite H6. exact Lwsx. }
            exact mul_SNo_pos_pos (sqrt_SNo_nonneg x) (sqrt_SNo_nonneg x)
                                  H1 H1 Lsxpos Lsxpos.
          }
    - assume H5: ~exists z, z :e R.
      apply LRne.
      apply Empty_eq.
      let z. assume Hz. apply H5. witness z. exact Hz.
  }
  claim LRnomin: forall z :e R, exists z' :e R, z' < z.
  { let z. assume Hz. apply LRE z Hz.
    let k. assume Hk.
    assume Hzk: z :e R_ k.
    apply LRE' z Hz.
    assume HzS: SNo z.
    assume Hzpos: 0 < z.
    claim Lzz: SNo (z + z).
    { exact SNo_add_SNo z z HzS HzS. }
    claim Lzzpos: 0 < z + z.
    { rewrite <- add_SNo_0R 0 SNo_0.
      prove 0 + 0 < z + z.
      exact add_SNo_Lt3 0 0 z z SNo_0 SNo_0 HzS HzS Hzpos Hzpos.
    }
    claim Lzzn0: z + z <> 0.
    { assume H5. apply SNoLt_irref 0. rewrite <- H5 at 2. exact Lzzpos. }
    claim Lzmz: SNo (z * z).
    { exact SNo_mul_SNo z z HzS HzS. }
    set z' := (x + z * z) :/: (z + z).
    claim Lz': z' :e R_ (ordsucc k).
    { prove z' :e SNo_sqrtaux x sqrt_SNo_nonneg (ordsucc k) 1.
      rewrite SNo_sqrtaux_S x sqrt_SNo_nonneg k (omega_nat_p k Hk).
      rewrite tuple_2_1_eq.
      apply binunionI2.
      prove (x + z * z) :/: (z + z) :e SNo_sqrtauxset (SNo_sqrtaux x sqrt_SNo_nonneg k 1) (SNo_sqrtaux x sqrt_SNo_nonneg k 1) x.
      apply SNo_sqrtauxset_I.
      - prove z :e R_ k. exact Hzk.
      - prove z :e R_ k. exact Hzk.
      - prove 0 < z + z. exact Lzzpos.
    }
    claim Lz'R: z' :e R.
    { exact famunionI omega R_ (ordsucc k) z' (omega_ordsucc k Hk) Lz'. }
    claim Lz'S: SNo z'.
    { exact real_SNo z' (LRsR z' Lz'R). }
    witness z'. apply andI.
    - prove z' :e R. exact Lz'R.
    - prove z' < z.
      prove (x + z * z) :/: (z + z) < z.
      apply div_SNo_pos_LtL (x + z * z) (z + z) z (SNo_add_SNo x (z * z) Hx1 Lzmz) Lzz HzS Lzzpos.
      prove x + z * z < z * (z + z).
      rewrite mul_SNo_distrL z z z HzS HzS HzS.
      prove x + z * z < z * z + z * z.
      apply add_SNo_Lt1 x (z * z) (z * z) Hx1 Lzmz Lzmz.
      prove x < z * z.
      rewrite <- H3.
      prove sqrt_SNo_nonneg x * sqrt_SNo_nonneg x < z * z.
      apply SNoLeE 0 (sqrt_SNo_nonneg x) SNo_0 H1 H2.
      + assume Hsxpos: 0 < sqrt_SNo_nonneg x.
        exact pos_mul_SNo_Lt2 (sqrt_SNo_nonneg x) (sqrt_SNo_nonneg x) z z H1 H1 HzS HzS Hsxpos Hsxpos (HLR4 z Hz) (HLR4 z Hz).
      + assume Hsx0: 0 = sqrt_SNo_nonneg x.
        rewrite <- Hsx0.
        rewrite mul_SNo_zeroR 0 SNo_0.
        prove 0 < z * z.
        exact mul_SNo_pos_pos z z HzS HzS Hzpos Hzpos.
  }
  exact real_SNoCut L LLsR R LRsR LLR LLne LRne LLnomax LRnomin.
Qed.

End SurrealSqrt.
Opaque sqrt_SNo_nonneg.

Section form100_1.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.

Theorem divides_int_div_SNo_int: forall m n, divides_int m n -> n :/: m :e int.
let m n.
assume H1: divides_int m n.
apply H1. assume H. apply H.
assume Hm: m :e int.
assume Hn: n :e int.
assume H. apply H.
let k. assume H. apply H.
assume Hk: k :e int.
assume H2: m * k = n.
claim LmS: SNo m.
{ exact int_SNo m Hm. }
claim LnS: SNo n.
{ exact int_SNo n Hn. }
claim LkS: SNo k.
{ exact int_SNo k Hk. }
apply xm (m = 0).
- assume H3: m = 0.
  prove n :/: m :e int.
  rewrite H3. rewrite div_SNo_0_denum n LnS.
  prove 0 :e int.
  apply Subq_omega_int. apply nat_p_omega.
  exact nat_0.
- assume H3: m <> 0.
  claim L1: n :/: m = k.
  { apply mul_SNo_nonzero_cancel m (n :/: m) k LmS H3 (SNo_div_SNo n m LnS LmS) LkS.
    prove m * (n :/: m) = m * k.
    rewrite mul_div_SNo_invR n m LnS LmS H3.
    prove n = m * k.
    symmetry.
    exact H2.
  }
  prove n :/: m :e int.
  rewrite L1.
  exact Hk.
Qed.

(** If m times m = 2 times n times n for naturals m and n, then n = 0. **)
Theorem form100_1_lem1 : forall m, nat_p m -> forall n, nat_p n -> m * m = 2 * n * n -> n = 0.
apply nat_complete_ind.
let m.
assume Hm: nat_p m.
assume IHm: forall m' :e m, forall n, nat_p n -> m' * m' = 2 * n * n -> n = 0.
let n.
assume Hn: nat_p n.
assume H1: m * m = 2 * n * n.
claim Ln: n :e omega.
{ exact nat_p_omega n Hn. }
claim LnS: SNo n.
{ exact nat_p_SNo n Hn. }
apply SNoLeE 0 n SNo_0 LnS (omega_nonneg n Ln).
- assume H2: 0 < n.
  prove False.
  claim LnZ: n :e int.
  { exact Subq_omega_int n Ln. }
  claim LnnS: SNo (n * n).
  { exact SNo_mul_SNo n n LnS LnS. }
  claim Lm: m :e omega.
  { exact nat_p_omega m Hm. }
  claim LmZ: m :e int.
  { exact Subq_omega_int m Lm. }
  claim LmS: SNo m.
  { exact nat_p_SNo m Hm. }
  claim Lmpos: 0 < m.
  { apply SNoLeE 0 m SNo_0 LmS (omega_nonneg m Lm).
    - assume H3: 0 < m. exact H3.
    - assume H3: 0 = m.
      prove False.
      apply SNoLt_irref (m * m).
      prove m * m < m * m.
      rewrite H1 at 2.
      prove m * m < 2 * n * n.
      rewrite <- H3 at 2.
      prove m * 0 < 2 * n * n.
      rewrite mul_SNo_zeroR m LmS.
      prove 0 < 2 * n * n.
      apply mul_SNo_pos_pos 2 (n * n) SNo_2 LnnS SNoLt_0_2.
      prove 0 < n * n.
      exact mul_SNo_pos_pos n n LnS LnS H2 H2.
  }
  claim Lm2pos: 0 < m :/: 2.
  { exact div_SNo_pos_pos m 2 LmS SNo_2 Lmpos SNoLt_0_2. }
  claim Ln2pos: 0 < n :/: 2.
  { exact div_SNo_pos_pos n 2 LnS SNo_2 H2 SNoLt_0_2. }
  claim L2mm: divides_int 2 (m * m).
  { prove divides_int 2 (m * m).
    rewrite H1.
    prove divides_int 2 (2 * n * n).
    apply divides_int_mul_SNo_L.
    - prove n * n :e int.
      apply Subq_omega_int.
      apply mul_SNo_In_omega.
      + exact Ln.
      + exact Ln.
    - prove divides_int 2 2.
      apply divides_int_ref.
      prove 2 :e int.
      apply Subq_omega_int. apply nat_p_omega.
      exact nat_2.
  }
  claim L2m: divides_int 2 m.
  { apply Euclid_lemma 2 prime_nat_2 m LmZ m LmZ L2mm.
    - assume H3: divides_int 2 m. exact H3.
    - assume H3: divides_int 2 m. exact H3.
  }
  claim Lm2Z: m :/: 2 :e int.
  { exact divides_int_div_SNo_int 2 m L2m. }
  claim Lm2N: nat_p (m :/: 2).
  { apply nonneg_int_nat_p (m :/: 2) Lm2Z.
    prove 0 <= m :/: 2.
    apply SNoLtLe.
    prove 0 < m :/: 2.
    exact Lm2pos.
  }
  claim Lm2S: SNo (m :/: 2).
  { exact nat_p_SNo (m :/: 2) Lm2N. }
  claim Lm2m: m :/: 2 :e m.
  { apply ordinal_SNoLt_In (m :/: 2) m (nat_p_ordinal (m :/: 2) Lm2N) (nat_p_ordinal m Hm).
    prove m :/: 2 < m.
    apply div_SNo_pos_LtL m 2 m LmS SNo_2 LmS SNoLt_0_2.
    prove m < m * 2.
    apply add_SNo_Lt1_cancel m (- m) (m * 2) LmS (SNo_minus_SNo m LmS) (SNo_mul_SNo m 2 LmS SNo_2).
    prove m + - m < m * 2 + - m.
    rewrite add_SNo_minus_SNo_rinv m LmS.
    prove 0 < m * 2 + - m.
    rewrite <- mul_SNo_oneR m LmS at 2.
    prove 0 < m * 2 + - m * 1.
    rewrite <- mul_SNo_minus_distrR m 1 LmS SNo_1.
    prove 0 < m * 2 + m * (- 1).
    rewrite <- mul_SNo_distrL m 2 (- 1) LmS SNo_2 (SNo_minus_SNo 1 SNo_1).
    prove 0 < m * (2 + - 1).
    rewrite <- add_SNo_1_1_2.
    prove 0 < m * ((1 + 1) + - 1).
    rewrite add_SNo_minus_R2 1 1 SNo_1 SNo_1.
    prove 0 < m * 1.
    rewrite mul_SNo_oneR m LmS.
    prove 0 < m.
    exact Lmpos.
  }
  claim L2nn: divides_int 2 (n * n).
  { prove divides_int 2 (n * n).
    prove 2 :e int /\ n * n :e int /\ exists k :e int, 2 * k = n * n.
    apply and3I.
    - prove 2 :e int. apply Subq_omega_int. apply nat_p_omega. exact nat_2.
    - prove n * n :e int.
      apply int_mul_SNo.
      + exact LnZ.
      + exact LnZ.
    - prove exists k :e int, 2 * k = n * n.
      witness (m :/: 2) * (m :/: 2).
      apply andI.
      + prove (m :/: 2) * (m :/: 2) :e int.
        apply int_mul_SNo.
	* exact Lm2Z.
	* exact Lm2Z.
      + prove 2 * ((m :/: 2) * (m :/: 2)) = n * n.
        rewrite mul_SNo_assoc 2 (m :/: 2) (m :/: 2) SNo_2 Lm2S Lm2S.
	prove (2 * (m :/: 2)) * (m :/: 2) = n * n.
	rewrite mul_div_SNo_invR m 2 LmS SNo_2 neq_2_0.
	prove m * (m :/: 2) = n * n.
	rewrite mul_div_SNo_L m 2 m LmS SNo_2 LmS.
	prove (m * m) :/: 2 = n * n.
	rewrite H1.
	prove (2 * n * n) :/: 2 = n * n.
	rewrite mul_SNo_com 2 (n * n) SNo_2 LnnS.
	prove ((n * n) * 2) :/: 2 = n * n.
        exact div_mul_SNo_invL (n * n) 2 LnnS SNo_2 neq_2_0.
  }
  claim L2n: divides_int 2 n.
  { apply Euclid_lemma 2 prime_nat_2 n LnZ n LnZ L2nn.
    - assume H3: divides_int 2 n. exact H3.
    - assume H3: divides_int 2 n. exact H3.
  }
  claim Ln2Z: n :/: 2 :e int.
  { exact divides_int_div_SNo_int 2 n L2n. }
  claim Ln2N: nat_p (n :/: 2).
  { apply nonneg_int_nat_p (n :/: 2) Ln2Z.
    prove 0 <= n :/: 2.
    apply SNoLtLe.
    exact Ln2pos.
  }
  claim L1: (m :/: 2) * (m :/: 2) = 2 * (n :/: 2) * (n :/: 2).
  { rewrite mul_div_SNo_both m 2 m 2 LmS SNo_2 LmS SNo_2.
    rewrite mul_div_SNo_both n 2 n 2 LnS SNo_2 LnS SNo_2.
    prove (m * m) :/: (2 * 2) = 2 * ((n * n) :/: (2 * 2)).
    rewrite H1.
    prove (2 * n * n) :/: (2 * 2) = 2 * ((n * n) :/: (2 * 2)).
    symmetry.
    exact mul_div_SNo_L (n * n) (2 * 2) 2 LnnS (SNo_mul_SNo 2 2 SNo_2 SNo_2) SNo_2.
  }
  claim Ln20: n :/: 2 = 0.
  { exact IHm (m :/: 2) Lm2m (n :/: 2) Ln2N L1. }
  apply SNoLt_irref 0.
  prove 0 < 0.
  rewrite <- Ln20 at 2.
  prove 0 < n :/: 2.
  exact div_SNo_pos_pos n 2 LnS SNo_2 H2 SNoLt_0_2.
- assume H2: 0 = n. symmetry. exact H2.
Qed.

(** There are no nonzero naturals m and n such that m times m = 2 times n times n. **)
Theorem form100_1_lem2 : forall m :e omega, forall n :e omega :\: 1, m * m <> 2 * n * n.
let m. assume Hm: m :e omega.
let n. assume Hn: n :e omega :\: 1.
assume H1: m * m = 2 * (n * n).
apply setminusE omega 1 n Hn.
assume Hn1: n :e omega.
assume Hn2: n /:e 1.
claim L1: n = 0.
{ exact form100_1_lem1 m (omega_nat_p m Hm) n (omega_nat_p n Hn1) H1. }
apply Hn2.
prove n :e 1.
rewrite L1.
prove 0 :e 1.
exact In_0_1.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.

Theorem sqrt_2_irrational: sqrt_SNo_nonneg 2 :e real :\: rational.
claim LS2R: sqrt_SNo_nonneg 2 :e real.
{ prove sqrt_SNo_nonneg 2 :e real. apply sqrt_SNo_nonneg_real 2.
  - prove 2 :e real. apply SNoS_omega_real.
    prove 2 :e SNoS_ omega.
    apply omega_SNoS_omega.
    prove 2 :e omega.
    exact nat_p_omega 2 nat_2.
  - prove 0 <= 2. apply SNoLtLe. exact SNoLt_0_2.
}
claim LS2: SNo (sqrt_SNo_nonneg 2).
{ apply real_SNo. exact LS2R. }
claim LS2nn: 0 <= sqrt_SNo_nonneg 2.
{ apply sqrt_SNo_nonneg_nonneg.
  - exact SNo_2.
  - prove 0 <= 2. apply SNoLtLe. exact SNoLt_0_2.
}
claim LS2pos: 0 < sqrt_SNo_nonneg 2.
{ apply SNoLeE 0 (sqrt_SNo_nonneg 2) SNo_0 LS2 LS2nn.
  - assume H1: 0 < sqrt_SNo_nonneg 2. exact H1.
  - assume H1: 0 = sqrt_SNo_nonneg 2.
    prove False.
    apply neq_0_2.
    prove 0 = 2.
    rewrite <- sqrt_SNo_nonneg_sqr 2 SNo_2 (SNoLtLe 0 2 SNoLt_0_2).
    prove 0 = sqrt_SNo_nonneg 2 * sqrt_SNo_nonneg 2.
    rewrite <- H1.
    prove 0 = 0 * 0.
    symmetry.
    exact mul_SNo_zeroR 0 SNo_0.
}
apply setminusI.
- prove sqrt_SNo_nonneg 2 :e real. exact LS2R.
- assume H1: sqrt_SNo_nonneg 2 :e rational.
  apply SepE real (fun x => exists m :e int, exists n :e omega :\: {0}, x = m :/: n) (sqrt_SNo_nonneg 2) H1.
  assume H2: sqrt_SNo_nonneg 2 :e real.
  assume H3: exists m :e int, exists n :e omega :\: {0}, sqrt_SNo_nonneg 2 = m :/: n.
  claim LnQ: forall m :e int, forall n :e omega :\: {0}, sqrt_SNo_nonneg 2 <> m :/: n.
  { apply int_SNo_cases.
    - let m. assume Hm: m :e omega.
      let n. assume Hn: n :e omega :\: {0}.
      assume H4: sqrt_SNo_nonneg 2 = m :/: n.
      prove False.
      apply setminusE omega {0} n Hn.
      assume Hn1: n :e omega.
      assume Hn2: n /:e {0}.
      claim LmS: SNo m.
      { exact omega_SNo m Hm. }
      claim LnN: nat_p n.
      { exact omega_nat_p n Hn1. }
      claim Ln1: n :e omega :\: 1.
      { rewrite eq_1_Sing0. exact Hn. }
      claim LnS: SNo n.
      { exact omega_SNo n Hn1. }
      apply form100_1_lem2 m Hm n Ln1.
      prove m * m = 2 * n * n.
      claim L1: sqrt_SNo_nonneg 2 * n = m.
      { rewrite H4.
        prove (m :/: n) * n = m.
        apply mul_div_SNo_invL.
        - prove SNo m. exact LmS.
        - prove SNo n. exact LnS.
        - prove n <> 0.
          assume Hn0: n = 0.
          apply Hn2.
          prove n :e {0}. rewrite Hn0. apply SingI.
      }
      rewrite <- L1.
      prove (sqrt_SNo_nonneg 2 * n) * (sqrt_SNo_nonneg 2 * n) = 2 * (n * n).
      rewrite mul_SNo_com_4_inner_mid (sqrt_SNo_nonneg 2) n (sqrt_SNo_nonneg 2) n LS2 LnS LS2 LnS.
      prove (sqrt_SNo_nonneg 2 * sqrt_SNo_nonneg 2) * (n * n) = 2 * (n * n).
      f_equal.
      prove sqrt_SNo_nonneg 2 * sqrt_SNo_nonneg 2 = 2.
      apply sqrt_SNo_nonneg_sqr.
      + prove SNo 2. exact SNo_2.
      + prove 0 <= 2. apply SNoLtLe. exact SNoLt_0_2.
    - let m. assume Hm: m :e omega.
      let n. assume Hn: n :e omega :\: {0}.
      assume H4: sqrt_SNo_nonneg 2 = (- m) :/: n.
      prove False.
      apply setminusE omega {0} n Hn.
      assume Hn1: n :e omega.
      assume Hn2: n /:e {0}.
      claim LmS: SNo m.
      { exact omega_SNo m Hm. }
      claim Lmnn: 0 <= m.
      { exact omega_nonneg m Hm. }
      claim LnS: SNo n.
      { exact omega_SNo n Hn1. }
      claim Lnnn: 0 <= n.
      { exact omega_nonneg n Hn1. }
      claim Lnpos: 0 < n.
      { apply SNoLeE 0 n SNo_0 LnS Lnnn.
        - assume H5: 0 < n. exact H5.
	- assume H5: 0 = n.
	  prove False.
	  apply Hn2.
	  prove n :e {0}.
	  rewrite <- H5.
	  apply SingI.
      }
      apply SNoLt_irref 0.
      prove 0 < 0.
      apply SNoLtLe_tra 0 (sqrt_SNo_nonneg 2) 0 SNo_0 LS2 SNo_0 LS2pos.
      prove sqrt_SNo_nonneg 2 <= 0.
      rewrite H4.
      prove (- m) :/: n <= 0.
      apply SNoLeE 0 m SNo_0 LmS Lmnn.
      + assume H5: 0 < m.
        apply SNoLtLe.
        apply div_SNo_neg_pos (- m) n (SNo_minus_SNo m LmS) LnS.
	* prove - m < 0.
	  apply minus_SNo_Lt_contra1 0 m SNo_0 LmS.
	  prove - 0 < m.
	  rewrite minus_SNo_0.
	  exact H5.
	* prove 0 < n. exact Lnpos.
      + assume H5: 0 = m.
        rewrite <- H5.
	rewrite minus_SNo_0.
	rewrite div_SNo_0_num n LnS.
	prove 0 <= 0.
	apply SNoLe_ref.
  }
  apply H3.
  let m. assume H. apply H.
  assume Hm: m :e int. assume H. apply H.
  let n. assume H. apply H.
  assume Hn: n :e omega :\: {0}.
  assume H4: sqrt_SNo_nonneg 2 = m :/: n.
  exact LnQ m Hm n Hn H4.
Qed.

End form100_1.
